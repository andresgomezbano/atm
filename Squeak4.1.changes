'From Squeak4.1 of 17 April 2010 [latest update: #9957] on 17 April 2010 at 5:22:05 pm'!----STARTUP----{17 April 2010 . 5:21:54 pm} as C:\Squeak\4.0\4.1-final\Squeak4.1.image!Smalltalk appendChangesTo: 'SqueakV41.sources'.!----QUIT----{17 April 2010 . 5:22:11 pm} Squeak4.1.image priorSource: 89!----STARTUP----{15 March 2011 . 1:08:38 pm} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!a := EllipseMorph new openInWorld.!a := EllipseMorph new openInWorld.!a on: #click send: #value to:[		Transcript show "adfadsf".	].!a on: #click send: #value to:[		Transcript show:'adfadsf'.	].!a := EllipseMorph new openInWorld.!a on: #click send: #value to:[		Transcript show:'adfadsf'.	].!ActiveHand newKeyboardFocus: a.!Morph subclass: #KeyButton	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!EllipseMorph subclass: #KeyButton	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!KeyButton methodsFor: 'nil' stamp: 'agb 3/15/2011 14:20'!handlesKeyboard^ true.! !!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 14:21'!handlesKeyboard: evt ^ true.! !KeyButton removeSelector: #handlesKeyboard!!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 14:21'!mouseEnter: evtevt hand keyboardFocus: self ! !!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 14:21'!mouseLeave: evtevt hand releaseKeyboardFocus: self ! !!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 14:22'!keyDown: anEvent"Handle a key down event. ."  anEvent keyCharacter = $a     ifTrue: [Transcript show:'asdfa'].  anEvent keyCharacter = $q     ifTrue: [Transcript show:'asdfad']! !b:= KeyButton new openInWorld.!!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 14:24' prior: 33555758!mouseEnter: evtevt hand keyboardFocus: self.! !!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 14:24' prior: 33556322!mouseEnter: evtevt hand keyboardFocus: self.Transcript show:'asdfa'.! !b:= KeyButton new openInWorld.!!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 14:59'!handlesKeyboard ^ true.! !KeyButton removeSelector: #handlesKeyboard:!KeyButton removeSelector: #handlesKeyboard!KeyButton removeSelector: #keyDown:!KeyButton removeSelector: #mouseLeave:!KeyButton removeSelector: #mouseEnter:!!KeyButton methodsFor: 'nil' stamp: 'agb 3/15/2011 15:33'! hasFocus   ^ true.! !!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 15:52'!handlesKeyboard: evt   ^true ! !!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 15:52'!keystroke: event    | aChar |   (self scrollByKeyboard: event) ifTrue: [^self].   aChar _ event keyCharacter.   ^ self keyPressed: aChar ! !!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 15:53' prior: 33557151!keystroke: event    | | Transcript show:'hola'.! !!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 15:53' prior: 33557387!keystroke: event  Transcript show:'hola'! !b:= KeyButton new openInWorld.!Transcript show:'hola'!b hasFocus.!b hasFocus.!!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 16:22'!keyStroke: anEvent  Transcript show: anEvent keyValue.! !KeyButton removeSelector: #keystroke:!!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 16:23'!keyboardFocusChange: aBoolean 	aBoolean 		ifTrue: [ Transcript show: 'Got Focus' ]		ifFalse: [ Transcript show: 'Lost Focus']! !a := EllipseMorph new openInWorld.!a on: #keyStroke send: #value to:[		Transcript show:'adfadsf'.	].!a on: #keyStroke send: #value to:[		Transcript show:#value.	].!ScriptableButton subclass: #Boton	instanceVariableNames: 'enabled'	classVariableNames: ''	poolDictionaries: ''	category: 'juego'!Smalltalk removeClassNamed: #Boton!ScriptableButton subclass: #Boton	instanceVariableNames: 'enabled'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!Boton methodsFor: 'nil' stamp: 'agb 3/15/2011 17:26'!enabled^enabled! !!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 17:26'!enabled:aBoolean|elemento|elemento := (self submorphs)first.enabled_ aBoolean.aBoolean = true ifTrue:[		self color:(Color r: 0.94 g: 0.94 b: 0.944).		elemento color:(Color r: 0 g: 0 b: 0).	]ifFalse:[		self color:(Color r: 0.878 g: 0.878 b: 0.882).		elemento color:(Color r: 0.721 g: 0.721 b: 0.725).	].! !!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 17:26'!initializeenabled_ true.super initialize.self color:(Color r: 0.94 g: 0.94 b: 0.944).! !!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 17:26'!text^self submorphs first! !!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 17:26'!text:aString|elemento|elemento := (self submorphs)first.elemento delete.elemento := StringMorph new.elemento contents:aString.self addMorphCentered:elemento.! !bo := Boton new openInWorld.!RectangleMorph subclass: #ATM	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!RectangleMorph subclass: #ATM	instanceVariableNames: 'b1 b2 b3 b4 b5 b6 b7 b8 b9 b0 enter'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!RectangleMorph subclass: #ATM	instanceVariableNames: 'botones enter'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!ATM methodsFor: 'nil' stamp: 'agb 3/15/2011 17:43'!initialize! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 17:43' prior: 33559989!initializebotones _OrderedCollection new.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 17:45' prior: 33560089!initializebotones _OrderedCollection new.1to:10do:[:i|	botones add: Boton new openInWorld. 				]! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 17:45' prior: 33560220!initializebotones _OrderedCollection new.1to:10do:[:i|	botones add: Boton new openInWorld. 				]self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 17:47' prior: 33560409!initializebotones _OrderedCollection new.1to:10do:[:i|	botones add: Boton new openInWorld. 				].self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 17:47' prior: 33560617!initializebotones _OrderedCollection new.1to:10do:[:i|	botones add: Boton new openInWorld. 				].! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 17:48' prior: 33560826!initializesuper initialize.botones _OrderedCollection new.1to:10do:[:i|	botones add: Boton new openInWorld. 				].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 17:50' prior: 33561035!initialize|b|super initialize.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	self addMorph:b.].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 17:54' prior: 33561279!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	self addMorph:b.].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 17:55' prior: 33561540!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:60@120.	self addMorph:b.].self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 17:55' prior: 33561846!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:60@120.	b text:i.	self addMorph:b.].self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/15/2011 17:55' prior: 33562152!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:60@120.	b text: i asString.	self addMorph:b.].self openInWorld.! !atm := ATM new.!atm := ATM new.!RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla inferior controles botones enter'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!----QUIT----{15 March 2011 . 6:02:16 pm} Squeak4.1.image priorSource: 229!----STARTUP----{16 March 2011 . 12:33:18 am} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 00:49' prior: 33562469!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@20.	b text: i asString.	self addMorph:b.].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 00:49' prior: 33563200!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@80.	b text: i asString.	self addMorph:b.].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 00:49' prior: 33563544!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@60.	b text: i asString.	self addMorph:b.].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 00:49' prior: 33563888!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@50.	b text: i asString.	self addMorph:b.].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 00:49' prior: 33564232!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	self addMorph:b.].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 00:50' prior: 33564576!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:50@40.	b text: i asString.	self addMorph:b.].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 00:51' prior: 33564920!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	self addMorph:b.].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 00:51' prior: 33565264!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b position:inicial.	b extent:40@40.	b text: i asString.	self addMorph:b.].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 00:52' prior: 33565608!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b position:inicial.	b extent:40@40.	b text: i asString.	self addMorph:b.	inicial:= inicial + 50@0.].self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 00:52' prior: 33565973!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b position:inicial.	b extent:40@40.	b text: i asString.	self addMorph:b.	inicial:= inicial + (50@0).].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 01:00' prior: 33566347!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b position:inicial.	b extent:40@40.	b text: i asString.	self addMorph:b.	inicial:= inicial + (50@0).	(i=4 | i=7) ifTrue:[inicial:=  10@((inicial y) + 50).].].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 01:01' prior: 33566741!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b position:inicial.	b extent:40@40.	b text: i asString.	self addMorph:b.	inicial:= inicial + (50@0).	(i=4 | i=7) ifTrue:[inicial:=  10@((inicial y) + 50).].].self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 01:01' prior: 33567192!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b position:inicial.	b extent:40@40.	b text: i asString.	self addMorph:b.	inicial:= inicial + (50@0).	(i=4) ifTrue:[inicial:=  10@((inicial y) + 50).].].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 01:02' prior: 33567625!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b position:inicial.	b extent:40@40.	b text: i asString.	self addMorph:b.	inicial:= inicial + (50@0).	(i=3) ifTrue:[inicial:=  10@((inicial y) + 50).].].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 01:03' prior: 33568070!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b position:inicial.	b extent:40@40.	b text: i asString.	self addMorph:b.	inicial:= inicial + (50@0).	(i=3 | i=7) ifTrue:[inicial:=  10@((inicial y) + 50).].].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 01:03' prior: 33568515!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b position:inicial.	b extent:40@40.	b text: i asString.	self addMorph:b.	inicial:= inicial + (50@0).	((i=3) | (i=7)) ifTrue:[inicial:=  10@((inicial y) + 50).].].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 01:04' prior: 33568966!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b position:inicial.	b extent:40@40.	b text: i asString.	self addMorph:b.	inicial:= inicial + (50@0).	((i=3) | (i=6)) ifTrue:[inicial:=  10@((inicial y) + 50).].].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 01:04' prior: 33569421!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b position:inicial.	b extent:40@40.	b text: i asString.	self addMorph:b.	inicial:= inicial + (50@0).	((i%3)=0) ifTrue:[inicial:=  10@((inicial y) + 50).].].self openInWorld.! !15\\3.!15\\3.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 01:11' prior: 33569876!initialize|b inicial|super initialize.self extent:200@200.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b position:inicial.	b extent:40@40.	b text: i asString.	self addMorph:b.	inicial:= inicial + (50@0).	(i\\3=0) ifTrue:[inicial:=  10@((inicial y) + 50).].].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 01:13' prior: 33570325!initialize|b inicial|super initialize.self extent:200@160.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b position:inicial.	b extent:40@40.	b text: i asString.	self addMorph:b.	inicial:= inicial + (50@0).	(i\\3=0) ifTrue:[inicial:=  10@((inicial y) + 50).].].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 01:14' prior: 33570773!initialize|b inicial|super initialize.self extent:160@210.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b position:inicial.	b extent:40@40.	b text: i asString.	self addMorph:b.	inicial:= inicial + (50@0).	(i\\3=0) ifTrue:[inicial:=  10@((inicial y) + 50).].].self openInWorld.! !atm := ATM new.!b:= ScriptableButton new openInWorld.!b label:'asdf'.!b on: #click send: #value to:[		Transcript show:'asd'.	].!b doButtonAction.!b doButtonAction.!b doButtonAction.!c _ SimpleButtonMorph.!c _ SimpleButtonMorph new openInWorld.!----STARTUP----{16 March 2011 . 2:09:22 am} as C:\Users\user\Desktop\Squeak 4.1\Squeak4.1.image!atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:16'!qinitialize|b inicial|super initialize.self extent:210@160.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b label: i asString.	b position:inicial.	self addMorph:b.	inicial:=inicial+10@0.].self openInWorld.! !ATM removeSelector: #initialize!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:16'!initialize|b inicial|super initialize.self extent:210@160.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b label: i asString.	b position:inicial.	self addMorph:b.	inicial:=inicial+10@0.].self openInWorld.! !ATM removeSelector: #qinitialize!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:17' prior: 33572408!initialize|b inicial|super initialize.self extent:210@160.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b label: i asString.	b position:inicial.	self addMorph:b.	inicial:=inicial+(10@0).].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:17' prior: 33572815!initialize|b inicial|super initialize.self extent:210@160.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:60@60.	b label: i asString.	b position:inicial.	self addMorph:b.	inicial:=inicial+(10@0).].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:18' prior: 33573207!initialize|b inicial|super initialize.self extent:210@160.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:60@60.	b text: i asString.	b position:inicial.	self addMorph:b.	inicial:=inicial+(10@0).].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:21' prior: 33573599!initialize|b inicial|super initialize.self extent:210@160.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	self addMorph:b.	inicial:=inicial+(50@0).].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:23' prior: 33573990!initialize|b inicial|super initialize.self extent:210@160.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	self addMorph:b.	inicial:=inicial+(50@0).	(i\\3)ifTrue:[inicial:=(10@(inicial y + 50))].].self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:26' prior: 33574381!initialize|b inicial|super initialize.self extent:210@160.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	self addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=(10@(inicial y + 50))].].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:26' prior: 33574802!initialize|b inicial|super initialize.self extent:160@210.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	self addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=(10@(inicial y + 50))].].self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:26' prior: 33575243!initialize|b inicial|super initialize.self extent:160@210.inicial:=10@10.botones _OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	self addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=10@(inicial y + 50)].].self openInWorld.! !atm := ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:29' prior: 33575666!initialize|b inicial|super initialize.controles:= RectangleMorph new.self add:controles.controles extent:160@210.inicial:=10@10.botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=10@(inicial y + 50)].].self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:29' prior: 33576105!initialize|b inicial|super initialize.controles:= RectangleMorph new.self addMorph:controles.controles extent:160@210.inicial:=10@10.botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=10@(inicial y + 50)].].self openInWorld.! !a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:31' prior: 33576589!initialize|b inicial|super initialize.self extent:600@400.controles:= RectangleMorph new.self addMorph:controles.controles extent:160@210.inicial:=10@10.botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=10@(inicial y + 50)].].self openInWorld.! !a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:33' prior: 33577093!initialize|b inicial|super initialize.self extent:600@400.self color:(Color r: 0.878 g: 0.878 b: 0.882).controles:= RectangleMorph new.self addMorph:controles.controles extent:160@210.inicial:=10@10.botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=10@(inicial y + 50)].].self openInWorld.! !a:= ATM new.!a:= ATM new.!!ATM methodsFor: 'nil' stamp: 'agb 3/16/2011 02:35'!handlesKeyboard: evt   ^true ! !!ATM methodsFor: 'nil' stamp: 'agb 3/16/2011 02:35'!hasFocus   ^ true.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:35'!keyStroke: anEvent  Transcript show: anEvent keyValue.! !!ATM methodsFor: 'nil' stamp: 'agb 3/16/2011 02:36'!keyboardFocusChange: aBoolean 	aBoolean 		ifTrue: [ Transcript show: 'Got Focus' ]		ifFalse: [ Transcript show: 'Lost Focus']! !a:= ATM new.!b:= KeyButton new openInWorld.!b:= KeyButton new openInWorld.!a:= ATM new.!!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:40' prior: 33557737!keyStroke: anEvent  Transcript show: (anEvent keyValue)-48.! !a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:41' prior: 33578352!keyStroke: anEvent  Transcript show: (anEvent keyValue)-48..! !a:= ATM new.!a := EllipseMorph new openInWorld.!a on: #mouseUp send: #value to:[		Transcript show:#value.	].!a on: #mouseUp send: #value to:[		Transcript show:'asdf'.	].!a on: #mouseDown send: #value to:[		Transcript show:#value.	].!a on: #mouseDown send: #value to:[		self position:self position - (2@2).	].a on: #mouseUp send: #value to:[		self position:self position + (2@2).	].!a on: #mouseDown send: #value to:[		self position:(self position) - (2@2).	].a on: #mouseUp send: #value to:[		self position:(self position) + (2@2).	].!a := EllipseMorph new openInWorld.!a on: #mouseDown send: #value to:[		self position:(self position) - (2@2).	].a on: #mouseUp send: #value to:[		self position:(self position) + (2@2).	].!a on: #mouseDown send: #value to:[		a position:(a position) - (2@2).	].a on: #mouseUp send: #value to:[		a position:(a position) + (2@2).	].!a on: #mouseDown send: #value to:[		a position:(a position) + (2@2).	].a on: #mouseUp send: #value to:[		a position:(a position) - (2@2).	].!a on: #mouseDown send: #value to:[		a position:(a position) + (-2@ -2).	].a on: #mouseUp send: #value to:[		a position:(a position) - (-2@ -2).	].!a on: #mouseDown send: #value to:[		a position:(a position) + (-2@ -2).	].a on: #mouseUp send: #value to:[		a position:(a position) - (-2@ -2).	].!a := EllipseMorph new openInWorld.!a on: #mouseDown send: #value to:[		a position:(a position) + (2@ -2).	].!a on: #mouseDown send: #value to:[		a position:(a position) + (-2@ 2).	].!a on: #mouseUp send: #value to:[		a position:(a position) - (-2@ 2).	].!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:54'!keyDown: anEvent  Transcript show: (anEvent keyValue)-48..! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:54' prior: 33580720!keyDown: anEvent  Transcript show: 'presionado'.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:56'!keyUp: anEvent  Transcript show: 'soltado'.! !!Boton methodsFor: 'nil' stamp: 'agb 3/16/2011 02:57'!pushself position:(self position) + (-2@ 2).! !!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:57'!popself position:(self position) - (-2@ 2).! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 02:58' prior: 33578950!keyStroke: anEvent  Transcript show: (anEvent keyValue)-48.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 03:03' prior: 33580868!keyDown: anEvent |valor|valor:=(anEvent keyValue)-48.valor:=1 ifTrue:[(botones at:1) push].! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 03:03' prior: 33581495!keyDown: anEvent |valor|valor:=(anEvent keyValue)-48.valor=1 ifTrue:[(botones at:1) push].! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 03:03' prior: 33580990!keyUp: anEvent |valor|valor:=(anEvent keyValue)-48.valor=1 ifTrue:[(botones at:1) pop].! !a:= ATM new.!a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 03:07' prior: 33581860!keyUp: anEvent |valor|valor:=(anEvent keyValue)-48.1to:10do:[:i|	valor=i ifTrue:[(botones at:i) pop].].! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 03:08' prior: 33581678!keyDown: anEvent |valor|valor:=(anEvent keyValue)-48.1to:10do:[:i|	valor=i ifTrue:[(botones at:i) push].].! !a:= ATM new.!RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla inferior controles botones enter estado'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 03:13' prior: 33577618!initialize|b inicial|estado := false.super initialize.self extent:600@400.self color:(Color r: 0.878 g: 0.878 b: 0.882).controles:= RectangleMorph new.self addMorph:controles.controles extent:160@210.inicial:=10@10.botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=10@(inicial y + 50)].].self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 03:14' prior: 33582267!keyDown: anEvent |valor|estado ifTrue:[^nil].valor:=(anEvent keyValue)-48.1to:10do:[:i|	valor=i ifTrue:[(botones at:i) push].].! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 03:15' prior: 33583235!keyDown: anEvent |valor|estado ifTrue:[^nil].valor:=(anEvent keyValue)-48.1to:10do:[:i|	valor=i ifTrue:[(botones at:i) push].].estado:=true.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 03:15' prior: 33582069!keyUp: anEvent |valor|valor:=(anEvent keyValue)-48.1to:10do:[:i|	valor=i ifTrue:[(botones at:i) pop].].estado:=false.! !a:= ATM new.!a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 03:18' prior: 33583457!keyDown: anEvent |valor|estado ifTrue:[^nil].estado:=true.valor:=(anEvent keyValue)-48.1to:10do:[:i|	valor=i ifTrue:[(botones at:i) push].].! !a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 03:35' prior: 33582661!initialize|b inicial|estado := false.super initialize.self extent:600@400.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.self addMorph:controles.controles extent:160@210.inicial:=10@10.botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=10@(inicial y + 50)].].self openInWorld.! !a:= ATM new.!a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 03:50' prior: 33584186!initialize|b inicial pinicial|estado := false.super initialize.self extent:600@400.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.self addMorph:controles.controles extent:160@210.inicial:=10@10.botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=10@(inicial y + 50)].].self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 03:55' prior: 33584899!initialize|b inicial|estado := false.super initialize.self extent:600@400.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.self addMorph:controles.controles extent:160@210.inicial:=10@10.botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=10@(inicial y + 50)].].self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 04:00' prior: 33585591!initialize|b inicial|estado := false.super initialize.self extent:600@400.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.controles position:200@0.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=10@(inicial y + 50)].].self openInWorld.! !a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 04:00' prior: 33586275!initialize|b inicial|estado := false.super initialize.self extent:600@400.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.controles position:0@200.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=10@(inicial y + 50)].].self openInWorld.! !a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 04:01' prior: 33587022!initialize|b inicial|estado := false.super initialize.self extent:600@400.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=10@(inicial y + 50)].].self openInWorld.! !a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 04:02' prior: 33587769!initialize|b inicial|estado := false.super initialize.self extent:600@400.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:0@200.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=10@(inicial y + 50)].].self openInWorld.! !a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 04:06' prior: 33588515!initialize|b inicial|estado := false.super initialize.self extent:610@400.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:0@200.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=10@(inicial y + 50)].].self openInWorld.! !a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 04:06' prior: 33589287!initialize|b inicial|estado := false.super initialize.self extent:600@410.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:0@200.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=10@(inicial y + 50)].].self openInWorld.! !a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 04:07' prior: 33590059!initialize|b inicial|estado := false.super initialize.self extent:600@410.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@200.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=10@(inicial y + 50)].].self openInWorld.! !a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 04:07' prior: 33590831!initialize|b inicial|estado := false.super initialize.self extent:600@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@200.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=10@(inicial y + 50)].].self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 04:08' prior: 33591604!initialize|b inicial|estado := false.super initialize.self extent:600@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=10@(inicial y + 50)].].self openInWorld.! !a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 04:09' prior: 33592362!initialize|b inicial|estado := false.super initialize.self extent:600@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=(controles x + 10)@(inicial y + 50)].].self openInWorld.! !a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 04:10' prior: 33593135!initialize|b inicial|estado := false.super initialize.self extent:600@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=(controles x)@(inicial y + 50)].].self openInWorld.! !a:= ATM new.!a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 04:12' prior: 33593924!initialize|b inicial|estado := false.super initialize.self extent:600@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=(10)@(inicial y + 50)].].self openInWorld.! !a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 04:12' prior: 33594723!initialize|b inicial|estado := false.super initialize.self extent:600@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=(controles x)@(inicial y + 50)].].self openInWorld.! !a:= ATM new.!a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 04:14' prior: 33595498!initialize|b inicial|estado := false.super initialize.self extent:600@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=(controles x)@(inicial y + 50). Transcript show:controles x.].].self openInWorld.! !a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 04:15' prior: 33596297!initialize|b inicial|estado := false.super initialize.self extent:600@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50). Transcript show:controles x.].].self openInWorld.! !a:= ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 04:15' prior: 33597111!initialize|b inicial|estado := false.super initialize.self extent:600@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].].self openInWorld.! !----QUIT----{16 March 2011 . 5:11:51 am} Squeak4.1.image priorSource: 8486!----STARTUP----{16 March 2011 . 2:27:07 pm} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 16:32' prior: 33597914!initialize|b inicial|estado := false.super initialize.self extent:600@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla extent:520@120.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].].self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 16:33' prior: 33598869!initialize|b inicial|estado := false.super initialize.self extent:600@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.superior position:20@20.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla extent:520@120.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].].self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 16:33' prior: 33599791!initialize|b inicial|estado := false.super initialize.self extent:600@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla extent:520@120.pantalla position:20@20.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].].self openInWorld.! !atm_  ATM new.!atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 16:35' prior: 33600738!initialize|b inicial|estado := false.super initialize.self extent:600@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@120.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla extent:520@120.pantalla position:20@20.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].].self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 16:35' prior: 33601702!initialize|b inicial|estado := false.super initialize.self extent:600@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla extent:520@120.pantalla position:20@20.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].].self openInWorld.! !atm_  ATM new.!atm_  ATM new.!atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 16:37' prior: 33602649!initialize|b inicial|estado := false.super initialize.self extent:600@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:580@180.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].].self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 16:37' prior: 33603630!initialize|b inicial|estado := false.super initialize.self extent:600@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:600@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:560@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].].self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 16:40' prior: 33604577!initialize|b inicial|estado := false.super initialize.self extent:500@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:500@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].].self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 16:41' prior: 33605524!initialize|b inicial|estado := false.super initialize.self extent:500@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:500@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].].self openInWorld.! !atm_  ATM new.!RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla inferior controles botones enter estado pdeposito pretiro'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 16:52' prior: 33606471!initialize|b inicial|estado := false.super initialize.self extent:500@430.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:500@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:170@220.pretiro extent:320@160.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 16:56' prior: 33607639!initialize|b inicial alto ancho|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:ancho@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:170@220.pretiro extent:320@160.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.self openInWorld.! !RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter estado pdeposito pretiro'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 17:01' prior: 33608778!initialize|b inicial alto ancho|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:ancho@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:320@160.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 17:01' prior: 33610144!initialize|b inicial alto ancho|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:ancho@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@160.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 17:02' prior: 33611321!initialize|b inicial alto ancho|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:ancho@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@160.pretiro borderWidth:0.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 17:02' prior: 33612498!initialize|b inicial alto ancho|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:ancho@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.self openInWorld.! !atm_  ATM new.!----QUIT----{16 March 2011 . 5:05:33 pm} Squeak4.1.image priorSource: 44155!----STARTUP----{16 March 2011 . 11:28:46 pm} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 23:29' prior: 33613681!initialize|b inicial alto ancho|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:ancho@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.self addMorph:pretiro.self openInWorld.! !atm_  ATM new.!atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 23:30' prior: 33615096!initialize|b inicial alto ancho|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:ancho@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.self addMorph:pdeposito.self openInWorld.! !atm_  ATM new.!RectangleMorph subclass: #Billete	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!RectangleMorph subclass: #Billete	instanceVariableNames: 'valor imagen'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!Billete methodsFor: 'nil' stamp: 'agb 3/16/2011 23:35'!initializesuper initialize.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 23:36' prior: 33617955!initializesuper initialize.self extent:280@80.! !atm_  ATM new.!billete_ Billete new.!billete openInWorld.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/16/2011 23:37' prior: 33618077!initializesuper initialize.self extent:280@80.self borderWidth:0.self openInWorld.! !atm_  ATM new.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 00:06' prior: 33618282!initialize|imagen|super initialize.self extent:180@76.self borderWidth:0.imagen:= ImageMorph new.imagen image: (ImageReadWriter formFromFileNamed: 'atm\oneDollar.jpg').self openInWorld.! !billete_ Billete new.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 00:07' prior: 33618478!initialize|imagen|super initialize.self extent:180@76.self borderWidth:0.imagen:= ImageMorph new.imagen image: (ImageReadWriter formFromFileNamed: 'atm\oneDollar.jpg').self addMorph:imagen.self openInWorld.! !billete_ Billete new.!billete_ Billete new.!!Billete methodsFor: 'nil' stamp: 'agb 3/17/2011 00:09'!tipo:aString! !RectangleMorph subclass: #Billete	instanceVariableNames: 'valor'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 00:10' prior: 33618787!initialize|imagen|super initialize.self extent:180@76.self borderWidth:0.imagen:= ImageMorph new.imagen image: (ImageReadWriter formFromFileNamed: 'atm\oneDollar.jpg').valor:=1.self addMorph:imagen.self openInWorld.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 00:11'!valor:aString|imagen|imagen:= ImageMorph new.imagen image: (ImageReadWriter formFromFileNamed: 'atm\',valor as String,'dollar.jpg').valor:=1.self addMorph:imagen.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 00:13' prior: 33619647!valor:aNumber|imagen|imagen:= ImageMorph new.imagen image: (ImageReadWriter formFromFileNamed: 'atm\',aNumber as String,'dollar.jpg').valor:=aNumber.self addMorph:imagen.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 00:13' prior: 33619346!initialize|imagen|super initialize.self extent:180@76.self borderWidth:0.imagen:= ImageMorph new.imagen image: (ImageReadWriter formFromFileNamed: 'atm\1Dollar.jpg').valor:=1.self addMorph:imagen.self openInWorld.! !billete_ Billete new.!billete tipo:5.!billete tipo:5.!Billete removeSelector: #tipo:!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 00:15' prior: 33619907!valor:aNumber|imagen|imagen:= ImageMorph new.imagen image: (ImageReadWriter formFromFileNamed: 'atm\',aNumber asString,'dollar.jpg').valor:=aNumber.self addMorph:imagen.! !billete valor:5.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 00:16' prior: 33620583!valor:aNumber|imagen|imagen:= ImageMorph new.imagen image: (ImageReadWriter formFromFileNamed: 'atm\',aNumber asString,'dollar.jpg').valor:=aNumber.self removeAllMorphs.self addMorph:imagen.! !billete_ Billete new.!billete valor:5.!RectangleMorph subclass: #Billete	instanceVariableNames: 'valor imagen'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 00:18' prior: 33620175!initializesuper initialize.self extent:180@76.self borderWidth:0.imagen:= ImageMorph new.imagen image: (ImageReadWriter formFromFileNamed: 'atm\1Dollar.jpg').valor:=1.self addMorph:imagen.self openInWorld.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 00:18' prior: 33620869!valor:aNumberimagen image: (ImageReadWriter formFromFileNamed: 'atm\',aNumber asString,'dollar.jpg').valor:=aNumber.self removeAllMorphs.self addMorph:imagen.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 00:18' prior: 33621645!valor:aNumberimagen image: (ImageReadWriter formFromFileNamed: 'atm\',aNumber asString,'dollar.jpg').valor:=aNumber.! !billete_ Billete new.!billete valor:5.!billete on: #mouseMove send: #value to:[		Transcript show:'hola'.	].!billete on: #mouseMove send: #value to:[		Transcript show:'hola'.	].!billete on: #mouseUp send: #value to:[		Transcript show:'hola'.	].!billete_ Billete new.!billete on: #mouseDown send: #value to:[		Transcript show:'hola'.	].!billete_ Billete new.!billete valor:5.!billete_ Billete new.!!Billete methodsFor: 'nil' stamp: 'agb 3/17/2011 00:28'!handlesMouseDown: evt 	^ true! !!Billete methodsFor: 'nil' stamp: 'agb 3/17/2011 00:30'! mouseDown: evt 	Transcript show:'asdf'.! !billete_ Billete new.!billete openInWorld.!a := EllipseMorph new openInWorld.!a on: #mouseDown send: #value to:[		Transcript show:'hola'.	].!a := EllipseMorph new openInWorld.!a on: #startDrag send: #value to:[		Transcript show:'hola'.	].!a := EllipseMorph new openInWorld.!a on: #startDrag send: #value to:[		Transcript show:'hola'.	].!a := EllipseMorph new openInWorld.!a enableDrop: false.!a enableDrop: false.!a enableDrop: true.!a := EllipseMorph new openInWorld.!a on: #mouseDown send: #value to:[		a position:(a position) + (-2@ 2).	].!a enableDrop: true.!billete_ Billete new.!billete valor:5.!!Billete methodsFor: 'nil' stamp: 'agb 3/17/2011 01:04'! firstClickTimedOut: evt	"Start the Drag with the hand grabbing me"		evt hand grabMorph: self! !billete_ Billete new.!!Billete methodsFor: 'nil' stamp: 'agb 3/17/2011 01:04'! doubleClick: evt 	"ignore"	^ self! !!Billete methodsFor: 'nil' stamp: 'agb 3/17/2011 01:05'!click: evt 	"ignore this and wait until #firstClickTimedOut: arrives"	^ self! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 01:07' prior: 33622594!mouseDown: evt.evt hand		waitForClicksOrDrag: self		event: evt		selectors: {#click:. #doubleClick:. #firstClickTimedOut:. nil}		threshold: 5! !billete_ Billete new.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 01:08' prior: 33623340!firstClickTimedOut: evt	Transcript show:'asdf'.	evt hand grabMorph: self! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 01:08' prior: 33623790!mouseDown: evt.Transcript show:'asdf'.evt hand		waitForClicksOrDrag: self		event: evt		selectors: {#click:. #doubleClick:. #firstClickTimedOut:. nil}		threshold: 5! !!Billete methodsFor: 'nil' stamp: 'agb 3/17/2011 01:11'!wantsToBeDroppedInto: aMorph Transcript show:'hola'.! !billete_ Billete new.!billete_ Billete new.!RectangleMorph subclass: #Billete	instanceVariableNames: 'valor imagen contenedor'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!Billete methodsFor: 'nil' stamp: 'agb 3/17/2011 01:12'!contenedor:aMorphcontenedor:=aMorph.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 01:13' prior: 33624449!wantsToBeDroppedInto: aMorph Transcript show:'hola'.^ (aMorph isKindOf: contenedor).! !contenedor:= RectangleMorph new openInWorld.!billete_ Billete new.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 01:15' prior: 33624891!wantsToBeDroppedInto: aMorph Transcript show:'hola'.^ (aMorph = contenedor).! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 01:16' prior: 33625142!wantsToBeDroppedInto: aMorph Transcript show:'hola'.^ false.! !cont:= RectangleMorph new openInWorld.!billete_ Billete new.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 01:17' prior: 33625314!wantsToBeDroppedInto: aMorph Transcript show:'hola'.^ (contenedor = aMorph).! !billete contenedor:cont.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 01:20' prior: 33625535!wantsToBeDroppedInto: aMorph Transcript show:aMorph asString.^ (contenedor = aMorph).! !!Billete methodsFor: 'nil' stamp: 'agb 3/17/2011 01:22'! aboutToBeGrabbedBy: aHand Transcript show:'asdf'.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 01:22' prior: 33625883!aboutToBeGrabbedBy: aHand Transcript show:'abouttobegrabbe'.! !billete_ Billete new.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 01:22' prior: 33625734!wantsToBeDroppedInto: aMorph Transcript show:aMorph asString.^ false.! !billete_ Billete new.!billete_ Billete new.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 01:23' prior: 33626027!aboutToBeGrabbedBy: aHand | idx |	super aboutToBeGrabbedBy: aHand.	idx := owner submorphs				indexOf: self				ifAbsent: [^ self].	idx = 1		ifTrue: [^ self].	(owner submorphs copyFrom: 1 to: idx - 1)		do: [:m | m class = self class				ifTrue: [self addMorphBack: m]]! !billete_ Billete new.!!Billete methodsFor: 'nil' stamp: 'agb 3/17/2011 01:25'!wantsDroppedMorph: aMorph event: evt 	"Ask my container."		(self owner isKindOf: contenedor)	ifTrue: [ ^(self owner) wantsDroppedMorph: aMorph 		                event: evt ]	ifFalse: [^ false]! !billete contenedor:cont.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 01:45' prior: 33626205!wantsToBeDroppedInto: aMorph Transcript show:contenedor asString.^ false.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 01:46' prior: 33627096!wantsToBeDroppedInto: aMorph Transcript show:contenedor asString.^ (aMorph isKindOf: contenedor).! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 01:47' prior: 33624052!firstClickTimedOut: evt	evt hand grabMorph: self! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 01:48' prior: 33626778!wantsDroppedMorph: aMorph event: evt 	(self owner isKindOf: contenedor)	ifTrue: [ ^(self owner) wantsDroppedMorph: aMorph 		                event: evt ]	ifFalse: [^ false]! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:04' prior: 33624219!mouseDown: evt.evt hand		waitForClicksOrDrag: self		event: evt		selectors: {#click:. #doubleClick:. #firstClickTimedOut:. nil}		threshold: 5! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:04' prior: 33627868!mouseDown: evt.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:06' prior: 33628106!mouseDown: evt.evt hand		waitForClicksOrDrag: self		event: evt		selectors: {#click:. #doubleClick:. #firstClickTimedOut:. nil}		threshold: 5! !atm_  ATM new.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:07' prior: 33627265!wantsToBeDroppedInto: aMorph Transcript show:aMorph asString.^ (aMorph isKindOf: contenedor).! !Morph subclass: #Billete	instanceVariableNames: 'valor imagen contenedor'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!ImageMorph subclass: #Billete	instanceVariableNames: 'valor imagen contenedor'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:08' prior: 33621339!initializesuper initialize.self image: (ImageReadWriter formFromFileNamed: 'atm\1Dollar.jpg').valor:=1.self openInWorld.! !billete_ Billete new.!billete_ Billete new.!RectangleMorph subclass: #Billete	instanceVariableNames: 'valor imagen contenedor'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 00:18' prior: 33628944!initializesuper initialize.self extent:180@76.self borderWidth:0.imagen:= ImageMorph new.imagen image: (ImageReadWriter formFromFileNamed: 'atm\1Dollar.jpg').valor:=1.self addMorph:imagen.self openInWorld.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:08' prior: 33629358!initializesuper initialize.self image: (ImageReadWriter formFromFileNamed: 'atm\1Dollar.jpg').valor:=1.self openInWorld.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 00:18' prior: 33629664!initializesuper initialize.self extent:180@76.self borderWidth:0.imagen:= ImageMorph new.imagen image: (ImageReadWriter formFromFileNamed: 'atm\1Dollar.jpg').valor:=1.self addMorph:imagen.self openInWorld.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:08' prior: 33629881!initializesuper initialize.self image: (ImageReadWriter formFromFileNamed: 'atm\1Dollar.jpg').valor:=1.self openInWorld.! !----STARTUP----{17 March 2011 . 2:13:42 am} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!atm_  ATM new.!RectangleMorph subclass: #BilleteinstanceVariableNames: 'imagen valor'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!Billete methodsFor: 'nil' stamp: 'agb 3/17/2011 02:15'!initializesuper initialize.self extent:180@76.self openInWorld.! !billete _ Billete new.!!Billete methodsFor: 'eventos' stamp: 'agb 3/17/2011 02:19'!handlesMouseOver: evt   ^ true. ! !billete _ Billete new.!!Billete methodsFor: 'eventos' stamp: 'agb 3/17/2011 02:20'!handlesMouseStillDown: evt   ^ true! !!Billete methodsFor: 'eventos' stamp: 'agb 3/17/2011 02:21'!mouseStillDown: evtTranscript show:'1'.! !billete _ Billete new.!Billete removeSelector: #handlesMouseOver:!Billete removeSelector: #handlesMouseStillDown:!Billete removeSelector: #mouseStillDown:!!Billete methodsFor: 'nil' stamp: 'agb 3/17/2011 02:22'!handlesMouseOver: evt   ^ true. ! !billete _ Billete new.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:23'!handlesMouseDown: evt 	^ true! !Billete removeSelector: #handlesMouseOver:!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:24'!handlesMouseStillDown: evt   ^ true. ! !Billete removeSelector: #handlesMouseDown:!!Billete methodsFor: 'nil' stamp: 'agb 3/17/2011 02:25'!mouseDown: evtTranscript show:1.! !!Billete methodsFor: 'nil' stamp: 'agb 3/17/2011 02:26'!mouseStillDown: evtTranscript show:'aun presionado'.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:26' prior: 33631720!mouseDown: evtTranscript show:'presionado'.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:26'!handlesMouseOver: evt   ^ true. ! !atm_  ATM new.!billete _ Billete new.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:27'!handlesMouseDown: evt   ^ true. ! !billete _ Billete new.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:28' prior: 33631960!mouseDown: evtTranscript show:'presionado'.evt hand		waitForClicksOrDrag: self		event: evt		selectors: {#click:. #doubleClick:. #firstClickTimedOut:. nil}		threshold: 5! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:29'!firstClickTimedOut: evt	"Start the Drag with the hand grabbing me"		evt hand grabMorph: self! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:30'!mouseUp: evtTranscript show:'soltado'.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:30'!mouseDrag: evtTranscript show:'soltado'.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:32'!startDrag: evtTranscript show:'soltado'.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:32'!handlesDrag: evt   ^ true. ! !Billete removeSelector: #firstClickTimedOut:!Billete removeSelector: #handlesMouseDown:!Billete removeSelector: #handlesMouseOver:!Billete removeSelector: #handlesMouseStillDown:!!ATMServiceProvider class methodsFor: 'initialization' stamp: 'agb 3/17/2011 02:33'!initialize 	ServiceRegistry buildProvider: self new! !Billete removeSelector: #mouseDown:!Billete removeSelector: #mouseDrag:!Billete removeSelector: #mouseStillDown:!Billete removeSelector: #mouseUp:!billete _ Billete new.!atm_  ATM new.!Billete removeSelector: #handlesDrag:!!Billete methodsFor: 'nil' stamp: 'agb 3/17/2011 02:40'!handleMouseMove^true! !atm_  ATM new.!billete _ Billete new.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:40'!handlesMouseMove^true! !billete _ Billete new.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:41'!mouseMove: evtTranscript show:'soltado'.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 02:41'!mouseMoveTranscript show:'soltado'.! !billete _ Billete new.!Billete removeSelector: #handleMouseMove!Billete removeSelector: #handlesMouseMove!Billete removeSelector: #mouseMove:!Billete removeSelector: #mouseMove!Billete removeSelector: #startDrag:!!Billete methodsFor: 'nil' stamp: 'agb 3/17/2011 03:02'!handlesMouseOverDragging: evt ^true! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:04'!mouseEnterDragging: evt Transcript show:1.! !billete _ Billete new.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:06'!mouseMove: evtTranscript show:2.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:07'!handlesMouseDown: evt ^true! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:10'!mouseMoveWhileButtonDown:eventTranscript show:'moviendo'.! !Billete removeSelector: #mouseMove:!Billete removeSelector: #handlesMouseDown:!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:12'!handlesMouseStillDown: evt ^true! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:14'!handlesMouseDown: evt ^true! !Billete removeSelector: #handlesMouseDown:!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:14' prior: 33635208!handlesMouseStillDown: evt ^true! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:16'!handlesMouseDown: evt ^true! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:16'!handlesMouseOver: evt ^true! !Billete removeSelector: #handlesMouseOver:!Billete removeSelector: #handlesMouseOverDragging:!Billete removeSelector: #handlesMouseStillDown:!Billete removeSelector: #mouseEnterDragging:!Billete removeSelector: #mouseMoveWhileButtonDown:!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:17'! mouseDown: evt evt handwaitForClicksOrDrag: selfevent: evtselectors: {#click:. #doubleClick:. #firstClickTimedOut:. nil}threshold: 5! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:18'!click: evt 	"ignore this and wait until #firstClickTimedOut: arrives"	^ self! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:18'!doubleClick: evt 	"ignore"	^ self! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:18'! firstClickTimedOut: evt	"Start the Drag with the hand grabbing me"		evt hand grabMorph: self! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:20'!handlesMouseOverDragging: evt ^true! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:20'!mouseLeaveDragging: evt Transcript show:1.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:23'!mouseMoveWhileButtonUpTranscript show:1.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:23'!mouseMoveWhileButtonDownTranscript show:1.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:23'!mouseUpTranscript show:1.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:24'!mouseUp:evtTranscript show:2.! !Billete removeSelector: #mouseUp!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:24'!mouseMoveWhileButtonUp:evtTranscript show:1.! !Billete removeSelector: #mouseMoveWhileButtonUp!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:24'!mouseMoveWhileButtonDown:evtTranscript show:1.! !Billete removeSelector: #mouseMoveWhileButtonDown!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:25' prior: 33637606!mouseMoveWhileButtonDown:evtTranscript show:3.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:25' prior: 33637433!mouseMoveWhileButtonUp:evtTranscript show:4.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 03:25'!mouseStillDown:evtTranscript show:5.! !----QUIT----{17 March 2011 . 3:27:50 am} Squeak4.1.image priorSource: 60363!----STARTUP----{17 March 2011 . 12:38:11 pm} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!Billete removeSelector: #click:!Billete removeSelector: #doubleClick:!Billete removeSelector: #handlesMouseDown:!Billete removeSelector: #firstClickTimedOut:!Billete removeSelector: #handlesMouseOverDragging:!Billete removeSelector: #mouseDown:!Billete removeSelector: #mouseLeaveDragging:!Billete removeSelector: #mouseMoveWhileButtonDown:!Billete removeSelector: #mouseStillDown:!Billete removeSelector: #mouseMoveWhileButtonUp:!Billete removeSelector: #mouseUp:!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 12:43'!handlesMouseDown: evt 	^ true! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 12:43'! mouseDown: evt evt hand		waitForClicksOrDrag: self		event: evt		selectors: {#click:. #doubleClick:. #firstClickTimedOut:. nil}		threshold: 5! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 12:44'! click: evt 	"ignore this and wait until #firstClickTimedOut: arrives"	^ self! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 12:44'! doubleClick: evt 	"ignore"	^ self! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 12:44'! firstClickTimedOut: evt	"Start the Drag with the hand grabbing me"		evt hand grabMorph: self! !billete _ Billete new.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 12:46'! aboutToBeGrabbedBy: aHand 	"I'm about to be grabbed by the hand. If other cards are	 above me in a Card Container, then move them from the 	 Container to being submorphs of me"	| idx |	super aboutToBeGrabbedBy: aHand.	idx := owner submorphs				indexOf: self				ifAbsent: [^ self].	idx = 1		ifTrue: [^ self].	(owner submorphs copyFrom: 1 to: idx - 1)		do: [:m | m class = self class				ifTrue: [self addMorphBack: m]]! !Billete removeSelector: #aboutToBeGrabbedBy:!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 12:48'!wantsDroppedMorph: aMorph event: evt 	(self owner isKindOf: acontainer)	ifTrue: [ ^(self owner) wantsDroppedMorph: aMorph 		                event: evt ]	ifFalse: [^ false]! !billete _ Billete new.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 12:49'!wantsToBeDroppedInto: aMorph 	"I want to be dropped onto a Card or Card Container"	^ (aMorph isKindOf: acontainer)! !RectangleMorph subclass: #Billete	instanceVariableNames: 'imagen valor container'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 12:56' prior: 33640216!wantsDroppedMorph: aMorph event: evt 	(self owner isKindOf: container)	ifTrue: [ ^(self owner) wantsDroppedMorph: aMorph 		                event: evt ]	ifFalse: [^ false]! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 12:56' prior: 33640493!wantsToBeDroppedInto: aMorph 	"I want to be dropped onto a Card or Card Container"	^ (aMorph isKindOf: container)! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 12:56'!contenedor:acontainercontainer:=acontainer! !cont_RectangleMorph new openInWorld.!billete contenedor:cont.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 12:58'! acceptDroppingMorph: aMorph event: evt 	"Delegate to my owning Card Container"		(self owner isKindOf: container)	ifTrue: [ ^(self owner) acceptDroppingMorph: aMorph				event: evt ]	ifFalse: [ ^false ]! !billete contenedor:cont.!billete _ Billete new.!billete contenedor:cont.!Billete removeSelector: #wantsDroppedMorph:event:!Billete removeSelector: #wantsToBeDroppedInto:!Billete removeSelector: #acceptDroppingMorph:event:!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 13:04' prior: 33639193!click: evt 	Transcript show:'click event'.	^ self! !'From Squeak3.4 of 1 March 2003 [latest update: #5170] on 7 March 2003 at 3:49:05 am'!"Change Set:		SendTreeExplorer-JWDate:			7 March 2003Author:			Jesse WeltonLike MessageTally, MessageSendTree traces the execution of a block in simulation.  There are three key differences:	1) Rather than tallying the number of times each method is called in a given context, MessageSendTree traces and returns the exact tree of the sends made, in send order.	2) MessageSendTree is designed to work with a SendTreeExplorer which presents the results in a hierarchical list view rather than flattened to a text pane.	3) MessageSendTree allows all sends above a given method to be ignored, so that such a method can be conveniently traced without the bother of wading through a long send chain to get there."!Object subclass: #MessageSendTree	instanceVariableNames: 'context children '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-MessageSendTree'!!MessageSendTree commentStamp: 'JW 3/7/2003 03:18' prior: 0!Like MessageTally, MessageSendTree traces the execution of a block in simulation.  There are three key differences:	1) Rather than tallying the number of times each method is called in a given context, MessageSendTree traces and returns the exact tree of the sends made, in send order.	2) MessageSendTree is designed to work with SendTreeExplorer to present the results in a hierarchical list view rather than flattened to a text pane.	3) MessageSendTree allows all sends above a given method to be ignored, so that such a method can be conveniently traced without the bother of wading through a long send chain to get there.Compare the results of	MessageSendTree traceBlockAndExplore: [5 factorial printString]with the results of	MessageSendTree traceBlockAndExplore: [5 factorial printString] fromMethod: #printString!AbstractHierarchicalList subclass: #SendTreeExplorer	instanceVariableNames: 'roots '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-MessageSendTree'!!SendTreeExplorer commentStamp: 'JW 3/7/2003 03:19' prior: 0!This is a hierarchical list tool for displaying MessageSendTrees.!ListItemWrapper subclass: #SendTreeExplorerWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-MessageSendTree'!!SendTreeExplorerWrapper commentStamp: 'JW 3/7/2003 03:10' prior: 0!Support for the SendTreeExplorer.!!MessageSendTree methodsFor: 'as yet unclassified' stamp: 'JW 3/6/2003 23:46'!addChild: subtree	children addLast: subtree.! !!MessageSendTree methodsFor: 'as yet unclassified' stamp: 'JW 3/6/2003 23:46'!children	^children! !!MessageSendTree methodsFor: 'as yet unclassified' stamp: 'JW 3/6/2003 23:42'!context	^context! !!MessageSendTree methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 00:15'!context: aContext	context := aContext."	recClass := context receiver class.	selector := recClass selectorAtMethod: context method setClass: [:c | methClass := c]."	children := OrderedCollection new: 5.! !!MessageSendTree methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 01:01'!contextString	^context printString! !!MessageSendTree class methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 00:11'!traceBlock: aBlock	"MessageSendTree traceBlock: [3.14 printString]"	| tree prev stack |	tree := self new context: aBlock.	prev := aBlock.	stack := OrderedCollection new.	thisContext sender		runSimulated: aBlock		contextAtEachStep: [:current |			current == prev ifFalse: [ "send or return"				prev sender ifNotNil: [ "send"					stack addLast: tree.					tree := self new context: current.					stack last addChild: tree.				] ifNil: [ "return"					tree := stack removeLast.				].				prev := current.			].		].	^tree.! !!MessageSendTree class methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 01:23'!traceBlock: aBlock fromMethod: rootSelector	"MessageSendTree traceBlock: [3.14 printString] fromMethod: #printOn:base:"	| roots tree prev stack |	roots := OrderedCollection new.	stack := OrderedCollection new.	tree := nil. "tree is nil whenever above the rootSelector"	prev := thisContext sender.	thisContext sender		runSimulated: aBlock		contextAtEachStep: [:current |			current == prev ifFalse: [ "send or return"				prev sender ifNotNil: [ "send"					(tree notNil or: [current selector == rootSelector]) ifTrue: [						stack addLast: tree.						tree := self new context: current.						stack last							ifNil: [roots addLast: tree]							ifNotNil: [stack last addChild: tree].					].				] ifNil: [ "return"					tree ifNotNil: [tree := stack removeLast].				].				prev := current.			].		].	^roots.! !!MessageSendTree class methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 01:04'!traceBlockAndExplore: aBlock	"MessageSendTree traceBlockAndExplore: [3.14 printString]"		SendTreeExplorer openExplorerOnRoot: (self traceBlock: aBlock).! !!MessageSendTree class methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 01:50'!traceBlockAndExplore: aBlock fromMethod: rootSelector	"MessageSendTree traceBlockAndExplore: [3.14 printString] fromMethod: #printOn:base:"	SendTreeExplorer openExplorerOnRoots:		(self traceBlock: aBlock fromMethod: rootSelector).! !!SendTreeExplorer methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 01:27'!getList	^roots collect: [:root | SendTreeExplorerWrapper with: root]! !!SendTreeExplorer methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 03:40'!label	^ roots isEmpty		ifFalse: ['MessageSendTree']		ifTrue: ['MessageSendTree',' (empty)']! !!SendTreeExplorer methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 00:46'!openExplorer	| window listMorph |	window _ (SystemWindow labelled: self label) model: self.	window addMorph: (listMorph _ SimpleHierarchicalListMorph 			on: self			list: #getList			selected: #getCurrentSelection			changeSelected: #noteNewSelection:			menu: #genericMenu:			keystroke: nil)		frame: (0@0 corner: 1@1).	listMorph autoDeselect: false.     window openInWorld.! !!SendTreeExplorer methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 01:26'!root: sendTree	roots := Array with: sendTree.! !!SendTreeExplorer methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 01:25'!roots: sendTreeList	roots := sendTreeList.! !!SendTreeExplorer class methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 01:03'!onRoot: sendTree	^self new root: sendTree! !!SendTreeExplorer class methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 01:28'!onRoots: sendTreeList	^self new roots: sendTreeList! !!SendTreeExplorer class methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 01:03'!openExplorerOnRoot: sendTree	(self onRoot: sendTree) openExplorer.! !!SendTreeExplorer class methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 01:28'!openExplorerOnRoots: sendTreeList	(self onRoots: sendTreeList) openExplorer.! !!SendTreeExplorerWrapper methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 00:37'!canBeDragged	^false! !!SendTreeExplorerWrapper methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 00:36'!contents	^item children collect: [:each | SendTreeExplorerWrapper with: each]! !!SendTreeExplorerWrapper methodsFor: 'nil' stamp: 'JW 3/7/2003 01:01'!asString	^item contextString! !SendTreeExplorerWrapper removeSelector: #hasContents!SendTreeExplorer class removeSelector: #on:!SendTreeExplorer class removeSelector: #openExplorerOn:!SendTreeExplorer removeSelector: #explorerFor:!SendTreeExplorer removeSelector: #openExplorerFor:!----End fileIn of a stream----!'From Squeak3.4 of 1 March 2003 [latest update: #5170] on 7 March 2003 at 3:49:36 am'!"Change Set:		EventInterceptorMorph-JWDate:			7 March 2003Author:			Jesse WeltonDependencies:	SendTreeExplorer-JWEventInterceptorMorph is a button which, when pressed, begins listening to the hand's event stream.  When an even of the appropriate type is encountered, this morph intercepts it and traces the dispatch of the event using MessageSendTree, and opens a SendTreeExplorer on the results.  This is useful for debugging parts of the UI process which are otherwise difficult to trace.The eventType can be any of the Morphic event types, but #mouseUp, #mouseDown, and #keystroke are by far the most useful because they are the triggers for the majority of actual UI activity.A methodSelector may be set which identifies a particular method the user is interested in.  All method sends above this method are ignored.  This is useful when the user wishes to study the execution of a known method which is eventually triggered by a UI gesture, but has no interest in the complete event dispatching send tree leading up to it.  For instance, do:	(EventInterceptorMorph forEventType: #keystroke methodSelector: #notify:at:) openInWorldArm the event interceptor by pressing the button, then select the following line and type cmd-d (alt-d) to see a trace of the mechanism used by the compiler to insert error messages into code panes:	#(This expression) is: missing: #(an argument)The methodSelector defaults to #handleEvent:, tracing the complete event dispatching process."!SimpleButtonMorph subclass: #EventInterceptorMorph	instanceVariableNames: 'eventType armed methodSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!EventInterceptorMorph commentStamp: 'JW 3/7/2003 03:35' prior: 0!This morph is a button which, when pressed, begins listening to the hand's event stream.  When an even of the appropriate type is encountered, this morph intercepts it and traces the dispatch of the event using MessageSendTree, and opens a SendTreeExplorer on the results.  This is useful for debugging parts of the UI process which are otherwise difficult to trace.The eventType can be any of the Morphic event types, but #mouseUp, #mouseDown, and #keystroke are by far the most useful because they are the triggers for the majority of actual UI activity.A methodSelector may be set which identifies a particular method the user is interested in.  All method sends above this method are ignored.  This is useful when the user wishes to study the execution of a known method which is eventually triggered by a UI gesture, but has no interest in the complete event dispatching send tree leading up to it.  For instance, do:	(EventInterceptorMorph forEventType: #keystroke methodSelector: #notify:at:) openInWorldArm the event interceptor by pressing the button, then select the following line and type cmd-d (alt-d) to see a trace of the mechanism used by the compiler to insert error messages into code panes:	#(This expression) is: missing: #(an argument)The methodSelector defaults to #handleEvent:, tracing the complete event dispatching process.!!EventInterceptorMorph methodsFor: 'as yet unclassified' stamp: 'JW 3/6/2003 17:52'!actWhen: condition	"Ignore the button action of SimpleButtonMorph"! !!EventInterceptorMorph methodsFor: 'as yet unclassified' stamp: 'JW 3/6/2003 17:56'!arm: evt	self color: self armedColor.	armed := true.	self updateLabel.	evt hand addEventListener: self.! !!EventInterceptorMorph methodsFor: 'as yet unclassified' stamp: 'JW 3/6/2003 17:46'!armedColor	^Color paleRed! !!EventInterceptorMorph methodsFor: 'as yet unclassified' stamp: 'JW 3/6/2003 17:56'!disarm: evt	self color: self unarmedColor.	armed := false.	self updateLabel.	evt ifNotNil: [		evt hand removeEventListener: self.	].! !!EventInterceptorMorph methodsFor: 'as yet unclassified' stamp: 'JW 3/6/2003 17:51'!doButtonAction	"Ignore the button action of SimpleButtonMorph"! !!EventInterceptorMorph methodsFor: 'as yet unclassified' stamp: 'JW 3/6/2003 17:41'!eventType: evtType	"evtType should be one of the Morphic event types:		#mouseUp, #mouseDown, #keystroke, etc."	eventType := evtType.! !!EventInterceptorMorph methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 01:59'!handleListenEvent: evt	evt type == eventType ifTrue: [		"stop listening to events -- prevent loops"		self disarm: evt.		"tally sends during redispatch of event"		MessageSendTree			traceBlockAndExplore: [ evt hand handleEvent: evt ]			fromMethod: methodSelector.		"abort the dispatch of the original event"		CurrentProjectRefactoring currentSpawnNewProcessAndTerminateOld: true.	].! !!EventInterceptorMorph methodsFor: 'as yet unclassified' stamp: 'JW 3/6/2003 19:13'!initializeAllButLabel	super initializeAllButLabel.	self eventType: #mouseUp.	self methodSelector: #handleEvent:.	self disarm: nil.! !!EventInterceptorMorph methodsFor: 'as yet unclassified' stamp: 'JW 3/6/2003 19:12'!methodSelector: aSymbol	methodSelector := aSymbol.! !!EventInterceptorMorph methodsFor: 'as yet unclassified' stamp: 'JW 3/6/2003 17:58'!mouseUp: evt	super mouseUp: evt.	self arm: evt.! !!EventInterceptorMorph methodsFor: 'as yet unclassified' stamp: 'JW 3/6/2003 17:57'!setDefaultLabel	self updateLabel.! !!EventInterceptorMorph methodsFor: 'as yet unclassified' stamp: 'JW 3/6/2003 17:47'!unarmedColor	^Color paleBlue! !!EventInterceptorMorph methodsFor: 'as yet unclassified' stamp: 'JW 3/6/2003 17:57'!updateLabel	self label:		(armed			ifTrue: ['Armed for ', eventType printString]			ifFalse: ['Click to Arm']).! !!EventInterceptorMorph class methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 02:10'!forEventType: evtType	"(EventInterceptorMorph forEventType: #mouseUp) openInWorld"	^self new eventType: evtType! !!EventInterceptorMorph class methodsFor: 'as yet unclassified' stamp: 'JW 3/7/2003 02:12'!forEventType: evtType methodSelector: aSymbol	"(EventInterceptorMorph forEventType: #mouseUp methodSelector: #sendMouseEvent:) openInWorld"	^self new eventType: evtType; methodSelector: aSymbol! !----End fileIn of a stream----!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 14:18'!startDrag: evt 	Transcript show:'drag event'.	^ self! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 14:19'!handlesMouseOverDragging: evt 	^ true! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 14:20'!mouseEnterDragging: evt 	Transcript show:'enter dragging'.	^ self! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 14:21'!mouseLeaveDragging: evt 	Transcript show:'leave dragging'.	^ self! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 14:21'!mouseUp: evt 	Transcript show:'mouse up'.	^ self! !!SokobanWorld commentStamp: '<historical>' prior: 0!This is a modified version of the Sokoban game.Modified by Stephan B Wessels!!SokobanMorph commentStamp: '<historical>' prior: 0!This is a modified version of the Sokoban game.Modified by Stephan B Wessels!!SokobanWorld class methodsFor: 'constants' stamp: 'rhi 7/16/2003 11:09'!allButFree	^ String		with: self box		with: self boxAtGoal		"with: self free"		with: self goal		with: self player		with: self wall! !!SokobanWorld class methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!box	^ $$! !!SokobanWorld class methodsFor: 'constants' stamp: 'rhi 7/16/2003 11:08'!boxAtGoal	^ $*! !!SokobanWorld class methodsFor: 'constants' stamp: 'rhi 7/16/2003 11:12'!boxOrBoxAtGoal	^ String		with: self box		with: self boxAtGoal! !!SokobanWorld class methodsFor: 'private' stamp: 'rhi 7/14/2003 17:42'!extentOf: aSequenceableCollection	^ (aSequenceableCollection inject: 0 into: [:longest :each |		each size max: longest]) @ aSequenceableCollection size! !!SokobanWorld class methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!free	^ Character space! !!SokobanWorld class methodsFor: 'constants' stamp: 'rhi 7/15/2003 17:23'!freeOrGoal	^ String		with: self free		with: self goal! !!SokobanWorld class methodsFor: 'instance creation' stamp: 'rhi 7/16/2003 08:50'!fromFile: aString	"inspectIt: [self fromFile: '.\Screens\screen.1']"	^ self fromString: (FileStream fileNamed: aString) contentsOfEntireFile! !!SokobanWorld class methodsFor: 'instance creation' stamp: 'rhi 7/15/2003 18:48'!fromIndex: anInteger	"inspectIt: [self fromIndex: 1]"	^ self fromString: (self mazes at: anInteger) index: anInteger! !!SokobanWorld class methodsFor: 'instance creation' stamp: 'rhi 7/15/2003 18:48'!fromString: aString	"inspectIt: [self fromString: '    #####    #   #    #$  #  ###  $##  #  $ $ #### # ## #   #######   # ## #####  ..## $  $          ..###### ### #@##  ..#    #     #########    #######']"	^ self fromString: aString index: 0! !!SokobanWorld class methodsFor: 'instance creation' stamp: 'rhi 7/15/2003 18:50'!fromString: aString index: anInteger	| world |	(world _ self new)		maze: (self mazeFrom: aString);		walls: (self wallsFrom: aString);		extent: (self extentOf: world maze);		position: (self playerPositionIn: world maze);		index: anInteger;		moves: 0;		pushes: 0;		addPadding.	^ world! !!SokobanWorld class methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!goal	^ $.! !!SokobanWorld class methodsFor: 'private' stamp: 'rhi 7/14/2003 18:03'!mazeFrom: aString	^ aString findTokens: String crlf! !!SokobanWorld class methodsFor: 'mazes' stamp: 'rhi 7/15/2003 17:24'!mazes	"http://www.cs.ualberta.ca/~games/Sokoban/Mazes/Screens/"	^ IdentityDictionary new		at: 1 put: '    #####    #   #    #$  #  ###  $##  #  $ $ #### # ## #   #######   # ## #####  ..## $  $          ..###### ### #@##  ..#    #     #########    #######';		at: 2 put: '#############..  #     ####..  # $  $  ##..  #$####  ##..    @ ##  ##..  # #  $ ######## ##$ $ #  # $  $ $ $ #  #    #     #  ############';		at: 3 put: '        ########        #     @#        # $#$ ##        # $  $#        ##$ $ ########## $ # ####....  ## $  $  ###...    $  $   ##....  ##################';		at: 4 put: '           ########           #  ....#############  ....##    #  $ $   ....## $$$#$  $ #  ....##  $     $ #  ....## $$ #$ $ $#########  $ #     ### ##########    #    ###     $   ###  $$#$$  @##    #    #############';		at: 5 put: '        #####        #   #####        # #$##  #        #     $ ########## ###   ##....  ## $  $####....    $ $$ ###....  ##$  $ @##########  $  ##        # $ $  #        ### ## #          #    #          ######';		at: 6 put: '######  ####..  # ##@###..  ###   ##..     $$ ##..  # # $ ##..### # $ ##### $ #$  #   #  $# $ #   # $  $  #   #  ##   #   #########';		at: 7 put: '       ##### #######   #### # @## $$ ##    $      ##  $  ###   #### #####$#### $  ### ..## $ $ $ ...##    ###...## $$ # #...##  ### #########';		at: 8 put: '  ####  #  ###########  #    $   $ $ #  # $# $ #  $  #  #  $ $  #    #### $# #  #### ##@#$ $ $  ##   ##    $ #$#   # ##   $    $ $ $ ######  #########  #      #  #      #  #......#  #......#  #......#  ########';		at: 9 put: '          #######          #  ...#      #####  ...#      #      . .#      #  ##  ...#      ## ##  ...#     ### ########     # $$$ ## #####  $ $ #######   #$ $   #   ##@ $  $    $  $ ####### $$ $ #####     #      #     ########';		at: 10 put: ' ###  ###############@####       #   ## $$   $$  $ $ ...##  $$$#    $  #...## $   # $$ $$ #...####   #  $    #...##     # $ $ $ #...##    ###### ###...### #  #  $ $  #...##  ## # $$ $ $##..## ..# #  $      #.## ..# # $$$ $$$ #.###### #       # #.#    # ######### #.#    #           #.#    ###############';		at: 11 put: '          ####     #### #  #   ### @###$ #  ##      $  # ##  $ $$## ## #  #$##     # # # $ $$ # ### #   $ #  # $ #########    #  $$ #   ##### ## $         ##.    ###  #########.. ..# #####...#.##.....########';		at: 12 put: '#################              ## # ######     ## #  $ $ $ $#  ## #   $@$   ## ### #  $ $ $###...## #   $ $  ##...## ###$$$ $ ##...##     # ## ##...######   ## ##...#    #####     ###        #     #        #######';		at: 13 put: '   #########  ##   ##  ########     #  #    ####  $ #$ #  #  ... ## # $#@$## # #.#. ##  # #$  #    . . ## $    $ # # #.#. ##   ##  ##$ $ . . ## $ #   #  #$#.#. ### $  $   $  $... # #$ ######    ##  # #  #    ########## ####';		at: 14 put: '       ####### #######     # #     # $@$ # #$$ #   ######### # ###......##   # #   $......## # # # ###......     ###   #### ### #$###  #$   #  $  # ##  $ $$$  # $## ##   $ $ ###$$ # ######     $   # #    ### ###   # #      #     #   #      ########  #             ####';		at: 15 put: '   ########   #   #  #   #  $   # ### #$   #### #  $  ##$   # #  # @ $ # $# #  #      $ #### ## ####$##     # # $#.....# #   # #  $..**. $# #####  #.....#   ##   ### ######## $$  #  ##  #     #######   #     #####';		at: 16 put: '######   ###    #  ##### $  ####  ##  $$ $   $####@ #$    ## #  ##  $ $ ## # $  ## ## .# #  #$##$  #.# ###   $..##.#  #    #.*...#  # $$ #.....#  #  #########  #  #  ####';		at: 17 put: '   ##########   #..  #   #   #..      #   #..  #  ####  #######  #  ##  #            #  #  #  ##  #  ##### ##  #### ###  $  ##### #  ## # $  $  # $  ## @$  $   #   ###### ## #######   #    #   ######';		at: 18 put: '     ###########     #  .  #   #     # #.    @ # ##### ##..# ######  # ..###     #### $ #...   $ #  $ ##    .. ##  ## ## #####$##$# $ #   # #  ## #    #$ $$ # #  #  $ # #  # $## #  #               #  #  ###########  #  ####         ####';		at: 19 put: '  ######  #   @######### $   ##   ##    ##### $ #  ##    ## $ #  ##### ### $  $    # ### $ $ ### # ### #  $  # # ### # #$#   # ### ###   # # #######  $  #### # #....##    $    $   ..#.#####$  $# $   ....##       #  ## ....####################';		at: 20 put: '    ###############        #####     #   $  #@ ## #######$####  #### #    ## #  #$ ..## # $     #  #  #.## # $  #     #$ ..## #  ### ##     #.## ###  #  #  #$ ..## #    #  ####  #.## #$   $  $  #$ ..##    $ # $ $ #  #.##### $###    #$ ..#   #    $$ ###....#   #      ## ######   ########';		at: 21 put: '##########       ##       ###### #### #  ### #@##    ## $$$ $  $$##  # ## $  ##  # ##  $ ########  $$$ $#  # #   ##   ....# # #   # #.. .# #   # # ##...# ##### $  #...#     ##   #####      #####';		at: 22 put: '######     #####    #######  ######   $#  #  $  #   ##  $  $  $ # $ $  ###$ $   # @# $    ##  $ ########### ### #   #.......# $## ##  # ......#  ## #   $........$ ## # $ #.... ..#  ##  $ $####$#### $## $   ### $   $  ### $     $ $  $    ### ###### $ ##### ##         #       ####################';		at: 23 put: '    #######    #  #  ######### $#$ #  ###.. #  #  #   ##.. # $#$ #  $#####.  #     #$  #  ##..   $#  # $    ##..@#  #$ #$  #  ##.. # $#     $#  ##.. #  #$$#$  #  ###.. # $#  #  $#$  ##.. #  #  #   #   ###. ####  #####   # ####  ####   #####';		at: 24 put: '################..........  .#####..........$$.#  ############$ #   ###      $  $     $ ### ####   #  $ #  ##      #   ##  # ###  $#  # ##  ### ### $ #$###    ### #####  $ #  #  ### #####    $ ## #  # ## # $  #  $  $ $   # #  $  $#$$$  #   # #  #  $      ##### # @##  #  #  # ##############';		at: 25 put: '#####  ###############  #   ..#......##  # # ##### ...###$#    ........##   ##$######  ##### $ #     ######@ ###$ # $   ######  ##  $ #$$$##       ##      #    #$#$#### #### #$$$$$    ## #    $     #   ## #   ##        #### ######$###### $ ##        #    #   ###########    #####';		at: 26 put: ' ####### #  #  #######  #  #...####  $#  #...  ## $ #$$ ...  ##  $#  #... .##   # $##########$       $ $ ###  #  $$ #   # ######  ##$$@#      #      ##      ########';		at: 27 put: ' ################# #...   #    #   ####.....  $## # #$ ##......#  $  #    ##......#  #  # #  ########## $  $ $  #  #     #$##$ ##$## ##   $    # $    # #  ## ### #  ##$ # # $ $$     $  $  # # $    $##$ ###### #######  @ ##       ######';		at: 28 put: '         #####     #####   #    ## $  $  ######### $  $ $ ##.##       $$  ##..##  ###### ###.. ### #  #    #... ## $   #    #... ##@ #$ ## ####...#####  $ $$  ##..#   ##  $ $  $...#    # $$  $ #  .#    #   $ $  ####    ######   #         #####';		at: 29 put: '######   ### $  ########### # #       ######## #   $#$#@  #   ##  #      $ #   $ ##  ### ######### ###  ## ..*..... # #### ## *.*..*.* # ### $########## ##$ ##  $   $  $    $  ##  #   #   #   #  ####################';		at: 30 put: '       ###########       #   #     ######  #     $ $ ##   ##### $## # ### $ ##   # ## $  ## $  @$$ # ##$$$ ### ###   # ##    ### #   ### #####$### #     $  #....##  ### ## $ #....### $   $ #   #..$. ##  ## $ #  ##.... ######   ######...##    #####    #####';		at: 31 put: '  ####  #  ######### ##  ##  #   # #  $# $@$   #### #$  $  # $ $#  ####  $## #$ $     ##  #  # #   $$$  ## $    $  $## ##### $ $ #$#  #  ###  ###  ###$ # #  #....     # ####......####   #....####   #...##   #...#   #####';		at: 32 put: '      ####  #####  # ##     $### $  ## ####@$ $ # $  ##### ##   $# #....#$ $ # #....#   $# #....  $$ ## #... # $   # ######$ $  #      #   ###      #$ ###      #  #      ####';		at: 33 put: '##############     ##  ###   $   $ ##### ## $$ ##   $ #    ## $$$ # #####   # # $ ###  #  #  $ ## $# $#    ##   ..# ########.. $ #@##.....# $# ###....#  $ ####..##    #############';		at: 34 put: ' ######### #....   ## #.#.#  $ ####....# # @### ....#  #  ###     #$ ##$ ### ###  $    # #$  $ $ $#  # # #  $ $ ## # #  ###  ##  # #    ## ## ## #  $ #  $  # ###$ $   ###   #  #####   ####';		at: 35 put: '############ #######   #    # ###....##   $$#   @  .....##   # ###   # ....### ## ###  #  ....# # $ $     # # #### #  $ $##  #      ##### #  #### # ## ##  # #$   ## #    ## $  $  # ## #   ### # $ $    # #   ##  $ ## ## # ###### $$     $$  ### ## ### $  # #    # #    # ###### ######';		at: 36 put: '            ##########  ######   ##   ####  $ $ $ ## $   ## ## ##  ###   $ $     $  $ #### $  ## ##     ##  # ##### #####$$ # ##$##### @##     # # $  ###$### $  ## # $  #   ###  ### # $$ $ #   $$ # #     #   ##  # #######.. .###    #.........#    #.........#    ###########';		at: 37 put: '############......   ##########......   #  ##   ##..### $    $     ##... $ $ #   ##   ##...#$#####    #  ####    #   #$  #$ #  #  $$ $ $  $##  #  #  $   #$#$ ##$ #  ### ## #    ##  #   #  $ $ ## ######   #    $  $  #   ##   # #   #    #####@#####        ###';		at: 38 put: '      ########### @##     $  ##   $## $###$#...# # # $...  # # #. .# ## #   # #$ # #$  $    # #  ####### ####';		at: 39 put: '             ###### #############....###   ##     ##....##  $$##  $ @##....##      $$ $#  ....##  $ ## $$ # # ...##  $ ## $  #  ....### ##### ### ##.#####   $  $ ##   .  ## $###  # ##### ####   $   #       ##  $ #$ $ $###  ## $$$# $   # #####    #  $$ #######   ###     #####';		at: 40 put: '    ############    #          ##    #  # #$$ $  #    #$ #$#  ## @#   ## ## # $ # ##   #   $ #$  # #   #   # $   # #   ## $ $   ## #   #  #  ##  $ #   #    ## $$# #######$$   #   ##....#  #########.#... ###....   ##....   ##########';		at: 41 put: '           #####          ##   ##         ##     #        ##  $$  #       ## $$  $ #       # $    $ #####   #   $$ ######  ######## ##    ##.            $$$@##.# ####### ##   ###.# #######. #$ $###........... #    ###############  $ #             ##  ##              ####';		at: 42 put: '     ########  ####      ######  #    ## $ $   @#  # ## ##$#$ $ $##### ......#  $$ ###   ......#  #   ## # ......#$  $  ## #$...... $$# $ ##   ### ###$  $ #####  $  $  $  $ #  #  $  $  $  $ #  ######   ######       #####';		at: 43 put: '        #######    #####  #  ####    #   #   $    # #### #$$ ## ##  ###      # #  ## ####  ### $#$  $  $  ##...    # ##  #   ##...#    @ # ### ###...#  ###  $  $  ######### ##   #   #          #########';		at: 44 put: ' ##### #   # # # ####### #      $@###### # $ ##$ ###   # # #### $    $ # # ##### #  #$ ######  #### ##$      ##  $#  $  # ## ## ##         # #...# #######  ###  ...  #     #### # #...# #          # ### # #          #       #          #########';		at: 45 put: '##### #####...# #  #####...###  $  ##....## $  $#####....##   $  ####... ## $ $ ## ##    #  $  ##  ## # ### ##### $ # #$  $    ##  $ @ $    $  ##   # $ $$ $ ####  ######  #### ##    #######';		at: 46 put: '###########        ##### ###### #  ### # $ $ $  $ ##       #$   ####$  $$#  ###  #  ## # $##  ##$#   $ @#   #  $ $ ###   # #   $  #   # ##   # #  ##  ##### #  #         #  #.......###  #.......#  #########';		at: 47 put: '         #### #########  ####  $      $ ######   ## ##   ##...## #$$ $ $$#$##...## #   @   #   ...##  $# ###$$   ...## $  $$  $ ##....####$       #######  #  #######  ####';		at: 48 put: '  #########    #*.*#*.*#    #.*.*.*.#    #*.*.*.*#    #.*.*.*.#    #*.*.*.*#    ###   ###      #   #    ###### #######           ## $ $ $ $ $ ### $ $ $ $ ## #$ $ $ $ $#  #   $@$   #  #  #####  #  ####   ####';		at: 49 put: '       ####       #  ##       #   ##       # $$ ##     ###$  $ ##  ####    $   ####  # #####  ##    # #....$ ## #   $ ....# ##  $ # #.*..# ####  #### ### #  #### @$  ##$##     ### $     #       #  ##   #       ######### ';		at: 50 put: '      ############     ##..    #   #    ##..* $    $ #   ##..*.# # # $##   #..*.# # # $  #####...#  #    # ##  ## #          ## @$ $ ###  #   ### $   $   # #   ####$$   # # # # #  #   $   # # #####  # $# #####      #  #$   #   #    # #  #  ###   ##     #  #  #      #    ##  ####      ######';		at: 51 put: ' ######### #       # # $ $$ $#### #  $ ##.#   $$ ###.###   $ ##.#. $ ## #####...  $## $  ##...$   $    ##..###$### #@##..# #     ####### #######';		at: 52 put: '           ########           #......#   ####    #......#   #  #########...#   # $   $    #...#   #  # # # # #   ###### # # #@# #   ##   # ### ### ## ###    $ # $ $ $ # ## $$$  $   #     ##   # ###$###$## #### #  $   #     # ## $  # $ $ $ ### #  # ### ### ##   # $          #    #  ###########    ####';		at: 53 put: '##################  #                ## # $#   $ ##  $    # #    $###    # $$ # #.###     $ $ ##  ###...#  #  #    #$  ##..##$$#### $  #   ##...#      $ ##  ####...$  ###  #    # ###..  $#  ##   ##@ # ##.#              #  ##################';		at: 54 put: '#####################   #    #   #   #@## $      $   $   # ### ###..## ###     ##   #....#$#  $### ## $ #....#  $  $ $ ##   #....# # # $ $ ##   ##..##   #$#   ###$##    ##  #  #$###   $  $     #  #  ##   #    #   #     #####################';		at: 55 put: '#####################    @##      #   ###    ##    $    $ ###  ###....# # #  ####   #....# # # $   #### #...#  #       ###  ##.#     $   $ ###  $ $ ###  # # ##### $       # # $   ##### $  $# # # # $ #####         # #  ######################';		at: 56 put: '#####################  #  ##    #   @#####    $    # $###  ###$# $ ##$# $ $    ##   $#    $      #### ##   $ ###  #....## # $# # # # #....###    $ $ #  #....#####$ ###  $ #....#####  # $        #######      # #    ##########################';		at: 57 put: '#####################@     ###   #  #  ## # #  #  $  $     ######     # $ $#$# ##.#..#    ##$ $    ##.....    $   #   ###.....    ###$##$####.#..#    $    #   ######     #  #$  $ ######  #  $    $ $ ######  #  #  #  #  #####################';		at: 58 put: '######################...   ## #    #  ##....         $ ## ##....# # #$###$    ##...#    #       # ###.#  #$ #     $## ##  #  # $ $ ###  $ ##     $  $ #  # ## ### # ## #$$# $#  # ##  #   $ $ #      ###    #     #  #   @#####################';		at: 59 put: '#####################   #  #@# ##  ###### # #  $    $  ###### #    ###### $  ####   #  #....#  $$  ###$##$##....#      ##      #....##$##$###  $$  #....#      ## $  $  #  #  ###  ######  $   $    $  ###### #    #  #   ######################';		at: 60 put: '##################### #     #          ##       $  ## ### #######  ##   $  $   ###..##  # # $ # #  ##....  $     ##$# ###....  $#####   #$####..# #  #   #  $  ####.# #  $   $  # @###  $  $ #   #  ######       ###############################';		at: 61 put: '#####################     ###..###     ## $$  ###..###  $@ ##  # ##......#  $  ##     #......#  $  #####  ###..######$ ##   $$$ #..#    #  ## $#   $  $  $$ #$ ##  #  ## $  ##  #  ## $    $ ## $    $ ##  #  ##    ##  #  #####################';		at: 62 put: '#####################    #  # #  #  #  ## @# # ## $   $   ###### #    #  # $   ##    # ## #$ ## ## ##      $   $   $   ##..###$$## $##$ ## ##..#.#  # $   $ #  ##....# $$   ##$ #####....#  #####      ##...###        ##  #####################';		at: 63 put: '#####################....#       #  #  ##....# # $  $      ##.... ##  $# # $#$ ##...#   $   $#  $  ##..####  # $   $$  ##      #### #### ####        #   #     ## ##   #   $ # $ $ ## ##    $ ## $  $  ##     @#     #   # #####################';		at: 64 put: '#####################....###           ##....##### #  #$# ###....###   #$  $   ##....###    $  #$$####  #### $#  #$ $  ###  ####  $  $  #  ##@  ####$###$## $  ###        #  #  $  ###   ###  #  $  ############  #  #     #####################';		at: 65 put: '#####################     #     @#...####     #      ##...### # # ##$## ## ....##   $ #   $$$  ....####$### $$  ### ##.##     $  #    # #####  $  #  ###  # #  ### #$##    $  $$   ##   $ ##   #  # #  ##     #    #  #    #####################';		at: 66 put: '#####################     #  #...#@    ## #       ....#    ##  $  #   #....#   ## ##$#### ##....#  ## $   $  #  #...#  ## $$ #   #   # $$  ####  $$$#   $$  $  ## $  #  #    # $#  ##   $#  #       $  ##  #    #    #  #  #####################';		at: 67 put: '#########################@###.##...##  ######$  ..#...#    #####    ......#  $ ####  $ #.....## # ####  $$# #####  $ $ ### $# $    ##  $$  ###  #  #    # $  $ ###   $$ ### #$##   ### $#      $ $  $ #####    #    #    #######################';		at: 68 put: '#####################@     #   #       ### ### ##  #### # ###    # #  $$       ##  # # # $ # $ ## ###     $ #  #$$ #   ##  ###  #      ## ###..#.# $ #  $ #    ##..#.#  $ # ## $$  ##....##   $$  $  # ##.....##        #  #####################';		at: 69 put: '#####################  #      #   #   ### $# $ $ ##...$  $ ##  $  # ##....# $  ## ## $ ##....#   $ ## $    #....## $   ## $##  #...#       ##   $$$##$##  ### ### # #  #   #  #    ## $ #  $  ##       ##    #    #@       #####################';		at: 70 put: '#####################  #  # #    #  #  ##   $      $ $     ### #  #$###$##  ## ##   $     $  #  $  ## ###$##$#   # $   ## #   $ $  ###### $## $  $$ $  #@#.#...## #     #  # #.#...## ########## #.....##            #.....#####################';		at: 71 put: '#####################  #     #  ##    ### $#   $ #     ##  ## $  $  #..#     $ ## $ $  #....#   # ### $#  #......### $ ##   #  #....#  #$  ## $  ####..#   #   ### $   ## # # $  $##### $    $#@$ $#   #####   #       #   #####################';		at: 72 put: '#####################      ....#    #####      ....        ## # ##########     ## #$   #      ###..##  $   #$$###   #..## $ ### $   $   #..## $ #   $ $ #  ##..##  #  $$ # $ ##   ###@## $#  $  $     ####       ##   #  #######################';		at: 73 put: '#####################        #   #@ #  ## $$  #$$# # #  ## ##  # $ $ #$$ #     ### #  #  # # #  #  ##   ##       #     ##   # $ #   #   #  ## $ #$ #   #  $ #..###$ #  ####    #...##  $          #....##   #  #     #.....#####################';		at: 74 put: '#####################     #   #####    ### $  #   ####  $  ##### $$   #..#  #  ##  $  $  ##..#### ### $   ###....   $$ ##  #$#   ....# # $ ## #  # $ ..###$#   ## #   $ #..#   ##  ##   $#  ####   # $### #  #    @#      ######################';		at: 75 put: '#####################   #   #    #   #@##   $  $     # $ # ###$# $### #    $$# ##  #  #.###  #$ $  ##  #$#....#  # ### ## $  #.....##    # ###$  #.#....#$$ $  ##  ######..## #  # ##  $         $ ### ##   #   #        # #####################';		at: 76 put: '##################### # # #   #@##   # ##             $    ##  ##$# ##### $ # ####    ##.....#  #  ###$##$#.....###$#$ ##   # ##.....#  # ###  $    ##..##  #  ## $ #   $   $  $$$ ### $  $# #  #  $   ##   ##   #  #      #####################';		at: 77 put: '#####################    ##   #    #   ##  $  $     ## $   ### #####  .###### ## # ##  ##....#### #### ##$ ###..##     ##      #... .# $ $ ## $ ## ## . ### ##### # $    #.## # ## $ $ #   .#### ### #  ## # ##  #  #########  $##$   $ #      ##      $ #@#       #  ## ######       #######';		at: 78 put: '       ###########       #         #       #    $ $  ####### # $ ##### ##    ##### $  ##$##       $ $      ##          ## ## ##    ##@##### ## ##    ####   # ## ###....#      # $   ##....#      #     #######      #######';		at: 79 put: '##############           ## ### $$    ##   # $  $  ##  $####$####### $ ##        ######  $$ $        ...#### ## $$#     ...#  # ##   #     ...#  #      #     ...#  ###@#############    ###';		at: 80 put: '  ####################@##         ...##    #         ...## $  #         ...## $$ #         ...### $ ###$########## # ###  $ ###   $  $ ##  $ #  $ ## $  #    ##  $ #    ##    #    ############';		at: 81 put: '              #####     ##########   #     #        #   #     #  $ $    $$ #     # ##### ## $ #     #$$   #$## $ #     # ### # ##$  ####### ### $ $    ##....        ##   ##....        #######....        ############@##          ###';		at: 82 put: '    ###### ####    # #    ## # # $     #### #### #########  $   $ ##  ...##   $$ $$    ...##    $  $##  ...###@## ## ##  ...# ###  $  ######## #   $$  # #    #  # #########';		at: 83 put: '####### ##########     # #   ##  ## ### # #   $   ## # $ ###   $   ##   $$      ##$ ##    ####   ##  ##@############ #####..    #####$ #  #..    ####   #  #..       $$  #  #..    #### $ #  #..    #  #   #  ########  #####';		at: 84 put: '########     ###########     #    #  ### $   #   $ $  ##  $  #  $ ##  ## $$  ##$ $    ### #  ## ######### #  ##    ...##  #$       ...##   $$      ...##     ##@#  ...#################';		at: 85 put: '#############      #   ### $  $   #  ##########  #####      # #..  #     #### # #.####  ####    # #....    #  $ #### # ...#   # $$$#  #####.#### ##  $@$   ##     ##### $ #    ## #.# $      $###$ ## #.########  #  $ ## #..        ##  $ ## # ####### $ # #  ##   #     #       #######     ##########';		at: 86 put: '#################       #@ #   ## # # # # $  $$## #...# #$$$   ##  ...# # $  $$### ##.## # ##    ## #...     $    ## ## ###  ########    # ##########';		at: 87 put: '    ##### ####   ## ##### #  $    ###   # # $@$ $    $  # # #$######## ## # #  $  #     # # # $ $ # #   ### #  $# # ######  ##    #     ##    $ # ###   ###### ##  #....##    $     ....##         #....#################';		at: 88 put: '##############........#####...#### #  ######...#  ###    $ ##...$$     $ $  ##  .#  $ $# $  ###...# #$#   $  ##.# # $   $    ##.  #$###$####$###  #   $ $    # #  #  $@$  #  # #  # #### $  $# #  #    ###   # #  # $$ # ##### #  #    # #########';		at: 89 put: ' ################## #   $       ...#.## #       ####..... # # #######  #..... # # #    $ $ ##....## # #  $ # # ###...# # # $@$ $  ##### ### #  $  $ $$   $ ##  #$# $#   # $## ## ##    ## ## $ # ## # $# $ $  #     ## #         ######## ########$##   ##        #  $   #########    #####       ###  #         ####';		at: 90 put: '#####################..#    #          ##.$  $  #$$  $## $###.$#  ###  ## ##   ##  # $ #  $$   $   ## ###  # #  #$  #####  ## # $   #@ #   ## $    $  ##.##  $ ##  # $# $# $     ####  #  #  #   ###   ##  ######## #      ##           #  #.#.###$########$#   ...##    .*  #    ##.#.## .*...*   $  .....#####################';		yourself! !!SokobanWorld class methodsFor: 'mazes' stamp: 'rhi 7/16/2003 08:50'!mazesShow	"inspectIt: [self mazesShow]"	^ [	| morph |		self mazes do: [:str |			morph _ SokobanMorph forWorld: (SokobanWorld fromString: str).			(Delay forSeconds: 0.5) wait.			morph delete].	] fork! !!SokobanWorld class methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!player	^ $@! !!SokobanWorld class methodsFor: 'private' stamp: 'rhi 7/14/2003 17:42'!playerPositionIn: aSequenceableCollection	| row |	1 to: aSequenceableCollection size do: [:idx |		row _ aSequenceableCollection at: idx.		(row includes: self player)			ifTrue: [^ (row indexOf: self player) @ idx]].	self error: 'Player missing...'.! !!SokobanWorld class methodsFor: 'instance creation' stamp: 'rhi 7/15/2003 15:25'!random	"inspectIt: [self random]"	^ self fromIndex: self mazes size atRandom! !!SokobanWorld class methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!wall	^ $#! !!SokobanWorld class methodsFor: 'private' stamp: 'rhi 7/16/2003 12:10'!wallsFrom: aString	^ (self mazeFrom: aString) do: [:row |		row			replaceAll: self player with: self free;			replaceAll: self box with: self free;			replaceAll: self boxAtGoal with: self goal]! !!SokobanWorld methodsFor: 'private' stamp: 'sbw 3/27/2004 15:31'!addMove: aPoint withPushed: secondPoint 	self moveStack add: (Array with: aPoint with: secondPoint)! !!SokobanWorld methodsFor: 'private' stamp: 'rhi 7/14/2003 18:19'!addPadding	self		addPaddingTo: self maze;		addPaddingTo: self walls.! !!SokobanWorld methodsFor: 'private' stamp: 'rhi 7/14/2003 18:19'!addPaddingTo: aSequenceableCollection	| x row |	x _ self extent x.	1 to: aSequenceableCollection size do: [:idx |		row _ aSequenceableCollection at: idx.		aSequenceableCollection			at: idx			put: row, (String new: x - row size withAll: self free)].! !!SokobanWorld methodsFor: 'constants' stamp: 'rhi 7/15/2003 17:05'!allButFree	^ self class allButFree! !!SokobanWorld methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!box	^ self class box! !!SokobanWorld methodsFor: 'constants' stamp: 'rhi 7/16/2003 11:10'!boxAtGoal	^ self class boxAtGoal! !!SokobanWorld methodsFor: 'constants' stamp: 'rhi 7/16/2003 11:12'!boxOrBoxAtGoal	^ self class boxOrBoxAtGoal! !!SokobanWorld methodsFor: 'private' stamp: 'rhi 7/16/2003 11:13'!canMoveBy: aPoint	^ (self freeOrGoal includes: (self mazeAt: self position + aPoint))		or: [(self boxOrBoxAtGoal includes: (self mazeAt: self position + aPoint))			and: [self freeOrGoal includes: (self mazeAt: self position + aPoint + aPoint)]]! !!SokobanWorld methodsFor: 'derived accessing' stamp: 'rhi 7/16/2003 11:31'!done	^ self maze noneSatisfy: [:row | row includes: self box]! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 17:42'!extent	"^ <Point>"	^ extent! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 17:42'!extent: aPoint	extent _ aPoint.! !!SokobanWorld methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!free	^ self class free! !!SokobanWorld methodsFor: 'constants' stamp: 'rhi 7/14/2003 18:35'!freeOrGoal	^ self class freeOrGoal! !!SokobanWorld methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!goal	^ self class goal! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/15/2003 18:49'!index	"^ <Integer>"	^ index! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/15/2003 18:49'!index: anInteger	index _ anInteger.! !!SokobanWorld methodsFor: 'accessing' stamp: 'sbw 3/27/2004 15:46'!initializeMoveStack	moveStack := OrderedCollection new! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 17:42'!maze	"^ <SequenceableCollection of: <SequenceableCollection of: Character>>"	^ maze! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 17:42'!maze: aSequenceableCollection	maze _ aSequenceableCollection.! !!SokobanWorld methodsFor: 'derived accessing' stamp: 'rhi 7/14/2003 18:21'!mazeAt: aPoint	^ (self maze at: aPoint y) at: aPoint x! !!SokobanWorld methodsFor: 'derived accessing' stamp: 'rhi 7/14/2003 19:05'!mazeAt: aPoint put: aCharacter	^ (self maze at: aPoint y) at: aPoint x put: aCharacter! !!SokobanWorld methodsFor: 'private' stamp: 'rhi 7/16/2003 11:40'!move: aPoint to: anotherPoint	self		mazeAt: anotherPoint put: (			((self boxOrBoxAtGoal includes: (self mazeAt: aPoint))				and: [(self wallsAt: anotherPoint) = self goal])					ifTrue: [self boxAtGoal]					ifFalse: [self mazeAt: aPoint]);		mazeAt: aPoint put: (self wallsAt: aPoint).! !!SokobanWorld methodsFor: 'private' stamp: 'sbw 3/27/2004 15:30'!moveBy: aPoint 	| next secondPoint |	secondPoint := nil.	(self canMoveBy: aPoint)		ifTrue: [next := self position + aPoint.			(self boxOrBoxAtGoal					includes: (self mazeAt: next))				ifTrue: [secondPoint := next + aPoint.					self move: next to: secondPoint.					self pushes: self pushes + 1.					self playSoundForPush].			self move: self position to: next.			self position: next.			self moves: self moves + 1.			self addMove: aPoint withPushed: secondPoint.			self playSoundForMove]! !!SokobanWorld methodsFor: 'moving' stamp: 'rhi 7/15/2003 17:10'!moveDown	self flag: #rhi. "Direction not intuitive!! See moveUp..."	self moveBy: 0 @ 1.! !!SokobanWorld methodsFor: 'moving' stamp: 'sbw 3/27/2004 21:19'!moveDownFull	self moveFullBy: 0 @ 1! !!SokobanWorld methodsFor: 'private' stamp: 'sbw 3/27/2004 21:22'!moveFullBy: aPoint 	[self canMoveBy: aPoint] whileTrue: [		self moveBy: aPoint]! !!SokobanWorld methodsFor: 'moving' stamp: 'rhi 7/14/2003 19:54'!moveLeft	self moveBy: -1 @ 0.! !!SokobanWorld methodsFor: 'moving' stamp: 'sbw 3/27/2004 21:19'!moveLeftFull	self moveFullBy: -1 @ 0! !!SokobanWorld methodsFor: 'moving' stamp: 'rhi 7/14/2003 19:54'!moveRight	self moveBy: 1 @ 0.! !!SokobanWorld methodsFor: 'moving' stamp: 'sbw 3/27/2004 21:19'!moveRightFull	self moveFullBy: 1 @ 0! !!SokobanWorld methodsFor: 'accessing' stamp: 'sbw 3/27/2004 15:46'!moveStack	moveStack isNil		ifTrue: [self initializeMoveStack].	^ moveStack! !!SokobanWorld methodsFor: 'moving' stamp: 'rhi 7/15/2003 17:10'!moveUp	self flag: #rhi. "Direction not intuitive!! See moveDown..."	self moveBy: 0 @ -1.! !!SokobanWorld methodsFor: 'moving' stamp: 'sbw 3/27/2004 21:19'!moveUpFull	self moveFullBy: 0 @ -1! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 18:56'!moves	"^ <Integer>"	^ moves! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 18:56'!moves: anInteger	moves _ anInteger.! !!SokobanWorld methodsFor: 'private' stamp: 'rhi 7/17/2003 09:21'!playSoundForMove	"printIt: [SampledSound soundNames]"	"self playSoundNamed: 'scratch'."	"self playSoundNamed: 'scritch'."! !!SokobanWorld methodsFor: 'private' stamp: 'rhi 7/17/2003 09:21'!playSoundForPush	"printIt: [SampledSound soundNames]"	"self playSoundNamed: 'scratch'."	"self playSoundNamed: 'scritch'."! !!SokobanWorld methodsFor: 'private' stamp: 'sbw 3/27/2004 15:34'!playSoundForUndo	^ self! !!SokobanWorld methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!player	^ self class player! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/15/2003 17:10'!position	"^ <Point>"	^ position! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 17:42'!position: aPoint	position _ aPoint.! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 18:57'!pushes	"^ <Integer>"	^ pushes! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 18:57'!pushes: anInteger	pushes _ anInteger.! !!SokobanWorld methodsFor: 'private' stamp: 'sbw 3/27/2004 15:36'!removeLastItemFromMoves	^self moveStack removeLast! !!SokobanWorld methodsFor: 'moving' stamp: 'sbw 3/27/2004 15:44'!undo	| lastMove point next other |	self moveStack isEmpty		ifTrue: [^ self].	lastMove := self removeLastItemFromMoves.	point := lastMove first.	next := self position - point.	self move: self position to: next.	self position: next.	self moves: self moves + 1.	other := lastMove last.	other isNil		ifFalse: [self move: other to: other - point.			self pushes: self pushes - 1].	self playSoundForUndo! !!SokobanWorld methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!wall	^ self class wall! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 18:01'!walls	"^ <SequenceableCollection of: <SequenceableCollection of: Character>>"	^ walls! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 18:01'!walls: aSequenceableCollection	walls _ aSequenceableCollection.! !!SokobanWorld methodsFor: 'derived accessing' stamp: 'rhi 7/14/2003 18:21'!wallsAt: aPoint	^ (self walls at: aPoint y) at: aPoint x! !!SokobanWorld methodsFor: 'derived accessing' stamp: 'rhi 7/14/2003 19:06'!wallsAt: aPoint put: aCharacter	^ (self walls at: aPoint y) at: aPoint x put: aCharacter! !!SokobanMorph class methodsFor: 'private' stamp: 'sbw 4/14/2004 21:31'!boxField	| m fill |	m := EllipseMorph new extent: self fieldSize;				 color: Color blue muchLighter;				 borderWidth: 0;				 borderColor: (Color r: 0.595 g: 0.595 b: 0.599).	fill := GradientFillStyle ramp: {0.0					-> (Color							r: 0.767							g: 0.767							b: 1.0). 1.0					-> (Color							r: 0.233							g: 0.233							b: 0.0)}.	fill origin: m topLeft.	fill direction: 23 @ 24.	fill radial: true.	m fillStyle: fill.	^ m! !!SokobanMorph class methodsFor: 'private' stamp: 'sbw 4/14/2004 21:43'!controlsHeight	^ self fieldSize x min: 18! !!SokobanMorph class methodsFor: 'parts bin' stamp: 'rhi 7/16/2003 09:20'!descriptionForPartsBin	^ self		partName: 'Sokoban'		categories: #('Games')		documentation: 'A tricky logic puzzle, created by Hiroyuki Imabayashi in 1982.'! !!SokobanMorph class methodsFor: 'private' stamp: 'sbw 4/14/2004 21:43'!fieldSize	^ 28@28! !!SokobanMorph class methodsFor: 'accessing' stamp: 'rhi 7/15/2003 17:18'!fields	^ Fields! !!SokobanMorph class methodsFor: 'accessing' stamp: 'rhi 7/15/2003 17:18'!fields: anIdentityDictionary	Fields _ anIdentityDictionary.! !!SokobanMorph class methodsFor: 'instance creation' stamp: 'rhi 7/16/2003 10:06'!forIndex: anInteger	"doIt: [(self forIndex: 1) openInWorld]"	^ self basicNew initializeForIndex: anInteger! !!SokobanMorph class methodsFor: 'instance creation' stamp: 'rhi 7/16/2003 10:06'!forWorld: aSokobanWorld	"doIt: [(self forWorld: (SokobanWorld fromFile: '.\Screens\screen.1')) openInWorld]"	"doIt: [(self forWorld: (SokobanWorld fromIndex: 1)) openInWorld]"	^ self basicNew initializeForWorld: aSokobanWorld! !!SokobanMorph class methodsFor: 'private' stamp: 'rhi 7/15/2003 17:17'!freeField	^ Morph new		extent: self fieldSize;		color: Color white! !!SokobanMorph class methodsFor: 'private' stamp: 'sbw 3/27/2004 19:21'!goalField	| m |	^ (m := BorderedMorph new) extent: self fieldSize;		 color: Color paleYellow darker;		 borderWidth: 1;		 borderColor: m color darker! !!SokobanMorph class methodsFor: 'class initialization' stamp: 'rhi 7/16/2003 11:43'!initFields	self fields: (IdentityDictionary new		at: SokobanWorld free put: [self freeField];		at: SokobanWorld wall put: [self wallField];		at: SokobanWorld box put: [self boxField];		at: SokobanWorld boxAtGoal put: [self boxField];		at: SokobanWorld goal put: [self goalField];		at: SokobanWorld player put: [self playerField];		yourself).! !!SokobanMorph class methodsFor: 'class initialization' stamp: 'rhi 7/16/2003 08:45'!initialize	"doIt: [self initialize]"	super initialize.	self initFields.! !!SokobanMorph class methodsFor: 'private' stamp: 'sbw 4/14/2004 21:38'!playerField	| m fill |	m := StarMorph new extent: self fieldSize;				 color: Color lightBlue darker darker;				 borderWidth: 0;				 borderColor: Color darkGray.	fill := GradientFillStyle ramp: {0.0->(Color r: 0.972 g: 0.878 b: 0.349).				1.0->(Color r: 0.972 g: 0.408 b: 0.317)}.	fill origin: m topLeft.	fill direction: 0 @ 21.	fill radial: false.	m fillStyle: fill.	^ m! !!SokobanMorph class methodsFor: 'instance creation' stamp: 'rhi 7/16/2003 10:05'!random	"doIt: [self random openInWorld]"	^ self new! !!SokobanMorph class methodsFor: 'private' stamp: 'sbw 3/27/2004 19:22'!wallField	| m |	^ (m := BorderedMorph new) extent: self fieldSize;		 color: Color paleGreen darker;		 borderWidth: 1;		 borderColor: m color darker;		 borderRaised! !!SokobanMorph methodsFor: 'private' stamp: 'sbw 3/27/2004 19:32'!addControlsWidth: anInteger 	| controls |	controls := Morph new color: Color darkGray;				 borderWidth: 0;				 height: self controlsHeight;				 width: anInteger;				 hResizing: #spaceFill;				 vResizing: #rigid;				 listDirection: #leftToRight;				 cellInset: 1;				 changeTableLayout;				 addMorph: self buildScores;								addMorph: (self						buildButtonForm: self downArrow						action: #moveDown						target: self);								addMorph: (self						buildButtonForm: self upArrow						action: #moveUp						target: self);								addMorph: (self						buildButtonForm: self rightArrow						action: #moveRight						target: self);								addMorph: (self						buildButtonForm: self leftArrow						action: #moveLeft						target: self);								addMorph: ((self						buildButtonLabel: 'z'						action: #undo						target: self						balloonText: 'undo')						color: Color lightGreen);								addMorph: ((self						buildButtonLabel: '?'						action: #help						target: self						balloonText: 'Help')						color: Color lightBlue);								addMorph: ((self						buildButtonLabel: 'X'						action: #quit						target: self						balloonText: 'Quit')						color: Color lightRed).	"addMorph: (Morph new  	color: Color black;  	height: self controlsHeight;  	hResizing: #spaceFill;  	vResizing: #rigid);"	self		addMorph: (controls position: self topLeft x @ (self bottomLeft y - self controlsHeight))! !!SokobanMorph methodsFor: 'moving etc' stamp: 'sbw 4/20/2004 22:18'!again	| position |	(self confirm: 'Really start over?')		ifTrue: [	position := self position.	self delete; initializeForIndex: self sworld index; position: position; openInWorld]! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/15/2003 20:08'!buildButtonForm: aForm action: aSymbol target: anObject	| button |	(button _ IconicButton new)		labelGraphic: aForm;		actionSelector: aSymbol;		target: anObject;		actWhen: #buttonDown;		color: Color black;		borderWidth: 0;		height: self controlsHeight;		layoutInset: 3;		hResizing: #rigid;		vResizing: #rigid;		cornerStyle: #square;		changeTableLayout.	^ button! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/16/2003 13:06'!buildButtonLabel: aString action: aSymbol target: anObject	| button |	(button _ SimpleButtonMorph new)		label: aString asText allBold;		actionSelector: aSymbol;		target: anObject;		actWhen: #buttonDown;		color: Color black;		borderWidth: 0;		height: self controlsHeight;		layoutInset: 3;		hResizing: #rigid;		vResizing: #rigid;		cornerStyle: #square;		changeTableLayout.	(button findA: StringMorph) color: Color black.	^ button! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/16/2003 13:11'!buildButtonLabel: aString action: aSymbol target: anObject balloonText: anotherString	^ (self buildButtonLabel: aString action: aSymbol target: anObject)		setBalloonText: anotherString! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/16/2003 11:59'!buildScores	^ TextMorph new		contents:			' Maze ', self sworld index printString,			' ¥ ', self sworld moves printString, ' Moves',			' ¥ ', self sworld pushes printString, ' Pushes';		color: Color white;		backgroundColor: Color transparent;		lock! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/15/2003 19:05'!controlsHeight	^ self class controlsHeight! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/15/2003 20:18'!cross	^ Form		extent: 9@9		depth: 16		fromArray: #( 65537 0 0 1 65536 65537 65536 0 65537 65536 1 65537 1 65537 0 0 65537 65537 65536 0 0 1 65537 0 0 0 65537 65537 65536 0 1 65537 1 65537 0 65537 65536 0 65537 65536 65537 0 0 1 65536)		offset: 0@0! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/15/2003 20:08'!downArrow	^ Form		extent: 9@9		depth: 16		fromArray: #( 14253 862794605 862794605 862729101 934150144 14221 724182793 654911241 654913323 931987456 0 793519881 722086698 652880586 862781440 0 931998474 654977834 648621835 0 0 12107 654911209 717895565 0 0 13164 654976681 789250048 0 0 14254 722085546 929890304 0 0 0 860630796 934150144 0 0 0 934098861 0 0)		offset: 0@0! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/15/2003 10:00'!fieldFor: aCharacter	^ (self fields at: aCharacter) value! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/14/2003 20:37'!fieldSize	^ self class fieldSize! !!SokobanMorph methodsFor: 'derived accessing' stamp: 'rhi 7/15/2003 17:20'!fields	^ self class fields! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/19/2003 18:38'!forceDestroyAndRedraw	| x y topLeftX topLeftY |	self flag: #rhi. "Apologies not only to Morphic fans..."	self removeAllMorphs.	self color: (self sworld done ifTrue: [Color veryVeryLightGray] ifFalse: [Color lightGray]).	topLeftX _ self topLeft x.	topLeftY _ self topLeft y.	y _ 0.	self sworld maze do: [:row |		x _ 0.		row do: [:col |			(self sworld allButFree includes: col) ifTrue: [				(col ~= self sworld goal					and: [(self sworld wallsAt: (x + 1) @ (y + 1)) = self sworld goal])						ifTrue: [self							addMorph: ((self fieldFor: self sworld goal)								position: (x * self fieldSize x + topLeftX)									@ (y * self fieldSize y + topLeftY))].				self					addMorph: ((self fieldFor: col)						position: (x * self fieldSize x + topLeftX)							@ (y * self fieldSize y + topLeftY))].			x _ x + 1].		y _ y + 1].	self addControlsWidth: self width.! !!SokobanMorph methodsFor: 'event handling' stamp: 'rhi 7/14/2003 20:05'!handlesKeyboard: aMorphicEvent	^ true! !!SokobanMorph methodsFor: 'event handling' stamp: 'rhi 7/14/2003 18:08'!handlesMouseOver: aMorphicEvent	^ true! !!SokobanMorph methodsFor: 'moving etc' stamp: 'sbw 3/27/2004 21:19'!help	((StringHolder new contents: 'The game was apparently invented in the early 1980s by Thinking Rabbit, a computer games company in the town of Takarazuka, Japan. The game design is said to have won first prize in a computer games contest. Because of the simplicity and elegance of the rules, and the intellectually challenging complexity of the composed problems, Sokoban quickly became a popular pastime. The object of Sokoban is to push all stones (or boxes) in a maze, such as the one to the right, to the designated goal areas. The player controls the man and the man can only push stones and only one at a time. The restriction of only being able to push the stones makes this game challenging: One can create unsolvable positions. Players will soon learn that this is the main obstacle in solving problems. Advanced players also try to find shorter and shorter solutions, measured in stone pushes and man moves. (http://www.cs.ualberta.ca/~games/Sokoban/)Key mappings:---Cursor left -> move left (control key down moves as far left as possible)Cursor right -> move right (control key down moves as far right as possible)Cursor up -> move up (control key down moves as far up as possible)Cursor down -> move down (control key down moves as far down as possible)--a -> again (same maze)h -> helpn -> next (another maze, next in line)p -> previous (another maze, previous in line)r -> random (another maze, random selection)g - select a game numberz -> undo last move--q -> quit')		embeddedInMorphicWindowLabeled: 'About Sokoban') setWindowColor: Color veryLightGray;		 openInWorld! !!SokobanMorph methodsFor: 'initialization' stamp: 'rhi 7/16/2003 12:33'!initialize	self initializeForIndex: 1.! !!SokobanMorph methodsFor: 'initialization' stamp: 'rhi 7/16/2003 10:07'!initializeForIndex: anInteger	self initializeForWorld: (SokobanWorld fromIndex: anInteger).! !!SokobanMorph methodsFor: 'initialization' stamp: 'sbw 3/27/2004 19:26'!initializeForWorld: aSokobanWorld 	super initialize.	self sworld: aSokobanWorld;		 extent: self fieldSize x * aSokobanWorld extent x @ (self fieldSize y * aSokobanWorld extent y + self controlsHeight);		 center: World center;		 initializeMoveStack;		 forceDestroyAndRedraw! !!SokobanMorph methodsFor: 'initialization' stamp: 'sbw 3/27/2004 15:48'!initializeMoveStack	self sworld initializeMoveStack! !!SokobanMorph methodsFor: 'initialization' stamp: 'rhi 7/16/2003 12:33'!initializeRandom	self initializeForWorld: SokobanWorld random.! !!SokobanMorph methodsFor: 'event handling' stamp: 'sbw 3/27/2004 21:16'!keyStroke: aKeyboardEvent 	| char accel |	accel := aKeyboardEvent controlKeyPressed.	char := aKeyboardEvent keyCharacter.	char = Character arrowLeft		ifTrue: [^ accel				ifTrue: [self moveLeftFull]				ifFalse: [self moveLeft]].	char = Character arrowRight		ifTrue: [^ accel				ifTrue: [self moveRightFull]				ifFalse: [self moveRight]].	char = Character arrowUp		ifTrue: [^ accel				ifTrue: [self moveUpFull]				ifFalse: [self moveUp]].	char = Character arrowDown		ifTrue: [^ accel				ifTrue: [self moveDownFull]				ifFalse: [self moveDown]].	char asLowercase = $a		ifTrue: [^ self again].	char asLowercase = $h		ifTrue: [^ self help].	char asLowercase = $n		ifTrue: [^ self next].	char asLowercase = $p		ifTrue: [^ self previous].	char asLowercase = $q		ifTrue: [^ self quit].	char asLowercase = $r		ifTrue: [^ self random].	char asLowercase = $z		ifTrue: [^ self undo].	char asLowercase = $g		ifTrue: [^ self selectGame].	^ super keyStroke: aKeyboardEvent! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/15/2003 20:08'!leftArrow	^ Form		extent: 9@11		depth: 16		fromArray: #( 0 0 0 0 934084608 0 0 0 934162252 864813056 0 0 14221 724249354 862715904 0 0 793520938 722021130 864813056 0 864824106 654977802 722086666 864813056 13164 722085641 722086666 722086666 864878592 12043 646523626 722086698 722086666 864878592 14254 858532522 648685290 722086666 864878592 0 14221 789260970 650717962 864878592 0 0 13132 717892331 934084608 0 0 0 932000621 0)		offset: 8@0! !!SokobanMorph methodsFor: 'event handling' stamp: 'rhi 7/14/2003 18:08'!mouseEnter: aMorphicEvent        aMorphicEvent hand newKeyboardFocus: self.! !!SokobanMorph methodsFor: 'moving etc' stamp: 'rhi 7/14/2003 20:39'!moveDown	self sworld moveDown.	self forceDestroyAndRedraw.! !!SokobanMorph methodsFor: 'moving etc' stamp: 'sbw 3/27/2004 21:17'!moveDownFull	self sworld moveDownFull.	self forceDestroyAndRedraw! !!SokobanMorph methodsFor: 'moving etc' stamp: 'rhi 7/14/2003 20:39'!moveLeft	self sworld moveLeft.	self forceDestroyAndRedraw.! !!SokobanMorph methodsFor: 'moving etc' stamp: 'sbw 3/27/2004 21:17'!moveLeftFull	self sworld moveLeftFull.	self forceDestroyAndRedraw! !!SokobanMorph methodsFor: 'moving etc' stamp: 'rhi 7/14/2003 20:39'!moveRight	self sworld moveRight.	self forceDestroyAndRedraw.! !!SokobanMorph methodsFor: 'moving etc' stamp: 'sbw 3/27/2004 21:18'!moveRightFull	self sworld moveRightFull.	self forceDestroyAndRedraw! !!SokobanMorph methodsFor: 'moving etc' stamp: 'rhi 7/14/2003 20:40'!moveUp	self sworld moveUp.	self forceDestroyAndRedraw.! !!SokobanMorph methodsFor: 'moving etc' stamp: 'sbw 3/27/2004 21:18'!moveUpFull	self sworld moveUpFull.	self forceDestroyAndRedraw! !!SokobanMorph methodsFor: 'moving etc' stamp: 'rhi 7/16/2003 11:22'!next	| position |	position _ self position.	self		delete;		initializeForIndex: ((self sworld index + 1) min: self sworld class mazes size);		position: position;		openInWorld.! !!SokobanMorph methodsFor: 'moving etc' stamp: 'rhi 7/16/2003 12:12'!previous	| position |	position _ self position.	self		delete;		initializeForIndex: ((self sworld index - 1) max: 1);		position: position;		openInWorld.! !!SokobanMorph methodsFor: 'moving etc' stamp: 'sbw 3/27/2004 20:24'!quit	(self confirm: 'Really quit?') ifTrue: [self delete]! !!SokobanMorph methodsFor: 'moving etc' stamp: 'rhi 7/16/2003 12:34'!random	| position |	position _ self position.	self		delete;		initializeRandom;		position: position;		openInWorld.! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/15/2003 20:07'!rightArrow	^ Form		extent: 9@11		depth: 16		fromArray: #( 934084608 0 0 0 0 864825164 934150144 0 0 0 862726922 724252557 0 0 0 864824074 722021162 793509888 0 0 864824074 722086666 654977834 864813056 0 864889610 722086666 722085641 722088812 0 864889610 722086698 722086634 646524683 0 864889610 722085610 648686250 858535854 0 864889610 650717866 789264269 0 0 934095595 717894476 0 0 0 13165 931987456 0 0 0)		offset: 0@0! !!SokobanMorph methodsFor: 'private' stamp: 'sbw 3/27/2004 21:04'!selectGame	| upperLimit defaultNextIndex response selected position |	upperLimit := self sworld class mazes size.	defaultNextIndex := self sworld index + 1 min: upperLimit.	response := FillInTheBlank request: 'Choose game # (1 to ', upperLimit printString, ')' initialAnswer: defaultNextIndex printString.	response isEmptyOrNil ifTrue: [^self].	selected := response asNumber.	(selected < 1 or: [selected > upperLimit]) ifTrue: [^self].	position := self position.	self delete;		initializeForIndex: selected; position: position; openInWorld! !!SokobanMorph methodsFor: 'accessing' stamp: 'rhi 7/14/2003 22:52'!sworld	"^ <SokobanWorld>"	^ sworld! !!SokobanMorph methodsFor: 'accessing' stamp: 'rhi 7/14/2003 22:53'!sworld: aSokobanWorld	sworld _ aSokobanWorld.! !!SokobanMorph methodsFor: 'moving etc' stamp: 'sbw 3/27/2004 15:24'!undo	self sworld undo.	self forceDestroyAndRedraw! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/15/2003 20:07'!upArrow	^ Form		extent: 9@8		depth: 16		fromArray: #( 0 0 932001709 0 0 0 14254 793457484 0 0 0 13197 654912266 931987456 0 0 12107 654912266 862715904 0 0 931998474 722020105 724252557 0 0 793455401 724183850 724187021 0 14221 724182761 652879594 652816171 931987456 0 791422634 717892298 648686282 862781440)		offset: 0@0! !"Games-Sokoban"!!PlayingCardMorph commentStamp: '<historical>' prior: 0!This class displays images from the PlayingCard class as morphs.  It attempts to be space-efficient by only producing its images on demand.!!ChineseCheckerPiece commentStamp: '<historical>' prior: 0!I represent a player piece for Chinese Checkers.  Mostly I act as an ellipse, but my special methods ensure that I cannot be picked up or dropped except in the proper circumstances.Structure: myBoard		a ChineseCheckers morph boardLoc		my current logical position on the board.!!FreeCellBoard commentStamp: '<historical>' prior: 0!The model of a freecell game.  Holds the stacks of cards.cardDeck		lastCardDeck		freeCells		homeCells		stacks		array of CardDecks of the columns of cards.----Hardness: a number from 1 to 10000.  	After dealing, count down the number.  For each count, go to next column, pick a ramdom card (with same generator as deck) and move it one place in its stack.  This is a kind of bubble sort.  Interesting that the slowness of bubble sort is a plus -- gives fine gradation in the hardness.	Moving a card:  Move red cards to deep half, black to shallow (or vice versa).  Within a color, put low cards deep and high cards shallow.  	If speed is an issue, move several steps at once, decrementing counter. 		(May make it easier?  If running columns, need a way to make harder in other ways.)!!SameGame commentStamp: '<historical>' prior: 0!See SameGame>>helpString for an explanation of how to play!!SameGameBoard commentStamp: '<historical>' prior: 0!I am an MxN array of SameGameTiles, and implement most of the logic to play the SameGame, including adjacent tile selection and removal.!!Tetris commentStamp: '<historical>' prior: 0!This is a port of JTetris.java 1.0.0.How to start:choose new morph.../Games/TetrisHow to play:1) using buttons2) using keyboard:	drop - spacebar	move to left - left arrow	move to right - right arrow	rotate clockwise - up arrow	rotate anticlockwise - down arrowNOTE: mouse must be over Tetris!!ChessBoard commentStamp: '<historical>' prior: 0!This class represents the chess board itself.!!ChessHistoryTable commentStamp: '<historical>' prior: 0!This class is a history table for our 'killer heuristic'. It remembers moves that have proven effective in the past and is later used to prioritize newly generated moves according to the effectiveness of the particular move in the past.!!ChessMove commentStamp: '<historical>' prior: 0!I represent a particular move in the chess game.!!ChessMoveGenerator commentStamp: '<historical>' prior: 0!This class generates moves for any given board. It's speed is critical - for each new position all moves need to be generated in that position. It may be worthwhile to make give this class a little plugin support at some time.!!ChessPlayer commentStamp: '<historical>' prior: 0!This class represents a player in the game, including its pieces and the current value of the player's position.!!ChessPlayerAI commentStamp: '<historical>' prior: 0!I am the AI that will beat you eventually. Well, maybe not today ... BUT MY TIME WILL COME!!!!!!!!ChessTTEntry commentStamp: '<historical>' prior: 0!This class represents an entry in the transposition table, storing the value (plus some maintenance information) of some position.!!ChessTranspositionTable commentStamp: '<historical>' prior: 0!The transposition table is a lookup cache for positions in a game that occur through transpositions in move. As an example, the same position is obtained by the moves:	1. e2-e4		Nb8-c6	2. d2-d4and	1. d2-d4		Nb8-c6	2. e2-e4An extremely large number of search branches can be cut off immediately by recognizing that the current position is just the transposition of another one. The transposition table is one of the techniques that actually make modern chess programs good enough to compete with or even beat humans.!!PlayingCard commentStamp: '<historical>' prior: 0!This class assembles card images from their parts.  The images are broken down so that the image data is very compact, and the code is written to display properly at all color depths.  The method imageData may be removed after initialization to save space, but must be re-built prior to fileOut if you wish to retain the images.To use in morphic, one can simply put these forms into ImageMorphs (see example in buildImage).  However it should be possible to define a subclass of ImageMorph that simply creates playingCard instances on the fly whenever the image form is needed.  This would avoid storing all the images.!!SameGameTile commentStamp: '<historical>' prior: 0!I am a single tile for the SameGame.  I act much like a switch.!!AtomicGame commentStamp: '<historical>' prior: 0!Atomic is game where you have to build chemical molecules using given atoms.!!ChessMorph commentStamp: '<historical>' prior: 0!This class defines the user interface for a fine game of chess.!!ChineseCheckers commentStamp: '<historical>' prior: 0!An implementation of Chinese Checkers by Dan Ingalls.  April 9, 2000.board:  A 19x19 rhombic array, addressed by row@col points, in which is imbedded the familiar six-pointed layout of cells.  A cell outside the board is nil (-).  - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - 5 - - - - -    - - - - - - - - - - - - 5 5 - - - - -     - - - - - - - - - - - 5 5 5 - - - - -      - - - - - - - - - - 5 5 5 5 - - - - -       - - - - - 6 6 6 6 0 0 0 0 0 4 4 4 4 -        - - - - - 6 6 6 0 0 0 0 0 0 4 4 4 - -         - - - - - 6 6 0 0 0 0 0 0 0 4 4 - - -          - - - - - 6 0 0 0 0 0 0 0 0 4 - - - -           - - - - - 0 0 0 0 0 0 0 0 0 - - - - -            - - - - 1 0 0 0 0 0 0 0 0 3 - - - - -             - - - 1 1 0 0 0 0 0 0 0 3 3 - - - - -              - - 1 1 1 0 0 0 0 0 0 3 3 3 - - - - -               - 1 1 1 1 0 0 0 0 0 3 3 3 3 - - - - -                - - - - - 2 2 2 2 - - - - - - - - - -                 - - - - - 2 2 2 - - - - - - - - - - -                  - - - - - 2 2 - - - - - - - - - - - -                   - - - - - 2 - - - - - - - - - - - - -                    - - - - - - - - - - - - - - - - - - -Cells within the board contain 0 if empty, or a team number (1..6) if occupied by a piece of that team.  An extra border of nils around the whole reduces bounds checking to a nil test.sixDeltas:  An array giving the x@y deltas for the 6 valid steps in CCW order from a given cell.  For team 1 they are: in fr, fl, l, bl, br, r.  To get, eg fl for a given team, use (sixDeltas atWrap: team+1).teams:  An array of six teams, each of which is an array of the x@y locations of the 10 pieces.homes:  The x@y coordinates of the six home points, namely 14@2, 18@6, 14@14, 6@18, 2@14, 6@6.  The goal, or farthest point in destination triangle, is thus (homes atWrap: teamNo+3).autoPlay:  An array of booleans, parallel to teams, where true means that Squeak will make the moves for the corresponding team.whoseMove:  A team number specifying whose turn it is next.  Set to 0 when game is over.plannedMove:  If not nil, it means the board is in a state where it is animating the next move to be made so that it can be seen.movePhase:  Holds the state of display of the planned move so that, eg, it can appear one jump at a time.  Advances from 1 to (plannedMove size * 2).A move is an array of locs which are the path of the move.Once the morph is open, the menu command 'reset...' allows you to reset the board and change the number of players.  The circle at turnIndicatorLoc indicates the color of the team whose turn it is.  If it is a human, play waits for drag and drop of a piece of that color.The current strategy is very simple: generate all moves, score them and pick the best.  Beyond this, it will look ahead a number of moves, but this becomes very expensive without pruning.  Pruning would help the speed of play, especially in the end game where we look a little deeper.  A more effective strategy would consider opponents' possible moves as well, but this is left as an exercise for the serious programmer.!!WordGameLetterMorph commentStamp: '<historical>' prior: 0!WordGameLetterMorph implements letter boxes for type-in and display of letter in word games.  Several variant displays are supported, depending on the setting of style, and blanks can be displayed as black boxes or empty letter boxes.Default support for type-in is distributed between this class and WordGamePaneMorphletter			the Character stored in this morph.				Can be either blank or nil as well as a letter.indexInQuote	a retained copy of the index of this character				Facilitates responses to, eg, clicking or typing in this box.				If indexInQuote==nil, then this is displayed as a black boxpredecessor		another LetterMorph or nil				Used for linked typing and, eg, word selectionsuccessor		another LetterMorph or nil				Used for linked typing and, eg, word selectionstyle			a Symbol, one of #(plain boxed underlined)				Boxed and underlined display further depends on whether				the id strings are nil or not.				Each format has an associated default sizeThe following two variables are also submorphs, as are the id strings if present.letterMorph		a StringMorph for displaying the letter				Used when changing the letter to be displayedlineMorph		a PolygonMorph used to display the underline				and also to place the id string in underlined format!!WordGamePanelMorph commentStamp: '<historical>' prior: 0!WordGamePanelMorph provides some default support for clicking and typing in a panel with letterMorphs.letterMorphs		a collection of LetterMorphs					Useful in referring specifically to active letterMorphs					when submorphs may contain other morphshaveTypedHere		a Boolean used to determine how backspace should be handled!!CipherPanel commentStamp: '<historical>' prior: 0!The CipherPanel, as its name suggests, is a tool for decoding simple substitution codes, such as are presented on the puzzle pages of many Sunday newspapers.  Most of the capability is inherited from the two WordGame classes used.  To try it out, choose newMorph/Games/CipherPanel in a morphic project, or execute, in any project:	CipherPanel new openInWorld!!CrosticPanel commentStamp: '<historical>' prior: 0!The CrosticPanel, as its name suggests, is a tool for decoding acrostic puzzles, such as are presented on the puzzle pages of some Sunday newspapers.  Much of the capability is inherited from the two WordGame classes used.  To try it out, choose newMorph/Games/CrosticPanel in a morphic project, or execute, in any project:	CrosticPanel new openInWorldThe instance variables of this class include...	letterMorphs (in superclass)  a collection of all the letterMorphs in this panel	quote		a string, being the entire quote in uppercase with no blanks	clues		a collection of the clue strings	answers		a collection of the answer indices.				For each answer, this is an array of the indices into the quote string.The final structure of a CrosticPanel is as follows	self					a CrosticPanel			the overall holder		quotePanel		a CrosticQuotePanel		holds the grid of letters from the quote		cluesPanel		an AlignmentMorph		holds most of the clue rows		cluesCol2		an AlignmentMorph		holds the rest of the clue rowsEach clue row is a horizontal AlignmentMorph with a textMorph and another alignmentMorph full of the letterMorphs for the answer.!!MorphicGamesInfo commentStamp: 'asm 7/5/2003 15:59' prior: 0!to create the package:in a 5325 image	-file in SARBuilderSARPackageDumper 	fileOutPackageNamed: 'Morphic-Games' 					as: (FileDirectory default nextNameFor: 'Morphic-Games' extension: 'sar')!!ChessMoveList commentStamp: '<historical>' prior: 0!An optimized representation of a set of moves - mainly there to avoid excessive allocation (and garbage collections) in a few critical places.!!ChessPieceMorph methodsFor: 'dropping/grabbing' stamp: 'ar 8/10/2001 11:35'!wantsToBeDroppedInto: aMorph	^aMorph isKindOf: ChessMorph! !!PlayingCardMorph class methodsFor: 'access' stamp: 'djp 10/17/1999 18:39'!cardSize	" a real hack, but I don't want to muck with Dan's class "	^71@96.! !!PlayingCardMorph class methodsFor: 'access' stamp: 'djp 10/17/1999 18:32'!height	^self cardSize y! !!PlayingCardMorph class methodsFor: 'new-morph participation' stamp: 'di 1/16/2000 10:40'!includeInNewMorphMenu	^false! !!PlayingCardMorph class methodsFor: 'access' stamp: 'djp 10/15/1999 07:14'!suits	^ #(clubs diamonds hearts spades)! !!PlayingCardMorph class methodsFor: 'testing' stamp: 'djp 10/17/1999 18:24'!test    "Display all cards in the deck"	"MessageTally spyOn: [20 timesRepeat: [PlayingCardMorph test]]"	| table row |	table _ AlignmentMorph newColumn.	self suits do: [:suit | 		row _ AlignmentMorph newRow.		table addMorph: row.		1 to: 13 do: [:cn |			row addMorph: 			(PlayingCardMorph the: cn of: suit)]].	table openInWorld.! !!PlayingCardMorph class methodsFor: 'initialize-release' stamp: 'di 10/18/1999 23:45'!the: cardNumber of: suit	^ self new 		image: (PlayingCard the: cardNumber of: suit) cardForm;		cardNumber: cardNumber suitNumber: (self suits indexOf: suit)! !!PlayingCardMorph class methodsFor: 'access' stamp: 'djp 10/17/1999 18:32'!width	^self cardSize x! !!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'di 12/12/2000 11:47'!aboutToBeGrabbedBy: aHand	"I'm about to be grabbed by the hand.  If other cards are above me in a deck,	then move them from the deck to being submorphs of me"	| i |	super aboutToBeGrabbedBy: aHand.	self removeProperty: #undoGrabCommand.  "So it won't interfere with overall move"	self board captureStateBeforeGrab.	i _ owner submorphs indexOf: self ifAbsent: [^ self].	i = 1 ifTrue: [^ self].	(owner submorphs copyFrom: 1 to: i-1) do:		[:m | m class = self class ifTrue: [self addMorphBack: m]].! !!PlayingCardMorph methodsFor: 'access' stamp: 'di 10/21/1999 21:41'!board	^ owner owner owner! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/24/1999 03:11'!cardDeck	^self owner! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!cardNumber	^cardNumber! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!cardNumber: c suitNumber: s	cardNumber _ c.	suitNumber _ s.! !!PlayingCardMorph methodsFor: 'event handling' stamp: 'RAA 2/12/2001 19:22'!click: evt		"since we really want to know about double-clicks before making our move, ignore this and wait until #firstClickTimedOut: arrives"! !!PlayingCardMorph methodsFor: 'event handling' stamp: 'djp 10/24/1999 03:12'!doubleClick: evt	^self cardDeck doubleClickOnCard: self! !!PlayingCardMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 14:14'!firstClickTimedOut: evt 	| root popUp |	root := owner rootForGrabOf: self.	root isNil 		ifTrue: 			["Display hidden card in front"			popUp := self copy.			self board owner owner addMorphFront: popUp.			self world displayWorld.			(Delay forMilliseconds: 750) wait.			popUp delete]		ifFalse: [evt hand grabMorph: root]! !!PlayingCardMorph methodsFor: 'event handling' stamp: 'di 10/19/1999 00:01'!handlesMouseDown: evt	^ true! !!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 20:05'!justDroppedInto: newOwner event: evt	(newOwner isKindOf: PlayingCardDeck)		ifFalse: ["Can't drop a card anywhere but on a deck"				self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt! !!PlayingCardMorph methodsFor: 'event handling' stamp: 'jcg 9/21/2001 13:25'!mouseDown: evt	"Do nothing upon mouse-down except inform the hand to watch for a double-click; wait until an ensuing click:, doubleClick:, or drag: message gets dispatched"	evt hand waitForClicksOrDrag: self event: evt selectors: { #click:. #doubleClick:. #firstClickTimedOut:. nil} threshold: 5! !!PlayingCardMorph methodsFor: 'printing' stamp: 'djp 10/17/1999 20:27'!printOn: aStream	aStream		print: cardNumber;		nextPutAll: ' of ';		print: (self class suits at: suitNumber).! !!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'di 12/12/2000 14:52'!slideBackToFormerSituation: evt	super slideBackToFormerSituation: evt.	self board removeProperty: #stateBeforeGrab.	self hasSubmorphs ifTrue:		["Just cancelled a drop of multiple cards -- have to unload submorphs"		self submorphs reverseDo: [:m | owner addMorphFront: m]].! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!suit	^self class suits at: suitNumber! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!suitColor	^#(black red red black) at: suitNumber! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!suitNumber	^suitNumber! !!TetrisBlock class methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 15:29'!flipShapes: anArray	^OrderedCollection new 		add: anArray;		add: (anArray collect: [ :each | each y negated @ each x]);		add: (anArray collect: [ :each | each x negated @ each y negated]);		add: (anArray collect: [ :each | each y @ each x negated]);		yourself	! !!TetrisBlock class methodsFor: 'new-morph participation' stamp: 'RAA 1/8/2000 11:55'!includeInNewMorphMenu	^false! !!TetrisBlock class methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 15:32'!shapeChoices	^ ShapeChoices ifNil: [		ShapeChoices _ {			{ {  0 @ 0 .  1 @ 0 .  0 @ 1 .  1 @ 1  } }.	"square - one is sufficient here"			self flipShapes: {  0 @  0 . -1 @  0 .  1 @  0 .  0 @ -1  }.	"T"			{ 				{  0 @ 0 . -1 @ 0 .  1 @ 0 .  2 @ 0  }.				{  0 @ 0 .  0 @-1 .  0 @ 1 .  0 @ 2  } 	"long - two are sufficient here"			}.			self flipShapes: { 0 @ 0 .  0 @ -1 .  0 @  1 .  1 @  1  }.	"L"			self flipShapes: { 0 @ 0 .  0 @ -1 .  0 @  1 . -1 @  1  }.	"inverted L"			self flipShapes: { 0 @ 0 . -1 @  0 .  0 @ -1 .  1 @ -1  }.	"S"			self flipShapes: {  0 @ 0 .  1 @ 0 .  0 @ -1 . -1 @ -1  } "Z"		}.	]! !!TetrisBlock methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 15:58'!board: theBoard	board _ theBoard.	4 timesRepeat: [		self addMorph: (			RectangleMorph new				color: color;				extent: board cellSize;				borderRaised		 )	].	self positionCellMorphs.! !!TetrisBlock methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:07'!defaultBounds"answer the default bounds for the receiver"	^ (2 @ 2) negated extent: 1 @ 1! !!TetrisBlock methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Tetris colors atRandom! !!TetrisBlock methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 12:37'!dropByOne 	^self moveDeltaX: 0 deltaY: 1 deltaAngle: 0! !!TetrisBlock methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:50'!initialize	"initialize the state of the receiver"	super initialize.	""		"keep this puppy out of sight"	shapeInfo _ self class shapeChoices atRandom.	baseCellNumber _ 4 atRandom + 2 @ 1.	angle _ 4 atRandom! !!TetrisBlock methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 13:56'!moveDeltaX: deltaX deltaY: deltaY deltaAngle: deltaAngle 	| delta |	delta _ deltaX @ deltaY.	(shapeInfo atWrap: angle + deltaAngle) do: [ :offsetThisCell | 		(board emptyAt: baseCellNumber + offsetThisCell + delta) ifFalse: [^ false]	].	baseCellNumber _ baseCellNumber + delta.	angle _ angle + deltaAngle - 1 \\ 4 + 1.	self positionCellMorphs.	^ true ! !!TetrisBlock methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 13:41'!positionCellMorphs	(shapeInfo atWrap: angle) withIndexDo: [ :each :index |		(submorphs at: index)			position: (board originForCell: baseCellNumber + each)	].	fullBounds _ nil.	self changed.	 ! !!ChineseCheckerPiece class methodsFor: 'new-morph participation' stamp: 'di 4/9/2000 11:17'!includeInNewMorphMenu	^ false! !!ChineseCheckerPiece methodsFor: 'accessing' stamp: 'di 4/9/2000 08:31'!boardLoc	^ boardLoc! !!ChineseCheckerPiece methodsFor: 'event handling' stamp: 'di 4/11/2000 08:36'!handlesMouseDown: evt	^ true! !!ChineseCheckerPiece methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 20:02'!justDroppedInto: newOwner event: evt	newOwner == myBoard ifFalse:		["Only allow dropping into my board."		^self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt! !!ChineseCheckerPiece methodsFor: 'event handling' stamp: 'di 4/9/2000 09:27'!mouseDown: evt	((owner isKindOf: ChineseCheckers)		and: [owner okToPickUpPieceAt: boardLoc])		ifTrue: [evt hand grabMorph: self]! !!ChineseCheckerPiece methodsFor: 'accessing' stamp: 'di 4/11/2000 08:34'!setBoard: aBoard loc: aBoardLoc	myBoard _ aBoard.	boardLoc _ aBoardLoc! !!FreeCell class methodsFor: 'parts bin' stamp: 'sw 8/2/2001 12:50'!descriptionForPartsBin	^ self partName:	'FreeCell'		categories:		#('Games')		documentation:	'A unique solitaire card game'! !!FreeCell class methodsFor: 'class initialization' stamp: 'djp 10/24/1999 14:50'!initialize	Statistics _ FreeCellStatistics new.! !!FreeCell methodsFor: 'actions' stamp: 'djp 10/31/1999 21:17'!autoMovingHome	elapsedTimeDisplay pause.	autoMoveRecursionCount _ autoMoveRecursionCount + 1.! !!FreeCell methodsFor: 'accessing' stamp: 'djp 10/31/1999 19:28'!board	board ifNil: 		[board _ FreeCellBoard new			target: self;			actionSelector: #boardAction:].	^board! !!FreeCell methodsFor: 'actions' stamp: 'djp 10/31/1999 21:35'!boardAction: actionSymbol	actionSymbol = #cardMovedHome 	ifTrue: [^self cardMovedHome].	actionSymbol = #autoMovingHome	ifTrue: [^self autoMovingHome].! !!FreeCell methodsFor: 'private' stamp: 'ar 11/9/2000 21:16'!buildButton: aButton target: aTarget label: aLabel selector: aSelector	"wrap a button or switch in an alignmentMorph to provide some space around the button"	| a |	aButton 		target: aTarget;		label: aLabel;		actionSelector: aSelector;		borderColor: #raised;		borderWidth: 2;		color: Color gray.	a _ AlignmentMorph newColumn		wrapCentering: #center; cellPositioning: #topCenter;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: Color transparent;		layoutInset: 1.	a addMorph: aButton.	^ a! !!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 15:30'!cardMovedHome	cardsRemainingDisplay value: (cardsRemainingDisplay value - 1).	autoMoveRecursionCount _ autoMoveRecursionCount - 1 max: 0.	cardsRemainingDisplay value = 0 		ifTrue: [self gameWon]		ifFalse: [autoMoveRecursionCount = 0 ifTrue: [elapsedTimeDisplay continue]].! !!FreeCell methodsFor: 'visual properties' stamp: 'RAA 3/3/2000 23:28'!colorNearBottom	^Color r: 0.0 g: 0.455 b: 0.18! !!FreeCell methodsFor: 'visual properties' stamp: 'RAA 3/4/2000 10:26'!colorNearTop	^ (Color r: 0.304 g: 0.833 b: 0.075)! !!FreeCell methodsFor: 'accessing' stamp: 'djp 10/24/1999 21:36'!currentGame	^self board cardDeck seed! !!FreeCell methodsFor: 'user interface' stamp: 'RAA 3/3/2000 23:29'!defaultBackgroundColor	^Color r: 0.365 g: 1.0 b: 0.09! !!FreeCell methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:27'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!FreeCell methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:26'!defaultColor	"answer the default color/fill style for the receiver"	^ self colorNearTop! !!FreeCell methodsFor: 'visual properties' stamp: 'RAA 3/4/2000 17:01'!fillStyle	myFillStyle ifNil: [		myFillStyle _ GradientFillStyle ramp: {			0.0 -> self colorNearTop. 			1.0 -> self colorNearBottom		}.	].	^myFillStyle		origin: self position;		direction: (self width // 2)@self height! !!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 16:20'!gameLost	state _ #lost.	elapsedTimeDisplay stop.	cardsRemainingDisplay highlighted: true; flash: true.	Statistics gameLost: self currentGame! !!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 16:20'!gameWon	state _ #won.	elapsedTimeDisplay stop; highlighted: true; flash: true.	Statistics gameWon: self currentGame! !!FreeCell methodsFor: 'actions' stamp: 'asm 11/24/2003 22:49'!help	| window helpMorph |	window := SystemWindow labelled: 'FreeCell Help' translated.	window model: self.	helpMorph := (PluggableTextMorph new editString: self helpText) lock.	window		addMorph: helpMorph		frame: (0 @ 0 extent: 1 @ 1).	window openInWorld! !!FreeCell methodsFor: 'accessing' stamp: 'asm 11/24/2003 22:48'!helpText	^ 'The objective of FreeCell is to move all of the cards to the four "home cells" in the upper right corner.  Each home cell will hold one suit and must be filled sequentially starting with the Ace.There are four "free cells" in the upper left corner that can each hold one card.  Cards can be moved from the bottom of a stack to a free cell or to another stack.  When moving a card to another stack, it must have a value that is one less than the exposed card and of a different color.' translated! !!FreeCell methodsFor: 'actions' stamp: 'di 12/12/2000 13:08'!inAutoMove	"Return true if an automove sequence is in progress"	^ autoMoveRecursionCount > 0! !!FreeCell methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:27'!initialize	"initialize the state of the receiver"	super initialize.	""	Statistics newSession.	autoMoveRecursionCount _ 0.	self listDirection: #topToBottom.	self wrapCentering: #center;		 cellPositioning: #topCenter.	self vResizing: #shrinkWrap.	self hResizing: #shrinkWrap.	self		 addMorph: self makeControls;		 addMorph: self board;		 newGame! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!makeCardsRemainingDisplay	cardsRemainingDisplay := LedMorph new digits: 2;				 extent: 2 * 10 @ 15.	^ self wrapPanel: cardsRemainingDisplay label: 'Cards Left: ' translated! !!FreeCell methodsFor: 'initialization' stamp: 'ar 11/9/2000 21:17'!makeControlBar	^AlignmentMorph newRow		color: self colorNearBottom;		borderColor: #inset;		borderWidth: 2;		layoutInset: 0;		hResizing: #spaceFill; vResizing: #shrinkWrap; wrapCentering: #center; cellPositioning: #leftCenter;		yourself.! !!FreeCell methodsFor: 'initialization' stamp: 'djp 10/24/1999 14:38'!makeControls	^self makeControlBar		addMorph: AlignmentMorph newVariableTransparentSpacer;		addMorph: self makeHelpButton;		addMorph: self makeQuitButton;		addMorph: self makeStatisticsButton;		addMorph: self makeGameNumberDisplay;		addMorph: self makePickGameButton;		addMorph: self makeSameGameButton;		addMorph: self makeNewGameButton;		addMorph: self makeElapsedTimeDisplay;		addMorph: self makeCardsRemainingDisplay;		yourself.! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!makeElapsedTimeDisplay	elapsedTimeDisplay := LedTimerMorph new digits: 3;				 extent: 3 * 10 @ 15.	^ self wrapPanel: elapsedTimeDisplay label: 'Elapsed Time: ' translated! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!makeGameNumberDisplay	gameNumberDisplay := LedMorph new digits: 5;				 extent: 5 * 10 @ 15.	^ self wrapPanel: gameNumberDisplay label: 'Game #: ' translated! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!makeHelpButton	^ self		buildButton: SimpleButtonMorph new		target: self		label: 'Help' translated		selector: #help! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!makeNewGameButton	^ self		buildButton: SimpleButtonMorph new		target: self		label: 'New game' translated		selector: #newGame! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!makePickGameButton	^ self		buildButton: SimpleButtonMorph new		target: self		label: 'Pick game' translated		selector: #pickGame! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:48'!makeQuitButton	^ self		buildButton: SimpleButtonMorph new		target: self		label: 'Quit' translated		selector: #quit! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:48'!makeSameGameButton	^ self		buildButton: SimpleButtonMorph new		target: self		label: 'Same game' translated		selector: #sameGame! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:48'!makeStatisticsButton	^ self		buildButton: SimpleButtonMorph new		target: self		label: 'Statistics' translated		selector: #statistics! !!FreeCell methodsFor: 'user interface' stamp: 'th 12/15/1999 15:20'!modelSleep	"When fixing #contains: calls beware of reinventing #includes:"	(#(newGame sameGame pickGame won lost ) includes: state)		ifTrue: [elapsedTimeDisplay pause]! !!FreeCell methodsFor: 'user interface' stamp: 'th 12/15/1999 15:22'!modelWakeUp	"Maybe less performant but more readable"	(#(won lost) includes: state)		ifFalse: [elapsedTimeDisplay resume]! !!FreeCell methodsFor: 'actions' stamp: 'di 1/16/2000 10:35'!newGame	Collection initialize.	self newGameNumber: nil.	state _ #newGame! !!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 16:21'!newGameNumber: aSeedOrNil 	cardsRemainingDisplay value ~~ 0 ifTrue: [self gameLost].	cardsRemainingDisplay flash: false; highlighted: false; value: 52.	elapsedTimeDisplay flash: false; highlighted: false.	"board handles nil case"	self board pickGame: aSeedOrNil.	elapsedTimeDisplay reset; start.	gameNumberDisplay value: self currentGame! !!FreeCell methodsFor: 'initialization' stamp: 'djp 10/31/1999 18:48'!openInWindowLabeled: aString inWorld: aWorld	^(super openInWindowLabeled: aString inWorld: aWorld)		model: self;		yourself! !!FreeCell methodsFor: 'actions' stamp: 'th 12/15/1999 15:05'!pickGame	| seed |	seed _ self promptForSeed.	seed isNil ifTrue: [^ self].	self newGameNumber: seed.	state _ #pickGame! !!FreeCell methodsFor: 'actions' stamp: 'asm 11/24/2003 22:50'!promptForSeed	| ss ii hh |	[hh := board hardness				ifNil: [0].	ss := FillInTheBlank request: 'Pick a game number between 1 and 32000.orset the hardness of the next game by typing ''H 30''.Above 100 is very hard.  Zero is standard game.Current hardness is: ' translated , hh printString.	"Let the user cancel."	ss isEmpty		ifTrue: [^ nil].	ss := ss withoutQuoting.	ss first asLowercase == $h		ifTrue: ["Set the hardness"			[ii := ss numericSuffix]				on: Error				do: [ii := 0].			board hardness: ii.			^ nil].	[ii := ss asNumber asInteger]		on: Error		do: [ii := 0].	ii between: 1 and: 32000] whileFalse.	^ ii! !!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 15:35'!quit	cardsRemainingDisplay value ~~ 0 ifTrue: [self gameLost].	self owner == self world		ifTrue: [self delete]		ifFalse: [self owner delete].	Statistics close! !!FreeCell methodsFor: 'actions' stamp: 'th 12/15/1999 15:03'!sameGame	self newGameNumber: self currentGame.	state _ #sameGame.! !!FreeCell methodsFor: 'actions' stamp: 'djp 10/24/1999 15:07'!statistics	Statistics display! !!FreeCell methodsFor: 'private' stamp: 'ar 11/9/2000 21:17'!wrapPanel: anLedPanel label: aLabel	"wrap an LED panel in an alignmentMorph with a label to its left"	| a |	a _ AlignmentMorph newRow		wrapCentering: #center; cellPositioning: #leftCenter;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 0;		layoutInset: 5;		color: Color transparent.	a addMorph: anLedPanel.	a addMorph: (StringMorph contents: aLabel). 	^ a! !!FreeCellBoard class methodsFor: 'new-morph participation' stamp: 'di 1/16/2000 10:39'!includeInNewMorphMenu	^false! !!FreeCellBoard methodsFor: 'actions' stamp: 'th 12/9/1999 19:10'!acceptCard: aCard onStack: aDeck	" assumes that number of cards was check at drag time, need to reduce count if dropping	into an empty stack"	aCard hasSubmorphs 		ifTrue: [			aDeck ifEmpty: [				(aCard submorphCount+1) > (self maxDraggableStackSize: true)					ifTrue: [^false]]]		ifFalse: [^ nil].	^nil.! !!FreeCellBoard methodsFor: 'actions' stamp: 'th 12/15/1999 16:17'!acceptSingleCard: aCard on: aDeck 	"Home cells and free cells don't accept multiple cards on a home cell, 	defer to deck for other cases"	aCard hasSubmorphs		ifTrue: [^ false]		ifFalse: [^ nil]! !!FreeCellBoard methodsFor: 'accessing' stamp: 'djp 10/16/1999 16:21'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!FreeCellBoard methodsFor: 'hardness' stamp: 'tk 3/30/2001 11:53'!addHardness	| cnt rand pileInd pile |	"post process the layout of cards to make it harder.  See class comment."	hardness ifNil: [^ self].	cnt _ hardness.	rand _ Random new seed: cardDeck seed.  "Same numbers but different purpose"	pileInd _ 1. 	[(cnt _ cnt - 1) > 0] whileTrue: [		pile _ stacks atWrap: (pileInd _ pileInd + 1).		cnt _ cnt - (self makeHarder: pile rand: rand toDo: cnt)].  "mostly 0, but moves cards"! !!FreeCellBoard methodsFor: 'private' stamp: 'RAA 3/4/2000 10:48'!autoMoveCardsHome	| first |	first _ false.	(self stacks, self freeCells) do: [:deck |		self homeCells do: [ :homeCell |			deck hasCards ifTrue: [				(homeCell repelCard: deck topCard) ifFalse: [					(self isPlayableCardInHomeCells: deck topCard) ifTrue: [						first ifFalse: [ " trigger autoMoving event on first move."							first _ true.							self performActionSelector: #autoMovingHome						].						self visiblyMove: deck topCard to: homeCell.					]				]			]		]	].! !!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 11:54'!captureStateBeforeGrab	self removeProperty: #stateBeforeGrab.	self setProperty: #stateBeforeGrab toValue: self capturedState! !!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 11:50'!capturedState	self valueOfProperty: #stateBeforeGrab ifPresentDo: [:st | ^ st].	^ {	freeCells collect: [:deck | deck submorphs].		homeCells collect: [:deck | deck submorphs].		stacks collect: [:deck | deck submorphs] }! !!FreeCellBoard methodsFor: 'layout' stamp: 'ar 11/20/2000 19:08'!cardCell	^PlayingCardDeck new		layout: #pile; 		listDirection: #topToBottom;		enableDragNDrop;		color: Color transparent;		borderColor: (Color gray alpha: 0.5);		borderWidth: 2;		layoutBounds: (0@0 extent: PlayingCardMorph width @ PlayingCardMorph height);		yourself! !!FreeCellBoard methodsFor: 'accessing' stamp: 'djp 10/11/1999 15:51'!cardDeck	^cardDeck! !!FreeCellBoard methodsFor: 'actions' stamp: 'th 12/15/1999 16:15'!cardMoved	"Free cells and stacks do nothing special here - yet - th 12/15/1999 	16:15 "	self autoMoveCardsHome! !!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/31/1999 22:02'!cardMovedHome	self autoMoveCardsHome.	self performActionSelector: #cardMovedHome.! !!FreeCellBoard methodsFor: 'layout' stamp: 'RAA 3/3/2000 23:33'!cellsRow	| row |	row := (AlignmentMorph newRow)		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		color: Color transparent;		addAllMorphs: self freeCells;		addMorphBack: self cellsRowSpacer;		addAllMorphs: self homeCells;		yourself.	^row! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/17/1999 18:25'!cellsRowSpacer	| column |	column := (AlignmentMorph newColumn)		vResizing: #rigid;		hResizing: #rigid;		color: Color transparent;		extent: PlayingCardMorph cardSize;		yourself.	^column! !!FreeCellBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:27'!defaultColor	"answer the default color/fill style for the receiver"	^ Color green! !!FreeCellBoard methodsFor: 'actions' stamp: 'RAA 3/4/2000 17:07'!doubleClickInStack: aDeck OnCard: aCard	"if there is an empty free cell, move the card there. otherwise try for an empty stack"	aCard == aDeck topCard ifFalse: [^self].	freeCells do: [:freeCell |		freeCell ifEmpty: [			self visiblyMove: aCard to: freeCell.			^ aCard		]	].	stacks do: [ :each |		each ifEmpty: [			self visiblyMove: aCard to: each.			^ aCard		]	].! !!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/24/1999 03:08'!dragCard: aCard fromHome: aCardDeck	^nil		"don't allow any cards to be dragged from a home cell"! !!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/24/1999 00:46'!dragCard: aCard fromStack: aCardDeck	| i cards |	cards _ aCardDeck cards.	i _ cards indexOf: aCard ifAbsent: [^ nil].	i > (self maxDraggableStackSize: false) ifTrue: [^ nil].	[i > 1] whileTrue:		[(aCardDeck inStackingOrder: (cards at: i-1) 					onTopOf: (cards at: i)) ifFalse: [^ nil].		i _ i-1].	^ aCard! !!FreeCellBoard methodsFor: 'drawing' stamp: 'RAA 3/4/2000 17:02'!drawOn: aCanvas	"we don't have anything to draw, but we need a color so the inset border of one of our submorphs will work"! !!FreeCellBoard methodsFor: 'layout' stamp: 'th 12/15/1999 16:14'!freeCell	| freeCell |	freeCell _ self cardCell.	freeCell stackingPolicy: #single;	 emptyDropPolicy: #any;	 target: self;	 cardDroppedSelector: #cardMoved;	 acceptCardSelector: #acceptSingleCard:on:.	^ freeCell! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 16:41'!freeCells	^freeCells ifNil: [freeCells := (1 to: 4) collect: [:i | self freeCell]]! !!FreeCellBoard methodsFor: 'accessing' stamp: 'tk 3/30/2001 13:08'!hardness	^ hardness! !!FreeCellBoard methodsFor: 'accessing' stamp: 'tk 3/30/2001 13:08'!hardness: integer	hardness _ integer	"or nil"! !!FreeCellBoard methodsFor: 'layout' stamp: 'th 12/15/1999 16:12'!homeCell	| homeCell |	homeCell _ self cardCell.	homeCell stackingPolicy: #straight;	 stackingOrder: #ascending;	 emptyDropPolicy: #inOrder;	 target: self;	 cardDroppedSelector: #cardMovedHome;	 cardDraggedSelector: #dragCard:fromHome:;	 acceptCardSelector: #acceptSingleCard:on:.	^ homeCell! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 16:41'!homeCells	^homeCells ifNil: [homeCells := (1 to: 4) collect: [:i | self homeCell]]! !!FreeCellBoard methodsFor: 'actions' stamp: 'di 12/12/2000 13:08'!inAutoMove	"Return true if an automove sequence is in progress"	^ owner inAutoMove! !!FreeCellBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:31'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;	  hResizing: #shrinkWrap;	  vResizing: #rigid;	  height: 500;	  layout! !!FreeCellBoard methodsFor: 'private' stamp: 'RAA 3/4/2000 17:11'!isPlayableCardInHomeCells: aPlayingCard	| unplayedOther topsThisColor topsOtherColor unplayedSame | 	" are all cards that could be played on this card if it stayed on the stack present in the	home cells?"	aPlayingCard cardNumber <= 2 ifTrue: [^true].	"special case for Aces and 2's"	topsThisColor _ OrderedCollection new.	topsOtherColor _ OrderedCollection new.	self homeCells do: [ :deck |		deck hasCards ifTrue: [			(aPlayingCard suitColor == deck topCard suitColor 					ifTrue: [topsThisColor] ifFalse: [topsOtherColor]) add: deck topCard cardNumber.		]	].	unplayedOther _ topsOtherColor size < 2 ifTrue: [1] ifFalse: [topsOtherColor min + 1].	unplayedSame _ topsThisColor size < 2 ifTrue: [1] ifFalse: [topsThisColor min + 1].	unplayedOther > (aPlayingCard cardNumber - 1) ifTrue: [^true].	unplayedOther < (aPlayingCard cardNumber - 1) ifTrue: [^false].	^unplayedSame >= (unplayedOther - 1)! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 18:27'!layout	self 		addMorphBack: self cellsRow;		addMorphBack: self stacksRow.! !!FreeCellBoard methodsFor: 'hardness' stamp: 'tk 3/30/2001 12:22'!makeHarder: pile rand: rand toDo: cnt	| deepColor ind thisPile thisCard otherCard |	"Move cards in a stack to make it harder.  Pick a card from the pile.  Only consider moving it deeper (toward last of pile)."	deepColor _ stacks first cards last suitColor.	ind _ ((pile cards size - 1) atRandom: rand).	"front card"	thisPile _ pile cards.  "submorphs array. We will stomp it."	thisCard _ thisPile at: ind.	otherCard _ thisPile at: ind+1.	"Move deepColor cards deeper, past cards of the other color"	(thisCard suitColor == deepColor) & (otherCard suitColor ~~ deepColor) ifTrue: [		thisPile at: ind put: otherCard.		thisPile at: ind+1 put: thisCard.		^ 0].	"single moves for now.  Make multiple when it's too slow this way"	"When colors the same, move low numbered cards deeper, past high cards"	(thisCard suitColor == otherCard suitColor) ifTrue: [		(thisCard cardNumber < otherCard cardNumber) ifTrue: [			thisPile at: ind put: otherCard.			thisPile at: ind+1 put: thisCard.			^ 0]].	"single moves for now.  Make multiple when it's too slow this way"	^ 0! !!FreeCellBoard methodsFor: 'private' stamp: 'djp 10/24/1999 00:50'!maxDraggableStackSize: dropIntoEmptyStack	"Note: dropIntoEmptyStack, means one less empty stack to work with.		This needs to be reevaluated at time of drop."	"Not super smart - doesn't use stacks that are buildable though not empty"	| nFree nEmptyStacks |	nFree _ (freeCells select: [:d | d hasCards not]) size.	nEmptyStacks _ (stacks select: [:d | d hasCards not]) size.	dropIntoEmptyStack ifTrue: [nEmptyStacks _ nEmptyStacks - 1].	^ (1 + nFree) * (2 raisedTo: nEmptyStacks)! !!FreeCellBoard methodsFor: 'private' stamp: 'dgd 2/22/2003 18:45'!performActionSelector: actionSymbol 	(target notNil and: [actionSelector notNil]) 		ifTrue: [target perform: actionSelector with: actionSymbol]! !!FreeCellBoard methodsFor: 'initialization' stamp: 'asm 11/24/2003 23:13'!pickGame: aSeedOrNil 	| sorted msg |	cardDeck := PlayingCardDeck newDeck.	aSeedOrNil == 1		ifTrue: ["Special case of game 1 does a time profile playing the entire 			(trivial) game."			sorted := cardDeck submorphs						asSortedCollection: [:a :b | a cardNumber >= b cardNumber].			cardDeck removeAllMorphs; addAllMorphs: sorted.			self resetBoard.			self world doOneCycle.			Utilities				informUser: 'Game #1 is a special casefor performance analysis' translated				during: [msg := self world firstSubmorph.					msg align: msg topRight with: owner bottomRight.					MessageTally						spyOn: [sorted last owner doubleClickOnCard: sorted last]]]		ifFalse: [aSeedOrNil				ifNotNil: [cardDeck seed: aSeedOrNil].			cardDeck shuffle.			self resetBoard]! !!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 12:14'!rememberUndoableAction: aBlock named: caption	self inAutoMove ifTrue: [^ aBlock value].	^ super rememberUndoableAction: aBlock named: caption! !!FreeCellBoard methodsFor: 'initialization' stamp: 'tk 3/30/2001 12:20'!resetBoard	self purgeAllCommands.	self resetFreeCells;		resetHomeCells;		resetStacks;		addHardness;		changed.! !!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/16/1999 20:06'!resetFreeCells	freeCells do: [:deck | deck removeAllCards]! !!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/16/1999 20:06'!resetHomeCells	homeCells do: [:deck | deck removeAllCards]! !!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/16/1999 20:06'!resetStacks	| card stackStream stack |	stacks do: [:deck | deck removeAllCards].	stackStream _ ReadStream on: stacks.	[card _ cardDeck deal.	card notNil] whileTrue: [		stack _ stackStream next ifNil: [stackStream reset; next].		stack addCard: card].! !!FreeCellBoard methodsFor: 'card in a stack' stamp: 'ar 11/9/2000 20:55'!stack	^ PlayingCardDeck new color: Color transparent;	 layout: #stagger;	 listDirection: #topToBottom;	 enableDragNDrop;	 stackingPolicy: #altStraight;	 stackingOrder: #descending;	 emptyDropPolicy: #any;	 target: self;	 cardDroppedSelector: #cardMoved;	 cardDraggedSelector: #dragCard:fromStack:;	 acceptCardSelector: #acceptCard:onStack:;	 cardDoubleClickSelector: #doubleClickInStack:OnCard:! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 16:41'!stacks	^stacks ifNil: [stacks:= (1 to: 8) collect: [:i | self stack]]! !!FreeCellBoard methodsFor: 'layout' stamp: 'ar 11/20/2000 18:58'!stacksRow	| row |	row := (AlignmentMorph newRow)		vResizing: #spaceFill;		hResizing: #spaceFill;		wrapCentering: #topLeft;		cellPositioning: #topLeft;		color: Color transparent;		yourself.	self stacks do: [:stack |		row 			addMorphBack: AlignmentMorph newVariableTransparentSpacer;			addMorphBack: stack].	row addMorphBack: AlignmentMorph newVariableTransparentSpacer.	^row! !!FreeCellBoard methodsFor: 'accessing' stamp: 'djp 10/16/1999 15:33'!target: anObject	target _ anObject! !!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 08:12'!undoFromCapturedState: st	freeCells with: st first do: [:deck :morphs | deck removeAllMorphs; addAllMorphs: morphs].	homeCells with: st second do: [:deck :morphs | deck removeAllMorphs; addAllMorphs: morphs].	stacks with: st third do: [:deck :morphs | deck removeAllMorphs; addAllMorphs: morphs]! !!FreeCellBoard methodsFor: 'private' stamp: 'di 12/12/2000 13:09'!visiblyMove: aCard to: aCell	| p1 p2 nSteps |	self inAutoMove ifFalse: [self captureStateBeforeGrab].	owner owner addMorphFront: aCard.	p1 _ aCard position.	p2 _ aCell position.	nSteps _ 10.	1 to: nSteps-1 do: "Note final step happens with actual drop"		[:i | aCard position: ((p2*i) + (p1*(nSteps-i))) // nSteps.		self world displayWorld].	aCell acceptDroppingMorph: aCard event: nil! !!Mines class methodsFor: 'parts bin' stamp: 'ar 11/25/2001 14:59'!descriptionForPartsBin	^ self partName: 	'Mines'		categories:		#('Games')		documentation:	'Find those mines'! !!Mines methodsFor: 'access' stamp: 'DAS 7/8/2001 15:25'!board	board ifNil:		[board _ MinesBoard new			target: self;			actionSelector: #selection].	^ board! !!Mines methodsFor: 'initialize' stamp: 'DAS 7/8/2001 14:16'!buildButton: aButton target: aTarget label: aLabel selector: aSelector	"wrap a button or switch in an alignmentMorph to allow a row of buttons to fill space"	| a |	aButton 		target: aTarget;		label: aLabel;		actionSelector: aSelector;		borderColor: #raised;		borderWidth: 2;		color: color.	a _ AlignmentMorph newColumn		wrapCentering: #center; cellPositioning: #topCenter;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: color.	a addMorph: aButton.	^ a! !!Mines methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:34'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ #raised! !!Mines methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!Mines methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:28'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!Mines methodsFor: 'actions' stamp: 'DAS 7/8/2001 14:38'!help: helpState	helpState		ifTrue: [self addMorphBack: self helpText]		ifFalse: [helpText delete]! !!Mines methodsFor: 'access' stamp: 'asm 11/25/2003 22:31'!helpString	^ 'Mines is a quick and dirty knock-off of the Minesweeper game found on Windows. I used this to teach myself Squeak. I liberally borrowed from the <SameGame> example, so the code should look pretty familiar, though like any project it has rapidly ...morphed... to reflect my own idiosyncracies. Note especially the lack of any idiomatic structure to the code - I simply haven''t learned them yet.Mines is a very simple, yet extremely frustrating, game to play. The rules are just this: there are 99 mines laid down on the board. Find them without ""finding"" them. Your first tile is free - click anywhere. The tiles will tell you how many mines are right next to it, including the diagonals. If you uncover the number ''2'', you know that there are two mines hidden in the adjacent tiles. If you think you have found a mine, you can flag it by either ''shift'' clicking, or click with the ''yellow'' mouse button. Once you have flagged all of the mines adjacent to a numbered tile, you can click on the tile again to uncover the rest. Of course, you could be wrong about those too... You win once you have uncovered all of the tiles that do not contain mines. Good luck...David A. Smithdastrs@bellsouth.net' translated! !!Mines methodsFor: 'access' stamp: 'DAS 7/8/2001 14:45'!helpText	helpText ifNil:		[helpText _ PluggableTextMorph new			width: self width; "board width;"			editString: self helpString].	^ helpText! !!Mines methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:34'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;	  wrapCentering: #center;		 cellPositioning: #topCenter;	  vResizing: #shrinkWrap;	  hResizing: #shrinkWrap;	  layoutInset: 3;	  addMorph: self makeControls;	  addMorph: self board.	helpText _ nil.	self newGame! !!Mines methodsFor: 'initialize' stamp: 'asm 11/25/2003 22:29'!makeControls	| row |	row := AlignmentMorph newRow color: color;				 borderWidth: 2;				 layoutInset: 3.	row borderColor: #inset.	row hResizing: #spaceFill;		 vResizing: #shrinkWrap;		 wrapCentering: #center;		 cellPositioning: #leftCenter;		 extent: 5 @ 5.	row		addMorph: (self				buildButton: SimpleSwitchMorph new				target: self				label: '  Help  ' translated				selector: #help:).	row		addMorph: (self				buildButton: SimpleButtonMorph new				target: self				label: '  Quit  ' translated				selector: #delete).	"row 	addMorph: (self 	buildButton: SimpleButtonMorph new 	target: self 	label: ' Hint '  translated	selector: #hint)."	row		addMorph: (self				buildButton: SimpleButtonMorph new				target: self				label: '  New game  ' translated				selector: #newGame).	minesDisplay := LedMorph new digits: 2;				 extent: 2 * 10 @ 15.	row		addMorph: (self wrapPanel: minesDisplay label: 'Mines:' translated).	timeDisplay := LedTimerMorph new digits: 3;				 extent: 3 * 10 @ 15.	row		addMorph: (self wrapPanel: timeDisplay label: 'Time:' translated).	^ row! !!Mines methodsFor: 'access' stamp: 'DAS 7/13/2001 03:28'!minesDisplay	^ minesDisplay! !!Mines methodsFor: 'actions' stamp: 'DAS 7/13/2001 03:49'!newGame	timeDisplay value: 0; flash: false.	timeDisplay stop.	timeDisplay reset.	minesDisplay value: 99.	self board resetBoard.! !!Mines methodsFor: 'access' stamp: 'DAS 7/13/2001 03:40'!timeDisplay	^ timeDisplay! !!Mines methodsFor: 'initialize' stamp: 'DAS 7/8/2001 14:25'!wrapPanel: anLedPanel label: aLabel	"wrap an LED panel in an alignmentMorph with a label to its left"	| a |	a _ AlignmentMorph newRow		wrapCentering: #center; cellPositioning: #leftCenter;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 0;		layoutInset: 3;		color: color lighter.	a addMorph: anLedPanel.	a addMorph: (StringMorph contents: aLabel). 	^ a! !!MinesBoard class methodsFor: 'new-morph participation' stamp: 'das 7/24/2001 00:11'!includeInNewMorphMenu	^false! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/8/2001 15:32'!actionSelector	^ actionSelector! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/8/2001 15:32'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/13/2001 01:50'!adjustTiles	"reset tiles"	| newSubmorphs count r c |	submorphs do: "clear out all of the tiles."		[:m | m privateOwner: nil].	newSubmorphs _ OrderedCollection new.	r _ 0.	c _ 0.	count _ columns * rows.	1 to: count do:				[:m |				newSubmorphs add:					(protoTile copy						position: self position + (self protoTile extent * (c @ r));						actionSelector: #tileClickedAt:newSelection:modifier:;						arguments: (Array with: (c+1) @ (r+1));						target: self;						privateOwner: self).				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]].	submorphs _ newSubmorphs asArray.! !!MinesBoard methodsFor: 'actions' stamp: 'das 7/22/2001 19:34'!blowUp	owner timeDisplay stop.	self submorphsDo:		[:m |		m isMine ifTrue:				[m switchState: true.].		].	flashCount _ 2.	gameOver _ true.! !!MinesBoard methodsFor: 'actions' stamp: 'das 7/22/2001 19:45'!clearMines: location	| al tile |	(self countFlags: location) = (self findMines: location) ifTrue:		[		{-1@-1. -1@0. -1@1. 0@1. 1@1. 1@0. 1@-1. 0@-1} do:			[:offsetPoint |			al _ location + offsetPoint.			((al x between: 1 and: columns) and: [al y between: 1 and: rows]) ifTrue: [				tile _ self tileAt: al.				(tile mineFlag or: [tile switchState]) ifFalse:[		   		self stepOnTile: al].].].		].! !!MinesBoard methodsFor: 'actions' stamp: 'das 7/22/2001 19:45'!countFlags: location	| al at flags |	flags _ 0.	{-1@-1. -1@0. -1@1. 0@1. 1@1. 1@0. 1@-1. 0@-1} do:		[:offsetPoint |		al _ location + offsetPoint.		((al x between: 1 and: columns) and: [al y between: 1 and: rows]) ifTrue:			[at _ self tileAt: al.			(at mineFlag ) ifTrue:				[flags _ flags+1]]].		^flags.! !!MinesBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:34'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ #inset! !!MinesBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!MinesBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:28'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!MinesBoard methodsFor: 'geometry' stamp: 'DAS 7/8/2001 19:38'!extent: aPoint	"constrain the extent to be a multiple of the protoTile size during resizing"	super extent: (aPoint truncateTo: protoTile extent).! !!MinesBoard methodsFor: 'actions' stamp: 'DAS 7/10/2001 14:58'!findMines: location	| al at mines |	mines _ 0.	{-1@-1. -1@0. -1@1. 0@1. 1@1. 1@0. 1@-1. 0@-1} do:		[:offsetPoint |		al _ location + offsetPoint.		((al x between: 1 and: columns) and: [al y between: 1 and: rows]) ifTrue:			[at _ self tileAt: al.			(at isMine ) ifTrue:				[mines _ mines+1]]].		^mines.! !!MinesBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:06'!initialize	"initialize the state of the receiver"	super initialize.	""	target _ nil.	actionSelector _ #selection.	arguments _ #().	""	self layoutPolicy: nil;	  hResizing: #rigid;	  vResizing: #rigid.	""	rows _ self preferredRows.	columns _ self preferredColumns.	flashCount _ 0.	""	self extent: self protoTile extent * (columns @ rows).	self adjustTiles.	self resetBoard! !!MinesBoard methodsFor: 'preferences' stamp: 'DAS 7/8/2001 15:41'!preferredColumns	^ 30! !!MinesBoard methodsFor: 'preferences' stamp: 'DAS 7/9/2001 01:25'!preferredMines	^ 99! !!MinesBoard methodsFor: 'preferences' stamp: 'DAS 7/8/2001 15:41'!preferredRows	^ 16! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/9/2001 13:19'!protoTile	protoTile ifNil: [protoTile _ MinesTile new].	^ protoTile! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/8/2001 15:40'!protoTile: aTile	protoTile _ aTile! !!MinesBoard methodsFor: 'initialization' stamp: 'di 11/26/2001 21:24'!resetBoard	gameStart _ false.	gameOver _ false.	[flashCount = 0] whileFalse: [self step].	flashCount _ 0.	tileCount _ 0.	Collection initialize.  "randomize the Collection class"	self purgeAllCommands.	self submorphsDo: "set tiles to original state."		[:m | m privateOwner: nil.  "Don't propagate all these changes..."		m mineFlag: false.		m disabled: false.		m switchState: false.		m isMine: false.		m privateOwner: self].	self changed  "Now note the change in bulk"! !!MinesBoard methodsFor: 'actions' stamp: 'das 7/22/2001 19:47'!selectTilesAdjacentTo: location	| al at mines |"	{-1@0. 0@-1. 1@0. 0@1} do:"	{-1@-1. -1@0. -1@1. 0@1. 1@1. 1@0. 1@-1. 0@-1} do:		[:offsetPoint |		al _ location + offsetPoint.		((al x between: 1 and: columns) and: [al y between: 1 and: rows]) ifTrue:			[at _ self tileAt: al.			(at switchState not and: [at disabled not]) ifTrue:				[				mines _ (self tileAt: al) nearMines.				at mineFlag ifTrue: [at mineFlag: false.].  "just in case we flagged it as a mine."				at switchState: true.				tileCount _ tileCount + 1.				mines=0 ifTrue: [self selectTilesAdjacentTo: al]]]]! !!MinesBoard methodsFor: 'initialization' stamp: 'das 7/22/2001 19:49'!setMines: notHere	| count total c r sm |	count _ 0.	total _ self preferredMines.	[count < total] whileTrue:[		c _ columns atRandom.		r _ rows atRandom.		c@r = notHere ifFalse: [			sm _ self tileAt: c@r.			sm isMine ifFalse: [				"sm color: Color red lighter lighter lighter lighter."				sm isMine: true.				count _ count + 1.]]		].	1 to: columns do: [ :col |		1 to: rows do: [ :row |			(self tileAt: col @ row) nearMines: (self findMines: (col @ row))			]].			! !!MinesBoard methodsFor: 'stepping and presenter' stamp: 'DAS 7/14/2001 18:16'!step	flashCount = 0 ifFalse: [		self submorphsDo:			[:m |				m color: m color negated.].			flashCount _ flashCount - 1.			].! !!MinesBoard methodsFor: 'actions' stamp: 'das 7/22/2001 19:46'!stepOnTile: location	| mines tile |	tile _ self tileAt: location.	tile mineFlag ifFalse:[		tile isMine ifTrue: [tile color: Color gray darker darker. self blowUp. ^false.]			ifFalse:[				mines _ self findMines: location.				tile switchState: true.				tileCount _ tileCount + 1.				mines = 0 ifTrue: 					[self selectTilesAdjacentTo: location]].		tileCount = ((columns*rows) - self preferredMines) ifTrue:[ gameOver _ true. flashCount _ 2. 	owner timeDisplay stop.].		^ true.] 		ifTrue: [^ false.]! !!MinesBoard methodsFor: 'testing' stamp: 'DAS 7/14/2001 18:12'!stepTime	^ 300! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/8/2001 15:31'!target	^ target! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/8/2001 15:31'!target: anObject	target _ anObject! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/10/2001 14:59'!tileAt: aPoint	^ submorphs at: (aPoint x + ((aPoint y - 1) * columns))! !!MinesBoard methodsFor: 'actions' stamp: 'das 7/22/2001 19:55'!tileClickedAt: location newSelection: isNewSelection modifier: mod	| tile |	"self halt."	gameOver ifTrue: [^ false].	tile _ self tileAt: location.	isNewSelection ifFalse: [		mod ifTrue: [				tile mineFlag: ((tile mineFlag) not).				tile mineFlag ifTrue: [owner minesDisplay value: (owner minesDisplay value - 1)]						ifFalse: [owner minesDisplay value: (owner minesDisplay value + 1)].				^ true.].		gameStart ifFalse: [ 			self setMines: location.			gameStart _ true. 			owner timeDisplay start.].		^ self stepOnTile: location.		]	ifTrue:[ self clearMines: location.].! !!PlayingCardDeck class methodsFor: 'new-morph participation' stamp: 'di 1/16/2000 10:38'!includeInNewMorphMenu	^false! !!PlayingCardDeck class methodsFor: 'instance creation' stamp: 'djp 10/15/1999 11:01'!newDeck	^self new newDeck! !!PlayingCardDeck class methodsFor: 'instance creation' stamp: 'djp 10/15/1999 09:53'!newSuit: suit	^self new newSuit: suit! !!PlayingCardDeck class methodsFor: 'symbols' stamp: 'djp 10/10/1999 18:06'!suits	^{#Clubs. #Diamonds. #Hearts. #Spades}! !!PlayingCardDeck class methodsFor: 'symbols' stamp: 'djp 10/17/1999 18:05'!values	^#(Ace),((2 to: 9) collect: [:i | i printString asSymbol]), #(Jack Queen King)! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'th 12/10/1999 16:07'!acceptCard: aCard default: aBoolean 	"if target and acceptCardSelector are both not nil, send to target, if not  	nil answer  	else answer aBoolean"	"Rewrote this a little (SmallLint calls this 'intention revealing')-th"	^ (target isNil or: [acceptCardSelector isNil])		ifTrue: [aBoolean]		ifFalse: [(target				perform: acceptCardSelector				with: aCard				with: self)				ifNil: [aBoolean]]! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 01:40'!acceptCardSelector: aSymbolOrString	acceptCardSelector _ self nilOrSymbol: aSymbolOrString.! !!PlayingCardDeck methodsFor: 'layout' stamp: 'asm 11/25/2003 22:37'!acceptDroppingMorph: aMorph event: evt 	target		rememberUndoableAction: [target inAutoMove				ifFalse: [target removeProperty: #stateBeforeGrab].			self addMorph: aMorph.			aMorph hasSubmorphs				ifTrue: ["Just dropped a sub-deck of cards"					aMorph submorphs						reverseDo: [:m | self addMorphFront: m]].			(target notNil					and: [cardDroppedSelector notNil])				ifTrue: [target perform: cardDroppedSelector]]		named: 'move card' translated! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/15/1999 11:07'!addCard: aPlayingCard	self addMorph: aPlayingCard! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 03:13'!cardDoubleClickSelector: aSymbolOrString	cardDoubleClickSelector _ self nilOrSymbol: aSymbolOrString.! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 01:39'!cardDraggedSelector: aSymbolOrString	cardDraggedSelector _ self nilOrSymbol: aSymbolOrString.! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 17:27'!cardDroppedSelector: aSymbolOrString	cardDroppedSelector _ self nilOrSymbol: aSymbolOrString.! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/15/1999 10:46'!cards	^submorphs! !!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'dgd 2/22/2003 13:37'!deal	| card |	^ self cards notEmpty 		ifTrue: 			[card := self topCard.			card delete.			card]		ifFalse: [nil]! !!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'djp 10/10/1999 18:48'!deal: anInteger	^(1 to: anInteger) collect: [:i | self deal]! !!PlayingCardDeck methodsFor: 'events' stamp: 'dgd 2/22/2003 18:49'!doubleClickOnCard: aCard 	(target notNil and: [cardDoubleClickSelector notNil]) 		ifTrue: 			[^target 				perform: cardDoubleClickSelector				with: self				with: aCard]! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 13:14'!emptyDropNotOk: aPlayingCard	^(self emptyDropOk: aPlayingCard) not! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 13:15'!emptyDropOk: aPlayingCard	emptyDropPolicy = #any 			ifTrue: [^true].	emptyDropPolicy = #inOrder			ifTrue: [^self inStackingOrder: aPlayingCard].	emptyDropPolicy = #anyClub 		ifTrue: [^aPlayingCard suit = #club].	emptyDropPolicy = #anyDiamond		ifTrue: [^aPlayingCard suit = #diamond].	emptyDropPolicy = #anyHeart		ifTrue: [^aPlayingCard suit = #heart].	emptyDropPolicy = #anySpade		ifTrue: [^aPlayingCard suit = #spade].! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 13:18'!emptyDropPolicy: aSymbol	"#any #inOrder #anyClub #anyDiamond #anyHeart #anySpade"	emptyDropPolicy _ aSymbol! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 19:41'!hasCards	^self hasSubmorphs! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 13:10'!ifEmpty: aBlock	self hasSubmorphs not ifTrue: [^aBlock value]! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 02:17'!ifEmpty: aBlock1 ifNotEmpty: aBlock2	self hasSubmorphs not 		ifTrue: [^aBlock1 value]		ifFalse: [^aBlock2 value]! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 21:54'!inStackingOrder: aPlayingCard	^self inStackingOrder: aPlayingCard event: nil! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'di 10/19/1999 15:45'!inStackingOrder: aCard event: evt	self hasSubmorphs 		ifTrue: [^ self inStackingOrder: aCard onTopOf: self topCard]		ifFalse: [stackingOrder = #ascending ifTrue: [^ aCard cardNumber = 1].				stackingOrder = #descending ifTrue: [^ aCard cardNumber = 13]].	^ false.! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'di 10/21/1999 22:03'!inStackingOrder: aCard onTopOf: cardBelow	| diff |	(stackingPolicy = #altStraight and: [aCard suitColor = cardBelow suitColor]) ifTrue: [^ false].	(stackingPolicy = #straight and: [aCard suit ~= cardBelow suit]) ifTrue: [^ false].	diff _ aCard cardNumber - cardBelow cardNumber.	stackingOrder = #ascending 	ifTrue: [^ diff = 1].	stackingOrder = #descending	ifTrue: [^ diff = -1].	^ false.! !!PlayingCardDeck methodsFor: 'initialization' stamp: 'ar 11/20/2000 19:11'!initialize	super initialize.	self cellPositioning: #topLeft.	self reverseTableCells: true.	self layout: #grid.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	borderWidth _ 0.	self layoutInset: 0.	stackingPolicy _ #stagger.	stackingOrder _ #ascending.	emptyDropPolicy _ #any.	self newSeed.	^self! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/15/1999 12:43'!insertionIndexFor: aMorph	"Return the index at which the given morph should be inserted into the submorphs of the receiver."	^1! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'ar 11/20/2000 18:43'!layout: aSymbol	" #grid #pile #stagger"	layout _ aSymbol.	layout == #grid 		ifTrue:[self maxCellSize: SmallInteger maxVal].	layout == #pile 		ifTrue:[self maxCellSize: 0].	layout == #stagger 		ifTrue:[self maxCellSize: self staggerOffset].! !!PlayingCardDeck methodsFor: 'initialization' stamp: 'djp 10/17/1999 18:25'!newDeck	| cards |	cards := OrderedCollection new: 52.	PlayingCardMorph suits 		do: [:suit | 1 to: 13			do: [:cardNo | cards add: (PlayingCardMorph the: cardNo of: suit)]].	self addAllMorphs: cards.	^self! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/23/1999 22:44'!newSeed	seed _ (1 to: 32000) atRandom! !!PlayingCardDeck methodsFor: 'initialization' stamp: 'djp 10/17/1999 18:25'!newSuit: suit	| cards |	cards := OrderedCollection new: 13.	1 to: 13 do: [:cardNo | cards add: (PlayingCardMorph the: cardNo of: suit)].	self addAllMorphs: cards.	^self! !!PlayingCardDeck methodsFor: 'private' stamp: 'djp 10/16/1999 17:27'!nilOrSymbol: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^nil]		ifFalse: [^aSymbolOrString asSymbol]! !!PlayingCardDeck methodsFor: 'printing' stamp: 'dgd 2/22/2003 13:38'!printOn: aStream 	| cards |	cards := self cards.	aStream nextPutAll: 'aCardDeck('.	cards size > 1 		ifTrue: 			[cards allButLast do: 					[:card | 					aStream						print: card;						nextPutAll: ', ']].	cards notEmpty ifTrue: [aStream print: cards last].	aStream nextPut: $)! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 20:05'!removeAllCards	self removeAllMorphs! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'th 12/10/1999 18:34'!repelCard: aCard 	stackingPolicy = #none ifTrue: [^ self repelCard: aCard default: true].	stackingPolicy = #single ifTrue: [^ self ifEmpty: [self repelCard: aCard default: false]			ifNotEmpty: [true]].	(stackingPolicy = #altStraight or: [stackingPolicy = #straight])		ifTrue: [self ifEmpty: [^ self repelCard: aCard default: (self emptyDropNotOk: aCard)]				ifNotEmpty: [(self inStackingOrder: aCard onTopOf: self topCard)						ifFalse: [^ self repelCard: aCard default: true]]].	^ false! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 04:09'!repelCard: aCard default: aBoolean		^(self acceptCard: aCard default: aBoolean not) not! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 02:20'!repelsMorph: aMorph event: evt	(aMorph isKindOf: PlayingCardMorph) 		ifTrue: [^self repelCard: aMorph]		ifFalse: [^true]! !!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'ar 11/12/2000 22:40'!reverse	self invalidRect: self fullBounds.	submorphs _ submorphs reversed.	self layoutChanged.! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'dgd 2/22/2003 18:49'!rootForGrabOf: aCard 	self hasSubmorphs ifFalse: [^nil].	(target notNil and: [cardDraggedSelector notNil]) 		ifTrue: 			[^target 				perform: cardDraggedSelector				with: aCard				with: self]		ifFalse: [^self firstSubmorph]! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/23/1999 22:22'!seed		^seed! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/23/1999 22:21'!seed: anInteger		seed _ anInteger! !!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'ar 11/12/2000 22:40'!shuffle	self invalidRect: self fullBounds.	submorphs _ submorphs shuffledBy: (Random new seed: seed).	self layoutChanged.! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/15/1999 16:39'!stackingOrder: aSymbol	"#ascending #descending"	stackingOrder _ aSymbol! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 00:08'!stackingPolicy	^ stackingPolicy! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 00:08'!stackingPolicy: aSymbol	"#straight #altStraight #single #none"	stackingPolicy _ aSymbol! !!PlayingCardDeck methodsFor: 'layout' stamp: 'djp 10/15/1999 11:25'!staggerOffset	^18! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 20:20'!subDeckStartingAt: aCard	| i subDeck |	i _ submorphs indexOf: aCard ifAbsent: [^ aCard].	i = 1 ifTrue: [^aCard].	subDeck _ PlayingCardDeck new.	(submorphs copyFrom: 1 to: i-1) do:			[:m | m class = aCard class ifTrue: [subDeck addMorphBack: m]].	^subDeck.	! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 17:21'!target: anObject	target _ anObject! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 19:24'!topCard	^self firstSubmorph! !!SameGame class methodsFor: 'parts bin' stamp: 'sw 8/2/2001 12:52'!descriptionForPartsBin	^ self partName:	'Same'		categories:		#('Games')		documentation:	'A board game implementedby Tim Olson, based on a game originally written for UNIX by Eiji Fukumoto.'! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 18:07'!board	board ifNil:		[board _ SameGameBoard new			target: self;			actionSelector: #selection].	^ board! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 16:19'!board: aSameGameBoard	board _ aSameGameBoard! !!SameGame methodsFor: 'initialization' stamp: 'ar 11/9/2000 21:21'!buildButton: aButton target: aTarget label: aLabel selector: aSelector	"wrap a button or switch in an alignmentMorph to allow a row of buttons to fill space"	| a |	aButton 		target: aTarget;		label: aLabel;		actionSelector: aSelector;		borderColor: #raised;		borderWidth: 2;		color: color.	a _ AlignmentMorph newColumn		wrapCentering: #center; cellPositioning: #topCenter;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: color.	a addMorph: aButton.	^ a! !!SameGame methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:30'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!SameGame methodsFor: 'actions' stamp: 'tao 5/18/1998 19:45'!help: helpState	helpState		ifTrue: [self addMorphBack: self helpText]		ifFalse: [helpText delete]! !!SameGame methodsFor: 'access' stamp: 'asm 11/25/2003 22:40'!helpString	^ 'The object of SameGame is to maximize your score by removing tiles from the board.  Tiles are selected and removed by clicking on a tile that has at least one adjacent tile of the same color (where adjacent is defined as up, down, left, or right).The first click selects a group of adjacent tiles, a second click in that group will remove it from the board, sliding tiles down and right to fill the space of the removed group.  If you wish to select a different group, simply click on it instead.The score increases by "(selection - 2) squared", so you want to maximize the selection size as much as possible.  However, making small strategic selections may allow you to increase the size of a later selection.If you are having a hard time finding a group, the "Hint" button will find one and select it for you (although it is likely not the best group to select!!).When there are no more groups available, the score display will flash with your final score.  Your final score is reduced by 1 for each tile remaining on the board.  If you manage to remove all tiles, your final score is increased by a bonus of 5 times the number of tiles on a full board.Come on, you can beat that last score!!  Click "New game"  ;-)SameGame was originally written by Eiji Fukumoto for UNIX and X; this version is based upon the same game concept, but was rewritten from scratch.' translated! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 19:43'!helpText	helpText ifNil:		[helpText _ PluggableTextMorph new			width: board width;			editString: self helpString].	^ helpText! !!SameGame methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:02'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;	  wrapCentering: #center;		 cellPositioning: #topCenter;	  vResizing: #shrinkWrap;	  hResizing: #shrinkWrap;	  layoutInset: 3;	  addMorph: self makeControls;	  addMorph: self board.	helpText _ nil.	self newGame! !!SameGame methodsFor: 'initialization' stamp: 'ar 11/9/2000 21:22'!makeControls	| row |	row _ AlignmentMorph newRow		color: color;		borderWidth: 0;		layoutInset: 3.	row hResizing: #spaceFill; vResizing: #shrinkWrap; wrapCentering: #center; cellPositioning: #leftCenter; extent: 5@5.	row addMorph:		(self			buildButton: SimpleSwitchMorph new			target: self			label: 'Help'			selector: #help:).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self			label: 'Quit'			selector: #delete).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self board			label: 'Hint'			selector: #hint).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self			label: 'New game'			selector: #newGame).	selectionDisplay _ LedMorph new		digits: 2;		extent: (2*10@15).	row addMorph: (self wrapPanel: selectionDisplay label: 'Selection:').	scoreDisplay _ LedMorph new		digits: 4;		extent: (4*10@15).	row addMorph: (self wrapPanel: scoreDisplay label: 'Score:').	^ row! !!SameGame methodsFor: 'actions' stamp: 'tao 5/18/1998 18:35'!newGame	scoreDisplay value: 0; flash: false.	selectionDisplay value: 0.	self board resetBoard.! !!SameGame methodsFor: 'access' stamp: 'di 9/12/2000 08:07'!scoreDisplay	^ scoreDisplay! !!SameGame methodsFor: 'actions' stamp: 'aoy 2/15/2003 21:40'!selection	"a selection was made on the board; get its count and update the displays"	| count score |	count := self board selectionCount.	count = 0 		ifTrue: 			[score := scoreDisplay value + (selectionDisplay value - 2) squared.			board findSelection ifNil: 					[count := board tilesRemaining.					score := count = 0 						ifTrue: [score + (5 * board rows * board columns)]						ifFalse: [score - count].					scoreDisplay flash: true].			scoreDisplay value: score].	selectionDisplay value: count! !!SameGame methodsFor: 'initialization' stamp: 'ar 11/9/2000 21:22'!wrapPanel: anLedPanel label: aLabel	"wrap an LED panel in an alignmentMorph with a label to its left"	| a |	a _ AlignmentMorph newRow		wrapCentering: #center; cellPositioning: #leftCenter;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 0;		layoutInset: 3;		color: color lighter.	a addMorph: anLedPanel.	a addMorph: (StringMorph contents: aLabel). 	^ a! !!SameGameBoard class methodsFor: 'new-morph participation' stamp: 'di 1/16/2000 10:37'!includeInNewMorphMenu	^false! !!SameGameBoard methodsFor: 'layout' stamp: 'tao 5/15/1998 14:15'!acceptDroppingMorph: aMorph event: evt	"Allow the user to set the protoTile just by dropping it on this morph."	self protoTile: aMorph.	self removeAllMorphs.! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!actionSelector	^ actionSelector! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 17:00'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!SameGameBoard methodsFor: 'private' stamp: 'ar 11/20/2000 19:26'!adjustTiles	"add or remove new protoTile submorphs to fill out my new bounds"	| newSubmorphs requiredSubmorphs count r c |	columns _ self width // protoTile width.	rows _ self height // protoTile height.	requiredSubmorphs _ rows * columns.	newSubmorphs _ OrderedCollection new.	r _ 0.	c _ 0.	self submorphCount > requiredSubmorphs		ifTrue: "resized smaller -- delete rows or columns"			[count _ 0.			submorphs do:				[:m | 				count < requiredSubmorphs					ifTrue:						[m position: self position + (protoTile extent * (c @ r)).						m arguments: (Array with: c @ r).						newSubmorphs add: m]					ifFalse: [m privateOwner: nil].				count _ count + 1.				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]]]		ifFalse: "resized larger -- add rows or columns"			[submorphs do:				[:m |				m position: self position + (self protoTile extent * (c @ r)).				m arguments: (Array with: c @ r).				newSubmorphs add: m.				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]].			1 to: (requiredSubmorphs - self submorphCount) do:				[:m |				newSubmorphs add:					(protoTile copy						position: self position + (self protoTile extent * (c @ r));						actionSelector: #tileClickedAt:newSelection:;						arguments: (Array with: c @ r);						target: self;						privateOwner: self).				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]]].	submorphs _ newSubmorphs asArray.! !!SameGameBoard methodsFor: 'undo' stamp: 'dgd 2/22/2003 13:36'!capturedState	"Note the state stored in the second element is an array of associations	from submorph index to a shallowCopy of the morph, but only for those	morphs that change.  Therefore the capturedState record *first* delivers	all the morphs, and *then* computes the difference and stores this back.	In the end, both undo and redo records follow this format."	| prior state oldMorphs priorChanges newChanges |	(prior := self valueOfProperty: #priorState) isNil 		ifTrue: 			[state := { 						self shallowCopy.	"selection, etc."						self submorphs collect: [:m | m shallowCopy].	"state of all tiles"						owner scoreDisplay flash.	"score display"						owner scoreDisplay value}.			self setProperty: #priorState toValue: state.			^state].	oldMorphs := prior second.	priorChanges := OrderedCollection new.	newChanges := OrderedCollection new.	1 to: oldMorphs size		do: 			[:i | 			(oldMorphs at: i) color = (submorphs at: i) color 				ifFalse: 					[priorChanges addLast: i -> (oldMorphs at: i).					newChanges addLast: i -> (submorphs at: i) shallowCopy]].	self removeProperty: #priorState.	prior at: 2 put: priorChanges asArray.	"Store back into undo state.2"	^{ 		self shallowCopy.	"selection, etc."		newChanges asArray.	"state of tiles that changed"		owner scoreDisplay flash.	"score display"		owner scoreDisplay value}! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 12:01'!collapseColumn: col fromRow: row	| targetTile sourceTile |	(targetTile _ self tileAt: col@row) disabled ifTrue:		[row - 1 to: 0 by: -1 do:			[:r |			(sourceTile _ self tileAt: col@r) disabled ifFalse:				[targetTile color: sourceTile color.				targetTile disabled: false.				sourceTile disabled: true.				^ true]]].	^ false! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 18:47'!collapseColumns: columnsToCollapse	| columnsToRemove |	columnsToRemove _ OrderedCollection new.	columnsToCollapse do:		[:c |		rows - 1 to: 0 by: -1 do: [:r | self collapseColumn: c fromRow: r].		(self tileAt: c@(rows-1)) disabled ifTrue: [columnsToRemove add: c]].	self world displayWorld.	columnsToRemove reverseDo: [:c | self removeColumn: c].! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:45'!columns	^ columns! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!columns: newColumns	self extent: self protoTile extent * (newColumns @ rows)! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!columns: newColumns rows: newRows	self extent: self protoTile extent * (newColumns @ newRows)! !!SameGameBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:39'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!SameGameBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:30'!defaultColor	"answer the default color/fill style for the receiver"	^ Color gray! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 11:38'!deselectSelection	selection ifNotNil:		[selection do: [:loc | (self tileAt: loc) setSwitchState: false; color: selectionColor].		selection _ nil.		flash _ false]! !!SameGameBoard methodsFor: 'geometry' stamp: 'ar 11/20/2000 19:28'!extent: aPoint	"constrain the extent to be a multiple of the protoTile size during resizing"	super extent: (aPoint truncateTo: protoTile extent).	self adjustTiles.! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 18:52'!findSelection	"find a possible selection and return it, or nil if no selection"	| tile k testTile |	0 to: rows-1 do:		[:r |		0 to: columns-1 do:			[:c |			tile _ self tileAt: c@r.			tile disabled  ifFalse:				[k _ tile color.				c+1 < columns ifTrue:					[testTile _ self tileAt: (c+1)@r.					(testTile disabled not and: [testTile color = k]) ifTrue: [^ tile]].				r+1 < rows ifTrue:					[testTile _ self tileAt: c@(r+1).					(testTile disabled not and: [testTile color = k]) ifTrue: [^ tile]]]]].	 ^ nil			! !!SameGameBoard methodsFor: 'actions' stamp: 'ar 10/25/2000 23:13'!hint	"find a possible selection and select it"	| tile |	self deselectSelection.	tile _ self findSelection.	tile ifNotNil: [tile mouseDown: MouseButtonEvent new]! !!SameGameBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:12'!initialize	"initialize the state of the receiver"	super initialize.	target _ nil.	actionSelector _ #selection.	arguments _ #().	self layoutPolicy: nil.	self hResizing: #rigid.	self vResizing: #rigid.	rows _ self preferredRows.	columns _ self preferredColumns.	palette _ (Color wheel: self preferredTileTypes + 1) asOrderedCollection.	flashColor _ palette removeLast.	flash _ false.	self extent: self protoTile extent * (columns @ rows).	self resetBoard! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:24'!preferredColumns	^ 20! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:24'!preferredRows	^ 10! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:34'!preferredTileTypes	^ 5! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:47'!protoTile	protoTile ifNil: [protoTile _ SameGameTile new].	^ protoTile! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:48'!protoTile: aTile	protoTile _ aTile! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 15:54'!removeColumn: column	| sourceTile |	column+1 to: columns-1 do:		[:c |		0 to: rows-1 do:			[:r |			sourceTile _ self tileAt: c@r.			(self tileAt: c-1@r)				color: sourceTile color;				disabled: sourceTile disabled]].	0 to: rows-1 do:		[:r | (self tileAt: columns-1@r) disabled: true]! !!SameGameBoard methodsFor: 'actions' stamp: 'asm 11/25/2003 22:41'!removeSelection	selection		ifNil: [^ self].	self		rememberUndoableAction: [selection				do: [:loc | (self tileAt: loc) disabled: true;						 setSwitchState: false].			self collapseColumns: (selection					collect: [:loc | loc x]) asSet asSortedCollection.			selection := nil.			flash := false.			(target notNil					and: [actionSelector notNil])				ifTrue: [target perform: actionSelector withArguments: arguments]]		named: 'remove selection' translated! !!SameGameBoard methodsFor: 'initialization' stamp: 'di 12/12/2000 15:03'!resetBoard	Collection initialize.  "randomize"	selection _ nil.	self purgeAllCommands.	self submorphsDo:		[:m |		m disabled: false.		m setSwitchState: false.		m color: palette atRandom].! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:45'!rows	^ rows! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!rows: newRows	self extent: self protoTile extent * (columns @ newRows)! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 11:37'!selectTilesAdjacentTo: location	| al at |	{-1@0. 0@-1. 1@0. 0@1} do:		[:offsetPoint |		al _ location + offsetPoint.		((al x between: 0 and: columns - 1) and: [al y between: 0 and: rows - 1]) ifTrue:			[at _ self tileAt: al.			(at color = selectionColor and: [at switchState not and: [at disabled not]]) ifTrue:				[selection add: al.				at setSwitchState: true.				self selectTilesAdjacentTo: al]]]! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:56'!selectionCount	^ selection isNil		ifTrue: [0]		ifFalse: [selection size]! !!SameGameBoard methodsFor: 'stepping and presenter' stamp: 'tao 5/17/1998 11:38'!step	| newColor |	selection ifNotNil:		[newColor _ flash			ifTrue: [selectionColor]			ifFalse: [flashColor].		selection do: [:loc | (self tileAt: loc) color: newColor].		flash _ flash not]! !!SameGameBoard methodsFor: 'testing' stamp: 'tao 5/18/1998 11:16'!stepTime	^ 500! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!target	^ target! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!target: anObject	target _ anObject! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 10:31'!tileAt: aPoint	^ submorphs at: (aPoint x + (aPoint y * columns) + 1)! !!SameGameBoard methodsFor: 'actions' stamp: 'dgd 2/22/2003 18:51'!tileClickedAt: location newSelection: isNewSelection 	| tile |	isNewSelection 		ifTrue: 			[self deselectSelection.			tile := self tileAt: location.			selectionColor := tile color.			selection := OrderedCollection with: location.			self selectTilesAdjacentTo: location.			selection size = 1 				ifTrue: [self deselectSelection]				ifFalse: 					[(target notNil and: [actionSelector notNil]) 						ifTrue: [target perform: actionSelector withArguments: arguments]]]		ifFalse: [self removeSelection]! !!SameGameBoard methodsFor: 'private' stamp: 'di 7/1/1998 00:04'!tilesRemaining	^ (submorphs reject: [:m | m disabled]) size! !!SameGameBoard methodsFor: 'undo' stamp: 'di 12/12/2000 16:44'!undoFromCapturedState: st 	self copyFrom: st first.	st second do: [:assn | (submorphs at: assn key) copyFrom: assn value].	selection ifNotNil:		[selection do: [:loc | (self tileAt: loc) setSwitchState: false; color: selectionColor].		selection _ nil].	owner scoreDisplay flash: st third.  "score display"	owner scoreDisplay value: st fourth.	self changed.! !!Tetris class methodsFor: 'as yet unclassified' stamp: 'RAA 1/7/2000 23:19'!colors	^{		Color r: 0.5 g: 0 b: 0.		Color r: 0 g: 0.5 b: 0.		Color r: 0 g: 0 b: 0.5.		Color r: 0.5 g: 0.5 b: 0.		Color r: 0.5 g: 0 b: 0.5.		Color r: 0 g: 0.5 b: 0.5	}! !!Tetris class methodsFor: 'parts bin' stamp: 'sw 8/2/2001 12:53'!descriptionForPartsBin	^ self partName:	'Tetris'		categories:		#('Games')		documentation:	'Tetris, yes Tetris'! !!Tetris methodsFor: 'initialization' stamp: 'RAA 1/8/2000 14:38'!buildButtonTarget: aTarget label: aLabel selector: aSelector help: aString	^self rowForButtons		addMorph: (			SimpleButtonMorph new 				target: aTarget;				label: aLabel;				actionSelector: aSelector;				borderColor: #raised;				borderWidth: 2;				color: color		)! !!Tetris methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!Tetris methodsFor: 'event handling' stamp: 'ar 9/15/2000 22:58'!handlesKeyboard: evt	^true! !!Tetris methodsFor: 'event handling' stamp: 'am 8/28/1999 14:22'!handlesMouseOver: evt	^ true! !!Tetris methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:26'!initialize	"initialize the state of the receiver"	super initialize.	""	board _ TetrisBoard new game: self.	self listDirection: #topToBottom;	  wrapCentering: #center;	  vResizing: #shrinkWrap;	  hResizing: #shrinkWrap;	  layoutInset: 3;	  addMorphBack: self makeGameControls;		 addMorphBack: self makeMovementControls;		 addMorphBack: self showScoreDisplay;		 addMorphBack: board.	board newGame! !!Tetris methodsFor: 'event handling' stamp: 'RAA 1/8/2000 15:42'!keyStroke: evt	| charValue |	charValue _ evt keyCharacter asciiValue.	charValue = 28 ifTrue: [board moveLeft].	charValue = 29 ifTrue: [board moveRight].	charValue = 30 ifTrue: [board rotateClockWise].	charValue = 31 ifTrue: [board rotateAntiClockWise].	charValue = 32 ifTrue: [board dropAllTheWay].! !!Tetris methodsFor: 'initialization' stamp: 'asm 11/25/2003 22:45'!makeGameControls	^ self rowForButtons		addMorph: (self				buildButtonTarget: self				label: 'Quit' translated				selector: #delete				help: 'quit' translated);				addMorph: (self				buildButtonTarget: board				label: 'Pause' translated				selector: #pause				help: 'pause' translated);				addMorph: (self				buildButtonTarget: board				label: 'New game' translated				selector: #newGame				help: 'new game' translated)! !!Tetris methodsFor: 'initialization' stamp: 'asm 11/25/2003 22:45'!makeMovementControls	^ self rowForButtons		addMorph: (self				buildButtonTarget: board				label: '->'				selector: #moveRight				help: 'move to the right' translated);				addMorph: (self				buildButtonTarget: board				label: ' ) '				selector: #rotateClockWise				help: 'rotate clockwise' translated);				addMorph: (self				buildButtonTarget: board				label: ' | '				selector: #dropAllTheWay				help: 'drop' translated);				addMorph: (self				buildButtonTarget: board				label: ' ( '				selector: #rotateAntiClockWise				help: 'rotate anticlockwise' translated);				addMorph: (self				buildButtonTarget: board				label: '<-'				selector: #moveLeft				help: 'move to the left' translated)! !!Tetris methodsFor: 'event handling' stamp: 'ar 9/15/2000 23:07'!mouseEnter: evt        evt hand newKeyboardFocus: self! !!Tetris methodsFor: 'initialization' stamp: 'ar 11/9/2000 21:24'!rowForButtons	^AlignmentMorph newRow		color: color;		borderWidth: 0;		layoutInset: 3;		vResizing: #shrinkWrap;		wrapCentering: #center! !!Tetris methodsFor: 'events' stamp: 'RAA 1/7/2000 22:37'!score: anInteger	scoreDisplay value: anInteger! !!Tetris methodsFor: 'initialization' stamp: 'asm 11/25/2003 22:45'!showScoreDisplay	^ self rowForButtons hResizing: #shrinkWrap;				addMorph: (self wrapPanel: ((scoreDisplay := LedMorph new) digits: 5;					 extent: 4 * 10 @ 15) label: 'Score:' translated)! !!Tetris methodsFor: 'initialization' stamp: 'RAA 1/8/2000 14:38'!wrapPanel: anLedPanel label: aLabel	"wrap an LED panel in an alignmentMorph with a label to its left"	^self rowForButtons		color: color lighter;		addMorph: anLedPanel;		addMorph: (StringMorph contents: aLabel)! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'RM 9/16/2004 14:34'!initialize	"ChessConstants initialize"	self initializePieceConstants.	self initializeCastlingConstants.	self initializePieceValues.	self initializeMoves.	self initializeCenterScores.	self initializeBishopMovers.	self initializeRookMovers.	self initializeSquareConstants.! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'RM 9/16/2004 19:38'!initializeBishopMovers.	BishopMovers _ Set new.	BishopMovers add:Bishop.	BishopMovers add:Queen.! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:15'!initializeBishopMoves	"ChessPlayer initialize"	| index moveList1 moveList2 moveList3 moveList4 px py |	BishopMoves _ Array new: 64 withAll: #().	0 to: 7 do:[:j|		0 to: 7 do:[:i|			index _ (j * 8) + i + 1.			moveList1 _ moveList2 _ moveList3 _ moveList4 _ #().			1 to: 7 do:[:k|				px _ i + k. py _ j - k.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList1 _ moveList1 copyWith: (py * 8) + px + 1].				px _ i - k. py _ j - k.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList2 _ moveList2 copyWith: (py * 8) + px + 1].				px _ i + k. py _ j + k.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList3 _ moveList3 copyWith: (py * 8) + px + 1].				px _ i - k. py _ j + k.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList4 _ moveList4 copyWith: (py * 8) + px + 1].			].			BishopMoves at: index put: {moveList1. moveList2. moveList3. moveList4}.		].	].! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:09'!initializeCastlingConstants	CastlingDone _ 1.	CastlingDisableKingSide _ 2.	CastlingDisableQueenSide _ 4.	CastlingDisableAll _ CastlingDisableQueenSide bitOr: CastlingDisableKingSide.	CastlingEnableKingSide _ CastlingDone bitOr: CastlingDisableKingSide.	CastlingEnableQueenSide _ CastlingDone bitOr: CastlingDisableQueenSide.! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:16'!initializeCenterScores	"ChessPlayer initialize"	PieceCenterScores _ Array new: 6.	1 to: 6 do:[:i| PieceCenterScores at: i put: (ByteArray new: 64)].	PieceCenterScores at: Knight put:		#(			-4	0	0	0	0	0	0	-4			-4	0	2	2	2	2	0	-4			-4	2	3	2	2	3	2	-4			-4	1	2	5	5	2	2	-4			-4	1	2	5	5	2	2	-4			-4	2	3	2	2	3	2	-4			-4	0	2	2	2	2	0	-4			-4	0	0	0	0	0	0	-4		).	PieceCenterScores at: Bishop put:		#(			-2	-2	-2	-2	-2	-2	-2	-2			-2	0	0	0	0	0	0	-2			-2	0	1	1	1	1	0	-2			-2	0	1	2	2	1	0	-2			-2	0	1	2	2	1	0	-2			-2	0	1	1	1	1	0	-2			-2	0	0	0	0	0	0	-2			-2	-2	-2	-2	-2	-2	-2	-2		).	PieceCenterScores at: Queen put:		#(			-3	0	0	0	0	0	0	-3			-2	0	0	0	0	0	0	-2			-2	0	1	1	1	1	0	-2			-2	0	1	2	2	1	0	-2			-2	0	1	2	2	1	0	-2			-2	0	1	1	1	1	0	-2			-2	0	0	0	0	0	0	-2			-3	0	0	0	0	0	0	-3		).! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:15'!initializeKingMoves	"ChessPlayer initialize"	| index px py moveList |	KingMoves _ Array new: 64 withAll: #().	0 to: 7 do:[:j|		0 to: 7 do:[:i|			index _ (j * 8) + i + 1.			moveList _ #().			#( (-1 -1) (0 -1) (1 -1) (-1 0) (1 0) (-1 1) (0 1) (1 1)) do:[:spec|				px _ i + spec first.				py _ j + spec last.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList _ moveList copyWith: (py * 8) + px + 1]].			KingMoves at: index put: moveList		].	].! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:14'!initializeKnightMoves	"ChessPlayer initialize"	| index px py moveList |	KnightMoves _ Array new: 64 withAll: #().	0 to: 7 do:[:j|		0 to: 7 do:[:i|			index _ (j * 8) + i + 1.			moveList _ #().			#( (-2 -1) (-1 -2) (1 -2) (2 -1) (-2 1) (-1 2) (1 2) (2 1)) do:[:spec|				px _ i + spec first.				py _ j + spec last.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList _ moveList copyWith: (py * 8) + px + 1]].			KnightMoves at: index put: moveList		].	].! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:11'!initializeMoves	"ChessPlayer initialize"	self initializeKnightMoves.	self initializeRookMoves.	self initializeBishopMoves.	self initializeKingMoves.! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:09'!initializePieceConstants	EmptySquare := 0.	Pawn := 1.	Knight := 2.	Bishop := 3.	Rook := 4.	Queen := 5.	King := 6.! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:14'!initializePieceValues	PieceValues _ Array new: 6.	PieceValues at: Pawn put: 100.	PieceValues at: Knight put: 300.	PieceValues at: Bishop put: 350.	PieceValues at: Rook put: 500.	PieceValues at: Queen put: 900.	PieceValues at: King put: 2000.! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'RM 9/16/2004 19:38'!initializeRookMovers.	RookMovers _ Set new.	RookMovers add:Rook.	RookMovers add:Queen.! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:14'!initializeRookMoves	"ChessPlayer initialize"	| index moveList1 moveList2 moveList3 moveList4 px py |	RookMoves _ Array new: 64 withAll: #().	0 to: 7 do:[:j|		0 to: 7 do:[:i|			index _ (j * 8) + i + 1.			moveList1 _ moveList2 _ moveList3 _ moveList4 _ #().			1 to: 7 do:[:k|				px _ i + k. py _ j.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList1 _ moveList1 copyWith: (py * 8) + px + 1].				px _ i. py _ j + k.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList2 _ moveList2 copyWith: (py * 8) + px + 1].				px _ i - k. py _ j.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList3 _ moveList3 copyWith: (py * 8) + px + 1].				px _ i. py _ j - k.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList4 _ moveList4 copyWith: (py * 8) + px + 1].			].			RookMoves at: index put: {moveList1. moveList2. moveList3. moveList4}.		].	].! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'RM 9/16/2004 14:34'!initializeSquareConstants	A1_1. B1_2. C1_3. D1_4. E1_5. F1_6. G1_7. H1_8.	A2_9. B2_10. C2_11. D2_12. E2_13. F2_14. G2_15. H2_16.	A3_17. B3_18. C3_19. D3_20. E3_21. F3_22. G3_23. H3_24.	A4_25. B4_26. C4_27. D4_28. E4_29. F4_30. G4_31. H4_32.	A5_33. B5_34. C5_35. D5_36. E5_37. F5_38. G5_39. H5_40.	A6_41. B6_42. C6_43. D6_44. E6_45. F6_46. G6_47. H6_48.	A7_49. B7_50. C7_51. D7_52. E7_53. F7_54. G7_55. H7_56.	A8_57. B8_58. C8_59. D8_60. E8_61. F8_62. G8_63. H8_64.! !!AtomicMap class methodsFor: 'enumerating' stamp: 'grp 12/29/2001 11:46'!E	^ 1 @ 0.! !!AtomicMap class methodsFor: 'enumerating' stamp: 'grp 12/29/2001 11:46'!N	^ 0 @ -1.! !!AtomicMap class methodsFor: 'enumerating' stamp: 'grp 12/29/2001 11:46'!NE	^  1 @ -1.! !!AtomicMap class methodsFor: 'enumerating' stamp: 'grp 12/29/2001 11:47'!NW	^  -1 @ -1! !!AtomicMap class methodsFor: 'enumerating' stamp: 'grp 12/29/2001 11:47'!S	^ 0 @ 1.	! !!AtomicMap class methodsFor: 'enumerating' stamp: 'grp 12/29/2001 11:47'!SE	^  1 @ 1.! !!AtomicMap class methodsFor: 'enumerating' stamp: 'grp 12/29/2001 11:47'!SW	^  -1 @ 1.! !!AtomicMap class methodsFor: 'enumerating' stamp: 'grp 12/29/2001 11:47'!W	^-1 @ 0.! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 8/1/2002 21:31'!atomPosition: indexes 	^ self atomSize  * indexes + self borderSpace! !!AtomicMap methodsFor: 'access properties' stamp: 'GP 4/14/2003 22:45'!atomSize	^ mapStyle		isSmallScreen ifTrue: [14 @ 14]		ifFalse: [28 @ 28]! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 7/29/2002 23:49'!borderSpace	^ 10 @ 5! !!AtomicMap methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:09'!buildLayout: aOwnerPanel 	| style beginning item object newPos newBound |	style _ AtomicMapStyle new.	beginning _ aOwnerPanel bounds bottomLeft.	1		to: layout rowCount		do: [:r | 1				to: layout columnCount				do: [:c | 					item _ layout at: r at: c.					object _ self createComponents: item .					object						ifNotNil: [object mapStyle: style.							newPos _ self atomPosition: r @ c - 1.							newBound _ newPos corner: newPos + self atomSize.							newBound _ newBound translateBy: beginning.							object bounds: newBound.							aOwnerPanel addMorphBack: object]]]! !!AtomicMap methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:09'!buildLayoutForPreview: aOwnerPanel 	| style beginning item object newPos newBound |	style _ AtomicMapStyle newForPreview.	beginning _ aOwnerPanel bounds topRight.	1		to: layout rowCount		do: [:r | 1				to: layout  columnCount				do: [:c | 					item _ layout at: r at: c.					object _ self createComponentsForPreview: item ..					object						ifNotNil: ["Specially for preview"							object mapStyle: style.							previewExtent _ previewExtent max: object previewPosition.							newPos _ self atomPosition: object previewPosition - 1.							newBound _ newPos corner: newPos + self atomSize.							newBound _ newBound translateBy: beginning.							object bounds: newBound.							aOwnerPanel addMorph: object]]]! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 8/21/2002 21:25'!createAtoms: aDescriptor 	"Returns the atom with the predefined setting"	| atomKind requiredClass items previewX previewY |	atomKind _ aDescriptor at: 1.	"get the class"	requiredClass _ self getClassOf: atomKind.	requiredClass		ifNotNil: ["preview position"			previewX _ aDescriptor at: 2.			previewY _ aDescriptor at: 3.			"removes used settings"			items _ ((aDescriptor copyWithout: atomKind)						copyWithout: previewX)						copyWithout: previewY.			"builds the atom"			^ ((requiredClass new				links: (self extractLinks: items))				forcedLinks: (self extractForcedLinks: items))				previewPosition: previewX @ previewY].	"Shows an error"	self log: 'Unknown Atom kind: ' , atomKind asString.	^ nil! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 8/21/2002 21:26'!createComponents: aDescriptor	"Spaces"	aDescriptor = 0		ifTrue: [^ nil].	"Bricks"	aDescriptor = 1		ifTrue: [^ AtomicBrick new].	"Atom"	(aDescriptor isKindOf: Array)		ifTrue: [^ self createAtoms: aDescriptor].	"Nothing"	^ nil! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 8/21/2002 21:26'!createComponentsForPreview: aDescriptor 	"Atom"	(aDescriptor isKindOf: Array)		ifTrue: [^ self createAtoms: aDescriptor].	"Nothing"	^ nil! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 9/20/2001 23:47'!createLayout"Returns and Array2D with the kind of molecules to be created"	self subclassResponsibility! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 6/2/2002 17:43'!extractForcedLinks: aSymbolList 	| result requiredClass |	result _ Bag new.	aSymbolList		do: [:item | 						requiredClass _ self getClassOf: item.			requiredClass				ifNotNil: [result add: requiredClass]].	^ result! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 8/5/2002 11:34'!extractLinks: aSymbolList 	| result link |	result _ Bag new.	aSymbolList		do: [:item | 			link _ nil.			"Create a link depending the kind"			item = #n				ifTrue: [link _ AtomicMap N].			item = #ne				ifTrue: [link _ AtomicMap NE].			item = #e				ifTrue: [link _ AtomicMap E].			item = #se				ifTrue: [link _ AtomicMap SE].			item = #s				ifTrue: [link _ AtomicMap S].			item = #sw				ifTrue: [link _ AtomicMap SW].			item = #w				ifTrue: [link _ AtomicMap W].			item = #nw				ifTrue: [link _ AtomicMap NW].			link								ifNotNil: [result add: link]].	^ result! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 5/1/2002 13:06'!getClassOf: aItem	"Which class is related to it"	aItem = #H		ifTrue: [^ AtomicHydrogen ].	aItem = #C		ifTrue: [^ AtomicCarbon ].	aItem = #O		ifTrue: [^ AtomicOxygen ].	aItem = #F		ifTrue: [^ AtomicFluor ].	aItem = #N		ifTrue: [^ AtomicNitrogen ].	aItem = #-		ifTrue: [^ AtomicLink ].^ nil.! !!AtomicMap methodsFor: 'initialization' stamp: 'grp 8/21/2002 21:16'!initialize	layout _ self createLayout.mapStyle _ AtomicMapStyle new.	previewExtent _ 0 @ 0! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 12/30/2001 17:06'!levelName	"Return the name of this level"	self subclassResponsibility! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 8/21/2002 23:14'!mapStyle^mapStyle! !!AtomicMap methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:32'!neededSize	^ self atomSize * (layout rowCount@layout columnCount) + (self borderSpace * 2)! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 8/1/2002 21:32'!previewNeededSize	^ self atomSize * previewExtent  + (self borderSpace * 2)! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 8/1/2002 21:14'!record^	self subclassResponsibility! !!AtomicMap01 methodsFor: 'access properties' stamp: 'asm 4/20/2004 20:17'!createLayout	layout _ Matrix  rows: 9 columns:11.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 1 0 0 0 0 0 0 1 ).	layout atRow: 3 put: #(1 0 #(#H 3 1 #w) 1 0 0 0 0 0 0 1 ).	layout atRow: 4 put: #(1 0 1 1 0 0 0 0 0 0 1 ).	layout atRow: 5 put: #(1 0 1 0 0 1 0 1 1 1 1 ).	layout atRow: 6 put: #(1 0 0 0 0 1 0 #(#O 2 1 #w #e #H) 0 0 1 ).	layout atRow: 7 put: #(1 1 1 0 1 0 0 0 0 0 1 ).	layout atRow: 8 put: #(1 #(#H 1 1 #e) 0 0 0 0 1 0 0 0 1 ).	layout atRow: 9 put: #(1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap01 methodsFor: 'access properties' stamp: 'asm 4/20/2004 20:43'!levelName	^ 'Water' translated! !!AtomicMap01 methodsFor: 'access properties' stamp: 'grp 7/30/2002 16:54'!record	^ 15! !!AtomicMap02 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:37'!createLayout	layout _ Matrix  rows: 11 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 0 1 0 0 1 0 0 0 0 1 ).	layout atRow: 3 put: #(1 0 1 0 0 1 #(#H 3 2 #w) 1 0 0 0 0 1 ).	layout atRow: 4 put: #(1 0 0 1 0 0 0 1 #(#C 2 2 #n #e #s #w) 0 1 0 1 ).	layout atRow: 5 put: #(1 0 0 0 0 0 0 1 1 1 1 0 1 ).	layout atRow: 6 put: #(1 0 0 0 0 0 0 0 1 #(#H 1 2 #e) 1 0 1 ).	layout atRow: 7 put: #(1 0 #(#H 2 1 #s) 0 0 1 0 0 1 0 0 0 1 ).	layout atRow: 8 put: #(1 0 1 1 1 1 1 0 0 0 0 1 1 ).	layout atRow: 9 put: #(1 0 #(#H 2 3 #n C) 0 1 0 1 1 0 0 0 1 0 ).	layout atRow: 10 put: #(1 1 1 1 1 0 0 1 0 0 0 1 0 ).	layout atRow: 11 put: #(0 0 0 0 0 0 0 1 1 1 1 1 0 ).	^ layout! !!AtomicMap02 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:37'!levelName	^ 'Methane' translated! !!AtomicMap02 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:02'!record	^ 32! !!AtomicMap03 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:37'!createLayout	layout _ Matrix  rows: 12 columns:13.		layout atRow: 1 put: #(0 0 0 0 0 0 0 0 0 1 1 1 1 ).	layout atRow: 2 put: #(1 1 1 1 0 0 0 0 0 1 0 0 1 ).	layout atRow: 3 put: #(1 0 0 1 0 0 0 0 0 1 0 0 1 ).	layout atRow: 4 put: #(1 0 0 1 1 0 0 0 1 1 0 #(#O 3 2 #w #e) 1 ).	layout atRow: 5 put: #(1 0 0 #(#H 2 3 #n) 1 1 1 1 1 0 0 0 1 ).	layout atRow: 6 put: #(1 0 1 0 1 0 #(#C 2 2 #n #e #s #w) 1 0 0 0 0 1 ).	layout atRow: 7 put: #(1 0 0 0 0 0 0 1 0 #(#H 4 2 #w #O) 0 0 1 ).	layout atRow: 8 put: #(1 0 0 1 0 1 0 0 0 1 0 0 1 ).	layout atRow: 9 put: #(1 #(#H 2 1 #s) 0 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 10 put: #(1 0 0 0 1 0 1 0 0 0 1 0 1 ).	layout atRow: 11 put: #(1 1 1 1 1 1 #(#H 1 2 #e) 0 0 0 1 0 1 ).	layout atRow: 12 put: #(0 0 0 0 0 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap03 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:38'!levelName	^ 'Methanol' translated! !!AtomicMap03 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:09'!record	^ 30! !!AtomicMap04 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:38'!createLayout	layout _ Matrix  rows: 11 columns:11.	layout atRow: 1 put: #(1 1 1 0 0 0 0 0 1 1 1 ).	layout atRow: 2 put: #(1 0 1 0 0 0 0 0 1 0 1 ).	layout atRow: 3 put: #(1 #(#H 1 3 #ne) 1 1 1 1 1 1 1 0 1 ).	layout atRow: 4 put: #(1 0 0 0 0 0 0 1 0 0 1 ).	layout atRow: 5 put: #(1 1 0 0 #(#C 3 2 #ne #se #w #w) 0 1 0 0 0 1 ).	layout atRow: 6 put: #(1 0 1 0 0 0 0 #(#H 4 1 #sw) 1 #(#C 2 2 #nw #e #e #sw) 1 ).	layout atRow: 7 put: #(1 0 0 0 1 0 0 0 0 1 1 ).	layout atRow: 8 put: #(1 0 0 1 0 0 0 0 #(#H 4 3 #nw) #(#H 1 1 #se) 1 ).	layout atRow: 9 put: #(1 0 1 1 1 1 1 1 1 0 1 ).	layout atRow: 10 put: #(1 0 1 0 0 0 0 0 1 0 1 ).	layout atRow: 11 put: #(1 1 1 0 0 0 0 0 1 1 1 ).	^ layout! !!AtomicMap04 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:38'!levelName	^ 'Ethylene' translated! !!AtomicMap04 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:13'!record	^ 70! !!AtomicMap05 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:39'!createLayout	layout _ Matrix  rows: 11 columns:12.	layout atRow: 1 put: #(0 1 1 1 1 1 1 1 1 1 0 0 ).	layout atRow: 2 put: #(0 1 #(#H 5 1 #sw) 1 0 1 0 1 0 1 0 0 ).	layout atRow: 3 put: #(0 1 0 1 0 1 0 1 0 1 1 1 ).	layout atRow: 4 put: #(1 1 #(#H 2 3 #n) 0 #(#C 4 2 #ne #se #w #w) 1 #(#H 3 1 #s) 1 0 1 0 1 ).	layout atRow: 5 put: #(1 #(#H 2 1 #s) 0 #(#H 1 2 #e) 0 0 0 1 #(#C 3 2 #n #e #e #w) 1 0 1 ).	layout atRow: 6 put: #(1 0 1 0 0 0 0 0 0 1 0 1 ).	layout atRow: 7 put: #(1 0 1 #(#C 2 2 #n #e #s #w) 1 0 0 0 0 0 0 1 ).	layout atRow: 8 put: #(1 0 1 0 1 0 1 0 0 0 1 1 ).	layout atRow: 9 put: #(1 1 1 0 1 #(#H 5 3 #nw) 1 0 1 0 1 0 ).	layout atRow: 10 put: #(0 0 1 0 1 0 1 0 1 0 1 0 ).	layout atRow: 11 put: #(0 0 1 1 1 1 1 1 1 1 1 0 ).	^ layout! !!AtomicMap05 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:39'!levelName	^ 'Propylene (Propene)' translated! !!AtomicMap05 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:17'!record	^ 68! !!AtomicMap06 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:39'!createLayout	layout _ Matrix  rows: 12 columns:12.	layout atRow: 1 put: #(0 0 0 0 0 1 1 1 1 1 0 0 ).	layout atRow: 2 put: #(0 0 0 0 0 1 #(#H 2 3 #n) #(#C 2 2 #n #s #e #w) 0 1 0 0 ).	layout atRow: 3 put: #(0 1 1 1 1 1 0 1 0 1 0 0 ).	layout atRow: 4 put: #(0 1 0 0 0 0 0 0 #(#H 3 3 #n) 1 0 0 ).	layout atRow: 5 put: #(0 1 1 1 #(#H 2 1 #s) 0 0 0 1 1 0 0 ).	layout atRow: 6 put: #(0 0 0 1 0 1 #(#H 1 2 #e) 1 0 1 1 1 ).	layout atRow: 7 put: #(0 0 0 1 1 #(#H 3 1 #s) 0 0 0 1 0 1 ).	layout atRow: 8 put: #(1 1 1 1 0 #(#C 3 2 #n #s #e #w) 0 0 0 0 0 1 ).	layout atRow: 9 put: #(1 0 #(#O 4 2 #e #w #C #H) 0 0 0 0 1 0 0 0 1 ).	layout atRow: 10 put: #(1 1 1 1 1 0 1 0 0 1 0 1 ).	layout atRow: 11 put: #(0 0 0 1 0 0 0 0 1 0 #(#H 5 2 #w) 1 ).	layout atRow: 12 put: #(0 0 0 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap06 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:39'!levelName	^ 'Ethanol (Ethylic alcohol)' translated! !!AtomicMap06 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:20'!record	^ 50! !!AtomicMap07 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:39'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(0 0 0 1 1 1 0 1 1 1 0 0 0 ).	layout atRow: 2 put: #(0 0 0 1 #(#H 1 2 #e) 1 1 1 0 1 0 0 0 ).	layout atRow: 3 put: #(0 0 0 1 #(#H 2 3 #n) 0 1 0 0 1 0 0 0 ).	layout atRow: 4 put: #(1 1 1 1 0 0 0 0 #(#H 3 1 #s) 1 1 1 1 ).	layout atRow: 5 put: #(1 0 0 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 6 put: #(1 1 0 0 0 0 0 0 0 0 0 1 1 ).	layout atRow: 7 put: #(0 1 1 0 0 0 1 0 0 0 1 1 0 ).	layout atRow: 8 put: #(1 1 0 #(#C 2 2 #n #s #e #w) 0 #(#C 3 2 #n #s #e #w) 0 0 0 0 #(#O 3 3 #n #s #C #H) 1 1 ).	layout atRow: 9 put: #(1 0 #(#H 4 1 #s) 0 0 0 0 #(#C 4 2 #n #s #e #w) 0 0 0 0 1 ).	layout atRow: 10 put: #(1 1 1 1 #(#H 2 1 #s) 0 0 0 #(#H 3 4 #n) 1 1 1 1 ).	layout atRow: 11 put: #(0 0 0 1 #(#H 5 2 #w) 0 1 0 #(#H 4 3 #n) 1 0 0 0 ).	layout atRow: 12 put: #(0 0 0 1 0 1 1 1 0 1 0 0 0 ).	layout atRow: 13 put: #(0 0 0 1 1 1 0 1 1 1 0 0 0 ).	^ layout! !!AtomicMap07 methodsFor: 'access properties' stamp: 'grp 1/5/2002 20:07'!levelName	^ 'Iso-Propanol (Isopropylic alcohol)'.! !!AtomicMap07 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:23'!record	^ 50! !!AtomicMap08 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:40'!createLayout	layout _ Matrix  rows: 11 columns:11.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 3 put: #(1 0 1 1 0 0 0 1 1 0 1 ).	layout atRow: 4 put: #(1 #(#H 2 1 #s) 0 0 0 0 0 #(#C 2 2 #n #s #e #w) 0 0 1 ).	layout atRow: 5 put: #(1 0 1 1 1 0 1 1 1 0 1 ).	layout atRow: 6 put: #(1 #(#H 2 3 #n) 0 0 0 #(#H 1 2 #e) 0 0 0 0 1 ).	layout atRow: 7 put: #(1 #(#C 3 2 #n #e #e #w) 1 1 1 #(#H 3 1 #s) 1 1 1 0 1 ).	layout atRow: 8 put: #(1 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 9 put: #(1 0 1 1 0 0 0 1 1 0 1 ).	layout atRow: 10 put: #(1 0 0 #(#O 4 2 #w #w) 0 0 0 0 0 0 1 ).	layout atRow: 11 put: #(1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap08 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:40'!levelName	^ 'Ethyl-aldehyde (Ethanal)' translated! !!AtomicMap08 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:27'!record	^ 45! !!AtomicMap09 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:40'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(0 0 0 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(0 1 1 1 0 0 1 1 0 0 0 0 1 ).	layout atRow: 3 put: #(1 1 0 0 0 0 0 1 0 1 0 0 1 ).	layout atRow: 4 put: #(1 0 0 0 0 0 #(#O 3 3 #n #n) 1 0 1 1 1 1 ).	layout atRow: 5 put: #(1 0 1 #(#C 2 2 #n #s #e #w) 1 0 #(#H 2 3 #n) 0 #(#C 3 2 #e #w #s #s #O #C) 0 0 #(#H 2 1 #s) 1 ).	layout atRow: 6 put: #(1 0 1 #(#H 4 3 #n) 1 1 1 0 0 #(#H 1 2 #e) 0 0 1 ).	layout atRow: 7 put: #(1 1 1 0 0 #(#H 4 1 #s) 0 0 0 0 1 1 1 ).	layout atRow: 8 put: #(1 0 0 0 0 0 1 1 1 0 1 0 1 ).	layout atRow: 9 put: #(1 0 0 0 0 0 #(#C 4 2 #n #s #e #w) 0 1 0 1 0 1 ).	layout atRow: 10 put: #(1 1 1 1 0 1 0 0 0 0 0 #(#H 5 2 #w) 1 ).	layout atRow: 11 put: #(1 0 0 1 0 1 0 0 0 0 0 1 1 ).	layout atRow: 12 put: #(1 0 0 0 0 1 1 0 0 1 1 1 0 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 0 0 0 ).	^ layout! !!AtomicMap09 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:40'!levelName	^ 'Acetone' translated! !!AtomicMap09 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:30'!record	^ 50! !!AtomicMap10 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:41'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 3 put: #(1 1 1 0 0 1 1 1 0 0 1 1 1 ).	layout atRow: 4 put: #(1 0 0 0 0 0 1 0 0 0 0 0 1 ).	layout atRow: 5 put: #(1 0 1 1 1 0 0 0 1 1 1 0 1 ).	layout atRow: 6 put: #(1 0 1 #(#O 2 1 #s #s) 0 0 1 0 0 0 1 0 1 ).	layout atRow: 7 put: #(1 #(#H 1 2 #e #C) #(#O 3 2 #w #e) #(#C 2 2 #n #n #e #w ) #(#H 4 2 #w) 1 1 1 0 0 0 0 1 ).	layout atRow: 8 put: #(1 0 1 0 0 0 1 0 0 0 1 0 1 ).	layout atRow: 9 put: #(1 0 1 1 1 0 0 0 1 1 1 0 1 ).	layout atRow: 10 put: #(1 0 0 0 0 0 1 0 0 0 0 0 1 ).	layout atRow: 11 put: #(1 1 1 0 0 1 1 1 0 0 1 1 1 ).	layout atRow: 12 put: #(1 0 0 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap10 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:40'!levelName	^ 'Formic Acid' translated! !!AtomicMap10 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:31'!record	^ 25! !!AtomicMap11 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:41'!createLayout	layout _ Matrix  rows: 11 columns:11.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 0 1 0 0 0 1 0 1 ).	layout atRow: 3 put: #(1 0 #(#O 4 2 #e #w) 0 0 0 0 0 0 0 1 ).	layout atRow: 4 put: #(1 0 1 0 0 #(#H 5 2 #w O) 1 0 #(#H 1 2 #e) 0 1 ).	layout atRow: 5 put: #(1 #(#H 2 3 #n) 0 #(#C 2 2 #n #s #e #w) 0 0 0 0 0 0 1 ).	layout atRow: 6 put: #(1 0 0 0 1 0 0 0 1 0 1 ).	layout atRow: 7 put: #(1 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 8 put: #(1 0 1 0 #(#C 3 2 #n #n #e #w) 0 1 0 0 0 1 ).	layout atRow: 9 put: #(1 #(#O 3 1 #s #s) 0 0 0 0 0 #(#H 2 1 #s) 0 0 1 ).	layout atRow: 10 put: #(1 0 0 0 1 0 0 0 1 0 1 ).	layout atRow: 11 put: #(1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap11 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:41'!levelName	^ 'Acetic Acid' translated! !!AtomicMap11 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:38'!record	^ 49! !!AtomicMap12 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:41'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 3 put: #(1 0 0 0 1 0 0 #(#C 4 3 #ne #se #w #w) 1 0 0 0 1 ).	layout atRow: 4 put: #(1 #(#C 3 3 #e #e #nw #sw) 0 1 0 #(#H 6 1 #sw) 0 0 0 1 0 0 1 ).	layout atRow: 5 put: #(1 0 1 0 1 1 0 1 1 0 1 0 1 ).	layout atRow: 6 put: #(1 0 0 #(#H 1 5 #ne) 0 0 0 0 0 0 0 0 1 ).	layout atRow: 7 put: #(1 1 1 #(#H 3 5 #nw) 1 1 0 1 1 0 1 1 1 ).	layout atRow: 8 put: #(1 0 0 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 9 put: #(1 0 1 0 1 1 #(#H 1 3 #se) 1 1 0 1 0 1 ).	layout atRow: 10 put: #(1 0 0 1 #(#C 2 4 #ne #se #nw #sw) #(#H 2 2 #se) 0 0 0 1 #(#H 4 1 #se) 0 1 ).	layout atRow: 11 put: #(1 0 0 0 1 0 0 #(#H 5 4 #nw) 1 0 0 0 1 ).	layout atRow: 12 put: #(1 #(#C 5 2 #ne #se #nw #sw) 0 0 #(#H 6 3 #nw) 0 0 0 0 0 0 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap12 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:42'!levelName	^ 'Trans-Buthylene (Trans-Buthene)' translated! !!AtomicMap12 methodsFor: 'access properties' stamp: 'grp 8/1/2002 21:13'!record	^ 120! !!AtomicMap13 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:44'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 1 0 0 1 1 0 0 0 1 0 1 ).	layout atRow: 3 put: #(1 1 0 0 1 0 0 0 0 0 1 0 1 ).	layout atRow: 4 put: #(1 1 0 0 0 0 1 0 0 1 0 0 1 ).	layout atRow: 5 put: #(1 0 #(#H 3 4 #nw) 0 0 #(#H 1 2 #se) 1 0 #(#H 1 4 #ne) 0 0 #(#H 5 1 #sw) 1 ).	layout atRow: 6 put: #(1 1 1 0 0 0 0 1 0 1 0 0 1 ).	layout atRow: 7 put: #(1 0 0 1 0 0 0 0 0 0 1 1 1 ).	layout atRow: 8 put: #(1 0 #(#C 3 2 #e #e #nw #sw) 0 0 #(#C 2 3 #ne #se #nw #sw) 0 1 #(#C 4 2 #ne #se #w #w) 0 0 #(#C 5 3 #ne #se #nw #sw) 1 ).	layout atRow: 9 put: #(1 0 1 1 0 1 1 0 0 0 0 0 1 ).	layout atRow: 10 put: #(1 1 0 0 0 0 0 0 1 0 1 0 1 ).	layout atRow: 11 put: #(1 0 #(#H 6 2 #sw) 1 1 #(#H 6 4 #nw) 0 1 #(#H 4 4 #ne) 0 1 #(#H 2 1 #se) 1 ).	layout atRow: 12 put: #(1 0 1 0 0 0 0 1 0 1 0 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap13 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:42'!levelName	^ 'Cis-Buthylene (Cis-Buthene)' translated! !!AtomicMap13 methodsFor: 'access properties' stamp: 'grp 7/30/2002 14:05'!record^166! !!AtomicMap14 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:44'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 0 #(#C 2 2 #n #s #e #w O) 0 1 #(#O 3 2 #e #w) 0 0 0 #(#H 1 2 #e) 1 ).	layout atRow: 3 put: #(1 0 1 1 1 0 1 0 1 1 1 0 1 ).	layout atRow: 4 put: #(1 0 1 0 0 #(#H 2 3 #n) 1 0 0 0 1 0 1 ).	layout atRow: 5 put: #(1 0 1 0 0 0 1 0 0 0 1 0 1 ).	layout atRow: 6 put: #(1 0 0 0 0 0 1 0 0 0 0 0 1 ).	layout atRow: 7 put: #(1 1 1 1 #(#H 2 1 #s) 0 0 0 0 0 1 1 1 ).	layout atRow: 8 put: #(1 0 0 0 0 0 1 0 0 0 0 0 1 ).	layout atRow: 9 put: #(1 0 1 0 0 0 1 0 0 0 1 0 1 ).	layout atRow: 10 put: #(1 0 1 0 0 #(#H 5 2 #w) 1 0 0 #(#H 4 3 #n) 1 0 1 ).	layout atRow: 11 put: #(1 0 1 1 1 0 1 0 1 1 1 #(#H 4 1 #s) 1 ).	layout atRow: 12 put: #(1 0 0 0 0 #(#C 4 2 #n #s #e #w O) 1 0 0 0 0 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap14 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:42'!levelName	^ 'Di-Methyl-Ether' translated! !!AtomicMap14 methodsFor: 'access properties' stamp: 'grp 7/30/2002 17:02'!record	^ 35! !!AtomicMap15 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:44'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 #(#H 2 3 #n) #(#H 2 1 #s) 0 0 0 0 0 #(#C 2 2 #n #s #e #w) 0 1 ).	layout atRow: 3 put: #(1 0 1 0 0 1 1 1 1 0 1 1 1 ).	layout atRow: 4 put: #(1 1 1 #(#H 3 1 #s) 0 0 0 1 0 0 0 0 1 ).	layout atRow: 5 put: #(1 0 #(#H 6 2 #w) 0 0 1 0 0 0 0 0 #(#H 3 3 #n) 1 ).	layout atRow: 6 put: #(1 0 1 1 0 1 0 1 1 0 #(#H 4 3 #n) 0 1 ).	layout atRow: 7 put: #(1 0 1 0 0 1 0 0 1 0 1 1 1 ).	layout atRow: 8 put: #(1 1 1 0 #(#C 3 2 #n #s #e #w) 1 0 #(#O 5 3 #n #s) 0 #(#C 4 2 #n #s #e #w) 1 0 1 ).	layout atRow: 9 put: #(1 #(#H 1 2 #e) 0 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 10 put: #(1 #(#H 5 4 #n) 0 0 0 1 0 0 #(#H 4 1 #s) 0 0 0 1 ).	layout atRow: 11 put: #(1 0 0 1 1 1 #(#H 5 1 #s) 1 1 0 1 0 1 ).	layout atRow: 12 put: #(1 0 0 0 0 1 0 #(#C 5 2 #n #s #e #w) 0 0 1 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap15 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:42'!levelName	^ 'Buthanol (Buthylic alcohol)' translated! !!AtomicMap15 methodsFor: 'access properties' stamp: 'grp 7/30/2002 17:10'!record	^ 115! !!AtomicMap16 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:44'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 0 0 0 1 1 1 1 1 ).	layout atRow: 2 put: #(1 #(#H 5 3 #w) 0 #(#C 3 2 #n #s #ne #nw) 1 0 0 0 1 #(#H 2 4 #n) 0 #(#H 2 1 #se) 1 ).	layout atRow: 3 put: #(1 #(#H 4 1 #sw) 1 0 1 1 1 1 1 0 1 0 1 ).	layout atRow: 4 put: #(1 #(#H 3 5 #n) 0 0 0 0 1 0 0 0 0 0 1 ).	layout atRow: 5 put: #(1 1 1 0 1 0 0 #(#H 2 2 #s) 1 0 1 1 1 ).	layout atRow: 6 put: #(0 0 1 0 0 0 0 0 #(#H 4 4 #n) #(#C 2 3 #n #s #e #w) 1 0 0 ).	layout atRow: 7 put: #(0 0 1 1 0 0 0 0 0 1 1 0 0 ).	layout atRow: 8 put: #(0 0 1 #(#C 3 3 #n #s #e #w) 0 0 0 0 0 #(#H 4 2 #s) 1 0 0 ).	layout atRow: 9 put: #(1 1 1 0 1 0 0 0 1 0 1 1 1 ).	layout atRow: 10 put: #(1 0 0 0 0 0 1 0 #(#H 3 1 #s) 0 0 #(#H 1 3 #e) 1 ).	layout atRow: 11 put: #(1 0 1 #(#O 3 4 #n #s) 1 1 1 1 1 0 1 0 1 ).	layout atRow: 12 put: #(1 #(#C 4 3 #n #s #e #w) 0 0 1 0 0 0 1 0 0 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 0 0 0 1 1 1 1 1 ).	^ layout! !!AtomicMap16 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:42'!levelName	^ 'Tert-Buthanol (Tert-buthylic alcohol)' translated! !!AtomicMap16 methodsFor: 'access properties' stamp: 'grp 7/30/2002 17:17'!record	^ 135! !!AtomicMap17 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:44'!createLayout	layout _ Matrix  rows: 13 columns:11.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 1 0 #(#H 2 5 #n) 1 #(#C 2 2 #n #s #e #w) 0 1 0 1 ).	layout atRow: 3 put: #(1 0 #(#O 3 2 #e #w) 1 0 1 0 1 0 0 1 ).	layout atRow: 4 put: #(1 1 0 0 #(#C 2 3 #n #s #e #w) 0 0 0 0 1 1 ).	layout atRow: 5 put: #(1 0 1 0 0 0 0 0 1 0 1 ).	layout atRow: 6 put: #(1 0 #(#H 4 2 #w #O) 0 0 0 0 #(#H 1 2 #e) 0 0 1 ).	layout atRow: 7 put: #(1 1 1 1 #(#O 3 3 #e #w) 0 0 1 1 1 1 ).	layout atRow: 8 put: #(1 0 0 0 0 #(#H 1 3#e) #(#O 3 4 #e #w) 0 #(#H 1 4#e) 0 1 ).	layout atRow: 9 put: #(1 0 1 0 0 0 0 #(#C 2 4 #n #s #e #w) 1 0 1 ).	layout atRow: 10 put: #(1 1 0 0 0 0 0 #(#H 4 3 #w #O) 0 1 1 ).	layout atRow: 11 put: #(1 0 0 1 0 1 0 1 0 #(#H 2 1 #s) 1 ).	layout atRow: 12 put: #(1 0 1 0 #(#H 4 4 #w #O) 1 0 0 1 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap17 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:42'!levelName	^ 'Glycerin (1, 2, 3 - Propane - triol)' translated! !!AtomicMap17 methodsFor: 'access properties' stamp: 'grp 7/30/2002 19:23'!record	^ 90! !!AtomicMap18 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:44'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 3 put: #(1 0 0 0 0 1 #(#F 1 3 #n) 1 #(#F 1 1 #s) 0 0 0 1 ).	layout atRow: 4 put: #(1 #(#O 1 2 #n #s #e) 0 0 0 1 0 1 0 0 0 0 1 ).	layout atRow: 5 put: #(1 0 1 1 1 1 #(#O 4 2 #n #s #w) 1 1 1 1 0 1 ).	layout atRow: 6 put: #(1 #(#F 2 3 #n) 0 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 7 put: #(1 1 1 1 0 0 1 0 #(#F 3 3 #n) 1 1 1 1 ).	layout atRow: 8 put: #(1 #(#F 2 1 #s) 0 0 0 0 0 0 0 0 0 #(#F 3 1 #s) 1 ).	layout atRow: 9 put: #(1 0 1 1 1 1 0 1 1 1 1 0 1 ).	layout atRow: 10 put: #(1 0 0 #(#F 4 3 #n) 0 1 0 1 0 0 0 0 1 ).	layout atRow: 11 put: #(1 #(#F 4 1 #s) 0 0 0 1 0 1 0 0 0 #(#O 3 2 #n #s #e #w) 1 ).	layout atRow: 12 put: #(1 0 0 #(#O 2 2 #n #s #e #w) 0 0 0 0 0 0 0 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap18 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:42'!levelName	^ 'Poly-Tetra-Fluoro-Ethane' translated! !!AtomicMap18 methodsFor: 'access properties' stamp: 'grp 8/1/2002 16:28'!record	^ 59! !!AtomicMap19 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:44'!createLayout	layout _ Matrix  rows: 13 columns:15.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 1 1 #(#O 2 2 #n #s) 0 0 0 1 0 0 0 0 1 1 1 ).	layout atRow: 3 put: #(1 1 0 0 0 0 0 1 0 0 #(#O 1 1 #e #e) 0 #(#C 3 1 #s #e #e #w) 1 1 ).	layout atRow: 4 put: #(1 0 0 0 1 0 0 0 0 0 1 0 0 0 1 ).	layout atRow: 5 put: #(1 0 0 0 1 1 0 #(#C 2 1 #s #e #w #w) 0 1 1 0 0 0 1 ).	layout atRow: 6 put: #(1 0 0 0 0 1 1 0 1 1 0 0 0 0 1 ).	layout atRow: 7 put: #(1 1 1 #(#O 4 1 #w #w) 0 0 0 #(#O 3 2 #n #s) 0 0 0 0 1 1 1 ).	layout atRow: 8 put: #(1 0 0 0 0 1 1 0 1 1 0 0 0 0 1 ).	layout atRow: 9 put: #(1 0 0 0 1 1 0 #(#H 2 3 #n) 0 1 1 0 0 0 1 ).	layout atRow: 10 put: #(1 0 #(#H 3 3 #n) 0 1 0 0 0 0 0 1 0 0 0 1 ).	layout atRow: 11 put: #(1 1 0 0 0 0 0 1 0 0 0 0 0 1 1 ).	layout atRow: 12 put: #(1 1 1 0 0 0 0 1 0 0 0 0 1 1 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap19 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:42'!levelName	^ 'Malic Acid' translated! !!AtomicMap19 methodsFor: 'access properties' stamp: 'grp 8/1/2002 17:42'!record	^ 48! !!AtomicMap20 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:45'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 #(#O 2 2 #w #w) 0 0 0 0 1 0 0 0 0 #(#C 1 2 #n #s #e #e) 1 ).	layout atRow: 3 put: #(1 0 0 1 1 0 1 0 1 1 0 0 1 ).	layout atRow: 4 put: #(1 1 0 1 0 0 0 0 0 1 0 1 1 ).	layout atRow: 5 put: #(1 0 0 1 0 0 0 0 0 1 0 0 1 ).	layout atRow: 6 put: #(1 0 1 1 0 0 1 0 0 1 1 0 1 ).	layout atRow: 7 put: #(1 0 0 0 0 1 1 1 0 0 0 0 1 ).	layout atRow: 8 put: #(1 0 1 1 0 0 1 0 0 1 1 0 1 ).	layout atRow: 9 put: #(1 0 0 1 0 0 0 0 0 1 0 0 1 ).	layout atRow: 10 put: #(1 1 0 1 0 0 0 0 0 1 0 1 1 ).	layout atRow: 11 put: #(1 0 0 1 1 0 1 0 1 1 0 0 1 ).	layout atRow: 12 put: #(1 #(#H 1 3 #n) 0 0 0 0 1 0 0 0 0 #(#H 1 1  #s) 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap20 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Formaldehyde' translated! !!AtomicMap20 methodsFor: 'access properties' stamp: 'grp 8/1/2002 17:43'!record	^ 25! !!AtomicMap21 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:45'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 1 1 0 1 0 1 1 0 0 1 ).	layout atRow: 3 put: #(1 0 0 0 1 0 #(#H 2 3 #n) 0 1 0 0 0 1 ).	layout atRow: 4 put: #(1 0 0 0 0 #(#C 2 2 #n #s #e #w) 0 0 0 #(#C 5 2 #n #s #e #w) 0 #(#C 6 2 #n #s #e #w) 1 ).	layout atRow: 5 put: #(1 1 0 0 1 0 0 0 1 0 0 1 1 ).	layout atRow: 6 put: #(1 #(#O 4 2 #e #w) 0 1 1 #(#C 3 2 #n #n #e #w #C #O) 0 0 1 1 0 0 1 ).	layout atRow: 7 put: #(1 #(#H 7 2 #w) 0 0 0 0 1 0 0 0 0 0 1 ).	layout atRow: 8 put: #(1 0 0 1 1 0 0 0 1 1 0 0 1 ).	layout atRow: 9 put: #(1 1 0 0 1 #(#H 2 1 #s) #(#H 5 1 #s) 0 1 #(#H 5 3 #n) 0 1 1 ).	layout atRow: 10 put: #(1 0 0 0 #(#H 6 1 #s) 0 0 0 0 0 0 0 1 ).	layout atRow: 11 put: #(1 0 0 #(#O 3 1 #s #s) 1 0 0 #(#H 1 2 #e) 1 0 0 0 1 ).	layout atRow: 12 put: #(1 0 #(#H 6 3 #n) 1 1 0 1 0 1 1 0 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap21 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Ethylic Acetate' translated! !!AtomicMap21 methodsFor: 'access properties' stamp: 'grp 8/1/2002 21:23'!record	^ 115! !!AtomicMap22 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:45'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 1 0 0 #(#H 3 1 #sw) 1 0 0 1 0 0 1 1 ).	layout atRow: 3 put: #(1 0 0 0 1 0 0 1 0 0 0 0 1 ).	layout atRow: 4 put: #(1 0 0 0 0 0 0 0 0 1 0 0 1 ).	layout atRow: 5 put: #(1 #(#H 1 2 #e) 1 0 1 0 0 0 1 0 0 1 1 ).	layout atRow: 6 put: #(1 1 0 0 0 1 0 0 0 0 1 0 1 ).	layout atRow: 7 put: #(1 0 0 0 0 #(#N 2 2 #ne #se #w) 0 0 0 0 0 0 1 ).	layout atRow: 8 put: #(1 0 1 0 0 0 0 1 0 0 #(#H #3 3 nw) 1 1 ).	layout atRow: 9 put: #(1 1 0 0 1 0 0 0 1 0 1 0 1 ).	layout atRow: 10 put: #(1 0 0 1 0 0 0 0 0 0 0 0 1 ).	layout atRow: 11 put: #(1 0 0 0 0 1 0 0 1 0 0 0 1 ).	layout atRow: 12 put: #(1 1 0 0 1 0 0 1 0 0 0 1 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap22 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Ammonia' translated! !!AtomicMap22 methodsFor: 'access properties' stamp: 'grp 8/1/2002 18:04'!record	^ 27! !!AtomicMap23 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:45'!createLayout	layout _ Matrix  rows: 13 columns:15.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 #(#H 4 1 #s) 0 #(#H 3 1 #se) 0 0 1 0 0 #(#C 2 3 #n #s #e #w) 0 0 #(#H 2 4 #n) 1 ).	layout atRow: 3 put: #(1 #(#H 2 2 #s) 0 1 0 0 0 1 0 0 0 1 0 0 1 ).	layout atRow: 4 put: #(1 0 1 1 1 0 #(#H 1 3 #e) #(#H 3 2 #s) 0 0 1 1 1 0 1 ).	layout atRow: 5 put: #(1 0 #(#C 3 3 #n #s #e #w) 1 0 0 0 0 #(#H 3 4 #n) 0 0 1 0 0 1 ).	layout atRow: 6 put: #(1 0 0 0 0 0 0 0 #(#C 4 3 #n #s #e #w) 0 0 0 0 0 1 ).	layout atRow: 7 put: #(1 1 1 0 #(#H 5 2 #s) 0 0 #(#H 4 4 #n) 0 0 0 0 1 1 1 ).	layout atRow: 8 put: #(1 0 0 0 0 #(#C 5 3 #n #s #e #w) 0 0 0 0 0 0 0 #(#H 5 1 #sw) 1 ).	layout atRow: 9 put: #(1 #(#H 7 3 #w) 0 1 0 0 0 0 0 0 0 1 0 #(#C 4 2 #n #ne #s #nw) 1 ).	layout atRow: 10 put: #(1 0 1 1 1 0 0 0 0 #(#H 6 2 #s) 1 1 1 0 1 ).	layout atRow: 11 put: #(1 0 0 1 #(#H 5 4 #n) 0 0 1 #(#H 6 4 #n) 0 0 1 0 0 1 ).	layout atRow: 12 put: #(1 0 0 0 0 0 #(#C 6 3 #n #s #e #w) 1 0 0 0 0 0 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap23 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ '3-Methyl-Pentane' translated! !!AtomicMap23 methodsFor: 'access properties' stamp: 'grp 8/1/2002 18:10'!record	^ 90! !!AtomicMap24 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:46'!createLayout	layout _ Matrix  rows: 13 columns:11.	layout atRow: 1 put: #( 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #( 1 0 #(#H 2 1 #s) 1 0 #(#C 4 2 #e #s #s #w #H #O #C) 0 0 0 0 1 ).	layout atRow: 3 put: #( 1 0 1 1 #(#H 2 3 #n) 0 0 1 1 0 1 ).	layout atRow: 4 put: #( 1 0 0 0 0 0 #(#C 2 2 #n #s #e #w) 0 1 1 1 ).	layout atRow: 5 put: #( 1 0 0 1 1 1 0 0 0 0 1 ).	layout atRow: 6 put: #( 1 0 0 1 0 0 0 0 1 1 1 ).	layout atRow: 7 put: #(1 0 0 0 0 1 0 0 0 0 1 ).	layout atRow: 8 put: #(1 1 1 1 0 0 1 0 0 0 1 ).	layout atRow: 9 put: #(1 #(#H 5 2 #w) #(#H 3 1 #s) 0 0 0 0 0 1 0 1 ).	layout atRow: 10 put: #(1 0 0 1 0 #(#C 3 2 #n #s #e #w) #(#H 1 2 #e) 0 1 0 1 ).	layout atRow: 11 put: #(1 #(#O 4 3 #n #n) 1 1 0 0 1 0 1 #(#H 3 3 #n) 1 ).	layout atRow: 12 put: #(1 0 0 0 0 0 1 0 0 0 1 ).	layout atRow: 13 put: #(1  1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap24 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Propyl-Aldehide (Propanal)' translated! !!AtomicMap24 methodsFor: 'access properties' stamp: 'grp 8/1/2002 18:49'!record	^ 55! !!AtomicMap25 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:46'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 0 0 0 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 0 1 1 1 1 1 0 0 0 1 ).	layout atRow: 3 put: #(1 0 1 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 4 put: #(1 0 1 0 #(#C 2 2 #e #e #e #w) 1 0 0 0 1 0 0 1 ).	layout atRow: 5 put: #(1 1 1 1 0 1 1 1 #(#H 4 3 #n) 1 0 0 1 ).	layout atRow: 6 put: #(1 0 0 0 0 0 0 1 0 1 1 0 1 ).	layout atRow: 7 put: #(1 #(#H 4 1 #s) 1 0 0 0 0 0 0 0 1 0 1 ).	layout atRow: 8 put: #(1 1 1 1 0 1 1 1 1 0 0 0 1 ).	layout atRow: 9 put: #(1 0 1 0 0 0 0 1 0 0 0 0 1 ).	layout atRow: 10 put: #(1 0 0 0 1 0 0 0 0 0 1 0 1 ).	layout atRow: 11 put: #(1 0 0 1 1 1 0 #(#H 1 2 #e) 0 1 1 #(#C 4 2 #n #s #e #w) 1 ).	layout atRow: 12 put: #(1 0 #(#H 5 2 #w) 1 0 0 0 0 1 1 #(#C 3 2 #w #w #w #e) 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap25 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Propyne (Methyl-acetylene)' translated! !!AtomicMap25 methodsFor: 'access properties' stamp: 'grp 8/1/2002 18:55'!record	^ 65! !!AtomicMap26 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:46'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(0 0 1 1 1 1 1 1 1 1 0 0 0 ).	layout atRow: 2 put: #(0 0 1 0 0 1 0 0 0 1 0 0 0 ).	layout atRow: 3 put: #(1 1 1 0 0 #(#- 3 2 #e #w) 0 0 0 1 1 1 1 ).	layout atRow: 4 put: #(1 0 0 #(#H 5 1 #sw) 1 1 1 0 0 #(#C 5 4 #e #e #s #nw) 0 0 1 ).	layout atRow: 5 put: #(1 0 0 #(#H 5 5 #n) 0 0 0 #(#C 2 2  #e #s #s #nw) 1 0 0 0 1 ).	layout atRow: 6 put: #(1 1 1 1 0 1 0 0 1 #(#O 3 4 #ne #nw) 0 0 1 ).	layout atRow: 7 put: #(1 #(#O 6 4 #w #w) 0 0 0 1 0 1 1 1 0 0 1 ).	layout atRow: 8 put: #(1 0 0 0 0 0 0 0 0 0 0 #(#C 2 3 #n #n #se #sw #O) 1 ).	layout atRow: 9 put: #(1 1 0 1 1 1 1 0 0 0 0 1 1 ).	layout atRow: 10 put: #(1 #(#C 4 3 #n #n #se #sw #O) 0 1 0 #(#C 4 2 #ne #s #s #w) 0 0 0 1 0 0 1 ).	layout atRow: 11 put: #(1 0 0 0 0 0 1 0 0 1 0 0 1 ).	layout atRow: 12 put: #(1 1 1 1 0 #(#H 1 1 #se) 1 0 #(#H 1 4 #ne) 1 0 1 1 ).	layout atRow: 13 put: #(0 0 0 1 1 1 1 1 1 1 1 1 0 ).	^ layout! !!AtomicMap26 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Floating link' translated! !!AtomicMap26 methodsFor: 'access properties' stamp: 'grp 8/1/2002 19:21'!record	^ 105! !!AtomicMap27 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:47'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(0 1 1 1 1 1 1 1 0 0 0 0 0 ).	layout atRow: 2 put: #(0 1 0 0 0 0 0 1 0 0 0 0 0 ).	layout atRow: 3 put: #(0 1 0 0 #(#C 3 2 #n #se #w #w) 0 0 1 1 1 1 1 1 ).	layout atRow: 4 put: #(0 1 0 1 1 0 0 1 #(#H 5 2 #sw) 0 0 0 1 ).	layout atRow: 5 put: #(0 1 0 #(#O 1 3 #ne #se #C) #(#H 2 1 #s) 0 #(#C 3 4 #ne #s #w #w) 1 1 1 1 0 1 ).	layout atRow: 6 put: #(0 1 1 1 0 0 0 1 0 0 0 0 1 ).	layout atRow: 7 put: #(1 1 0 1 1 0 0 1 0 #(#C 2 4 #e #e #s #nw) 0 0 1 ).	layout atRow: 8 put: #(1 0 0 0 0 0 1 #(#H 3 1 #s) 0 1 0 0 1 ).	layout atRow: 9 put: #(1 0 0 0 0 0 0 0 0 1 #(#H 2 5 #n) 0 1 ).	layout atRow: 10 put: #(1 0 #(#C 2 2 #n #e #e #sw) #(#H 5 4 #nw) 1 #(#H 3 5 #n) 0 1 0 1 1 0 1 ).	layout atRow: 11 put: #(1 1 1 1 1 0 0 1 0 0 0 0 1 ).	layout atRow: 12 put: #(0 0 0 1 0 0 0 1 #(#C 4 3 #ne #se #sw #nw) 1 1 1 1 ).	layout atRow: 13 put: #(0 0 0 1 1 1 1 1 1 1 0 0 0 ).	^ layout! !!AtomicMap27 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Pyrane' translated! !!AtomicMap27 methodsFor: 'access properties' stamp: 'grp 8/1/2002 19:26'!record	^ 96! !!AtomicMap28 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:47'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(0 1 1 1 1 1 1 1 1 0 0 0 0 ).	layout atRow: 2 put: #(0 1 #(#H 2 5 #n) 0 0 0 0 0 1 1 1 1 1 ).	layout atRow: 3 put: #(0 1 1 0 0 #(#H 1 3 #e) 1 0 0 #(#H 4 5 #nw) 0 0 1 ).	layout atRow: 4 put: #(0 1 0 0 #(#C 3 2 #ne #se #nw #sw) 1 #(#H 1 2 #se) 1 1 1 #(#C 3 4 #ne #se #s #w) 0 1 ).	layout atRow: 5 put: #(0 1 0 0 0 0 0 0 0 1 1 1 1 ).	layout atRow: 6 put: #(0 1 0 0 0 0 0 0 0 0 1 0 0 ).	layout atRow: 7 put: #(0 1 1 #(#H 1 4 #e) 1 0 #(#H 4 1 #sw) 1 0 0 1 0 0 ).	layout atRow: 8 put: #(0 0 1 1 1 0 1 1 0 0 1 0 0 ).	layout atRow: 9 put: #(1 1 1 #(#C 2 4 #n #s #e #w) #(#H 3 5 #n) #(#C 2 3 #ne #s #w #nw) 0 0 0 0 1 1 1 ).	layout atRow: 10 put: #(1 #(#H 2 1 #se) 0 0 1 1 0 0 1 #(#H 5 4 #nw) 0 0 1 ).	layout atRow: 11 put: #(1 0 0 0 0 #(#C 4 3 #ne #se #nw #sw) 0 0 1 1 1 1 1 ).	layout atRow: 12 put: #(1 0 1 0 0 0 0 #(#H 5 2 #sw) 1 0 0 0 0 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 0 0 0 0 ).	^ layout! !!AtomicMap28 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Cyclo-Pentane' translated! !!AtomicMap28 methodsFor: 'access properties' stamp: 'grp 8/1/2002 19:37'!record	^ 132! !!AtomicMap29 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:47'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(0 0 1 1 1 1 1 1 1 1 1 0 0 ).	layout atRow: 2 put: #(0 0 1 0 0 0 0 0 0 0 1 0 0 ).	layout atRow: 3 put: #(0 0 1 0 #(#O 3 1 #e #se) 1 #(#N 6 6 #e #s #nw) 0 0 1 1 1 1 ).	layout atRow: 4 put: #(0 0 1 #(#C 3 4 #n #s #e #w) 1 #(#N 4 2 #ne #s #nw) 1 0 #(#O 5 1 #sw #w) 0 0 0 1 ).	layout atRow: 5 put: #(0 0 1 #(#O 1 6 #e #se) 1 0 0 0 #(#H 6 4 #w) 0 0 #(#O 2 7 #n #nw) 1 ).	layout atRow: 6 put: #(1 1 1 0 1 1 1 0 0 0 1 1 1 ).	layout atRow: 7 put: #(1 0 0 0 0 0 #(#N 2 6 #ne #s #w) 0 0 #(#O 4 3 #n #s) 0 #(#O 7 6 #sw #w) 1 ).	layout atRow: 8 put: #(1 0 #(#H 3 3 #s) 1 #(#H 2 4 #e) 0 #(#C 4 4 #n #s #e #w) 0 1 1 0 0 1 ).	layout atRow: 9 put: #(1 0 1 1 1 #(#- 4 1 #e #w) 1 0 0 1 1 1 1 ).	layout atRow: 10 put: #(1 #(#O 6 7 #n #ne) 1 1 0 0 1 #(#H 4 5 #n) 0 0 #(#O 5 5 #n #se) #(#O 3 5 #n #sw) 1 ).	layout atRow: 11 put: #(1 #(#C 5 4 #n #s #e #w) 0 0 0 0 1 1 0 0 1 1 1 ).	layout atRow: 12 put: #(1 1 1 1 1 1 1 #(#H 5 3 #s) 0 0 1 0 0 ).	layout atRow: 13 put: #(0 0 0 0 0 0 1 1 1 1 1 0 0 ).	^ layout! !!AtomicMap29 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Nitro-Glycerin' translated! !!AtomicMap29 methodsFor: 'access properties' stamp: 'grp 8/1/2002 19:44'!record	^ 140! !!AtomicMap30 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:47'!createLayout	layout _ Matrix  rows: 11 columns:11.	layout atRow: 1 put: #(0 0 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(0 0 1 0 0 0 0 #(#H 1 4 #ne) 0 0 1 ).	layout atRow: 3 put: #(0 0 1 0 0 1 0 1 0 0 1 ).	layout atRow: 4 put: #(0 0 1 #(#H 2 1 #s) 0 #(#C 2 3 #n #s #se #sw) 0 1 1 1 1 ).	layout atRow: 5 put: #(1 1 1 1 1 #(#C 2 2 #n #s #ne #nw) 0 1 #(#H 1 1 #se) 1 0 ).	layout atRow: 6 put: #(1 0 0 0 1 0 0 0 0 1 0 ).	layout atRow: 7 put: #(1 0 0 0 0 0 0 0 0 1 0 ).	layout atRow: 8 put: #(1 0 #(#H 2 4 #n) 0 1 1 1 #(#H 3 4 #nw) 0 1 1 ).	layout atRow: 9 put: #(1 1 1 #(#H 3 1 #sw) 0 0 0 1 0 0 1 ).	layout atRow: 10 put: #(1 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 11 put: #(1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap30 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Ethane' translated! !!AtomicMap30 methodsFor: 'access properties' stamp: 'grp 8/1/2002 19:59'!record	^ 66! !!AtomicMapStyle class methodsFor: 'instance creation' stamp: 'asm 4/20/2004 20:27'!newForPreview	| this |	this _ super new.	this isPreview: true.^this.! !!AtomicMapStyle methodsFor: 'initialization' stamp: 'GP 4/14/2003 23:09'!initialize	smallScreen _ DisplayScreen actualScreenSize < (500 @ 500).	isPreview _ false! !!AtomicMapStyle methodsFor: 'access properties' stamp: 'grp 8/21/2002 19:51'!isPreview^	isPreview ! !!AtomicMapStyle methodsFor: 'access properties' stamp: 'grp 8/21/2002 19:51'!isPreview: aBooleanisPreview _ aBoolean.! !!AtomicMapStyle methodsFor: 'access properties' stamp: 'GP 4/14/2003 23:09'!isSmallScreen	^ smallScreen! !!ChessBoard class methodsFor: 'class initialization' stamp: 'ar 8/9/2001 23:44'!initialize	"ChessGame initialize"	self initializeHashKeys.! !!ChessBoard class methodsFor: 'class initialization' stamp: 'ar 10/18/2001 23:22'!initializeHashKeys	"ChessGame initialize"	| random |	HashKeys _ Array new: 12.	1 to: HashKeys size do:[:i| HashKeys at: i put: (WordArray new: 64)].	HashLocks _ Array new: 12.	1 to: HashLocks size do:[:i| HashLocks at: i put: (WordArray new: 64)].	random _ Random seed: 23648646.	1 to: 12 do:[:i|		1 to: 64 do:[:j|			(HashKeys at: i) at: j put: (random nextInt: SmallInteger maxVal) - 1.			(HashLocks at: i) at: j put: (random nextInt: SmallInteger maxVal) - 1.		].	].! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/8/2001 23:02'!activePlayer	^activePlayer! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/8/2001 22:41'!blackPlayer	^blackPlayer! !!ChessBoard methodsFor: 'copying' stamp: 'ar 8/9/2001 04:14'!copy	^self shallowCopy postCopy! !!ChessBoard methodsFor: 'copying' stamp: 'aoy 2/17/2003 01:15'!copyBoard: aBoard 	"Copy all volatile state from the given board"	whitePlayer copyPlayer: aBoard whitePlayer.	blackPlayer copyPlayer: aBoard blackPlayer.	activePlayer := aBoard activePlayer isWhitePlayer 				ifTrue: [whitePlayer]				ifFalse: [blackPlayer]. 	hashKey := aBoard hashKey.	hashLock := aBoard hashLock.	userAgent := nil! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/10/2001 06:15'!generator	^generator! !!ChessBoard methodsFor: 'hashing' stamp: 'ar 8/9/2001 23:45'!hashKey	^hashKey! !!ChessBoard methodsFor: 'hashing' stamp: 'ar 8/9/2001 23:45'!hashLock	^hashLock! !!ChessBoard methodsFor: 'initialize' stamp: 'ar 8/24/2001 18:04'!initialize	generator ifNil:[generator _ ChessMoveGenerator new initialize].	searchAgent ifNil:[searchAgent _ ChessPlayerAI new initialize].	self resetGame.! !!ChessBoard methodsFor: 'initialize' stamp: 'ar 8/9/2001 03:50'!initializeNewBoard	self resetGame.	whitePlayer addWhitePieces.	blackPlayer addBlackPieces.! !!ChessBoard methodsFor: 'moving' stamp: 'ar 10/18/2001 20:19'!movePieceFrom: sourceSquare to: destSquare	| move |	searchAgent isThinking ifTrue:[^self].	move _ (activePlayer findPossibleMovesAt: sourceSquare) contents		detect:[:any| any destinationSquare = destSquare].	self nextMove: move.	searchAgent activePlayer: activePlayer.! !!ChessBoard methodsFor: 'moving' stamp: 'aoy 2/17/2003 01:16'!nextMove: aMove 	activePlayer applyMove: aMove.	userAgent 		ifNotNil: [userAgent completedMove: aMove white: activePlayer isWhitePlayer].	activePlayer := activePlayer == whitePlayer 				ifTrue: [blackPlayer]				ifFalse: [whitePlayer].	activePlayer prepareNextMove ! !!ChessBoard methodsFor: 'moving' stamp: 'aoy 2/17/2003 01:16'!nullMove	activePlayer := activePlayer == whitePlayer 				ifTrue: [blackPlayer]				ifFalse: [whitePlayer]. 	activePlayer prepareNextMove! !!ChessBoard methodsFor: 'copying' stamp: 'ar 8/9/2001 17:35'!postCopy	whitePlayer == activePlayer ifTrue:[		whitePlayer _ whitePlayer copy.		blackPlayer _ blackPlayer copy.		activePlayer _ whitePlayer.	] ifFalse:[		whitePlayer _ whitePlayer copy.		blackPlayer _ blackPlayer copy.		activePlayer _ blackPlayer.	].	whitePlayer opponent: blackPlayer.	blackPlayer opponent: whitePlayer.	whitePlayer board: self.	blackPlayer board: self.	self userAgent: nil.! !!ChessBoard methodsFor: 'printing' stamp: 'ar 8/24/2001 18:25'!printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		print: hashKey; space; print: hashLock;		nextPut: $).! !!ChessBoard methodsFor: 'initialize' stamp: 'ar 8/24/2001 18:19'!resetGame	hashKey _ hashLock _ 0.	whitePlayer _ ChessPlayer new initialize.	blackPlayer _ ChessPlayer new initialize.	whitePlayer opponent: blackPlayer.	whitePlayer board: self.	blackPlayer opponent: whitePlayer.	blackPlayer board: self.	activePlayer _ whitePlayer.	searchAgent reset: self.	userAgent ifNotNil:[userAgent gameReset].! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:04'!searchAgent	^searchAgent! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:04'!searchAgent: anAgent	searchAgent _ anAgent.! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/12/2001 22:53'!statusString	^searchAgent statusString! !!ChessBoard methodsFor: 'moving' stamp: 'aoy 2/17/2003 01:17'!undoMove: aMove 	activePlayer := activePlayer == whitePlayer 				ifTrue: [blackPlayer]				ifFalse: [whitePlayer]. 	activePlayer undoMove: aMove.	userAgent 		ifNotNil: [userAgent undoMove: aMove white: activePlayer isWhitePlayer]! !!ChessBoard methodsFor: 'hashing' stamp: 'aoy 2/17/2003 01:17'!updateHash: piece at: square from: player 	| index |	index := player == whitePlayer ifTrue: [piece] ifFalse: [piece + 6].	hashKey := hashKey bitXor: ((HashKeys at: index) at: square). 	hashLock := hashLock bitXor: ((HashLocks at: index) at: square)! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/9/2001 03:49'!userAgent	^userAgent! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/24/2001 18:19'!userAgent: anObject	userAgent _ anObject.! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/8/2001 22:41'!whitePlayer	^whitePlayer! !!ChessHistoryTable class methodsFor: 'instance creation' stamp: 'ar 8/9/2001 17:50'!new	^self new: 4096+64! !!ChessHistoryTable methodsFor: 'accessing' stamp: 'ar 8/24/2001 16:18'!addMove: aMove	| index |	index _ (aMove sourceSquare bitShift: 6) + aMove destinationSquare.	self at: index put: (self at: index + 1)! !!ChessHistoryTable methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:18'!atAllPut: aPositiveInteger	"Fill the receiver, an indexable bytes or words object, with the given positive integer. The range of possible fill values is [0..255] for byte arrays and [0..(2^32 - 1)] for word arrays."	<primitive: 145>	self errorImproperStore.! !!ChessHistoryTable methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:18'!clear	self atAllPut: 0.! !!ChessHistoryTable methodsFor: 'sorting' stamp: 'ar 8/24/2001 16:18'!sorts: move1 before: move2	^(self at: (move1 sourceSquare bitShift: 6) + move1 destinationSquare) >		(self at: (move2 sourceSquare bitShift: 6) + move2 destinationSquare)! !!ChessMove class methodsFor: 'accessing' stamp: 'ar 8/9/2001 01:05'!basicMoveMask	^BasicMoveMask! !!ChessMove class methodsFor: 'accessing' stamp: 'ar 8/24/2001 23:07'!decodeFrom: encodedMove	^self new moveEncoded: encodedMove! !!ChessMove class methodsFor: 'class initialization' stamp: 'ar 8/9/2001 01:50'!initialize	"ChessMove initialize"	MoveNormal _ 1.	MoveDoublePush _ 2.	MoveCaptureEnPassant _ 3.	MoveCastlingKingSide _ 4.	MoveCastlingQueenSide _ 5.	MoveResign _ 6.	MoveStaleMate _ 7.	BasicMoveMask _ 15.	PromotionShift _ 4.	ExtractPromotionShift _  0 - PromotionShift.	EvalTypeAccurate _ 0.	EvalTypeUpperBound _ 1.	EvalTypeLowerBound _ 2.	NullMove _ 0.! !!ChessMove methodsFor: 'comparing' stamp: 'ar 8/7/2001 22:11'!= aMove	movingPiece = aMove movingPiece ifFalse:[^false].	capturedPiece = aMove capturedPiece ifFalse:[^false].	type = aMove type ifFalse:[^false].	sourceSquare = aMove sourceSquare ifFalse:[^false].	destinationSquare = aMove destinationSquare ifFalse:[^false].	^true! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/24/2001 22:48'!bestMove	^nil! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:19'!captureEnPassant: aPiece from: startSquare to: endSquare	movingPiece _ capturedPiece _ aPiece.	sourceSquare _ startSquare.	destinationSquare _ endSquare.	type _ MoveCaptureEnPassant.! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/7/2001 22:06'!capturedPiece	^capturedPiece! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:24'!capturedPiece: aValue	^capturedPiece _ aValue! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!checkMate: aPiece	movingPiece _ aPiece.	sourceSquare _ 0.	destinationSquare _ 0.	type _ MoveResign.	capturedPiece _ 0.! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/7/2001 22:06'!destinationSquare	^destinationSquare! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:24'!destinationSquare: aValue	^destinationSquare _ aValue! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!doublePush: aPiece from: startSquare to: endSquare	movingPiece _ aPiece.	sourceSquare _ startSquare.	destinationSquare _ endSquare.	type _ MoveDoublePush.	capturedPiece _ 0.! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/24/2001 22:48'!encodedMove	"Return an integer encoding enough of a move for printing"	^destinationSquare + 		(sourceSquare bitShift: 8) +		(movingPiece bitShift: 16) +		(capturedPiece bitShift: 24)! !!ChessMove methodsFor: 'comparing' stamp: 'ar 8/7/2001 22:12'!hash	^((movingPiece hash bitXor: capturedPiece hash) bitXor:		(sourceSquare hash bitXor: destinationSquare hash)) bitXor: type hash! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!init	movingPiece _ sourceSquare _ destinationSquare _ 1.	type _ MoveNormal.	capturedPiece _ 0.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!move: aPiece from: startSquare to: endSquare	movingPiece _ aPiece.	sourceSquare _ startSquare.	destinationSquare _ endSquare.	type _ MoveNormal.	capturedPiece _ 0.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!move: aPiece from: startSquare to: endSquare capture: capture	movingPiece _ aPiece.	sourceSquare _ startSquare.	destinationSquare _ endSquare.	capturedPiece _ capture.	type _ MoveNormal.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!moveCastlingKingSide: aPiece from: startSquare to: endSquare	movingPiece _ aPiece.	sourceSquare _ startSquare.	destinationSquare _ endSquare.	type _ MoveCastlingKingSide.	capturedPiece _ 0.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:19'!moveCastlingQueenSide: aPiece from: startSquare to: endSquare	movingPiece _ aPiece.	sourceSquare _ startSquare.	destinationSquare _ endSquare.	type _ MoveCastlingQueenSide.	capturedPiece _ 0.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/24/2001 23:08'!moveEncoded: encodedMove	destinationSquare _ encodedMove bitAnd: 255.	sourceSquare _ (encodedMove bitShift: -8) bitAnd: 255.	movingPiece _ (encodedMove bitShift: -16) bitAnd: 255.	capturedPiece _ (encodedMove bitShift: -24) bitAnd: 255.	type _ MoveNormal.! !!ChessMove methodsFor: 'printing' stamp: 'ar 8/9/2001 18:06'!moveString	^String streamContents:[:aStream|		aStream nextPutAll: (#('' 'N' 'B' 'R' 'Q' 'K') at: movingPiece).		aStream nextPutAll: (String with: ($a asInteger + (sourceSquare - 1 bitAnd: 7)) asCharacter with: ($1 asInteger + (sourceSquare -1 bitShift: -3)) asCharacter).		capturedPiece = 0 ifTrue:[			aStream nextPutAll: '-'.		] ifFalse:[			aStream nextPutAll: 'x'.			aStream nextPutAll: (#('' 'N' 'B' 'R' 'Q' 'K') at: capturedPiece).		].		aStream nextPutAll: (String with: ($a asInteger + (destinationSquare - 1 bitAnd: 7)) asCharacter with: ($1 asInteger + (destinationSquare -1 bitShift: -3)) asCharacter).	].! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/10/2001 02:32'!moveType	^type! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/10/2001 02:32'!moveType: aType	^type _ aType! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/7/2001 22:06'!movingPiece	^movingPiece! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:24'!movingPiece: aValue	^movingPiece _ aValue! !!ChessMove methodsFor: 'printing' stamp: 'ar 8/9/2001 15:38'!printOn: aStream	super printOn: aStream.	aStream nextPutAll:'('.	aStream nextPutAll: (#('' 'N' 'B' 'R' 'Q' 'K') at: movingPiece).	aStream nextPutAll: (String with: ($a asInteger + (sourceSquare - 1 bitAnd: 7)) asCharacter with: ($1 asInteger + (sourceSquare -1 bitShift: -3)) asCharacter).	capturedPiece = 0 ifTrue:[		aStream nextPutAll: '-'.	] ifFalse:[		aStream nextPutAll: 'x'.		aStream nextPutAll: (#('' 'N' 'B' 'R' 'Q' 'K') at: capturedPiece).	].	aStream nextPutAll: (String with: ($a asInteger + (destinationSquare - 1 bitAnd: 7)) asCharacter with: ($1 asInteger + (destinationSquare -1 bitShift: -3)) asCharacter).	aStream nextPutAll:')'.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!promote: move to: promotion	movingPiece _ move movingPiece.	capturedPiece _ move capturedPiece.	sourceSquare _ move sourceSquare.	destinationSquare _ move destinationSquare. 	type _ move moveType.	type _ type bitOr: (promotion bitShift: PromotionShift).! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:25'!promotion	^type bitShift: ExtractPromotionShift! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/7/2001 22:07'!sourceSquare	^sourceSquare! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:24'!sourceSquare: aValue	^sourceSquare _ aValue! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!staleMate: aPiece	movingPiece _ aPiece.	sourceSquare _ 0.	destinationSquare _ 0.	type _ MoveStaleMate.	capturedPiece _ 0.! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/9/2001 18:03'!value	^value! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/9/2001 18:03'!value: newValue	value _ newValue! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/10/2001 22:31'!attackSquares	^attackSquares! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/24/2001 15:58'!blackPawnCaptureAt: square direction: dir	| destSquare move piece |	destSquare _ square-8-dir.	piece _ itsPieces at: destSquare.	piece = 0 ifFalse:[		(move _ moveList at: (lastMoveIndex _ lastMoveIndex + 1))			move: Pawn from: square to: destSquare capture: piece.		piece = King ifTrue:[kingAttack _ move].		destSquare <= 8 "a promotion"			ifTrue:[self promotePawn: move].	].	"attempt an en-passant capture"	enpassantSquare = destSquare ifTrue:[		(moveList at: (lastMoveIndex _ lastMoveIndex + 1))			captureEnPassant: Pawn from: square to: destSquare.	].! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/24/2001 22:05'!blackPawnPushAt: square	| destSquare move |	"Try to push this pawn"	destSquare _ square-8.	(myPieces at: destSquare) = 0 ifFalse:[^self].	(itsPieces at: destSquare) = 0 ifFalse:[^self].	(move _ moveList at: (lastMoveIndex _ lastMoveIndex + 1))		move: Pawn from: square to: destSquare.	destSquare <= 8 "a promotion (can't be double-push so get out)"		ifTrue:[^self promotePawn: move].	"Try to double-push if possible"	square > 48 ifFalse:[^self].	destSquare _ square-16.	(myPieces at: destSquare) = 0 ifFalse:[^self].	(itsPieces at: destSquare) = 0 ifFalse:[^self].	(moveList at: (lastMoveIndex _ lastMoveIndex + 1))		doublePush: Pawn from: square to: destSquare.! !!ChessMoveGenerator methodsFor: 'support' stamp: 'RM 9/16/2004 19:28'!canCastleBlackKingSide	(castlingStatus bitAnd: CastlingEnableKingSide) = 0 ifFalse:[^false].	"Quickly check if all the squares are zero"	((myPieces at: G8) + (myPieces at: F8) + (itsPieces at: G8) + (itsPieces at: F8) = 0) ifFalse:[^false].	"Check for castling squares under attack..  See canCastleBlackQueenSide for details"	(self checkAttack:{H7. H6. H5. H4. H3. H2. H1} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{G7. G6. G5. G4. G3. G2. G1} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{F7. F6. F5. F4. F3. F2. F1} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{E7. E6. E5. E4. E3. E2. E1.} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{D8. C8. B8. A8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{G7. F6. E5. D4. C3. B2. A1} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{F7. E6. D5. C4. B3. A2} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{E7. D6. C5. B4. A3} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{D7. C6. B5. A4} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{F7. G6. H5} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{G7. H6} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{H7} fromPieces:BishopMovers) ifTrue:[^false].	(self checkUnprotectedAttack:{H7. G7. F7. E7. D7. C7. H6. G6. F6. E6. D6} fromPiece:Knight) ifTrue:[^false].	(self checkUnprotectedAttack:{H7. G7. F7. E7. D7} fromPiece:Pawn) ifTrue:[^false].	^true.					! !!ChessMoveGenerator methodsFor: 'support' stamp: 'RM 9/16/2004 19:26'!canCastleBlackQueenSide	(castlingStatus bitAnd: CastlingEnableQueenSide) = 0 ifFalse:[^false].	"Quickly check if all the squares are zero"	((myPieces at: B8) +  (myPieces at: C8) +  (myPieces at: D8) +		(itsPieces at: B8) + (itsPieces at: C8) + (itsPieces at: D8) 			= 0) ifFalse:[^false].	"Check to see if any of the squares involved in castling are under attack.  First	check for vertical (rook-like) attacks"	(self checkAttack:{A7. A6. A5. A4. A3. A2. A1} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{B7. B6. B5. B4. B3. B2. B1} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{C7. C6. C5. C4. C3. C2. C1} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{D7. D6. D5. D4. D3. D2. D1} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{E7. E6. E5. E4. E3. E2. E1} fromPieces:RookMovers) ifTrue:[^false].	"Check for a rook attack from the baseline"	(self checkAttack:{F8. G8. H8} fromPieces:RookMovers) ifTrue:[^false].	"Check for bishop attacks from the diagonals"	(self checkAttack:{B7. C6. D5. E4. F3. G2. H1} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{C7. D6. E5. F4. G3. H2} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{D7. E6. F5. G4. H3} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{E7. F6. G5. H4} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{F7. G6. H5} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{A7} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{B7. A6} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{C7. B6. A5} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{D7. C6. B5. A4} fromPieces:BishopMovers) ifTrue:[^false].	"Check for a knight attack"	(self checkUnprotectedAttack:{A7. B7. C7. D7. E7. F7. G7. A6. B6. C6. D6. E6. F6} fromPiece:Knight) ifTrue:[^false].	"check for a pawn attack"	(self checkUnprotectedAttack:{A7. B7. C7. D7. E7. F7} fromPiece:Pawn) ifTrue:[^false].	"check for a king attack"	(self checkUnprotectedAttack:{B7. C7. } fromPiece:King) ifTrue:[^false].	^true.! !!ChessMoveGenerator methodsFor: 'support' stamp: 'RM 9/16/2004 19:28'!canCastleWhiteKingSide	(castlingStatus bitAnd: CastlingEnableKingSide) = 0 ifFalse: [^false].	"Quickly check if all the squares are zero"	((myPieces at:G1) + (myPieces at:F1) + (itsPieces at:G1) + (itsPieces at:F1) = 0) ifFalse:[^false].	"Check for castling squares under attack..  See canCastleBlackQueenSide for details"	(self checkAttack:{H2. H3. H4. H5. H6. H7. H8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{G2. G3. G4. G5. G6. G7. G8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{F2. F3. F4. F5. F6. F7. F8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{E2. E3. E4. E5. E6. E7. E8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{A1. A2. A3. A4} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{G2. F3. E4. D5. C6. B7. A8} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{F2. E3. D4. C5. B6. A7} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{E2. D3. C4. B5. A6} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{D2. C3. B4. A5} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{F2. G3. H4} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{G2. H3} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{H2} fromPieces:BishopMovers) ifTrue:[^false].	(self checkUnprotectedAttack:{H2. G2. F2. E2. D2. C2. H3. G3. F3. E3. D3} fromPiece:Knight) ifTrue:[^false].	(self checkUnprotectedAttack:{H2. G2. F2. E2. D2} fromPiece:Pawn) ifTrue:[^false].	(self checkUnprotectedAttack:{G2} fromPiece:King) ifTrue:[^false].	^true.! !!ChessMoveGenerator methodsFor: 'support' stamp: 'RM 9/16/2004 19:28'!canCastleWhiteQueenSide	(castlingStatus bitAnd: CastlingEnableQueenSide) = 0 ifFalse: [^false].	"Quickly check if all the squares are zero"	((myPieces at:B1) + (myPieces at:C1) + (myPieces at:D1) +	 (itsPieces at:B1) + (itsPieces at:C1) + (itsPieces at:D1) = 0) ifFalse:[^false].	"Check for castling squares under attack..  See canCastleBlackQueenSide for details"	(self checkAttack:{A2. A3. A4. A5. A6. A7. A8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{B2. B3. B4. B5. B6. B7. B8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{C2. C3. C4. C5. C6. C7. C8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{D2. D3. D4. D5. D6. D7. D8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{E2. E3. E4. E5. E6. E7. E8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{F1. G1. H1} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{B2. C3. D4. E5. F6. G7. H8} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{C2. D3. E4. F5. G6. H7} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{D2. E3. F4. G5. H6} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{E2. F3. G4. H5} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{F2. G3. H4} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{A2} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{B2. A3} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{C2. B3. A4} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{D2. C3. B4. A5} fromPieces:BishopMovers) ifTrue:[^false].	(self checkUnprotectedAttack:{A2. B2. C2. D2. E2. F2. G2. A3. B3. C3. D3. E3. F3} fromPiece:Knight) ifTrue:[^false].	(self checkUnprotectedAttack:{A2. B2. C2. D2. E2. F2} fromPiece:Pawn) ifTrue:[^false].	(self checkUnprotectedAttack:{B2. C2} fromPiece:King) ifTrue:[^false].	^true.! !!ChessMoveGenerator methodsFor: 'support' stamp: 'RM 9/16/2004 19:37'!checkAttack:squares fromPieces:pieces	"check for an unprotected attack along squares by one of pieces.  Squares is a list of 	squares such that any piece in pieces can attack unless blocked by another piece.	E.g., a Bishop of Queen on the file  B7 C6 D5 E4 F3 G2 H1 can attack A8 unless blocked by	another piece.  To find out if A8 is under attack along B7 C6 D5 E4 F3 G2 H1, use	checkAttack:{B7. C6.D5. E4. F3. G2. H1} fromPieces:BishopMovers.  Note the order is important;	squares must be listed in increasing distance from the square of interest"	squares do:[:sqr|		"invariant: no piece has been seen on this file at all"		"one of my pieces blocks any attack"		(myPieces at:sqr) = 0 ifFalse:[^false].		"One of its pieces blocks an attack unless it is the kind of piece that can move along this		file: a Bishop or Queen for a diagonal and a Rook or Queen for a Horizontal or		Verrtical File"		(itsPieces at:sqr) = 0 ifFalse:[			^pieces includes:(itsPieces at:sqr).		].			].	"no pieces along file, no attack"	^false.		! !!ChessMoveGenerator methodsFor: 'support' stamp: 'RM 9/16/2004 19:38'!checkUnprotectedAttack:squares fromPiece:piece	"check to see if my opponent has a piece of type piece on any of squares.  In general, this	is used because that piece could launch an attack on me from those squares".	squares do:[:sqr|		(itsPieces at:sqr) = piece ifTrue:[^true].	].	^false.		! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 9/29/2005 10:39'!findAllPossibleMovesFor: player 	"Find all possible moves. This method does not check if the move is legal, e.g., if the king of the player is under attack after the move. If the opponent is check mate (e.g., the king could be taken in the next move) the method returns nil. If the game is stale mate (e.g., the receiver has no move left) this method returns an empty array."	| piece actions square |	myPlayer := player.	myPieces := player pieces.	itsPieces := player opponent pieces.	castlingStatus := player castlingStatus.	enpassantSquare := player opponent enpassantSquare.	firstMoveIndex = lastMoveIndex ifFalse: [self error: 'I am confused'].	kingAttack := nil.	myPlayer isWhitePlayer ifTrue:[		actions := #(moveWhitePawnAt: moveKnightAt: moveBishopAt: 					moveRookAt: moveQueenAt: moveWhiteKingAt:)	] ifFalse:[ 		actions := #(moveBlackPawnAt: moveKnightAt: moveBishopAt: 					moveRookAt: moveQueenAt: moveBlackKingAt:)	].	square := 0.	[square < 64] whileTrue:[		"Note: The following is only to skip empty fields efficiently.		It could well be replaced by going through each field and test it		for zero but this is *much* faster."		square := self skipEmptySquaresIn: myPieces							using: EmptyPieceMap							startingAt: square + 1.		square = 0 ifTrue: [^self moveList].		piece := myPieces at: square.		self perform: (actions at: piece) with: square.		kingAttack ifNotNil: [^self moveList].	].	^self moveList! !!ChessMoveGenerator methodsFor: 'public' stamp: 'dgd 2/22/2003 14:38'!findAttackSquaresFor: player 	"Mark all the fields of a board that are attacked by the given player.	The pieces attacking a field are encoded as (1 << Piece) so that we can	record all types of pieces that attack the square."	| move square piece attack list |	forceCaptures := false.	attackSquares ifNil: [attackSquares := ByteArray new: 64].	attackSquares atAllPut: 0.	list := self findAllPossibleMovesFor: player.		[move := list next.	move isNil] whileFalse: 				[square := move destinationSquare.				piece := move movingPiece.				attack := attackSquares at: square.				attack := attack bitOr: (1 bitShift: piece).				attackSquares at: square put: attack].	self recycleMoveList: list.	^attackSquares! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 15:59'!findPossibleMovesFor: player	"Find all possible moves. This method does not check if the move is legal, e.g., if the king of the player is under attack after the move. If the opponent is check mate (e.g., the king could be taken in the next move) the method returns nil. If the game is stale mate (e.g., the receiver has no move left) this method returns an empty array."	forceCaptures _ false.	^self findAllPossibleMovesFor: player.! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 20:58'!findPossibleMovesFor: player at: square	"Find all possible moves at the given square. This method does not check if the move is legal, e.g., if the king of the player is under attack after the move. If the opponent is check mate (e.g., the king could be taken in the next move) the method returns nil. If the game is stale mate (e.g., the receiver has no move left) this method returns an empty array."	| piece action |	forceCaptures _ false.	myPlayer _ player.	myPieces _ player pieces.	itsPieces _ player opponent pieces.	castlingStatus _ player castlingStatus.	enpassantSquare _ player opponent enpassantSquare.	firstMoveIndex = lastMoveIndex ifFalse:[self error:'I am confused'].	kingAttack _ nil.	piece _ myPieces at: square.	piece = 0 ifFalse:[		action _ #(movePawnAt:					moveKnightAt:					moveBishopAt:					moveRookAt:					moveQueenAt:					moveKingAt:) at: piece.		self perform: action with: square.	].	^self moveList! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 16:00'!findQuiescenceMovesFor: player	"Find all the quiescence moves (that is moves capturing pieces)"	forceCaptures _ true.	^self findAllPossibleMovesFor: player.! !!ChessMoveGenerator methodsFor: 'initialize' stamp: 'ar 8/24/2001 15:55'!initialize	EmptyPieceMap ifNil:[		EmptyPieceMap _ ByteArray new: 256.		2 to: 7 do:[:i| EmptyPieceMap at: i put: 1]].	streamList _ Array new: 100. "e.g., 100 plies"	1 to: streamList size do:[:i| streamList at: i put: (ChessMoveList on: #())].	moveList _ Array new: streamList size * 30. "avg. 30 moves per ply"	1 to: moveList size do:[:i| moveList at: i put: (ChessMove new init)].	firstMoveIndex _ lastMoveIndex _ streamListIndex _ 0.! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/10/2001 22:32'!kingAttack	^kingAttack! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/22/2001 15:19'!moveBishopAt: square	| moves |	moves _ BishopMoves at: square.	1 to: moves size do:[:i|		self movePiece: Bishop along: (moves at: i) at: square.	].! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/24/2001 21:30'!moveBlackKingAt: square	| capture |	(KingMoves at: square) do:[:destSquare|		(myPieces at: destSquare) = 0 ifTrue:[			capture _ itsPieces at: destSquare.			(forceCaptures and:[capture = 0]) ifFalse:[				(moveList at: (lastMoveIndex _ lastMoveIndex + 1))					move: King from: square to: destSquare capture: capture.				capture = King ifTrue:[kingAttack _ moveList at: lastMoveIndex].			].		].	].	forceCaptures ifTrue:[^self].	"now consider castling"	self canCastleBlackKingSide ifTrue:[		(moveList at: (lastMoveIndex _ lastMoveIndex + 1))			moveCastlingKingSide: King from: square to: square+2.	].	self canCastleBlackQueenSide ifTrue:[		(moveList at: (lastMoveIndex _ lastMoveIndex + 1))			moveCastlingQueenSide: King from: square to: square-2.	].! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/22/2001 15:22'!moveBlackPawnAt: square	"Pawns only move in one direction so check for which direction to use"	forceCaptures ifFalse:[self blackPawnPushAt: square].	(square bitAnd: 7) = 1		ifFalse:[self blackPawnCaptureAt: square direction: 1].	(square bitAnd: 7) = 0 		ifFalse:[self blackPawnCaptureAt: square direction: -1].! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/24/2001 21:32'!moveKingAt: square	myPlayer isWhitePlayer		ifTrue:[^self moveWhiteKingAt: square]		ifFalse:[^self moveBlackKingAt: square]! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/24/2001 15:56'!moveKnightAt: square	| capture moves destSquare |	moves _ KnightMoves at: square.	1 to: moves size do:[:i|		destSquare _ moves at: i.		(myPieces at: destSquare) = 0 ifTrue:[			capture _ itsPieces at: destSquare.			(forceCaptures and:[capture = 0]) ifFalse:[				(moveList at: (lastMoveIndex _ lastMoveIndex + 1))					move: Knight from: square to: destSquare capture: capture.				capture = King ifTrue:[kingAttack _ (moveList at: lastMoveIndex)].			].		].	].! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 16:37'!moveList	| list |	kingAttack ifNotNil:[		lastMoveIndex _ firstMoveIndex.		^nil].	list _ streamList at: (streamListIndex _ streamListIndex + 1).	list on: moveList from: firstMoveIndex+1 to: lastMoveIndex.	firstMoveIndex _ lastMoveIndex.	^list! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/22/2001 15:16'!movePawnAt: square	"Pawns only move in one direction so check for which direction to use"	myPlayer isWhitePlayer		ifTrue:[^self moveWhitePawnAt: square]		ifFalse:[^self moveBlackPawnAt: square]! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/24/2001 15:57'!movePiece: piece along: rayList at: square	| destSquare capture |	1 to: rayList size do:[:i|		destSquare _ rayList at: i.		(myPieces at: destSquare) = 0 ifFalse:[^self].		capture _ itsPieces at: destSquare.		(forceCaptures and:[capture = 0]) ifFalse:[			(moveList at: (lastMoveIndex _ lastMoveIndex + 1))				move: piece from: square to: destSquare capture: capture.			capture = King ifTrue:[kingAttack _ moveList at: lastMoveIndex].		].		capture = 0 ifFalse:[^self].	].! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/22/2001 15:19'!moveQueenAt: square	| moves |	moves _ RookMoves at: square.	1 to: moves size do:[:i|		self movePiece: Queen along: (moves at: i) at: square.	].	moves _ BishopMoves at: square.	1 to: moves size do:[:i|		self movePiece: Queen along: (moves at: i) at: square.	].! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/22/2001 15:19'!moveRookAt: square	| moves |	moves _ RookMoves at: square.	1 to: moves size do:[:i|		self movePiece: Rook along: (moves at: i) at: square.	].! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/24/2001 21:30'!moveWhiteKingAt: square	| capture |	(KingMoves at: square) do:[:destSquare|		(myPieces at: destSquare) = 0 ifTrue:[			capture _ itsPieces at: destSquare.			(forceCaptures and:[capture = 0]) ifFalse:[				(moveList at: (lastMoveIndex _ lastMoveIndex + 1))					move: King from: square to: destSquare capture: capture.				capture = King ifTrue:[kingAttack _ moveList at: lastMoveIndex].			].		].	].	forceCaptures ifTrue:[^self].	"now consider castling"	self canCastleWhiteKingSide ifTrue:[		(moveList at: (lastMoveIndex _ lastMoveIndex + 1))			moveCastlingKingSide: King from: square to: square+2.	].	self canCastleWhiteQueenSide ifTrue:[		(moveList at: (lastMoveIndex _ lastMoveIndex + 1))			moveCastlingQueenSide: King from: square to: square-2.	].! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/22/2001 15:22'!moveWhitePawnAt: square	"Pawns only move in one direction so check for which direction to use"	forceCaptures ifFalse:[self whitePawnPushAt: square].	(square bitAnd: 7) = 0 		ifFalse:[self whitePawnCaptureAt: square direction: 1].	(square bitAnd: 7) = 1 		ifFalse:[self whitePawnCaptureAt: square direction: -1].! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 21:25'!profileGenerationFor: player	| list |	Smalltalk garbageCollect.	MessageTally spyOn:[		1 to: 100000 do:[:i|			list _ self findPossibleMovesFor: player.			self recycleMoveList: list].	].! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/24/2001 15:57'!promotePawn: move	"Duplicate the given move and embed all promotion types"	(moveList at: (lastMoveIndex _ lastMoveIndex + 1)) promote: move to: Knight.	(moveList at: (lastMoveIndex _ lastMoveIndex + 1)) promote: move to: Bishop.	(moveList at: (lastMoveIndex _ lastMoveIndex + 1)) promote: move to: Rook.	move promote: move to: Queen.! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 16:31'!recycleMoveList: aChessMoveList	(streamList at: streamListIndex) == aChessMoveList ifFalse:[^self error:'I am confused'].	streamListIndex _ streamListIndex - 1.	firstMoveIndex _ lastMoveIndex _ aChessMoveList startIndex - 1.! !!ChessMoveGenerator methodsFor: 'private' stamp: 'ar 9/29/2005 10:46'!skipEmptySquaresIn: pieces using: aMap startingAt: startIndex	"Find the first empty (zero) square in pieces. The method is layed out so we can (re)use the a particularly effective String primitive (which requires the map argument) but the failure code will do the more natural search for zero instead of the actual primitive equivalent."	<primitive: 'primitiveFindFirstInString' module: 'MiscPrimitivePlugin'>	startIndex to: pieces size do:[:index|		(pieces at: index) = 0 ifFalse:[^index].	].	^0! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/24/2001 15:56'!whitePawnCaptureAt: square direction: dir	| destSquare move piece |	destSquare _ square+8+dir.	piece _ itsPieces at: destSquare.	piece = 0 ifFalse:[		(move _ moveList at: (lastMoveIndex _ lastMoveIndex + 1))			move: Pawn from: square to: destSquare capture: piece.		piece = King ifTrue:[kingAttack _ move].		destSquare > 56 "a promotion"			ifTrue:[self promotePawn: move].	].	"attempt an en-passant capture"	enpassantSquare = destSquare ifTrue:[		(moveList at: (lastMoveIndex _ lastMoveIndex + 1))			captureEnPassant: Pawn from: square to: destSquare.	].! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/24/2001 22:06'!whitePawnPushAt: square	"Pawns only move in one direction so check for which direction to use"	| destSquare move |	"Try to push this pawn"	destSquare _ square+8.	(myPieces at: destSquare) = 0 ifFalse:[^self].	(itsPieces at: destSquare) = 0 ifFalse:[^self].	(move _ moveList at: (lastMoveIndex _ lastMoveIndex + 1))		move: Pawn from: square to: destSquare.	destSquare > 56 "a promotion (can't be double-push so get out)"		ifTrue:[^self promotePawn: move].	"Try to double-push if possible"	square <= 16 ifFalse:[^self].	destSquare _ square+16.	(myPieces at: destSquare) = 0 ifFalse:[^self].	(itsPieces at: destSquare) = 0 ifFalse:[^self].	(moveList at: (lastMoveIndex _ lastMoveIndex + 1))		doublePush: Pawn from: square to: destSquare.! !!ChessPlayer class methodsFor: 'accessing' stamp: 'ar 8/9/2001 19:53'!king	^King! !!ChessPlayer class methodsFor: 'accessing' stamp: 'ar 8/10/2001 01:00'!rook	^Rook! !!ChessPlayer methodsFor: 'adding/removing' stamp: 'ar 8/8/2001 22:25'!addBlackPieces	self initialize.	49 to: 56 do:[:i| self addPiece: Pawn at: i].	self addPiece: Rook at: 57.	self addPiece: Knight at: 58.	self addPiece: Bishop at: 59.	self addPiece: Queen at: 60.	self addPiece: King at: 61.	self addPiece: Bishop at: 62.	self addPiece: Knight at: 63.	self addPiece: Rook at: 64.! !!ChessPlayer methodsFor: 'adding/removing' stamp: 'ar 8/24/2001 18:18'!addPiece: piece at: square	pieces at: square put: piece.	materialValue _ materialValue + (PieceValues at: piece).	positionalValue _ positionalValue + ((PieceCenterScores at: piece) at: square).	piece = Pawn ifTrue:[numPawns _ numPawns + 1].	board updateHash: piece at: square from: self.	self userAgent ifNotNil:[self userAgent addedPiece: piece at: square white: self isWhitePlayer].! !!ChessPlayer methodsFor: 'adding/removing' stamp: 'ar 8/8/2001 22:24'!addWhitePieces	self addPiece: Rook at: 1.	self addPiece: Knight at: 2.	self addPiece: Bishop at: 3.	self addPiece: Queen at: 4.	self addPiece: King at: 5.	self addPiece: Bishop at: 6.	self addPiece: Knight at: 7.	self addPiece: Rook at: 8.	9 to: 16 do:[:i| self addPiece: Pawn at: i].! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/10/2001 00:36'!applyCastleKingSideMove: move	self movePiece: move movingPiece from: move sourceSquare to: move destinationSquare.	self movePiece: Rook from: move sourceSquare+3 to: (castlingRookSquare _ move sourceSquare+1).	pieces at: castlingRookSquare put: King.	castlingStatus _ castlingStatus bitOr: CastlingDone.! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/10/2001 00:33'!applyCastleQueenSideMove: move	self movePiece: move movingPiece from: move sourceSquare to: move destinationSquare.	self movePiece: Rook from: move sourceSquare-4 to: (castlingRookSquare _ move sourceSquare-1).	pieces at: castlingRookSquare put: King.	castlingStatus _ castlingStatus bitOr: CastlingDone.! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/9/2001 01:58'!applyDoublePushMove: move	enpassantSquare _ (move sourceSquare + move destinationSquare) bitShift: -1.	"Above means: the field between start and destination"	^self movePiece: move movingPiece from: move sourceSquare to: move destinationSquare.! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/9/2001 22:26'!applyEnpassantMove: move	opponent removePiece: move capturedPiece at: move destinationSquare - 		(self isWhitePlayer ifTrue:[8] ifFalse:[-8]).	^self movePiece: move movingPiece from: move sourceSquare to: move destinationSquare! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/10/2001 02:46'!applyMove: move	"Apply the given move"	| action |	"Apply basic move"	action _ #(			applyNormalMove:			applyDoublePushMove:			applyEnpassantMove:			applyCastleKingSideMove:			applyCastleQueenSideMove:			applyResign:			applyStaleMate:		) at: (move moveType bitAnd: ChessMove basicMoveMask).	self perform: action with: move.	"Promote if necessary"	self applyPromotion: move.	"Maintain castling status"	self updateCastlingStatus: move.! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/9/2001 00:54'!applyNormalMove: move	| piece |	(piece _ move capturedPiece) = EmptySquare 		ifFalse:[opponent removePiece: piece at: move destinationSquare].	^self movePiece: move movingPiece from: move sourceSquare to: move destinationSquare.! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/9/2001 22:20'!applyPromotion: move	| piece |	piece _ move promotion.	piece = 0 ifFalse:[self replacePiece: move movingPiece with: piece at: move destinationSquare].! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/24/2001 18:18'!applyResign: move	"Give up."	self userAgent ifNotNil:[		self isWhitePlayer 			ifTrue:[self userAgent finishedGame: 0]			ifFalse:[self userAgent finishedGame: 1].	].! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/24/2001 18:18'!applyStaleMate: move	"Itsa draw."	self userAgent ifNotNil:[self userAgent finishedGame: 0.5].! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/8/2001 22:40'!board	^board! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/8/2001 22:40'!board: aBoard	board _ aBoard! !!ChessPlayer methodsFor: 'testing' stamp: 'dgd 2/22/2003 18:41'!canCastleKingSide	(castlingStatus bitAnd: CastlingEnableKingSide) = 0 ifFalse: [^false].	self isWhitePlayer 		ifTrue: 			[(pieces sixth) = 0 ifFalse: [^false].			pieces seventh = 0 ifFalse: [^false].			(opponent pieceAt: 6) = 0 ifFalse: [^false].			(opponent pieceAt: 7) = 0 ifFalse: [^false]]		ifFalse: 			[(pieces at: 62) = 0 ifFalse: [^false].			(pieces at: 63) = 0 ifFalse: [^false].			(opponent pieceAt: 62) = 0 ifFalse: [^false].			(opponent pieceAt: 63) = 0 ifFalse: [^false]].	^true! !!ChessPlayer methodsFor: 'testing' stamp: 'dgd 2/22/2003 18:41'!canCastleQueenSide	(castlingStatus bitAnd: CastlingEnableQueenSide) = 0 ifFalse: [^false].	self isWhitePlayer 		ifTrue: 			[pieces second = 0 ifFalse: [^false].			(pieces third) = 0 ifFalse: [^false].			pieces fourth = 0 ifFalse: [^false].			(opponent pieceAt: 2) = 0 ifFalse: [^false].			(opponent pieceAt: 3) = 0 ifFalse: [^false].			(opponent pieceAt: 4) = 0 ifFalse: [^false]]		ifFalse: 			[(pieces at: 58) = 0 ifFalse: [^false].			(pieces at: 59) = 0 ifFalse: [^false].			(pieces at: 60) = 0 ifFalse: [^false].			(opponent pieceAt: 58) = 0 ifFalse: [^false].			(opponent pieceAt: 59) = 0 ifFalse: [^false].			(opponent pieceAt: 60) = 0 ifFalse: [^false]].	^true! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/10/2001 00:52'!castlingRookSquare	^castlingRookSquare! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/24/2001 18:03'!castlingStatus	^castlingStatus! !!ChessPlayer methodsFor: 'copying' stamp: 'ar 8/9/2001 04:10'!copy	^self shallowCopy postCopy! !!ChessPlayer methodsFor: 'copying' stamp: 'ar 8/24/2001 18:02'!copyPlayer: aPlayer	"Copy all the volatile state from aPlayer"	castlingRookSquare _ aPlayer castlingRookSquare.	enpassantSquare _ aPlayer enpassantSquare.	castlingStatus _ aPlayer castlingStatus.	materialValue _ aPlayer materialValue.	numPawns _ aPlayer numPawns.	positionalValue _ aPlayer positionalValue.	pieces replaceFrom: 1 to: pieces size with: aPlayer pieces startingAt: 1.! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/9/2001 01:58'!enpassantSquare	^enpassantSquare! !!ChessPlayer methodsFor: 'evaluation' stamp: 'ar 8/10/2001 23:26'!evaluate	^self evaluateMaterial + self evaluatePosition! !!ChessPlayer methodsFor: 'evaluation' stamp: 'ar 8/9/2001 20:37'!evaluateMaterial	"Compute the board's material balance, from the point of view of the side	player.  This is an exact clone of the eval function in CHESS 4.5"	| total diff value |	self materialValue = opponent materialValue ifTrue:[^0]. "both sides are equal"	total _ self materialValue + opponent materialValue.	diff _ self materialValue - opponent materialValue.	value _ (2400 min: diff) + 		((diff * (12000 - total) * self numPawns) // (6400 * (self numPawns + 1))).	^value! !!ChessPlayer methodsFor: 'evaluation' stamp: 'ar 8/24/2001 16:02'!evaluatePosition	"Compute the board's positional balance, from the point of view of the side player."	^positionalValue - opponent positionalValue! !!ChessPlayer methodsFor: 'moves-general' stamp: 'ar 8/24/2001 16:04'!findPossibleMoves	"Find all possible moves. This method does not check if the move is legal, e.g., if the king of the player is under attack after the move. If the opponent is check mate (e.g., the king could be taken in the next move) the method returns nil. If the game is stale mate (e.g., the receiver has no move left) this method returns an empty array."	| moveList moves |	moveList _ board generator findPossibleMovesFor: self.	moveList ifNil:[^nil].	moves _ moveList contents collect:[:move| move copy].	board generator recycleMoveList: moveList.	^moves! !!ChessPlayer methodsFor: 'moves-general' stamp: 'ar 8/24/2001 16:06'!findPossibleMovesAt: square	"Find all possible moves at the given square. This method does not check if the move is legal, e.g., if the king of the player is under attack after the move. If the opponent is check mate (e.g., the king could be taken in the next move) the method returns nil. If the game is stale mate (e.g., the receiver has no move left) this method returns an empty array."	| moveList moves |	moveList _ board generator findPossibleMovesFor: self at: square.	moveList ifNil:[^nil].	moves _ moveList contents collect:[:move| move copy].	board generator recycleMoveList: moveList.	^moves! !!ChessPlayer methodsFor: 'moves-general' stamp: 'ar 8/24/2001 16:06'!findQuiescenceMoves	"Find all possible moves. This method does not check if the move is legal, e.g., if the king of the player is under attack after the move. If the opponent is check mate (e.g., the king could be taken in the next move) the method returns nil. If the game is stale mate (e.g., the receiver has no move left) this method returns an empty array."	| moveList moves |	moveList _ board generator findQuiescenceMovesFor: self.	moveList ifNil:[^nil].	moves _ moveList contents collect:[:move| move copy].	board generator recycleMoveList: moveList.	^moves! !!ChessPlayer methodsFor: 'moves-general' stamp: 'ar 8/10/2001 03:09'!findValidMoves	"Find all the valid moves"	| moveList |	moveList _ self findPossibleMoves ifNil:[^nil].	^moveList select:[:move| self isValidMove: move].! !!ChessPlayer methodsFor: 'moves-general' stamp: 'ar 8/10/2001 03:09'!findValidMovesAt: square	"Find all the valid moves"	| moveList |	moveList _ (self findPossibleMovesAt: square) ifNil:[^nil].	^moveList select:[:move| self isValidMove: move].! !!ChessPlayer methodsFor: 'initialize' stamp: 'ar 8/24/2001 18:20'!initialize	"ChessPlayer initialize"	pieces _ ByteArray new: 64.	materialValue _ 0.	positionalValue _ 0.	numPawns _ 0.	enpassantSquare _ 0.	castlingRookSquare _ 0.	castlingStatus _ 0.! !!ChessPlayer methodsFor: 'testing' stamp: 'ar 8/9/2001 19:45'!isValidMove: move	"Is the given move actually valid for the receiver?	If the receiver's king can't be taken after applying the move, it is."	| copy |	copy _ board copy.	copy nextMove: move.	^copy activePlayer findPossibleMoves notNil! !!ChessPlayer methodsFor: 'testing' stamp: 'ar 8/10/2001 02:47'!isValidMoveFrom: sourceSquare to: destSquare	| move |	move _ (self findValidMovesAt: sourceSquare)			detect:[:any| any destinationSquare = destSquare] ifNone:[nil].	^move notNil! !!ChessPlayer methodsFor: 'testing' stamp: 'ar 8/9/2001 01:23'!isWhitePlayer	^board whitePlayer == self! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/9/2001 17:56'!materialValue	^materialValue! !!ChessPlayer methodsFor: 'adding/removing' stamp: 'ar 8/24/2001 18:18'!movePiece: piece from: sourceSquare to: destSquare	| score |	score _ PieceCenterScores at: piece.	positionalValue _ positionalValue - (score at: sourceSquare).	positionalValue _ positionalValue + (score at: destSquare).	pieces at: sourceSquare put: 0.	pieces at: destSquare put: piece.	board updateHash: piece at: sourceSquare from: self.	board updateHash: piece at: destSquare from: self.	self userAgent ifNotNil:[self userAgent movedPiece: piece from: sourceSquare to: destSquare].! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/9/2001 17:56'!numPawns	^numPawns! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/8/2001 22:35'!opponent	^opponent! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/8/2001 22:35'!opponent: aPlayer	opponent _ aPlayer! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/10/2001 00:38'!pieceAt: square	"Return the piece at the given square"	^pieces at: square! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/10/2001 02:00'!pieces	^pieces! !!ChessPlayer methodsFor: 'evaluation' stamp: 'ar 8/24/2001 15:57'!positionalValue	"Evaluate our current position"	^positionalValue! !!ChessPlayer methodsFor: 'copying' stamp: 'ar 8/10/2001 05:16'!postCopy	pieces _ pieces clone.! !!ChessPlayer methodsFor: 'initialize' stamp: 'ar 8/10/2001 00:37'!prepareNextMove	"Clear enpassant square and reset any pending extra kings"	enpassantSquare _ 0.	castlingRookSquare = 0 ifFalse:[pieces at: castlingRookSquare put: Rook].	castlingRookSquare _ 0.! !!ChessPlayer methodsFor: 'adding/removing' stamp: 'ar 8/24/2001 18:18'!removePiece: piece at: square	pieces at: square put: 0.	materialValue _ materialValue - (PieceValues at: piece).	positionalValue _ positionalValue - ((PieceCenterScores at: piece) at: square).	piece = Pawn ifTrue:[numPawns _ numPawns - 1].	board updateHash: piece at: square from: self.	self userAgent ifNotNil:[self userAgent removedPiece: piece at: square].! !!ChessPlayer methodsFor: 'adding/removing' stamp: 'ar 8/24/2001 18:18'!replacePiece: oldPiece with: newPiece at: square	pieces at: square put: newPiece.	materialValue _ materialValue - (PieceValues at: oldPiece) + (PieceValues at: newPiece).	positionalValue _ positionalValue - ((PieceCenterScores at: oldPiece) at: square).	positionalValue _ positionalValue + ((PieceCenterScores at: newPiece) at: square).	oldPiece = Pawn ifTrue:[numPawns _ numPawns - 1].	newPiece = Pawn ifTrue:[numPawns _ numPawns + 1].	board updateHash: oldPiece at: square from: self.	board updateHash: newPiece at: square from: self.	self userAgent ifNotNil:[self userAgent replacedPiece: oldPiece with: newPiece at: square white: self isWhitePlayer].! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/9/2001 22:22'!undoCastleKingSideMove: move	self prepareNextMove. "in other words, remove extra kings"	self movePiece: move movingPiece from: move destinationSquare to: move sourceSquare.	self movePiece: Rook from: move sourceSquare+1 to: move sourceSquare+3.! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/9/2001 22:22'!undoCastleQueenSideMove: move	self prepareNextMove. "in other words, remove extra kings"	self movePiece: move movingPiece from: move destinationSquare to: move sourceSquare.	self movePiece: Rook from: move sourceSquare-1 to: move sourceSquare-4.! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/9/2001 22:24'!undoDoublePushMove: move	enpassantSquare _ 0.	self movePiece: move movingPiece from: move destinationSquare to: move sourceSquare.! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/10/2001 08:42'!undoEnpassantMove: move	self movePiece: move movingPiece from: move destinationSquare to: move sourceSquare.	opponent addPiece: move capturedPiece at: move destinationSquare - 		(self isWhitePlayer ifTrue:[8] ifFalse:[-8]).! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/10/2001 03:18'!undoMove: move	"Undo the given move"	| action |	self undoPromotion: move.	"Apply basic move"	action _ #(			undoNormalMove:			undoDoublePushMove:			undoEnpassantMove:			undoCastleKingSideMove:			undoCastleQueenSideMove:			undoResign:			undoStaleMate:		) at: (move moveType bitAnd: ChessMove basicMoveMask).	self perform: action with: move.! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/10/2001 08:41'!undoNormalMove: move	| piece |	self movePiece: move movingPiece from: move destinationSquare to: move sourceSquare.	(piece _ move capturedPiece) = EmptySquare 		ifFalse:[opponent addPiece: piece at: move destinationSquare].! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/9/2001 22:20'!undoPromotion: move	| piece |	piece _ move promotion.	piece = 0 ifFalse:[self replacePiece: piece with: move movingPiece at: move destinationSquare].! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/9/2001 22:27'!undoResign: move! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/9/2001 22:27'!undoStaleMate: move! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/9/2001 02:11'!updateCastlingStatus: move	"Cannot castle when king has moved"	(move movingPiece = King) 		ifTrue:[^castlingStatus _ castlingStatus bitOr: CastlingDisableAll].	"See if a rook has moved"	(move movingPiece = Rook) ifFalse:[^self].	self isWhitePlayer ifTrue:[		(move sourceSquare = 1) 			ifTrue:[^castlingStatus _ castlingStatus bitOr: CastlingDisableQueenSide].		(move sourceSquare = 8) 			ifTrue:[^castlingStatus _ castlingStatus bitOr: CastlingDisableKingSide].	] ifFalse:[		(move sourceSquare = 57) 			ifTrue:[^castlingStatus _ castlingStatus bitOr: CastlingDisableQueenSide].		(move sourceSquare = 64) 			ifTrue:[^castlingStatus _ castlingStatus bitOr: CastlingDisableKingSide].	].! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/24/2001 18:17'!userAgent	^board userAgent! !!ChessPlayerAI class methodsFor: 'class initialization' stamp: 'ar 8/12/2001 14:39'!initialize	"ChessPlayerAI initialize"	AlphaBetaGiveUp _ -29990.	AlphaBetaIllegal _ -31000.	AlphaBetaMaxVal _ 30000.	AlphaBetaMinVal _ -30000.	ValueAccurate _ 2.	ValueBoundary _ 4.	ValueLowerBound _ 4.	ValueUpperBound _ 5.	ValueThreshold _ 200.! !!ChessPlayerAI methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:15'!activePlayer: aPlayer	player _ aPlayer.	board _ player board.	generator _ board generator.	self reset.! !!ChessPlayerAI methodsFor: 'searching' stamp: 'dgd 2/22/2003 14:44'!copyVariation: move 	| av mv count |	count := 0.	av := variations at: ply + 1.	ply < 9 		ifTrue: 			[mv := variations at: ply + 2.			count := mv first.			av 				replaceFrom: 3				to: count + 2				with: mv				startingAt: 2].	av at: 1 put: count + 1.	av at: 2 put: move encodedMove! !!ChessPlayerAI methodsFor: 'initialize' stamp: 'ar 10/20/2001 14:28'!initialize	historyTable _ ChessHistoryTable new.	"NOTE: transposition table is initialized only when we make the first move. It costs a little to do all the entries and the garbage collections so we do it only when we *really* need it."	transTable _ nil.	random _ Random new.	nodesVisited _ ttHits _ alphaBetaCuts _ stamp _ 0.	variations _ Array new: 11.	1 to: variations size do:[:i| 		variations at: i put: (Array new: variations size).		(variations at: i) atAllPut: 0].	bestVariation _ Array new: variations size.	bestVariation atAllPut: 0.	activeVariation _ Array new: variations size.	activeVariation atAllPut: 0.	self reset.! !!ChessPlayerAI methodsFor: 'initialize' stamp: 'ar 10/18/2001 23:36'!initializeTranspositionTable	"Initialize the transposition table. Note: For now we only use 64k entries since they're somewhat space intensive. If we should get a serious speedup at some point we may want to increase the transposition table - 256k seems like a good idea; but right now 256k entries cost us roughly 10MB of space. So we use only 64k entries (2.5MB of space).	If you have doubts about the size of the transition table (e.g., if you think it's too small or too big) then modify the value below and have a look at ChessTranspositionTable>>clear which can print out some valuable statistics.	"	transTable _ ChessTranspositionTable new: 16. "1 << 16 entries"! !!ChessPlayerAI methodsFor: 'thinking' stamp: 'ar 10/18/2001 20:14'!isThinking	^myProcess notNil! !!ChessPlayerAI methodsFor: 'searching' stamp: 'dgd 2/22/2003 14:44'!mtdfSearch: theBoard score: estimate depth: depth 	"An implementation of the MTD(f) algorithm. See:		http://www.cs.vu.nl/~aske/mtdf.html	"	| beta move value low high goodMove |	value := estimate.	low := AlphaBetaMinVal.	high := AlphaBetaMaxVal.	[low >= high] whileFalse: 			[beta := value = low ifTrue: [value + 1] ifFalse: [beta := value].			move := self 						searchMove: theBoard						depth: depth						alpha: beta - 1						beta: beta.			stopThinking ifTrue: [^move].			move ifNil: [^move].			value := move value.			value < beta 				ifTrue: [high := value]				ifFalse: 					["NOTE: It is important that we do *NOT* return a move from a search which didn't reach the beta goal (e.g., value < beta). This is because all it means is that we didn't reach beta and the move returned is not the move 'closest' to beta but just one that triggered cut-off. In other words, if we'd take a move which value is less than beta it could mean that this move is a *LOT* worse than beta."					low := value.					goodMove := move.					activeVariation 						replaceFrom: 1						to: activeVariation size						with: (variations first)						startingAt: 1]].	^goodMove! !!ChessPlayerAI methodsFor: 'searching' stamp: 'asm 6/23/2003 22:02'!negaScout: theBoard depth: depth alpha: initialAlpha beta: initialBeta 	"Modified version to return the move rather than the score"	| move score alpha bestScore moveList newBoard beta goodMove a b notFirst |	self		assert: [initialAlpha < initialBeta].	ply < 10		ifTrue: [(variations at: ply + 1)				at: 1				put: 0].	ply _ 0.	alpha _ initialAlpha.	beta _ initialBeta.	bestScore _ AlphaBetaMinVal.	"Generate new moves"	moveList _ generator findPossibleMovesFor: theBoard activePlayer.	moveList		ifNil: [^ nil].	moveList size = 0		ifTrue: [generator recycleMoveList: moveList.			^ nil].	"Sort move list according to history heuristics"	moveList sortUsing: historyTable.	"And search"	a _ alpha.	b _ beta.	notFirst _ false.	[(move _ moveList next) isNil]		whileFalse: [newBoard _ (boardList at: ply + 1)						copyBoard: theBoard.			newBoard nextMove: move.			"Search recursively"			"Search recursively"			ply _ ply + 1.			score _ 0						- (self								ngSearch: newBoard								depth: depth - 1								alpha: 0 - b								beta: 0 - a).			(notFirst					and: [score > a							and: [score < beta									and: [depth > 1]]])				ifTrue: [score _ 0								- (self										ngSearch: newBoard										depth: depth - 1										alpha: 0 - beta										beta: 0 - score)].			notFirst _ true.			ply _ ply - 1.			stopThinking				ifTrue: [generator recycleMoveList: moveList.					^ move].			score = AlphaBetaIllegal				ifFalse: [score > bestScore						ifTrue: [ply < 10								ifTrue: [self copyVariation: move].							goodMove _ move copy.							goodMove value: score.							activeVariation								replaceFrom: 1								to: activeVariation size								with: variations first								startingAt: 1.							bestScore _ score].					"See if we can cut off the search"					score > a						ifTrue: [a _ score.							a >= beta								ifTrue: [transTable										storeBoard: theBoard										value: score										type: (ValueBoundary												bitOr: (ply bitAnd: 1))										depth: depth										stamp: stamp.									historyTable addMove: move.									alphaBetaCuts _ alphaBetaCuts + 1.									generator recycleMoveList: moveList.									^ goodMove]].					b _ a + 1]].	transTable		storeBoard: theBoard		value: bestScore		type: (ValueAccurate				bitOr: (ply bitAnd: 1))		depth: depth		stamp: stamp.	generator recycleMoveList: moveList.	^ goodMove! !!ChessPlayerAI methodsFor: 'searching' stamp: 'dgd 2/22/2003 14:45'!ngSearch: theBoard depth: depth alpha: initialAlpha beta: initialBeta 	"A basic alpha-beta algorithm; based on negaMax rather than from the text books"	| move score alpha entry bestScore moveList newBoard beta a b notFirst |	self assert: [initialAlpha < initialBeta].	ply < 10 ifTrue: [(variations at: ply + 1) at: 1 put: 0].	depth = 0 		ifTrue: 			[^self 				quiesce: theBoard				alpha: initialAlpha				beta: initialBeta].	nodesVisited := nodesVisited + 1.	"See if there's already something in the transposition table. If so, skip the entire search."	entry := transTable lookupBoard: theBoard.	alpha := initialAlpha.	beta := initialBeta.	(entry isNil or: [entry depth < depth]) 		ifFalse: 			[ttHits := ttHits + 1.			(entry valueType bitAnd: 1) = (ply bitAnd: 1) 				ifTrue: [beta := entry value max: initialBeta]				ifFalse: [alpha := 0 - entry value max: initialAlpha].			beta > initialBeta ifTrue: [^beta].			alpha >= initialBeta ifTrue: [^alpha]].	bestScore := AlphaBetaMinVal.	"Generate new moves"	moveList := generator findPossibleMovesFor: theBoard activePlayer.	moveList ifNil: [^0 - AlphaBetaIllegal].	moveList isEmpty 		ifTrue: 			[generator recycleMoveList: moveList.			^bestScore].	"Sort move list according to history heuristics"	moveList sortUsing: historyTable.	"And search"	a := alpha.	b := beta.	notFirst := false.	[(move := moveList next) isNil] whileFalse: 			[newBoard := (boardList at: ply + 1) copyBoard: theBoard.			newBoard nextMove: move.			"Search recursively"			ply := ply + 1.			score := 0 - (self 								ngSearch: newBoard								depth: depth - 1								alpha: 0 - b								beta: 0 - a).			(notFirst and: [score > a and: [score < beta and: [depth > 1]]]) 				ifTrue: 					[score := 0 - (self 										ngSearch: newBoard										depth: depth - 1										alpha: 0 - beta										beta: 0 - score)].			notFirst := true.			ply := ply - 1.			stopThinking 				ifTrue: 					[generator recycleMoveList: moveList.					^score].			score = AlphaBetaIllegal 				ifFalse: 					[score > bestScore 						ifTrue: 							[ply < 10 ifTrue: [self copyVariation: move].							bestScore := score].					score > a 						ifTrue: 							[a := score.							a >= beta 								ifTrue: 									[transTable 										storeBoard: theBoard										value: score										type: (ValueBoundary bitOr: (ply bitAnd: 1))										depth: depth										stamp: stamp.									historyTable addMove: move.									alphaBetaCuts := alphaBetaCuts + 1.									generator recycleMoveList: moveList.									^score]].					b := a + 1]].	transTable 		storeBoard: theBoard		value: bestScore		type: (ValueAccurate bitOr: (ply bitAnd: 1))		depth: depth		stamp: stamp.	generator recycleMoveList: moveList.	^bestScore! !!ChessPlayerAI methodsFor: 'searching' stamp: 'dgd 2/22/2003 14:46'!quiesce: theBoard alpha: initialAlpha beta: initialBeta 	"A variant of alpha-beta considering only captures and null moves to obtain a quiet position, e.g. one that is unlikely to change heavily in the very near future."	| move score alpha entry bestScore moveList newBoard beta |	self assert: [initialAlpha < initialBeta].	ply < 10 ifTrue: [(variations at: ply + 1) at: 1 put: 0].	nodesVisited := nodesVisited + 1.	"See if there's already something in the transposition table."	entry := transTable lookupBoard: theBoard.	alpha := initialAlpha.	beta := initialBeta.	entry isNil 		ifFalse: 			[ttHits := ttHits + 1.			(entry valueType bitAnd: 1) = (ply bitAnd: 1) 				ifTrue: [beta := entry value max: initialBeta]				ifFalse: [alpha := 0 - entry value max: initialAlpha].			beta > initialBeta ifTrue: [^beta].			alpha >= initialBeta ifTrue: [^alpha]].	ply < 2 		ifTrue: 			["Always generate moves if ply < 2 so that we don't miss a move that		would bring the king under attack (e.g., make an invalid move)."			moveList := generator findQuiescenceMovesFor: theBoard activePlayer.			moveList ifNil: [^0 - AlphaBetaIllegal]].	"Evaluate the current position, assuming that we have a non-capturing move."	bestScore := theBoard activePlayer evaluate.	"TODO: What follows is clearly not the Right Thing to do. The score we just evaluated doesn't take into account that we may be under attack at this point. I've seen it happening various times that the static evaluation triggered a cut-off which was plain wrong in the position at hand.	There seem to be three ways to deal with the problem. #1 is just deepen the search. If we go one ply deeper we will most likely find the problem (although that's not entirely certain). #2 is to improve the evaluator function and make it so that the current evaluator is only an estimate saying if it's 'likely' that a non-capturing move will do. The more sophisticated evaluator should then take into account which pieces are under attack. Unfortunately that could make the AI play very passive, e.g., avoiding situations where pieces are under attack even if these attacks are outweighed by other factors. #3 would be to insert a null move here to see *if* we are under attack or not (I've played with this) but for some reason the resulting search seemed to explode rapidly. I'm uncertain if that's due to the transposition table being too small (I don't *really* think so but it may be) or if I've just got something else wrong."	bestScore > alpha 		ifTrue: 			[alpha := bestScore.			bestScore >= beta 				ifTrue: 					[moveList ifNotNil: [generator recycleMoveList: moveList].					^bestScore]].	"Generate new moves"	moveList ifNil: 			[moveList := generator findQuiescenceMovesFor: theBoard activePlayer.			moveList ifNil: [^0 - AlphaBetaIllegal]].	moveList isEmpty 		ifTrue: 			[generator recycleMoveList: moveList.			^bestScore].	"Sort move list according to history heuristics"	moveList sortUsing: historyTable.	"And search"	[(move := moveList next) isNil] whileFalse: 			[newBoard := (boardList at: ply + 1) copyBoard: theBoard.			newBoard nextMove: move.			"Search recursively"			ply := ply + 1.			score := 0 - (self 								quiesce: newBoard								alpha: 0 - beta								beta: 0 - alpha).			stopThinking 				ifTrue: 					[generator recycleMoveList: moveList.					^score].			ply := ply - 1.			score = AlphaBetaIllegal 				ifFalse: 					[score > bestScore 						ifTrue: 							[ply < 10 ifTrue: [self copyVariation: move].							bestScore := score].					"See if we can cut off the search"					score > alpha 						ifTrue: 							[alpha := score.							score >= beta 								ifTrue: 									[transTable 										storeBoard: theBoard										value: score										type: (ValueBoundary bitOr: (ply bitAnd: 1))										depth: 0										stamp: stamp.									historyTable addMove: move.									alphaBetaCuts := alphaBetaCuts + 1.									generator recycleMoveList: moveList.									^bestScore]]]].	transTable 		storeBoard: theBoard		value: bestScore		type: (ValueAccurate bitOr: (ply bitAnd: 1))		depth: 0		stamp: stamp.	generator recycleMoveList: moveList.	^bestScore! !!ChessPlayerAI methodsFor: 'initialize' stamp: 'ar 10/18/2001 22:35'!reset	transTable ifNotNil:[transTable clear].	historyTable clear.! !!ChessPlayerAI methodsFor: 'initialize' stamp: 'ar 10/18/2001 20:52'!reset: aBoard	self reset.	boardList ifNil:[		boardList _ Array new: 100.		1 to: boardList size do:[:i| boardList at: i put: (aBoard copy userAgent: nil)].		boardListIndex _ 0].	board _ aBoard.! !!ChessPlayerAI methodsFor: 'searching' stamp: 'dgd 2/22/2003 14:46'!search: theBoard depth: depth alpha: initialAlpha beta: initialBeta 	"A basic alpha-beta algorithm; based on negaMax rather than from the text books"	| move score alpha entry bestScore moveList newBoard beta |	self assert: [initialAlpha < initialBeta].	ply < 10 ifTrue: [(variations at: ply + 1) at: 1 put: 0].	depth = 0 		ifTrue: 			[^self 				quiesce: theBoard				alpha: initialAlpha				beta: initialBeta].	nodesVisited := nodesVisited + 1.	"See if there's already something in the transposition table. If so, skip the entire search."	entry := transTable lookupBoard: theBoard.	alpha := initialAlpha.	beta := initialBeta.	(entry isNil or: [entry depth < depth]) 		ifFalse: 			[ttHits := ttHits + 1.			(entry valueType bitAnd: 1) = (ply bitAnd: 1) 				ifTrue: [beta := entry value max: initialBeta]				ifFalse: [alpha := 0 - entry value max: initialAlpha].			beta > initialBeta ifTrue: [^beta].			alpha >= initialBeta ifTrue: [^alpha]].	bestScore := AlphaBetaMinVal.	"Generate new moves"	moveList := generator findPossibleMovesFor: theBoard activePlayer.	moveList ifNil: [^0 - AlphaBetaIllegal].	moveList isEmpty 		ifTrue: 			[generator recycleMoveList: moveList.			^bestScore].	"Sort move list according to history heuristics"	moveList sortUsing: historyTable.	"And search"	[(move := moveList next) isNil] whileFalse: 			[newBoard := (boardList at: ply + 1) copyBoard: theBoard.			newBoard nextMove: move.			"Search recursively"			ply := ply + 1.			score := 0 - (self 								search: newBoard								depth: depth - 1								alpha: 0 - beta								beta: 0 - alpha).			stopThinking 				ifTrue: 					[generator recycleMoveList: moveList.					^score].			ply := ply - 1.			score = AlphaBetaIllegal 				ifFalse: 					[score > bestScore 						ifTrue: 							[ply < 10 ifTrue: [self copyVariation: move].							bestScore := score].					"See if we can cut off the search"					score > alpha 						ifTrue: 							[alpha := score.							score >= beta 								ifTrue: 									[transTable 										storeBoard: theBoard										value: score										type: (ValueBoundary bitOr: (ply bitAnd: 1))										depth: depth										stamp: stamp.									historyTable addMove: move.									alphaBetaCuts := alphaBetaCuts + 1.									generator recycleMoveList: moveList.									^bestScore]]]].	transTable 		storeBoard: theBoard		value: bestScore		type: (ValueAccurate bitOr: (ply bitAnd: 1))		depth: depth		stamp: stamp.	generator recycleMoveList: moveList.	^bestScore! !!ChessPlayerAI methodsFor: 'searching' stamp: 'dgd 2/22/2003 14:47'!searchMove: theBoard depth: depth alpha: initialAlpha beta: initialBeta 	"Modified version to return the move rather than the score"	| move score alpha bestScore moveList newBoard beta goodMove |	self assert: [initialAlpha < initialBeta].	ply < 10 ifTrue: [(variations at: ply + 1) at: 1 put: 0].	ply := 0.	alpha := initialAlpha.	beta := initialBeta.	bestScore := AlphaBetaMinVal.	"Generate new moves"	moveList := generator findPossibleMovesFor: theBoard activePlayer.	moveList ifNil: [^nil].	moveList isEmpty 		ifTrue: 			[generator recycleMoveList: moveList.			^nil].	"Sort move list according to history heuristics"	moveList sortUsing: historyTable.	"And search"	[(move := moveList next) isNil] whileFalse: 			[newBoard := (boardList at: ply + 1) copyBoard: theBoard.			newBoard nextMove: move.			"Search recursively"			ply := ply + 1.			score := 0 - (self 								search: newBoard								depth: depth - 1								alpha: 0 - beta								beta: 0 - alpha).			stopThinking 				ifTrue: 					[generator recycleMoveList: moveList.					^move].			ply := ply - 1.			score = AlphaBetaIllegal 				ifFalse: 					[score > bestScore 						ifTrue: 							[ply < 10 ifTrue: [self copyVariation: move].							goodMove := move copy.							goodMove value: score.							bestScore := score].					"See if we can cut off the search"					score > alpha 						ifTrue: 							[alpha := score.							score >= beta 								ifTrue: 									[transTable 										storeBoard: theBoard										value: score										type: (ValueBoundary bitOr: (ply bitAnd: 1))										depth: depth										stamp: stamp.									historyTable addMove: move.									alphaBetaCuts := alphaBetaCuts + 1.									generator recycleMoveList: moveList.									^goodMove]]]].	transTable 		storeBoard: theBoard		value: bestScore		type: (ValueAccurate bitOr: (ply bitAnd: 1))		depth: depth		stamp: stamp.	generator recycleMoveList: moveList.	^goodMove! !!ChessPlayerAI methodsFor: 'thinking' stamp: 'ar 10/18/2001 20:15'!startThinking	self isThinking ifTrue:[^self].	self activePlayer: board activePlayer.	self thinkStep.! !!ChessPlayerAI methodsFor: 'accessing' stamp: 'jdl 3/28/2003 08:12'!statusString	| av count |	^String streamContents: 			[:s | 			(myMove == #none or: [myMove isNil]) 				ifFalse: 					[s						print: myMove value * 0.01;						space].			av := bestVariation.			count := av first.			count > 0 				ifFalse: 					[av := activeVariation.					count := av first].			count > 0 				ifFalse: 					[s nextPutAll: '***'.					av := variations first.					count := av first.					count := count min: 3].			2 to: count + 1				do: 					[:index | 					s nextPutAll: (ChessMove decodeFrom: (av at: index)) moveString.					s space].			s nextPut: $[.			s print: nodesVisited.			"		s nextPut:$|.		s print: ttHits.		s nextPut: $|.		s print: alphaBetaCuts."			s nextPut: $]]! !!ChessPlayerAI methodsFor: 'thinking' stamp: 'dgd 2/22/2003 14:47'!think	| move |	self isThinking ifTrue: [^nil].	self startThinking.	[(move := self thinkStep) isNil] whileTrue.	^move! !!ChessPlayerAI methodsFor: 'thinking' stamp: 'aoy 2/15/2003 21:21'!thinkProcess	| score theMove depth |	stopThinking := false.	score := board activePlayer evaluate.	depth := 1.	stamp := stamp + 1.	ply := 0.	historyTable clear.	transTable clear.	startTime := Time millisecondClockValue.	nodesVisited := ttHits := alphaBetaCuts := 0.	bestVariation at: 1 put: 0.	activeVariation at: 1 put: 0.	[nodesVisited < 50000] whileTrue: 			["whats this ? (aoy)  false ifTrue:[] ????!!"			theMove := false 						ifTrue: 							[self 								mtdfSearch: board								score: score								depth: depth]						ifFalse: 							[self 								negaScout: board								depth: depth								alpha: AlphaBetaMinVal								beta: AlphaBetaMaxVal].			theMove ifNil: [^myProcess := nil].			stopThinking ifTrue: [^myProcess := nil].			myMove := theMove.			bestVariation 				replaceFrom: 1				to: bestVariation size				with: activeVariation				startingAt: 1.			score := theMove value.			depth := depth + 1].	myProcess := nil! !!ChessPlayerAI methodsFor: 'thinking' stamp: 'dgd 2/22/2003 14:48'!thinkStep	transTable ifNil: [self initializeTranspositionTable].	myProcess isNil 		ifTrue: 			[myMove := #none.			false 				ifTrue: 					[self thinkProcess.					^myMove].			myProcess := [self thinkProcess] forkAt: Processor userBackgroundPriority.			myProcess suspend.			^nil].	myProcess resume.	(Delay forMilliseconds: 50) wait.	myProcess ifNil: [^myMove == #none ifTrue: [nil] ifFalse: [myMove]].	myProcess suspend.	"Do we have a valid move?"	myMove == #none ifTrue: [^nil].	"no"	"Did we time out?"	Time millisecondClockValue - startTime > self timeToThink 		ifTrue: 			["Yes. Abort and return current move."			stopThinking := true.			myProcess resume.			[myProcess isNil] whileFalse: [(Delay forMilliseconds: 10) wait].			^myMove == #none ifTrue: [nil] ifFalse: [myMove]].	"Keep thinking"	^nil! !!ChessPlayerAI methodsFor: 'thinking' stamp: 'ar 10/21/2001 01:12'!timeToThink	"Return the number of milliseconds we're allowed to think"	^5000! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/10/2001 19:36'!clear	value _ valueType _ timeStamp _ depth _ -1.! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/10/2001 19:05'!depth	^depth! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 10/19/2001 00:04'!depth: aNumber	depth _ aNumber! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/8/2001 09:14'!hashLock	^hashLock! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/8/2001 09:14'!hashLock: aNumber	hashLock _ aNumber! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/8/2001 09:14'!timeStamp	^timeStamp! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/8/2001 09:14'!timeStamp: aNumber	timeStamp _ aNumber! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/10/2001 19:37'!value	^value! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/10/2001 19:37'!value: newValue	value _ newValue! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/10/2001 19:37'!valueType	^valueType! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/10/2001 19:37'!valueType: newType	valueType _ newType! !!ChessTranspositionTable class methodsFor: 'instance creation' stamp: 'ar 8/8/2001 09:15'!new: bits	^self basicNew initialize: bits! !!ChessTranspositionTable methodsFor: 'initialize' stamp: 'dgd 2/22/2003 13:24'!clear	"Set the following to true for printing information about the fill rate and number of collisions. The transposition table should have *plenty* of free space (it should rarely exceed 30% fill rate) and *very* few collisions (those require us to evaluate positions repeatedly that we've evaluated before -- bad idea!!)"	| entry |	false 		ifTrue: 			[used position > 0 				ifTrue: 					['entries used:	' , used position printString , ' (' 						, (used position * 100 // array size) printString , '%)	' 						displayAt: 0 @ 0].			collisions > 0 				ifTrue: 					['collisions:		' , collisions printString , ' (' 						, (collisions * 100 // array size) printString , '%)	' 						displayAt: 0 @ 15]].	used position: 0.	[(entry := used next) isNil] whileFalse: [entry clear].	used resetToStart.	collisions := 0! !!ChessTranspositionTable methodsFor: 'initialize' stamp: 'ar 10/18/2001 23:28'!initialize: nBits	"Initialize the receiver using 1<<nBits entries. See also ChessPlayerAI>>initializeTranspositionTable."	| entry |	array _ Array new: 1 << nBits.	used _ ReadWriteStream on: (Array new: 50000). "<- will grow if not sufficient!!"	entry _ ChessTTEntry new clear.	1 to: array size do:[:i| array at: i put: entry clone].	collisions _ 0.	Smalltalk garbageCollect. "We *really* want them old here"! !!ChessTranspositionTable methodsFor: 'lookup' stamp: 'ar 8/12/2001 14:06'!lookupBoard: aBoard	| key entry |	key _ aBoard hashKey bitAnd: array size - 1.	entry _ array at: key + 1.	entry ifNil:[^nil].	entry valueType = -1 ifTrue:[^nil].	entry hashLock = aBoard hashLock ifFalse:[^nil].	^entry! !!ChessTranspositionTable methodsFor: 'initialize' stamp: 'ar 10/18/2001 23:32'!storeBoard: aBoard value: value type: valueType depth: depth stamp: timeStamp	| key entry |	key _ aBoard hashKey bitAnd: array size - 1.	entry _ array at: key + 1.	entry valueType = -1 		ifTrue:[used nextPut: entry]		ifFalse:[entry hashLock = aBoard hashLock ifFalse:[collisions _ collisions + 1]].	(entry valueType = -1 		or:[entry depth <= depth		or:[entry timeStamp < timeStamp]]) ifFalse:[^self].	entry hashLock: aBoard hashLock.	entry value: value.	entry valueType: valueType.	entry depth: depth.	entry timeStamp: timeStamp.! !!FreeCellStatistics class methodsFor: 'instance creation' stamp: 'di 1/16/2000 10:39'!includeInNewMorphMenu	^false! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'ar 11/9/2000 21:17'!buildButton: aButton target: aTarget label: aLabel selector: aSelector	"wrap a button or switch in an alignmentMorph to provide some space around the button"	| a |	aButton 		target: aTarget;		label: aLabel;		actionSelector: aSelector;		borderColor: #raised;		borderWidth: 2;		color: Color gray.	a _ AlignmentMorph newColumn		wrapCentering: #center; cellPositioning: #topCenter;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: Color transparent;		layoutInset: 1.	a addMorph: aButton.	^ a! !!FreeCellStatistics methodsFor: 'updating' stamp: 'djp 10/24/1999 19:04'!changed	window ifNotNil: [		statsMorph ifNotNil: [statsMorph contents: self statsText]]! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 19:20'!close	window ifNotNil: [		window delete.		window _ nil].! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 16:42'!color	^Color green darker! !!FreeCellStatistics methodsFor: 'initialization' stamp: 'asm 11/24/2003 23:10'!defaultColor	"answer the default color/fill style for the receiver"	^ Color green! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'asm 11/24/2003 22:55'!display	| panel |	(window notNil and: [window owner notNil]) ifTrue: [window activate. ^nil].	panel _ AlignmentMorph newColumn.	panel		wrapCentering: #center; cellPositioning: #topCenter;		hResizing: #rigid;		vResizing: #rigid;		extent: 250@150;		color: self color;		addMorphBack: self makeStatistics;		addMorphBack: self makeControls.	window _ panel openInWindowLabeled: 'FreeCell Statistics' translated.! !!FreeCellStatistics methodsFor: 'actions' stamp: 'di 3/5/2000 14:30'!gameLost: gameNumber	"Don't count multiple losses of the same game"	gameNumber = lastGameLost ifTrue: [^ self].	lastGameLost _ gameNumber.	sessionLosses _ sessionLosses + 1.	totalLosses _ totalLosses + 1.	lossesWithReplay _ lossesWithReplay + 1.	currentType = #losses		ifTrue: [currentCount _ currentCount + 1]		ifFalse: 			[currentCount _ 1.			currentType _ #losses].	self updateStreak.	self changed! !!FreeCellStatistics methodsFor: 'actions' stamp: 'di 3/5/2000 16:48'!gameWon: gameNumber	sessionWins _ sessionWins + 1.	totalWins _ totalWins + 1.	gameNumber = lastGameWon ifFalse:		[gameNumber = lastGameLost ifTrue:			["Finally won a game by replaying"			lossesWithReplay _ lossesWithReplay - 1].		winsWithReplay _ winsWithReplay + 1].	lastGameWon _ gameNumber.	currentType = #wins		ifTrue: [currentCount _ currentCount + 1]		ifFalse: [currentCount _ 1.				currentType _ #wins].	self updateStreak.	self changed! !!FreeCellStatistics methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:56'!initialize	super initialize.	self reset! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'ar 11/9/2000 21:18'!makeControls	| row |	row _ AlignmentMorph newRow.	row		wrapCentering: #center; cellPositioning: #leftCenter;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: self color;		borderWidth: 2;		borderColor: #inset;		addMorphBack: self makeOkButton;		addMorphBack: self makeResetButton.	^row.! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 16:34'!makeOkButton	^self		buildButton: SimpleButtonMorph new		target: self		label: 'OK'		selector: #ok! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 17:07'!makeResetButton	^self		buildButton: SimpleButtonMorph new		target: self		label: 'Reset'		selector: #reset! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'ar 11/9/2000 21:26'!makeStatistics	| row |	row _ AlignmentMorph newRow.	row		wrapCentering: #center; cellPositioning: #leftCenter;		hResizing: #spaceFill;		vResizing: #spaceFill;		color: self color;		borderWidth: 2;		borderColor: #inset;		addMorphBack: (AlignmentMorph newColumn			wrapCentering: #center; cellPositioning: #topCenter;			color: self color;			addMorph: (statsMorph _ TextMorph new contents: self statsText)).	^row.! !!FreeCellStatistics methodsFor: 'actions' stamp: 'djp 10/24/1999 19:21'!newSession	sessionWins _ 0.	sessionLosses _ 0.	currentCount _ 0.	currentType _ nil.	self changed.! !!FreeCellStatistics methodsFor: 'actions' stamp: 'djp 10/24/1999 17:15'!ok	window delete.	window _ nil.! !!FreeCellStatistics methodsFor: 'printing' stamp: 'asm 11/24/2003 22:57'!print: aNumber type: type on: aStream 	"I moved the code from #printWins:on: and #printLosses:on: here because 	it is basically 	the same. I hope this increases the maintainability. - th 12/20/1999 20:37"	aStream print: aNumber.	type = #wins		ifTrue: [aNumber = 1				ifTrue: [aStream nextPutAll: ' win' translated]				ifFalse: [aStream nextPutAll: ' wins' translated]].	type = #losses		ifTrue: [aNumber = 1				ifTrue: [aStream nextPutAll: ' loss' translated]				ifFalse: [aStream nextPutAll: ' losses' translated]]! !!FreeCellStatistics methodsFor: 'printing' stamp: 'di 3/5/2000 15:22'!printOn: aStream	self printSessionOn: aStream.	aStream cr.	self printTotalOn: aStream.	aStream cr.	self printReplaysOn: aStream.	aStream cr.	self printStreaksOn: aStream.! !!FreeCellStatistics methodsFor: 'printing' stamp: 'asm 11/24/2003 23:02'!printReplaysOn: aStream 	| total |	aStream nextPutAll: 'With replays: ' translated;		 tab.	self		print: winsWithReplay		type: #wins		on: aStream.	aStream nextPutAll: ', '.	self		print: lossesWithReplay		type: #losses		on: aStream.	total := winsWithReplay + lossesWithReplay.	total ~~ 0		ifTrue: [aStream nextPutAll: ', ';				 print: (winsWithReplay / total * 100) asInteger;				 nextPut: $%]! !!FreeCellStatistics methodsFor: 'printing' stamp: 'asm 11/24/2003 23:02'!printSessionOn: aStream 	| total |	aStream nextPutAll: 'This session: ' translated, String tab.	self		print: sessionWins		type: #wins		on: aStream.	aStream nextPutAll: ', '.	self		print: sessionLosses		type: #losses		on: aStream.	total := sessionWins + sessionLosses.	total ~~ 0		ifTrue: [aStream nextPutAll: ', ';				 print: (sessionWins / total * 100) asInteger;				 nextPut: $%]! !!FreeCellStatistics methodsFor: 'printing' stamp: 'asm 11/24/2003 23:02'!printStreaksOn: aStream 	aStream nextPutAll: 'Streaks: ' translated;		 tab;		 tab.	self		print: streakWins		type: #wins		on: aStream.	aStream nextPutAll: ', '.	self		print: streakLosses		type: #losses		on: aStream.	aStream cr; tab; tab; tab; tab; nextPutAll: 'Current: '.	self		print: currentCount		type: currentType		on: aStream! !!FreeCellStatistics methodsFor: 'printing' stamp: 'asm 11/24/2003 23:03'!printTotalOn: aStream 	| total |	aStream nextPutAll: 'Total: ' translated;		 tab;		 tab;		 tab.	self		print: totalWins		type: #wins		on: aStream.	aStream nextPutAll: ', '.	self		print: totalLosses		type: #losses		on: aStream.	total := totalWins + totalLosses.	total ~~ 0		ifTrue: [aStream nextPutAll: ', ';				 print: (totalWins / total * 100) asInteger;				 nextPut: $%]! !!FreeCellStatistics methodsFor: 'actions' stamp: 'di 3/5/2000 14:30'!reset	sessionWins 		_ 0.	sessionLosses 	_ 0.	totalWins 		_ 0.	totalLosses 		_ 0.	streakWins		_ 0.	streakLosses 	_ 0. 	winsWithReplay _ 0.	lossesWithReplay _ 0.	lastGameWon	_ 0.	lastGameLost 	_ 0.	currentCount 	_ 0.	currentType		_ nil.	self changed.		! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 19:04'!statsText	^ String cr,self printString,String cr! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 15:56'!stringMorphFromPrintOn: aSelector		^StringMorph new 		contents: (String streamContents: [:s | self perform: aSelector with: s]);		yourself.! !!FreeCellStatistics methodsFor: 'actions' stamp: 'th 12/20/1999 20:42'!updateStreak	"I moved the code from #printWins:on: and #printLosses:on: here because 	 it is basically the same. I hope this increases the maintainability. 	th 12/20/1999 20:41"	currentType = #losses ifTrue: [streakLosses _ streakLosses max: currentCount].	currentType = #wins ifTrue: [streakWins _ streakWins max: currentCount]! !!PlayingCard class methodsFor: 'all' stamp: 'di 10/13/1999 17:26'!imageData ^ 'AgQALwAlAAAAAIDjaN4VEeFDEREREBIiIiIiIiIiIYiBiIGIgYiIiIgSIiIiEBIiIiIREiIiIhgRGBEYERiBiIEiIiIiEBIiIiERESIiIiFEREREREQRGBIiIiIiEBIiIhERERIiIiIRERERERFEQSIiIiISEBIiIhERERIiIiIRERERERERESIiIiEREBIiIhERERIiIiESIiIiISERESIiIhIUEBIiIiERESIiIhISIiIiISEhESIiIhIUEBIiERIREhESIhIRESERESEhISIiIhIUEBIhERERERERIhEREhESESEhISIiIhIUEBIREREREREREhISIhIiISEhISIiIhIUEBIREREREREREhISIhIiISEhISIiIhIUEBIREREREREREhISIhIiISEhISIiIhIUEBIhEREhIRERIhISIREiISEhISIiIhIUEBIiERIKISIREuIfIhEhISEhESIiEhQQEiIiIhESIiIhERIhESIhISEhIhIiEhQQEiIiIRERIiIiEhIiIiIhISISEhEiEhQQEiIiIiIiIiIREhISIhIRISERIRQREhQQEiIiIiIiIiEiEhISEhISESEhIUREEhQQEiIiIiIiIiEhIhISEhIRISIhFIREEhQQEiIiIiIiEREiISEhQSEiFBEUSIREEhQQEiIiIiERERERERQURBQRREQURESBEhQQEiIiERRBiBEhGBFERERERBFIREQSEhQQEiIhREREGIEREYERREREERSIRIEiEhQQEiEUJCQkIYgRIYGBEUQRGBRERBIhEhQQEhEURERERBiBERgYERERgUREgSIREhQQFBESQkJCQkGIERgYgREYgUhEQSEREhQQFBEUREREREEYQRGBGBGBFIhEEiEREhQQFBEUJCQkJCERhBGBiIiIFERIEhFBEhQQFBEUREQREUEUGBEYERQRFEREEhEREhQQEYgRQkEiIhEREYEYGIiIFISBIhFBEhQQGIiBRBIhEiEUQYEYERQRSIRBIREREhQQEYgRFBIUQSERERgRgYiBRESBIRERERQQERERERIUQSEURBgRgRQRRERBIREiEiEQEUQRERIhEiERERGBgYiBRISBIRIiIREQEREREREiIhERERERERERSIRBIRIRIiEQESISIREREUQSIiFEQRERFESBIRIiEREQBAAvACUAAAAAgONk3hURExERERAYiIiIiIQRQhISESEJIuNPIiIiEBGIiIiIhBFCESEhESIiIiIiIhESIiIiEBIYiIgRhBFCEiESESIiIiIiIRERIiIiEBIhiIgYRBFCEhIhISIiIiIiEREREiIiEBIhiIiEQRRCESIiERIiIiIiEREREiIiEBIiGIiEQRQiEiIiIRIiIiIiEREREiIiEBIiGBGEERQiERIREUEiIiIiIRERIiIiEBIiGBhEEUQhIRIhEUEiIiIREhESERIiEBIhiIRBEUIhIiEiIRQSIiEREREREREiEBIhiIRBFEISIiEiIRQSIhERERERERESEBIYEUQRRCISIiEiIRFBIhERERERERESEBGIFEERQiEiIhESIUFEEhERERERERESEBIRRBEUQiEiIiIiIUQUQSERESEhEREiEBIiERFEIhQSIhESERQRRBIREiEiERIiEBIiIRFCIhFBIiEiERFBFEEiIhESIiIiEBIiERRCIRgREiIhgREUEUQSIRERIiIiEBIhEUQhFISBgREYFIhBRBFBIiIiIiIiEBIRFEISIUhEgYGESIQSFEEUEiIRIiIiEBERQRERERSIRERIiEEREUQUEiFEESIiEBEUiIERESEUiIiIRBISGBQUEhQRRBIiEBGIGIgSISIRFBEUESIRgYFBIUREQSIiEBiIgYGBISERIURBIREYiBESIhEUEhESEBRERBiIEREhIUhBISGBgRGBIiIhIYiBEBREREGIGBEhIURBIRiIFBGBEhESGIESEBREREQRiIgRERQREYGBRBGBEYiBEREiEBgYGBREEYGIiBEYiIERhBGBGIgSEiISEBGBgYGBRBEYiIiIgRERhEEYERESIRESEBgYEREREUSBERERERgRhEERRBQRISISEBGBGIiIiBFEgREYEYEYREQUIkERERESEBgYiBERGIgUQRERgYEYREGBQkQUEiISEBGIERgYERiBSBERGBEYRBiBFERBEREiEBQRGBgYGBGIFBERgYEYRBgYgUIkFBIiEBRBGBEREYgYFIEYERgYQYgRERQkQREiEBQkEUREQREYgUGBEREYQYGIFEFERBQSEBQiQUIiRBiBgRERGIEREYERFCIUIkEREBFERBIRJBERgURBREQYgYGIFCEhQkQUEAQALwAlAAAAAIDjaN4VEeE/EREREBIiIiEUFEFEQUFEFBREFBIiIiIiIiIiEBEiIiIRQUQUQUFEFBRBQSIiIhESIiIiEBQSIiIhFBRBEUERFBEUEiIiIRERIiIiEBRBIiIiFERERERERERBEiIiEREREiIiEBREEiIiERERERERERERIiIiEREREiIiEBERESIiGBIiIiIhgYGBIiIiEREREiIiEBiIEiIiGBIiIiIhgYGBIiIiIRERIiIiEBGIEiIiGBERIREhgYGBIiIREhESERIiEBiIEiIiGBESERIRgYGBIiEREREREREiEBGIEiIiGBIiEiIhgYGBIhERERERERESEBiIEiIhGBIiEiIhgYGBIhERERERERESEBGIEiIYGBIiEiIhgYGBIhERERERERESEBiIEiIYGBIhESIhgYGBEiERESEhEREiEAoRGBIi4iMiIiGBgRiBIhESISIREiIQGIgSIYgYISERIiGBEYgRIiIiERIiIiIQERgSIYGIESIiIhGBiBERESIhEREiIiIQGIgSIYiBFBIiIUGBGBESEhIiIiIiIiIQGIgRIhEUFEERFEQYiBEhEkESIiIiIiEQEYEiEUFBFERBFEQREREYEkRBEiIiIhgQEhIiIRQUFIhBEUESIRIYEkSEIRIiIYgQERERIUFBFERBIREiESGIEkiIQhERGIgQEiESIRQUFIhBIhIhEhiIEohIghERGIgQERgSIUFBFERBEiIRIYgREkiIQhERGIgQEhgSIRQUFIhBESESQYiIEkSEQhERGIgQEYgSIUFBFERBIREkGIEREkREQhERGIgQEhgSFBQRFIhBEhIRiIiIEkSEQhERGIgQEYgREUERFERBQSFBgYEREkiIQhERGIgQGIgRERERSIQYFBQYiIiIEohIghERGIgQGIgRIREhREQRgUGBgREREkiIQRFEGIgQGIgSIhIhSIQYiBiIiIiIEkSEQUSIGIgQGIgSEiIRREQREYgYEREREhERREREGIgQGIgRISEhSIQYiIiIiIiIESIUSIREGIgQGIgSEhIRREQRhBgRGBSBIiFEREQRGIgQGIgRISEkiEGIgUEiIUESIiFIhEESGIgQGIgSEhIUREEYiBIREhIiIhRERBISGIgQGIgRISEUiEGBESFEQSEiIRSIQSEhGIgQBAAvACUAAAAAgONg3hUR4dsREREQEiIiIiIiIhiIgYiBiIiIiIiIgSIiIiIQEiIiIkIiIiGIERgRGIGIiIiIEiIREiEQEiIiJEQiIiIURERESBEYgYiBIiGBIhQQEiIiRERCIiIRERERFERIERgRIhiBIhQQEiIpRERJIiIhEREREREUREQSIhiBIhQQEiKUREREkiIhIiIiESERERESIYgSEREQEiKUREREkiIhIRIiEhIRERESIYEiQkIQEiRERERERCIhESEiEhISEhISIRIiQkIQEkREREREREImIiIiEhISEhISIYEiEhIQEiRERERERCISIiIiEhISEhISIYgSEREQEiKUREREkiEiIiIiEhISEhISIhiBIhQQEiKUREREkiEWIiIiISEhISEhIhiBIhQQEiIpRERJIiIhERISISEhISEhIiGBIhQQEiIiRERCIiIhIhESIhISEhISEiIREhQQEiIiJEQiIiIiESIiIiEhISEhISIiIhQQEiIiIkIiIiIhIiIiERIhISEhISIiIhQQEiERIiIiIiIhEiIhIiEhISEhISIiIhQQEhISERIiIhEhIiIhIRIhISEhISIiIhQQEhEhISEiISESIiIhEiISEhISEiIiIhQQERISEhISISIiIiIiCRFbIiIUEBEhISIiIRgSIiIRERERiBIiGIEiEREREBISEiIhERGBEREREREhGIEhEYgSIYgSEBIhIhERFEEYERRBERIRIYgREhiBIRiBEBIiEUEYFEERgUFEEQkR4ScRIYIQEhFEREGBEhGBRBQRiIiIiIiIiBEREREQEUREQRgYEUQRFEESEhISEhISIYEREREQFERBGIiBgUQYERIiIiIiIiIiGBRBEiEQFEEYiIERGBEYEiIRERERERIhgYFEESEQFBiIgRERGBIYEhGIiIiIiBIYEUgUQREQEYiBEREhGBEYEYgRERERgSGBiBSBRBEQGIgRESIhEYERGBERREQYEiGBGIFIFEEQGIFEERIiEYERgRFEREQYEhgREYEREREQGBQUQREiEYERgRERERGBIhgRERSBSBQQEYhBRBESERgRgUREREGBIYERGBSBSBQQEUiEFEERIRgRgRERERgSIYEUSBQREREQFEFIhBERERERGBIiIhgRERERERSIQUQQBAAvACUAAAAAgONo3hUR4bsREREQEhiIiIiIFEEiEhIRgSIiIiIiIiIiIiIQEiGIiIEYFEEhISEhiBIiIiIiIkIiIiIQEiGIiIiIFEEiIRIRGBIiIiIiJEQiIiIQEiIYiIEYFEEiEiEhEYEiIiIiRERCIiIQEiIYiIiBFBIRIiIRERgSIiIpRERJIiIQEiIYiBGBRBEiIiIhQRgSIiKUREREkiIQEiIYiIgRQSIREhERQRGBIiKUREREkiIQEiIYgRgUQSEhESERRBGBIiRERERERCIQEiIYiIEUESIiISIhRBEYEkREREREREIQEiGIEYFEEhIiISIhREEYEiRERERERCIQEiGIiBFBISEiISIhREEYEiKUREREkiIQEhiBgRRBIRIiERIhREEYEiKUREREkiIQEiGIEUQSISIiIiIhREQRgSIpRERJIiIQEiIRFEEiFBIiERIYFEQRgSIiRERCIiIQEiIhRBIiEUEiISIYEUQRgSIiJEQiIiIQEiIUQSIhiBESIiGIEhQRgSIiIkIiIiIQEiFEERESGIgRERGIEhERgSIiIiIiIiIQEhRBEhERIREYiIERIRERgSIiIhESIiIQEUQRIQohERIi4acREhGBIiIRiBEiIhAUQSESERERESIiIhESERgRIiIYEYgSEhAUGBIRESESEREREREhIRGBIiGIiIEiERAREYEhEREhIRESERESERIYEiIRGBIhgRARGBgSEREhISEhISERESGIESIiIRIYgRARgRGBIhESEREhIREREhiBERIiIhGBEhAYEUEYESERERESERESIYGBEhEiIRERIhARFBGBiBEYERERERIhGBGBIRESEiIREhARQRgUEYgRESIiIiEYgRGBIRERIhESEhAUEYERQhGIgRERERiBEUGBIREYEiEhEhARGBFBFCERGIiIiIEYEUGBEhGIESISEhARgRgUEUJBgRERERiIEUIYERiBERISEhAYERgRQSQhGBERGIEYEUIYgYgSEhEhIhASEhGBQUJCGBJBGIiIEUJBiIERERESIhARERGBQSQhGBJBGBEYEUEUGBESEhIRIhASEhIYEUJCGBJBGIiIERRBgRgREREREhAREREYFCQhGBERERERREhBgUGBEhISERASEhIRgUJCGBREREREiIQYESQYERERERAEAC8AJQAAAACA42neFRHjZxERERASIiIiIhQkRCRCRCRCRCQRIiIiIiIiIhASIiIiIiFCRCRCRCRCQkESIiIiQiIiIhASIiIiIiIUIiRCIiRCJBEiIiIkRCIiIhARIiIiIiIhRERERERERBIiIiJEREIiIhAREiIiIiIhERERERERERIiIilEREkiIhARgSIiIiIhERGBIiIiIhEiIpRERESSIhARgSIiIiIhEYGBIiIiIhEiIpRERESSIhARgSIiIiIhgYGBIREhERgSJEREREREIhARgSIiEiIhgYGBEhESERgSREREREREQhARgSIhEiIhgYGBIiISIhgSJEREREREIhARgSEYEiIhgYGBIiISIhgSIpRERESSIhARERiBIiIhgYGBIiISIhgSIpRERESSIhAUiIERIiIhgYGBIiERIhgSIilEREkiIhARgRESIiIhgYGBIiIiIhgREiJEREIiIhAUgRIiIiEYgYGBIiERISgYgSIkRCIiIhARgSIiIhiBgYGBEiIiIRiBgSIiQiIiIhAUgSIiIhgRgRgUISIiEkGIgSIiIiIiIRARgSIiIhiIGIFERBERREQRERIiIiIiFBAUgSIiIhERERFEREREREESGBESIiIhgRARgSIiEUERIRERREREQRERGBIREiIhhBAUgSIRGBQRESEREREREREhGBEYgRIhgRARgREREYFBEREhERERESERGBIYgUERhBAUgRERERgUERERISEhIRFBGBERgURBgRARgRFBERGBQREREREREUFBGIEhiBFBhBARESEUEREYFBFBQUFBQUFBIYERGIgRgRASISGBQRERgUEUhISEhISBIYgSERiBhBARESEYFBERGBQRQUFBQUFBIRiBEhERgRASIRGBgUEREYFBEUFBQUFBIRGIgREhhBAREUQYERgRERgUEUFBQUFBIRIRiIERgRASESQYGIFBERGBQRSEhISBIRISEYiBhBARgURBgRFIEREYFBFBQUFBIRIRgRERgRARgSJBgYFIQRERgUERQUFBIRIREYFBhBAUgURBgRFISBEhGBQRQUFBIRIYgYEhgRARgSJBgYFIQRERFIFBFISBERIRGBRBhBAUgURBgRFIESERhEgUEUFBERGIGBQhgRARgSJBgYFBEREUGESBQRQRIRERgURBhBAEAC8AJQAAAACA42neFRHjZxERERASIiIiIiIiIhgYiBiIGIgYiIiBIiIiIhASIkRJIilEQiERgRGBEYERgRgSIiIiIhASJEREkpRERCIYiIiIiIiBiBEiESIiIhASREREQkREREIhREREREiIiBIhiBIiIhASREREREREREIhERERERRERBIhiBESIhASREREREREREIhIiIiIhERERERgSIRIhASREREREREREIhIiIiIhISEhIhgSIYEhASlERERERERJIRERIRERISEhEYgREYEhASKURERERESSEhESERIRISEhEYgRIhIhASKURERERESSEhIiEiIhISEhIYgSIhIhASIpREREREQiEhIiEiIhISEhIhERERIhASIiREREREIiEhIiEiIhISEiEiFERBIhASIiJERERCIhISIhESIiEhISEhEREREhASIiIkREQiIhISIiIiIiEiEhIRQUFBQRASIiIiREIiIiESEhESIiISEhIUREREERASIiIiJCIhEREiEiIiISEhISIRRERBIhASIiIiIiERQRIhISIhISEhIiEiERQSRBASIiIiERERFBESISEhIREiIRISIhEUQRASIiIRFBIhFEEhEiEhIhIREiIiEUERERASIhEiFBIiEUQRIhEhEhiBIhIhQUGBERASERISFBISIRRBEYESEYiBISIUgUERgRARiEEhIUEhIhRBGBgRiIgSIiFIFBERGBAYREESIUEiIhFEEYEYiIgRIiGEFBgRERAUQRERIhQSEiFEQRGIiIgSIhhBQRSIERAUEREUEhRBISEUQRiIiIEiEhQUQREYgRARgRFEQSFEEiIURBiIiBEhIhFEERFEiBAYRIERRBIURBIRQYiIgUEiIRRBERRESBAUSIhBEREhFEESEYiIgRIhFEEREUSEGBAUiIFIgRESIREREREREREUQRERFEREiBAYiBQRGBEREiIiRERERERBERERRIQYgRAYiBSIiBgSIiQRERERERESEREURESIgRAYiBQRGBgSIiIiIhREQSIiERFEhBiIERAYiBSIiBgSIiIiERJEQSEhERSERIiBERARiIFIgRERERERIRERQRIREREUGIgRFBARGIiBERERESIhGIiIESIREUQYiIERQRAUEYEREYiIgSIhGBQYEiEhiIiIiBERRBAEAC8AJQAAAACA42neFRHjZxERERASIiIiIiIRISEiERSIiIEiIiIiIiIiIhASIiIiIiESEhISERSBiBIiREkiKURCIhASIiIiIhERIRIiERSIiBIkRESSlEREIhASIiIiIhgSEiEiIRSBgSJERERCREREQhASIiIiIRgRIiIRIRRIgSJEREREREREQhASIiIiIYQSIiIiERFIgSJEREREREREQhASIiIiEYQRESERIRFEiBJEREREREREQhASIiIiGEQREhESEREUSBKUREREREREkhASIiIhGEQSIhIiISERQSIpRERERERJIhASIiIhhEgSIhIiISEREiIpRERERERJIhASIiIhhEgSIhIiISIRESIiRERERESSIhASIiIhhEgSIREiIhIRERIiJEREREQiIhASIiIYRIgSIiIiIhIhEREiIkREREIiIhASIiIYRIERIREiIYEiERESIiRERCIiIhASIiIYRBGBIhIiGIEiIREREiJEQiIiIhASIiIYQYEYEiIhiBESIhERERIkIiIiIhASIiIYEoERgREYgRGBIiERERIiIiIiIhASIiIRghgRGIiBERgSEiIRESIiESESIhASIiEYGEKBEREREYQoERIiEiIhiBiBIhASIhiIgYIYgREYiBKBEREREiIhhEQSIhASIRGBGBhCGIiBJIgRESIiISIiGEiBIhASGIiIiIGIhCFIiBEhEiEhIRIREYgSEhARERgRGIERGIiBERgRISIiFEGIgRGBEhAYiIiIiBEiEREYERgRIiIRRBiIEiEYEhAREYERGBISERERgYESEhFEERERIiGIEhAYiIiIgRIRESIRgYESIURBiIEhERGBIhARgYERgREhEiEhGBEhIUQYREEhQSESIhAYiIiIgSEhQRIhGBEiFEGESEESESESIhARGBgRgREhhEEiGBISFEGERBESEhIhIhAYiIiIgRIRiEQSERIhRBhEhBEhEhIhIhARgREYESEYGIQRERIhRBhERBIREiERIhAYiIiIESEYEYQRiBERRBhIRBISEiIUEhARgRiBESEYQYhBEYiBFBhEERIREhFEQRAYiIgUERIYQYRBgREYgRERRBEhEURERBAREYFEEhIYEYhBgYiBGIFESBISFEREQRAYiBREESEYGIQYGERIERRIiBESFERBGBAEAC8AJQAAAACA42jeFRHiZxERERASIiIiIhRCREJCRCQkRCQSIiIiIiIiIhARIhESIiFEJEJCRCQkQkEiREkiKURCIhAUEiGBIiIUQiJCIiQiJBEkRESSlEREIhAUEiGIEiIUREREREREQRJERERCREREQhAUEiGIEiIRERERERERERJEREREREREQhARERIYgSIhgYGBgSIiISJEREREREREQhASQkIhgSIhgYGBgSIRISJEREREREREQhASQkIiESIYGBgYEhEhISKUREREREREkhASEhIhgSIYGBgYEiIiJiIpRERERERJIhARERIYgSIYGBgYEiIiIhIpRERERERJIhAUEiGIEiIYGBgYEiIiIiEiRERERESSIhAUEiGIEiIYGBgYEiIRJhEiJEREREQiIhAUEiGBIiIYGBgYEhESISIiIkREREIiIhAUEhESIhEYGBgYEiIiISIiIiRERCIiIhAUEiIiIYiBGBgYEiIhESIiIiJEQiISIhAUEiIiGIGBgYEYEiIiISIiIiIkIhFBEhAUEiIiGBiBgYGBREIiIREREiIiIhREEhAUEiIiGIEYgYEUREQRGIGIgSIiIiFBIhAUEiIiIYiIGBFEREREQYgRgSIiERFBIhAUEiIiIREREYgRREREQRiIgSIhIiFBIhAUEiIhFCQYiIiIERERiIGIESISIiIREhAUEiERERQhGIiIiIiIiIgRJBESIRISEhAUERIkQREUIRGIiIiIgREkRBERIhEREhAUFEIiJEERFCQRERERFCREERFEEiEiEhARERRCIiRBERQkJCQkJEQREUQiIREREhAYiBEUQiIkQQoRFBER4PtEIiJBESEiEBiBiIEUQiIkQRFBIiFBEUQiIkQRIhEiEBgYiBiBFEIiJEEUEhQRRCIiRBGBISESEBERgYhBERRCIiQRQUEUIiJEEYiBIiIREBIiGIQRiIEUQiJBFBFCIiQRiIiBISEREBEiIUEYiIiBRCIkERQiJEGIiIiBIiIREBIhIRGBEREREUIiQUIiQRERERGBISEREBEiIhiBIiIiIUQiERIkQSIiIiGBIiIREBESEhiBIRERIRRBIiFEESERESGBISEREBESIiGBIYgRESESERIRIREYgSGBIiIREBERISGBIYgRIhEhREEhEiEYgSGBISEREAQALwAlAAAAAIDjad4VEeNnEREREBIiIiIiIiIiGIiIiIiIiIiIiIEiIiIiEBIiIiIhIiIiIYiIiIGBgYGBgRIiIiIiEBIiIiIREiIiIhGBgYFBQUFBQSIiIiIiEBIiIiERESIiIkFBQUREREREEiIiIiIhEBIiIhERERIiIiFEREEREREREiIiIiIREBIiIREREREiIiEREREiIiIiESIiIiGBEBIiERERERESIiEhISEiIiIiEhIiIiGBEBIhERERERERIiEhISERESEREhIiIiGBEBIhERERERERIiEhISESERIRESIiIiGBEBIREREREREREiEhISEiIhIiEhIiIiGBEBIREREREREREiEhISEiIhIiEhIiIiGBEBIREREREREREiEhISEiIhIiEhIiIiGBEBIREREhIREREiEhISEiIREiEhIiIiGBEBIhERIhIhERIiEhISEhEiISEhIiIiGBEBIiIiIREiIiIREhISEhIREiESESIiGBEBIiIiERESIiEiEhISEiIiIiEhIhIiGBEBIiIiIiIiIhISEhISEiEiISEhIhIiGBEBIiIiIiIiERIRIhISESEhISEiEYESGBEBIiIiIiIRGBEiISISEiEhESIRGBEhGBEBIiIiIhGBSBEREhEhIhISGBQRgRIUGBEBIiIiERGBEYEYERERESEhGBEYESERGBEBIiIRgYEYEYFBGBgYERERgUGBEhREGBEBIhFEEREYFBgUQRERGBgRgRGBEhQRGBEBIUiBGBEYERgURIiIEREYFBgRIUREGBEBGEQRERgRgRgURIERiEQYERgRIUERGBEBSIQRgYGBgUGBRIiIiEQYEYESFEREGBEBRIEREYERgRGBERERERGBQYESFBEREREBhEEYGBiIGBGBEiISIhGBEYESFBiIgREBiEERGBgRGBGBIhIiEiGBGBEhQYERiIEBSIEYGBiIGBQYEhISEiGBGBEhQYgSGIEBRIERGBgRGBEYEiISIhgUGBERRBERIREBhEEYGBiIgYEYEhIiEhgRGBgRFEREEREBSEERGBgREYEYERERERgRgRERERERIiEBRIEYEYGIgYEYGIiIiIgRgRERERIiEREBEUEREYGBEYEYERERERgRgYgRGBEhIiEBIhIRgRgYgYFIERREERgRgRGIEREiEREAQALwAlAAAAAIDjWd4VEeMnEREREBIiIiIiIRIRISEkGBGIiBIiIiIiIiIiEBIhIiIiERESEhEkGIGIgSIiIiEiIiIiEBIhIiIiESEhEiEkGIiIgSIiIhESIiIiEBIhIiIiERISISIUGBGIEiIiIRERIiIiEBIYEiIiEhEiIhIUGIGIEiIiEREREiIiEBIYEiIhEhIiIiEUQYiIgSIhERERESIiEBIYEiIhQhERIREUQYEYgSIRERERERIiEBIYEiIhQhESERIURBgYEiEREREREREiEBGIgSIhQhIiEiISRBiBIiEREREREREiEBGBgSIhQhIiEiIhREGBIhERERERERESEBGIgSIUQhIiEiIhJEQRIhERERERERESEBIYEiIUIRIhESIiFEQRIhERERERERESEBIYEiIUIRIiIiIiEkRBIhERESEhERESEBERESISEREhESIhQSREEiEREiEiEREiEBGIgSFCEREiEiIUESREESIiIhESIiIiEBIREiFCERgSIiERgRJEQRIiIRERIiIiEBGIgSFCGBGBERgYGIEkRBEiIiIiIiIiEBGIgSERGIEYGBgRiBESIiESIiIiRCIiEBIREiERGIiBERGIgRERERQRIiJEEUQiEBIUEhESEYGIiIgYERIhFERBgiRBiBRCEBIYEYESEYgYGBiBEiERREIYESJEEUQhEBIYFIgRERiIiIgRIRFERCGBGBEiRCIUEBEYFEgRIRgYGIESERREIhgRGIgSEiGEEBEYFEgRERGIiBEhFERCIYFBEYiBEhEYEBEYFEiBEhGIgRIRREQkQYEREREYEREYEBEYEkSBESERgSEURCJEQYFEQRERIiIYEBEYEUSIERGIEhFEQkRBEYERERESIiIYEBEYEhRIERhEgRREJEEREYgUREEiIiIYEBEYESRIgRhEgURCQREiERgRERIhIhGEEBEYEhFEiBhEgUQkERIiIRGBRBIREREUEBEYESFESIGIFEIRFCIRIhEYEREYEREREBEYEhIURIgRFCERIhEREiERgUGIGBEYEBEYESEhRERERBESIiIiIiIRGBiIGIiBEBEYEhISERERCRETERERiIiBGBARGBEhIURERAlED0REQRERGIEQERgSEg4REhESCxESERiIgREQBAAvACUAAAAAgONM3hUR4dcREREQEiIRIiFBREFBRBQURBRBIiIiIiIiIiIQEiGIEiIUFEFBRBQUQUQSIiIiISIiIiIQEhgUgSIhQRFBERQRFEEiIiIiERIiIiIQEhgUgSIiFEREREREREEiIiIhEREiIiIQEhgUgSIiEREREREREREiIiIRERESIiIQEiGIEiIiEiIiGBgYGBIiIiERERERIiIQEiIRIiIiEhEiGBgYGBIiIhEREREREiIQEiGIEiIiEhIRIYGBgYEiIRERERERESIQEhgUgSIiYiIiIYGBgYEiIRERERERESIQEiGIEiIhIiIiIYGBgYEiERERERERERIQEiIRIiISIiIiIYGBgYEiERERERERERIQEiGIEiIRIhEmIYGBgYEiERERERERERIQEhgUgSIiEiEWIYGBgYEiERERISERERIQEhgUgSIiEiIiIYGBgYgRIRESISIRESIQEhgUgSIiERIiGIGBgYiIEiIiERIiIiIQEiGIEiIiEiIiGIGIGBgYgSIhEREiIiIQEhEREiIhEiIiQRgYGBiBgSIiIiIiIiIQEhIiESERFiJERBgRgYEYgSIiIiIiIiIQEiESIRERERRERBGIGBiIESIiIiIiIiIQEhIhERIREREJEeDrESIiIiIiIhASEhESEhEREREREREREREhIREiIiIiIhASERIRESGBgYGBgYGBgYEhESERIiIiIhARQREhISEREREREREREREhISEUESIiIhAUEUEhERIUREREREREREEhESFEQREiERARFBESEhIRSESESESESEEhISFBEUQRgRARQRgSEREhREgYSEgYREEhESERRBGIgRAUEYGBISEhFIGEiISBhEEhISFEEYgRERARGBgRIRERgUhEgYRIREEhESERGIiIERARgYGBEhGBERESERIREhEhISERiBERGBAYGBgRERgRgQkhKxERGIiIgRgQEYGBFBGBGIESERIREhERISERiBgREYEQGIgRJBgREYEJERMRGIiIiBGBEBgRFEGBGIiBCSITIhiBgREYFBARESQYEYERgQlEE0GIiIiBGEQQERRBgRiIiBEJESMRgYEREYFEEBGEGBERgRgRGBEhIiESESEYiIiIGEREEAQAJwAnAAAAAIDi8MMJIg8iISIiIiIiIiIiIiAJIg8iERIiIiIiIiIiIiAJIg8hEREiIiIiIiIiIiAJIuJ7EREREiIiIiIiIiIgIiIiIiIiIiEREhERIiIiIiIiIiAiIiIiIiIiEREhIRESIiIiIiIiICIiIiIiIiEREhESEREiIiIiIiIgIiIiIiIiEREhEREhERIiIiIiIiAiIiIiIiEREhERERIRESIiIiIiICIiIiIiEREhERIRESEREiIiIiIgIiIiIiEREhERISEREhERIiIiIiAiIiIiEREhERIREhERIRESIiIiICIiIiEREhERIRIRIRESEREiIiIgIiIiEREhERIRISESEREhERIiIiAiIiEREhERIRIREhEhERIRESIiICIiEREhERIREhESERIRESEREiIgIiEREhERIRERISERESEREhERIiAiEREhERESERESERESERERIRESICIREhEREREhESEhESERERESERIgIRESERIRERISERISERESERIRESAhESERESESESESESESESERESERICERIRERIRESEhESEhERIRERIREgERIRESIRESERISERIRESIRESERAREhESERESERESERESERESERIREBESERIRESEREREREREhERIREhEQERIREhESERESERIRERIREhESERAREhERIiERESEhISERESIhERIREBESERERERESERIREhEREREREhEQERIRERERESERERERIRERERESERARESERERESERERERESERERESERECERIhEREiEREhESEREiERESIREgIRERIiIhEREiERIhEREiIiERESAiEREREREREiIREiIRERERERESICIhEREREREiIRERIiERERERESIgIiIhERERIiIhEREiIiEREREiIiAJIg8RERESIiIiIiIiIiAJIjcRERESIiIiIiIiIiAiIiIiIiIiIREREREiIiIiIiIiICIiIiIiIiIRERERERIiIiIiIiIgAQALAAsAAAAAgB8LBw4AAAAOHwAAAAduwAAADv/gAAAHdcAAAAoOAAAAAQAJAAoAAAAAgB8KBxwAAAAKPgAAAAddAAAADv+AAAAHawAAAAocAAAAAQAPAA8AAAAAgDIPCwOAAAAHwAAADg/gAAAPB8AAADu4AAB//AAADv/+AAATfXwAADk4AAADgAAAB8AAAAEACwALAAAAAIAiCw8IAAAAHAAAAD4AAAAOfwAAAA8+AAAAHAAAAAgAAAAJAAEACQAKAAAAAIAkCg8IAAAAHAAAAD4AAAAOfwAAABM+AAAAHAAAAAgAAAAAAAAAAQAPAA8AAAAAgDoPEwEAAAADgAAAB8AAAA/gAAAKH/AAAA8/+AAAf/wAAD/4AAAKH/AAABMP4AAAB8AAAAOAAAABAAAAAQALAAsAAAAAgCYLBQALdwAAAPeAAAAO/4AAABd/AAAAPgAAABwAAAAIAAAAAAAAAAEACQAKAAAAAIAkCgt3AAAA94AAAA7/gAAAF38AAAA+AAAAHAAAAAgAAAAAAAAAAQAPAA8AAAAAgDEPDzx4AAB+/AAA/v4AABL//gAACn/8AAAbP/gAAB/wAAAP4AAAB8AAAAOAAAABAAAAAQALAAsAAAAAgCMLBQATCAAAABwAAAA+AAAAfwAAAA7/gAAAB2sAAAAKHAAAAAEACQAKAAAAAIAhChMIAAAAHAAAAD4AAAB/AAAADv+AAAAHawAAAAocAAAAAQAPAA8AAAAAgDUPGwEAAAADgAAAB8AAAA/gAAAf8AAAP/gAAAp//AAADv/+AAAT/X4AAHk8AAADgAAAB8AAAAEADAAMAAAAAIAmDAoCAAAACgcAAAAKDYAAABMYwAAAH8AAAD/gAAAwYAAACnjwAAABAAoADAAAAACALwwrHwAAAD+AAAAxgAAAAYAAAAOAAAAHAAAADgAAABwAAAA5gAAAMYAAAAo/gAAAAQAKAAwAAAAAgC0MCj+AAAAXMwAAAAYAAAAMAAAAHwAAAB+AAAAKAYAAAA8xgAAAP4AAAB8AAAABAAoADAAAAACAKQwbAwAAAAcAAAAPAAAAHwAAADsAAABzAAAACn/AAAAKAwAAAAoHgAAAAQAKAAwAAAAAgCcMCn8AAAAKYAAAAAt+AAAAfwAAAAoDAAAACmMAAAALfwAAAD4AAAABAAoADAAAAACAKAwbDwAAAB8AAAA4AAAAMAAAAD8AAAA/gAAAEjGAAAALP4AAAB8AAAABAAoADAAAAACAGgwKP4AAAAcxgAAACgMAAAAOBgAAABIMAAAAAQAKAAwAAAAAgCYMCx8AAAA/gAAADjGAAAALHwAAAD+AAAAOMYAAAAs/gAAAHwAAAAEACgAMAAAAAIAoDAsfAAAAP4AAABIxgAAAGz+AAAAfgAAAAYAAAAOAAAAfAAAAHgAAAAEACgAMAAAAAIAYDAtngAAAb8AAACJswAAAC2/AAABngAAAAQAKAAwAAAAAgBkMCg8AAAAaBgAAAApmAAAAC34AAAA8AAAAAQAKAA4AAAAAgCAOCz4AAAB/AAAAImMAAAATfwAAAD4AAAAHAAAAAwAAAAEACgAMAAAAAIAsDAr3gAAAI2YAAABsAAAAeAAAAHAAAAB4AAAAbAAAAGYAAABjAAAACveAAAA='! !!PlayingCard class methodsFor: 'all' stamp: 'di 1/16/2000 10:38'!includeInNewMorphMenu	^false! !!PlayingCard class methodsFor: 'class initialization' stamp: 'asm 11/25/2003 22:35'!initialize	"PlayingCard initialize"	"Read the stored forms from mime-encoded data in imageData."	| forms f |	f := Base64MimeConverter				mimeDecodeToBytes: (ReadStream on: self imageData).	forms := OrderedCollection new.	f next = 2		ifFalse: [self error: 'corrupted imageData' translated].	[f atEnd]		whileFalse: [forms				add: (Form new readFrom: f)].	"1/2 image of Kc, Qc, Jc, ... d, h, s, and center image of As"	FaceForms := forms copyFrom: 1 to: 13.	"Images of small club, smaller club (for face cards), large club (for 	2-10, A), 	followed by 3 more each for diamonds, heardt, spaces, all as 1-bit 	forms. "	SuitForms := forms copyFrom: 14 to: 25.	"Images of A, 2, 3 ... J, Q, K as 1-bit forms"	NumberForms := forms copyFrom: 26 to: 38.	CardSize := 71 @ 96.	FaceLoc := 12 @ 11.	NumberLoc := 2 @ 4.	SuitLoc := 3 @ 18.	FaceSuitLoc := 2 @ 18.	TopSpotLocs := {{}. {28 @ 10}. {28 @ 10}. {15 @ 10. 41 @ 10}. {15 @ 10. 41 @ 10}. {14 @ 10. 42 @ 10}. {14 @ 10. 42 @ 10}. {14 @ 10. 28 @ 26. 42 @ 10}. {14 @ 10. 14 @ 30. 42 @ 10. 42 @ 30}. {14 @ 10. 14 @ 30. 42 @ 10. 42 @ 30. 28 @ 21}}.	"A"	"2"	"3"	"4"	"5"	"6"	"7"	"8"	"9"	"10"	MidSpotLocs := {{28 @ 40}. {}. {28 @ 40}. {}. {28 @ 40}. {14 @ 40. 42 @ 40}. {14 @ 40. 42 @ 40. 28 @ 26}. {14 @ 40. 42 @ 40}. {28 @ 40}. {}}.	"A"	"2"	"3"	"4"	"5"	"6"	"7"	"8"	"9"	"10"	ASpadesLoc := 16 @ 27! !!PlayingCard class methodsFor: 'all' stamp: 'di 10/18/1999 23:36'!test    "Display all cards in the deck"	"MessageTally spyOn: [20 timesRepeat: [PlayingCard test]]"	1 to: 13 do: [:i | 1 to: 4 do: [:j |		(PlayingCard the: i of: (#(clubs diamonds hearts spades) at: j)) cardForm				displayAt: (i-1*CardSize x)@(j-1*CardSize y)]]! !!PlayingCard class methodsFor: 'all' stamp: 'di 10/18/1999 23:22'!the: cardNo of: suitOrNumber	^ self new setCardNo: cardNo		suitNo: (suitOrNumber isNumber				ifTrue: [suitOrNumber]				ifFalse: [#(clubs diamonds hearts spades) indexOf: suitOrNumber])		cardForm: (Form extent: CardSize depth: Display depth)! !!PlayingCard methodsFor: 'all' stamp: 'di 10/18/1999 23:38'!blankCard 	CachedDepth = Display depth ifFalse:		[CachedDepth _ Display depth.		CachedBlank _ Form extent: CardSize depth: CachedDepth.		CachedBlank fillWhite; border: CachedBlank boundingBox width: 1.		CachedBlank fill: (0@0 extent: 2@2) fillColor: Color transparent.  "Round the top corners"		CachedBlank fill: (1@1 extent: 1@1) fillColor: Color black.		CachedBlank fill: (CachedBlank width-2@0 extent: 2@2) fillColor: Color transparent.		CachedBlank fill: (CachedBlank width-2@1 extent: 1@1) fillColor: Color black].	^ CachedBlank! !!PlayingCard methodsFor: 'all' stamp: 'ar 5/14/2001 23:39'!buildImage     "(PlayingCard the: 12 of: #hearts) cardForm display"	"World addMorph: (ImageMorph new image: (PlayingCard the: 12 of: #hearts) cardForm)"	"PlayingCard test"	| blt numForm suitForm spot face ace sloc colorMap fillColor |		"Set up blt to copy in color for 1-bit forms"	blt _ BitBlt current toForm: cardForm.	fillColor _ self color.	colorMap _ (((Array with: Color white with: fillColor)				collect: [:c | cardForm pixelWordFor: c])					 as: Bitmap).	blt copy: cardForm boundingBox from: 0@0 in: self blankCard.  "Start with a blank card image"	numForm _ NumberForms at: cardNo.  "Put number in topLeft"	blt copyForm: numForm to: NumberLoc rule: Form over colorMap: colorMap.	suitForm _ SuitForms at: suitNo*3-2.   "Put small suit just below number"	sloc _ SuitLoc.	cardNo > 10 ifTrue:		[suitForm _ SuitForms at: suitNo*3-1.   "Smaller for face cards"		sloc _ SuitLoc - (1@0)].	blt copyForm: suitForm to: sloc rule: Form over colorMap: colorMap.	cardNo <= 10	ifTrue:		["Copy top-half spots to the number cards"		spot _ SuitForms at: suitNo*3.   "Large suit spots"		(TopSpotLocs at: cardNo) do:			[:loc | blt copyForm: spot to: loc rule: Form over colorMap: colorMap]]	ifFalse:		["Copy top half of face cards"		face _ FaceForms at: suitNo-1*3 + 14-cardNo.		blt colorMap: self faceColorMap;			copy: (FaceLoc extent: face extent) from: 0@0 in: face].	"Now copy top half to bottom"	self copyTopToBottomHalf.	cardNo <= 10 ifTrue:		["Copy middle spots to the number cards"		(MidSpotLocs at: cardNo) do:			[:loc | blt copyForm: spot to: loc rule: Form over colorMap: colorMap]].	(cardNo = 1 and: [suitNo = 4]) ifTrue:		["Special treatment for the ace of spades"		ace _ FaceForms at: 13.		blt colorMap: self faceColorMap;			copy: (ASpadesLoc extent: ace extent) from: 0@0 in: ace]	! !!PlayingCard methodsFor: 'all' stamp: 'di 10/18/1999 23:31'!cardForm	^ cardForm! !!PlayingCard methodsFor: 'all' stamp: 'di 10/15/1999 09:12'!color	CachedDepth = 1 ifTrue: [^ Color black].	CachedDepth = 2 ifTrue: [^ Color perform: (#(black gray gray black) at: suitNo)].	^ Color perform: (#(black red red black) at: suitNo)! !!PlayingCard methodsFor: 'all' stamp: 'ar 5/28/2000 12:13'!copyTopToBottomHalf	"The bottom half is a 180-degree rotation of the top half (except for 7)"	| topHalf corners |	topHalf _ 0@0 corner: cardForm width@(cardForm height+1//2).	corners _ topHalf corners.	(WarpBlt current toForm: cardForm)		sourceForm: cardForm;		combinationRule: 3;		copyQuad: ((3 to: 6) collect: [:i | corners atWrap: i])		toRect: (CardSize - topHalf extent corner: CardSize).	! !!PlayingCard methodsFor: 'all' stamp: 'di 10/14/1999 20:17'!faceColorMap	| map |	map _ Color colorMapIfNeededFrom: 4 to: Display depth.	^ map! !!PlayingCard methodsFor: 'all' stamp: 'di 10/18/1999 23:23'!setCardNo: c suitNo: s cardForm: f	cardNo _ c.	suitNo _ s.	cardForm _ f.	self buildImage! !!MinesTile class methodsFor: 'new-morph participation' stamp: 'das 7/24/2001 00:11'!includeInNewMorphMenu	^false! !!MinesTile methodsFor: 'accessing' stamp: 'dgd 2/14/2003 21:59'!color: aColor 	super color: aColor.	onColor _ aColor.	offColor _ aColor.	self changed! !!MinesTile methodsFor: 'accessing' stamp: 'DAS 7/9/2001 13:14'!disabled	^ disabled! !!MinesTile methodsFor: 'accessing' stamp: 'DAS 7/9/2001 13:14'!disabled: aBoolean	disabled _ aBoolean.	disabled		ifTrue:			[self color: owner color.			self borderColor: owner color]		ifFalse:			[self setSwitchState: self switchState]! !!MinesTile methodsFor: 'accessing' stamp: 'dgd 2/22/2003 19:09'!doButtonAction: modifier 	"Perform the action of this button. The first argument of the message sent to the target is the current state of this switch, 	the second argument is the modifier button state."	(target notNil and: [actionSelector notNil]) 		ifTrue: 			[^target perform: actionSelector				withArguments: ((arguments copyWith: switchState) copyWith: modifier)]! !!MinesTile methodsFor: 'drawing' stamp: 'ar 12/31/2001 02:38'!drawOn: aCanvas 	"Draw a rectangle with a solid, inset, or raised border.	Note: the raised border color *and* the inset border color are generated	from the receiver's own color, instead of having the inset border color	generated from the owner's color, as in BorderedMorph."	| font rct |	borderWidth = 0 ifTrue: [  "no border"		aCanvas fillRectangle: bounds color: color.		^ self.].	borderColor == #raised ifTrue: [		^ aCanvas frameAndFillRectangle: bounds			fillColor: color			borderWidth: borderWidth			topLeftColor: color lighter lighter			bottomRightColor: color darker darker darker].	borderColor == #inset ifTrue: [		aCanvas frameAndFillRectangle: bounds			fillColor: color			borderWidth: 1 " borderWidth"			topLeftColor: (color darker darker darker)			bottomRightColor: color lighter.		self isMine ifTrue: [  			font  _ StrikeFont familyName: 'Atlanta' size: 22 emphasized: 1.			rct _ bounds insetBy: ((bounds width) - (font widthOfString: '*'))/2@0.			rct _ rct top: rct top + 1.			aCanvas drawString: '*' in: (rct translateBy: 1@1) font: font color: Color black.			^ aCanvas drawString: '*' in: rct font: font color: Color red .].		self nearMines > 0 ifTrue: [ 			font _ StrikeFont familyName: 'ComicBold' size: 22 emphasized: 1.			rct _ bounds insetBy: ((bounds width) - (font widthOfString: nearMines asString))/2@0.			rct _ rct top: rct top + 1.			aCanvas drawString: nearMines asString in: (rct translateBy: 1@1) font: font color: Color black.			^ aCanvas drawString: nearMines asString in: rct font: font color: ((palette at: nearMines) ) .].		^self. ].	"solid color border"	aCanvas frameAndFillRectangle: bounds		fillColor: color		borderWidth: borderWidth		borderColor: borderColor.! !!MinesTile methodsFor: 'initialization' stamp: 'ar 11/25/2001 14:56'!initialize	super initialize.	self label: ''.	self borderWidth: 3.	bounds _ 0@0 corner: 20@20.	offColor _ self preferredColor.	onColor _ self preferredColor.	switchState _ false.	oldSwitchState _ false.	disabled _ false.	isMine _ false.	nearMines _ 0.	self useSquareCorners.	palette _ (Color wheel: 8) asOrderedCollection reverse."	flashColor _ palette removeLast."! !!MinesTile methodsFor: 'accessing' stamp: 'DAS 7/9/2001 15:47'!isMine	^ isMine! !!MinesTile methodsFor: 'accessing' stamp: 'das 7/22/2001 19:49'!isMine: aBoolean	isMine _ aBoolean.! !!MinesTile methodsFor: 'accessing' stamp: 'das 7/22/2001 19:44'!mineFlag	^ mineFlag.! !!MinesTile methodsFor: 'accessing' stamp: 'das 7/22/2001 19:47'!mineFlag: boolean	mineFlag _ boolean.	mineFlag ifTrue: [		self color: Color red lighter lighter lighter lighter.]		ifFalse: [		self color: self preferredColor.].	^ mineFlag.! !!MinesTile methodsFor: 'event handling' stamp: 'das 7/21/2001 16:08'!mouseDown: evt 	"The only real alternative mouse clicks are the yellow button or the shift key. I will treat them as the same thing, and ignore two button presses for now. I am keeping this code around, because it is the only documentation I have of MouseButtonEvent."	| mod |"	Transcript show: 'anyModifierKeyPressed - '; show: evt anyModifierKeyPressed printString ; cr;			 show: 'commandKeyPressed - '; show: evt commandKeyPressed printString ;  cr;			 show: 'controlKeyPressed - '; show:evt controlKeyPressed printString ; cr;			 show: 'shiftPressed - '; show: evt shiftPressed printString ; cr;			 show: 'buttons - '; show: evt buttons printString ; cr;			 show: 'handler - '; show: evt handler printString ;  cr;			 show: 'position - '; show: evt position printString ; cr;			 show: 'type - '; show: evt type printString ; cr;			 show: 'anyButtonPressed - '; show: evt anyButtonPressed printString ; cr;			 show: 'blueButtonPressed - '; show: evt blueButtonPressed printString ; cr;			 show: 'redButtonPressed - '; show: evt redButtonPressed printString ; cr;			 show: 'yellowButtonPressed - '; show: evt yellowButtonPressed printString ; cr; cr; cr."					mod _  (evt yellowButtonPressed) | (evt shiftPressed). 	switchState ifFalse:[		(self doButtonAction: mod) ifTrue:			[mod ifFalse: [ self setSwitchState: true. ].].	] ifTrue: [			self doButtonAction: mod.].! !!MinesTile methodsFor: 'event handling' stamp: 'DAS 7/9/2001 13:16'!mouseMove: evt	"don't do anything, here"! !!MinesTile methodsFor: 'event handling' stamp: 'DAS 7/9/2001 13:16'!mouseUp: evt	"don't do anything, here"! !!MinesTile methodsFor: 'accessing' stamp: 'DAS 7/10/2001 14:27'!nearMines	^ nearMines.! !!MinesTile methodsFor: 'accessing' stamp: 'das 7/22/2001 19:48'!nearMines: nMines	nearMines _ nMines.! !!MinesTile methodsFor: 'initialization' stamp: 'di 11/26/2001 21:27'!preferredColor		"PreferredColor _ nil  <-- to reset cache"	PreferredColor ifNil:		["This actually takes a while to compute..."		PreferredColor _ Color gray lighter lighter lighter].	^ PreferredColor! !!MinesTile methodsFor: 'accessing' stamp: 'DAS 7/9/2001 13:15'!switchState	^ switchState! !!MinesTile methodsFor: 'accessing' stamp: 'das 7/22/2001 19:32'!switchState: aBoolean	switchState _ aBoolean.	disabled ifFalse:		[switchState			ifTrue:[				"flag ifTrue: [self setFlag]." "if this is a flagged tile, unflag it."				self borderColor: #inset.				self color: onColor]			ifFalse:[				self borderColor: #raised.				self color: offColor]]! !!SameGameTile class methodsFor: 'new-morph participation' stamp: 'di 1/16/2000 10:37'!includeInNewMorphMenu	^false! !!SameGameTile methodsFor: 'accessing' stamp: 'dgd 2/14/2003 21:59'!color: aColor 	super color: aColor.	onColor _ aColor.	offColor _ aColor.	self changed! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 08:46'!disabled	^ disabled! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:21'!disabled: aBoolean	disabled _ aBoolean.	disabled		ifTrue:			[self color: owner color.			self borderColor: owner color]		ifFalse:			[self setSwitchState: self switchState]! !!SameGameTile methodsFor: 'button' stamp: 'dgd 2/22/2003 19:00'!doButtonAction	"Perform the action of this button. The last argument of the message sent to the target is the new state of this switch."	(target notNil and: [actionSelector notNil]) 		ifTrue: 			[target perform: actionSelector				withArguments: (arguments copyWith: switchState)]! !!SameGameTile methodsFor: 'initialization' stamp: 'sw 11/30/1999 08:21'!initialize	super initialize.	self label: ''.	self borderWidth: 2.	bounds _ 0@0 corner: 16@16.	offColor _ Color gray.	onColor _ Color gray.	switchState _ false.	oldSwitchState _ false.	disabled _ false.	self useSquareCorners	! !!SameGameTile methodsFor: 'accessing' stamp: 'ar 8/26/2001 17:14'!insetColor	"Use my own color for insets"	^color! !!SameGameTile methodsFor: 'event handling' stamp: 'tao 5/18/1998 17:43'!mouseDown: evt	disabled ifFalse:		[oldSwitchState _ switchState.		self setSwitchState: (oldSwitchState = false).		self doButtonAction].! !!SameGameTile methodsFor: 'event handling' stamp: 'njb 9/29/2005 22:24'!mouseEnter: evt! !!SameGameTile methodsFor: 'event handling' stamp: 'njb 9/29/2005 22:15'!mouseLeave: evt! !!SameGameTile methodsFor: 'event handling' stamp: 'tao 5/18/1998 17:43'!mouseMove: evt	"don't do anything, here"! !!SameGameTile methodsFor: 'event handling' stamp: 'tao 5/18/1998 17:42'!mouseUp: evt	"don't do anything, here"! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:21'!setSwitchState: aBoolean	switchState _ aBoolean.	disabled ifFalse:		[switchState			ifTrue:				[self borderColor: #inset.				self color: onColor]			ifFalse:				[self borderColor: #raised.				self color: offColor]]! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:19'!switchState	^ switchState! !!AtomicAtom methodsFor: 'visual properties' stamp: 'GP 4/15/2003 23:38'!drawAtom: aCanvas bound: aBound 	"Draw the shadow and the body"	| newBound |	mapStyle isSmallScreen		ifTrue: [newBound _ aBound insetBy: 2]		ifFalse: [newBound _ aBound insetBy: 4.			"shadow"			aCanvas				fillOval: (newBound translateBy: 2)				color: Color veryVeryLightGray].	"draws the links"	self drawLinks: aCanvas.	"real color..."	aCanvas fillOval: newBound color: self defaultColor.	^ newBound! !!AtomicAtom methodsFor: 'visual properties' stamp: 'grp 8/21/2002 21:48'!drawBright: aCanvas bound: aBound 	"Circles representing light"	| selectedColor newBound |	selectedColor _ self defaultColor.	newBound _ aBound insetBy: 2.	1		to: 4		do: [:index | 			selectedColor _ selectedColor alphaMixed: 0.77 with: Color white.			aCanvas fillOval: newBound color: selectedColor.			newBound _ (newBound insetBy: 2)						translateBy: -1].	^ aBound! !!AtomicAtom methodsFor: 'visual properties' stamp: 'grp 8/21/2002 20:53'!drawLinks: aCanvas 	"Draw the list of arrows"	| lineWidth maxSize startPos linksCount endPos |	maxSize _ self bounds extent // 2.	startPos _ self bounds center.links ifNotNil: [	links		do: [:link | 			"for every link"			linksCount _ (links						select: [:item | item = link]) size.			lineWidth _ linksCount * 2.			endPos _ maxSize - lineWidth + linksCount * link + startPos.			"draw the line"			aCanvas				line: startPos				to: endPos				width: lineWidth				color: Color darkGray]]! !!AtomicAtom methodsFor: 'visual properties' stamp: 'GP 4/14/2003 22:46'!drawOn: aCanvas 	| newBound |	newBound _ self bounds.	"draws a basic shape of the atom"	newBound _ self drawAtom: aCanvas bound: newBound.	"Special behavior for small devices"	mapStyle		isSmallScreen ifFalse: [newBound _ self drawBright: aCanvas bound: newBound.			mapStyle isPreview				ifTrue: [self drawTitle: aCanvas]].	"draw the seleccion mark"	self drawActivation: aCanvas! !!AtomicAtom methodsFor: 'visual properties' stamp: 'GP 4/14/2003 23:17'!drawTitle: aCanvas 	"Draw the text inside"	| newBound text |	newBound _ Rectangle center: self bounds center + (3 @ 0) extent: 12 @ 12.	text _ self getText.	aCanvas		text: text		bounds: newBound		font: nil		color: Color white.aCanvas		text: text		bounds: (newBound translateBy: -1)		font: nil		color: (self defaultColor alphaMixed: 0.7 with: Color black)! !!AtomicAtom methodsFor: 'access properties' stamp: 'grp 5/1/2002 13:26'!forcedLinks: aLinks 	forcedLinks _ aLinks.	! !!AtomicAtom methodsFor: 'access properties' stamp: 'grp 8/21/2002 20:54'!fullyLinkedlinks		ifNotNil: [	"Verifies if all the links are ok"	(links			allSatisfy: [:link | self owner isAtom: self linkedTo: link])		ifFalse: [^ false].	"If has required links, verify them"	forcedLinks		allSatisfy: [:forced | links				anySatisfy: [:link | self owner						isAtomKind: forced						fromAtom: self						linkedTo: link]].].	"no more checks"	^ true! !!AtomicAtom methodsFor: 'access properties' stamp: 'grp 1/4/2002 09:23'!getTextself subclassResponsibility! !!AtomicAtom methodsFor: 'access properties' stamp: 'grp 2/2/2002 10:30'!isAtom	^ true! !!AtomicAtom methodsFor: 'access properties' stamp: 'grp 9/24/2001 00:54'!links: aLinks links _ aLinks! !!AtomicAtom methodsFor: 'access properties' stamp: 'grp 7/19/2002 18:00'!previewPosition^	previewPosition! !!AtomicAtom methodsFor: 'access properties' stamp: 'grp 8/21/2002 20:43'!previewPosition: aPosition 	previewPosition _ aPosition! !!AtomicCarbon methodsFor: 'access properties' stamp: 'grp 6/1/2002 23:34'!defaultColor	^ Color		r: 0		g: 0		b: 0.6! !!AtomicCarbon methodsFor: 'access properties' stamp: 'grp 1/3/2002 01:50'!getText	^ 'C'! !!AtomicFluor methodsFor: 'access properties' stamp: 'grp 7/27/2002 19:01'!defaultColor	^ Color		r: 1		g: 0		b: 0.4! !!AtomicFluor methodsFor: 'access properties' stamp: 'grp 1/12/2002 11:38'!getText	^ 'F'! !!AtomicHydrogen methodsFor: 'access properties' stamp: 'grp 6/1/2002 23:34'!defaultColor	^ Color		r: 0		g: 0.6		b: 0.0! !!AtomicHydrogen methodsFor: 'access properties' stamp: 'grp 12/29/2001 12:28'!getText	^ 'H'! !!AtomicLink methodsFor: 'visual properties' stamp: 'grp 2/2/2002 11:40'!drawOn: aCanvas 	| |	self drawLinks: aCanvas.	self drawActivation: aCanvas! !!AtomicNitrogen methodsFor: 'access properties' stamp: 'grp 6/1/2002 23:48'!defaultColor	^ Color		r: 0.6		g: 0.6		b: 0! !!AtomicNitrogen methodsFor: 'access properties' stamp: 'grp 1/26/2002 01:59'!getText	^ 'N'! !!AtomicOxygen methodsFor: 'access properties' stamp: 'grp 6/1/2002 23:34'!defaultColor	^ Color		r: 0.6		g: 0		b: 0.0! !!AtomicOxygen methodsFor: 'access properties' stamp: 'grp 9/4/2001 19:07'!getText	^ 'O'! !!AtomicBrick methodsFor: 'visual properties' stamp: 'grp 7/20/2002 02:37'!defaultColor	^ Color darkGray! !!AtomicBrick methodsFor: 'visual properties' stamp: 'GP 4/15/2003 23:45'!drawOn: aCanvas 	| rectBound rectColor |	rectBound _ self bounds.	rectColor _ self defaultColor.	aCanvas fillRectangle: rectBound fillStyle: rectColor.	rectBound _ rectBound insetBy: 1.	1		to: (mapStyle isSmallScreen				ifTrue: [2]				ifFalse: [4])		do: [:value | 			rectColor _ rectColor alphaMixed: 0.75 with: Color white.			aCanvas fillRectangle: rectBound fillStyle: rectColor.			rectBound _ rectBound insetBy: 2]! !!AtomicComponent class methodsFor: 'instance creation' stamp: 'grp 8/1/2002 22:16'!includeInNewMorphMenu	^ false! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 1/31/2002 22:56'!activate	isActive _ true.self changed.! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 2/2/2002 11:06'!canBeProgramed	^ isMoving not! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 1/31/2002 22:56'!deactivate	isActive _ false .self changed! !!AtomicComponent methodsFor: 'stepping and presenter' stamp: 'grp 8/22/2002 20:33'!doMovement	| distances direction |	self		position: (owner fastMoves				ifTrue: [futurePosition]				ifFalse: [distances _ futurePosition - self position.					direction _ distances x sign @ distances y sign.					self position + (direction + (distances // 6))])! !!AtomicComponent methodsFor: 'visual properties' stamp: 'grp 5/1/2002 16:31'!drawActivation: aCanvas 	"When is active has a border"	isActive		ifTrue: [aCanvas frameRectangle: self bounds color: Color black.			aCanvas				frameRectangle: (self bounds insetBy: 1)				color: self defaultColor]! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 12/25/2001 20:41'!fullyLinked^ false! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 4/15/2002 23:21'!initialize	super initialize.	isActive _ false.	isMoving _ false! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 2/2/2002 10:29'!isAtom	^ false! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 8/21/2002 20:41'!isMovable	^ mapStyle isPreview not! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 8/21/2002 20:39'!isPreview	^ mapStyle isPreview! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 8/21/2002 20:30'!mapStyle^ mapStyle! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 8/21/2002 20:02'!mapStyle: aMapStylemapStyle _ aMapStyle! !!AtomicComponent methodsFor: 'stepping and presenter' stamp: 'grp 8/22/2002 20:30'!startMovement: aNewPosition 	futurePosition _ aNewPosition.	isMoving _ true.	self startStepping! !!AtomicComponent methodsFor: 'stepping and presenter' stamp: 'grp 1/30/2002 22:31'!step	futurePosition = self position		ifTrue: [self stopMovement]		ifFalse: [self doMovement]! !!AtomicComponent methodsFor: 'stepping and presenter' stamp: 'grp 1/30/2002 22:32'!stepTime	^ 15! !!AtomicComponent methodsFor: 'stepping and presenter' stamp: 'grp 8/22/2002 20:31'!stopMovement	self stopStepping.	isMoving _ false.	futurePosition _ nil.	self owner checkIsCompleted! !!AtomicComponent methodsFor: 'stepping and presenter' stamp: 'grp 1/30/2002 22:32'!wantsSteps^isMoving! !!AtomicGame class methodsFor: 'parts bin' stamp: 'asm 4/20/2004 22:00'!descriptionForPartsBin	^ self		partName: 'Atomic'		categories: #('Games' )		documentation: 'A game where you have to build chemical molecules using given atoms.'! !!AtomicGame class methodsFor: 'instance creation' stamp: 'grp 8/1/2002 21:58'!includeInNewMorphMenu	^ true! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 8/5/2002 13:29'!availableMaps	| maps |	maps _ OrderedCollection new.	maps add: AtomicMap01;		 add: AtomicMap02;		 add: AtomicMap03;		 add: AtomicMap04;		 add: AtomicMap05;		 add: AtomicMap06;		 add: AtomicMap07;		 add: AtomicMap08;		 add: AtomicMap09;		 add: AtomicMap10.	maps add: AtomicMap11;		 add: AtomicMap12;		 add: AtomicMap13;		 add: AtomicMap14;		 add: AtomicMap15;		 add: AtomicMap16;		 add: AtomicMap17;		 add: AtomicMap18;		 add: AtomicMap19;		 add: AtomicMap20.	maps add: AtomicMap21;		 add: AtomicMap22;		 add: AtomicMap23;		 add: AtomicMap24;		 add: AtomicMap25;		 add: AtomicMap26;		 add: AtomicMap27;		 add: AtomicMap28;		 add: AtomicMap29; add: AtomicMap30.	^ maps! !!AtomicGame methodsFor: 'access properties' stamp: 'asm 4/20/2004 20:55'!checkIsCompleted	"Checks if the level is completed"	| map result |	result _ ((self submorphs				select: [:each | each isKindOf: AtomicAtom])				select: [:each | each isPreview not])				allSatisfy: [:each | each fullyLinked].	result		ifTrue: ["how many movements"			gameMoves _ gameMoves + mapMoves.			"Has next map?"			map _ self createNextMap.			map				ifNil: ["No selection"					self select: nil.					"show a final message"					infoMorph contents: 'YOU WON !!!!!!!!!!!!' translated]				ifNotNil: ["Go to the next level"					self goLevel: map]]! !!AtomicGame methodsFor: 'structure' stamp: 'GP 4/14/2003 22:44'!createButtonFor: anAction shortText: aShortText longText: aLongText hint: aHint 	| text |	text _ currentMap mapStyle				isSmallScreen ifTrue: [aShortText]				ifFalse: [aLongText].	^ (SimpleButtonMorph newWithLabel: text) target: self;		 actionSelector: anAction;		 useSquareCorners;		 borderWidth: 0;		 color: Color yellow twiceLighter;		 setBalloonText: aHint! !!AtomicGame methodsFor: 'structure' stamp: 'asm 4/20/2004 20:57'!createButtonsBar	| controlPosition moveStyleButton helpButton prevButton sameButton nextButton quitButton |	controlPosition _ currentMap borderSpace + (bounds origin x @ bounds corner y).	"Instructions"	helpButton _ self				createButtonFor: #showHelpWindow				shortText: '?'				longText: '? Help' translated				hint: 'Shows instructions' translated.	helpButton position: controlPosition.	self addMorph: helpButton.	"Go to previous map"	controlPosition _ controlPosition + (helpButton bounds width * 1.5 @ 0).	prevButton _ self				createButtonFor: #goPrevLevel				shortText: '<<'				longText: '< Prev' translated				hint: 'Jumps to the previous level' translated.	prevButton position: controlPosition.	self addMorph: prevButton.	"Restart this map"	controlPosition _ controlPosition + (prevButton bounds width * 1.2 @ 0).	sameButton _ self				createButtonFor: #goSameLevel				shortText: 'Rst' translated				longText: 'Reset' translated				hint: 'Restarts this level' translated.	sameButton position: controlPosition.	self addMorph: sameButton.	"Go to next map"	controlPosition _ controlPosition + (sameButton bounds width * 1.2 @ 0).	nextButton _ self				createButtonFor: #goNextLevel				shortText: '>>'				longText: 'Next >' translated				hint: 'Jumps to the next level' translated.	nextButton position: controlPosition.	self addMorph: nextButton.	"Moves style"	controlPosition _ controlPosition + (nextButton bounds width * 1.5 @ 0).	moveStyleButton _ self				createSwitchButtonFor: #moveStyleState:				shortText: 'F'				longText: 'Fast'				state: fastMoves				hint: 'Animation on/off' translated.	moveStyleButton position: controlPosition.	self addMorph: moveStyleButton.	"Close the game"	controlPosition _ controlPosition + (nextButton bounds width * 1.5 @ 0).	quitButton _ self				createButtonFor: #delete				shortText: '[X]'				longText: 'Quit' translated				hint: 'Closes the game' translated.	quitButton position: controlPosition.	self addMorph: quitButton.	"Extends the morph bound"	bounds _ bounds extendBy: 0 @ prevButton bounds height.	bounds _ bounds extendBy: currentMap borderSpace! !!AtomicGame methodsFor: 'structure' stamp: 'grp 7/19/2002 01:12'!createFirstMap	| maps |	maps _ self availableMaps.	^ (maps at: 1) new	! !!AtomicGame methodsFor: 'structure' stamp: 'grp 7/20/2002 01:04'!createMaze	| dx dy |	currentMap buildLayout: self.	dx _ currentMap neededSize x - bounds width.	dx > 0		ifTrue: [bounds _ bounds extendBy: dx @ 0].	dy _ currentMap neededSize y.	bounds _ bounds extendBy: 0 @ dy.	self changed! !!AtomicGame methodsFor: 'structure' stamp: 'grp 1/9/2002 00:24'!createNextMap	| maps mapName index |	maps _ self availableMaps.	mapName _ currentMap class.	index _ maps indexOf: mapName.	index < maps size		ifTrue: [^ (maps at: index + 1) new]		ifFalse: [^ nil]! !!AtomicGame methodsFor: 'structure' stamp: 'grp 1/9/2002 00:24'!createPrevMap	| maps mapName index |	maps _ self availableMaps.	mapName _ currentMap class.	index _ maps indexOf: mapName.	index > 1		ifTrue: [^ (maps at: index - 1) new]		ifFalse: [^ nil]! !!AtomicGame methodsFor: 'structure' stamp: 'grp 7/20/2002 02:05'!createPreview	| extra |	currentMap buildLayoutForPreview: self.	extra _ currentMap previewNeededSize x.	bounds _ bounds extendBy: extra @ 0.	self changed! !!AtomicGame methodsFor: 'structure' stamp: 'grp 1/5/2002 12:42'!createSameMap	| mapName |	mapName _ currentMap class.	^ mapName new! !!AtomicGame methodsFor: 'structure' stamp: 'GP 4/14/2003 22:45'!createSwitchButtonFor: anAction shortText: aShortText longText: aLongText state: aBoolean hint: aHint 	| text |	text _ currentMap mapStyle				isSmallScreen ifTrue: [aShortText]ifFalse: [aLongText].	^ (SimpleSwitchMorph newWithLabel: text) target: self;		 actionSelector: anAction;		 useSquareCorners;		 borderWidth: 0;		 offColor: Color yellow twiceLighter;		 onColor: Color orange;		 setSwitchState: aBoolean;		 setBalloonText: aHint! !!AtomicGame methodsFor: 'structure' stamp: 'GP 4/15/2003 22:40'!createTextBars	"title"	titleMorph _ StringMorph new contents: ' ATOMIC 1.2 ';				 font: Preferences windowTitleFont emphasis: 3.	titleMorph position: bounds origin x @ bounds corner y + currentMap borderSpace.	titleMorph color: Color blue twiceDarker.	self addMorph: titleMorph.	bounds _ bounds extendBy: 0 @ titleMorph bounds height + currentMap borderSpace.	"information"	infoMorph _ StringMorph new contents: self levelMessage.	infoMorph position: bounds origin x @ bounds corner y + currentMap borderSpace.	infoMorph color: Color gray twiceDarker.	self addMorph: infoMorph.	bounds _ bounds extendBy: 0 @ infoMorph bounds height + currentMap borderSpace.	"points"	pointsMorph _ StringMorph new contents: ''.	pointsMorph position: bounds origin x @ bounds corner y + currentMap borderSpace.	pointsMorph color: Color gray twiceDarker.	self addMorph: pointsMorph.	bounds _ bounds extendBy: 0 @ pointsMorph bounds height + currentMap borderSpace! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 8/1/2002 18:22'!defaultColor	^ Color yellow veryMuchLighter! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 8/22/2002 20:32'!fastMoves^fastMoves! !!AtomicGame methodsFor: 'structure' stamp: 'grp 8/1/2002 21:31'!getNextPosition: aDirection 	| currentPosition delta morph |	currentPosition _ selected position.	delta _ currentMap atomSize  * aDirection.	[morph _ self somethingAt: currentPosition + delta.	morph isNil]		whileTrue: [currentPosition _ currentPosition + delta].	^ currentPosition! !!AtomicGame methodsFor: 'structure' stamp: 'grp 7/19/2002 01:13'!goFirstLevel	| map |	map _ (self createFirstMap).	map		ifNotNil: [self goLevel: map]! !!AtomicGame methodsFor: 'structure' stamp: 'GP 4/14/2003 22:39'!goLevel: aMap 	"Initialization"	self select: nil.	self removeAllMorphs.	mapMoves _ 0.	currentMap _ aMap.	fastMoves		ifNil: [fastMoves _ currentMap mapStyle isSmallScreen].	bounds _ self position corner: self position.	"creates new controls"	self createTextBars.	self createButtonsBar.	self createMaze.	self createPreview.	"information"	self showPointsInfo.	"select the first atom"	self select: self nextMolecule! !!AtomicGame methodsFor: 'structure' stamp: 'grp 1/5/2002 12:14'!goNextLevel	| map |	map _ self createNextMap.	map		ifNotNil: [self goLevel: map]! !!AtomicGame methodsFor: 'structure' stamp: 'grp 1/5/2002 12:16'!goPrevLevel	| map |	map _ self createPrevMap.	map		ifNotNil: [self goLevel: map]! !!AtomicGame methodsFor: 'structure' stamp: 'grp 1/5/2002 12:41'!goSameLevel	| map |	map _ self createSameMap.	map		ifNotNil: [self goLevel: map]! !!AtomicGame methodsFor: 'event handling' stamp: 'grp 9/6/2001 22:21'!handlesKeyboard: evt 	^ true! !!AtomicGame methodsFor: 'event handling' stamp: 'grp 2/2/2002 12:03'!handlesMouseDown: evt 	| morph movable |	morph _ self somethingAt: evt position.	movable _ morph notNil				and: [morph isMovable].	movable		ifFalse: [self select: nil].^ movable! !!AtomicGame methodsFor: 'initialization' stamp: 'grp 8/22/2002 20:36'!initialize	super initialize.	gameMoves _ 0.	self position: 50 @ 50.	self goFirstLevel! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 8/1/2002 21:31'!isAtom: aAtom linkedTo: aLink 	| currentPosition delta |	currentPosition _ aAtom position.	delta _ currentMap atomSize  * aLink.	^ self isAtomAt: currentPosition + delta! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 2/2/2002 10:37'!isAtomAt: aPosition 	| morph |	morph _ self somethingAt: aPosition.^ morph notNil and:[ morph isAtom]! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 7/30/2002 16:34'!isAtomKind: aKind at: aPosition 	| morph |	morph _ self somethingAt: aPosition.		^ morph isKindOf: aKind! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 8/1/2002 21:31'!isAtomKind: aKind fromAtom: aAtom linkedTo: aLink 	| currentPosition delta |	currentPosition _ aAtom position.	delta _ currentMap atomSize  * aLink.	^ self isAtomKind: aKind at: currentPosition + delta! !!AtomicGame methodsFor: 'event handling' stamp: 'grp 8/23/2002 15:33'!keyStroke: evt 	| charValue |	charValue _ evt keyCharacter asciiValue.	"Tab pressed"	(charValue = 9			or: [charValue = 32])		ifTrue: [self select: self nextMolecule].	"This keys requires something selected"	selected		ifNotNil: ["Left pressed"			charValue = 28				ifTrue: [self makeMovement: -1 @ 0].			"Right pressed"			charValue = 29				ifTrue: [self makeMovement: 1 @ 0].			"Up pressed"			charValue = 30				ifTrue: [self makeMovement: 0 @ -1].			"Down pressed"			charValue = 31				ifTrue: [self makeMovement: 0 @ 1]].! !!AtomicGame methodsFor: 'access properties' stamp: 'asm 4/20/2004 20:56'!levelMessage	| number message |	number _ self availableMaps indexOf: currentMap class.	message _ 'Level ' translated, number asString.	currentMap mapStyle		isSmallScreen ifFalse: [message _ message , ': ' , currentMap levelName].	^ message! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 8/2/2002 16:36'!makeMovement: aDirection 	selected canBeProgramed		ifTrue: ["Increase the movements counter"			mapMoves _ mapMoves + 1.			self showPointsInfo.			"Moves the piece"			selected				startMovement: (self getNextPosition: aDirection)]! !!AtomicGame methodsFor: 'event handling' stamp: 'grp 2/2/2002 12:01'!mouseDown: evt 		self		select: (self somethingAt: evt position)! !!AtomicGame methodsFor: 'structure' stamp: 'grp 8/22/2002 20:34'!moveStyleState: aState 	fastMoves _ aState! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 7/23/2002 17:04'!nextMolecule	| current morph |	selected		ifNil: [current _ 0]		ifNotNil: [current _ submorphs indexOf: selected].	"get the next molecule since the current"	current + 1		to: submorphs size		do: [:index | 			morph _ submorphs at: index.(			(morph isKindOf: AtomicAtom) and: [morph isMovable])						ifTrue: [^ morph]].	"nothing"	^ nil! !!AtomicGame methodsFor: 'structure' stamp: 'GP 4/14/2003 22:46'!pointsMessage	| message |	message _ 'Record: ' , currentMap record asString.	message _ message , '   Moves: ' , mapMoves asString.	currentMap mapStyle		isSmallScreen ifFalse: [message _ message , '   Total: ' , gameMoves asString].	^ message! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 9/8/2001 19:19'!select: aMolecule 	selected == aMolecule		ifFalse: ["Replace the selected for the new one" selected				ifNotNil: [selected deactivate].			selected _ aMolecule.			selected				ifNotNil: [selected activate]]! !!AtomicGame methodsFor: 'structure' stamp: 'asm 4/20/2004 20:59'!showHelpWindow	((StringHolder new contents: 'Instructions:  The aim of ATOMIC is to build chemical molecules using given atoms. The goal is to solve a level with as few moves as possible.  The level is solved when the new molecule has the same structure as shown by the preview molecule (on the top right). In the higher levels, some tactical skill will be neccessary for solving the puzzle.  Clicking on an atom will cause to be selected (like with [Tab] key). The selected atom will move in any direction until it reaches a border or another atom. Direction is specified with cursor keys ([Up][Down][Left][Right]). If all the atoms touch each other with the corresponding connectors, they form a molecule. The atoms can only be moved one at a time. Controls:   ''Record'' shows the lowest number of moves used for this level.   ''Moves'' shows the current number of moves.   ''Total'' shows the number of moves in all the levels.    [Prev][Next] buttons on the top left changes the game level.    [Restart] button restarts to the current level.    [Quit] closes the game.Dedicated to:  - Smalltalk & Linux Comunities.Thanks to:  - Diego Gomez Deck.  - Alejandro Reimondo.  - Andreas Wüst.Implemented By:  Gustavo Rafael Pistoia.  ' translated)		embeddedInMorphicWindowLabeled: 'ATOMIC')		setWindowColor: (Color				r: 0.032				g: 0.968				b: 1.0);		 openInWorld: self world extent: 400 @ 320! !!AtomicGame methodsFor: 'structure' stamp: 'grp 8/2/2002 16:39'!showPointsInfo	pointsMorph contents: self pointsMessage.	mapMoves = currentMap record		ifTrue: [pointsMorph color: Color blue]		ifFalse: [mapMoves - 1 = currentMap record				ifTrue: [pointsMorph color: Color red]]! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 7/19/2002 18:20'!somethingAt: aPosition 	| morphs morph |	morphs _ self rootMorphsAt: aPosition.	morphs notEmpty		ifTrue: [morph _ morphs at: 1.			(morph isKindOf: AtomicComponent)				ifTrue: [^ morph]].	^ nil! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:18'!blackBishopImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 21053440 0 0 21053440 0 0 4538368 0 0 88489984 0 0 357978112 0 0 357994496 0 0 1431675904 0 1 1452647424 0 1 1452631040 0 5 1789487360 0 5 1789483264 0 5 1452628224 0 21 1452627200 0 21 1452626944 0 21 1431655424 0 21 1431655424 0 21 1431655424 0 21 1431654400 0 21 1431654400 0 5 1431654400 0 5 1431650304 0 1 1431650304 0 1 2863284224 0 1 2863284224 0 0 1431633920 0 0 445644800 0 1 1431650304 0 1 1789476864 0 1 1789476864 0 1 1431650304 0 0 20971520 0 0 89128960 0 0 357826560 0 21840 1414858069 0 349525 1410684245 1342177280 344085 1074091009 1342177280 262144 0 268435456 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:18'!blackKingImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 0 0 0 4194304 0 0 22020096 0 0 4194304 0 0 89391104 0 0 111411200 0 1398016 107216981 1426063360 22369600 107218261 1430257664 22456660 107222362 2772434944 89740885 111416741 1498415104 90527125 1162892885 1448083456 93672805 1095850325 1448083456 362108249 1431656790 2522087424 362190169 1435854230 2522087424 362190422 1452643686 2522087424 362112598 1431672169 1448345600 362112597 2505463146 2522087424 93760085 2505463145 1448083456 93678165 2526434665 1448083456 93673045 1704351141 1498415104 90527317 1700353429 1498415104 23418261 1700353429 1497366528 22631829 1499027029 1497366528 22631829 1503221333 1698693120 5657957 1503222101 1694498816 1463653 1499026773 2483027968 1414485 1499026774 1409286144 354986 2841291433 1342177280 87381 1431655765 1073741824 21845 1431655765 0 5802 2863311508 0 6485 1431655780 0 6485 1521046884 0 6485 1431655780 0 6826 2863311524 0 5461 1431655764 0 0 0 0 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!blackKnightImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 268435456 0 1 335544320 0 1 335544320 0 1 1430257664 0 0 1431568384 0 1 1431650304 0 21 1432704000 0 342 2774160704 0 1370 1767216464 0 5461 2505402708 0 21845 1431656021 0 87381 1431655829 0 349525 1431655781 1073741824 1398101 1431672149 1342177280 1398101 1431672153 1342177280 5592405 1431983446 1409286144 5592405 1343576406 1409286144 22369600 1402197 2483027968 26543360 5920085 2768240640 22287360 5593685 1694498816 22040576 23766357 1694498816 81920 89478485 1698693120 0 89478485 1698693120 0 357913941 1765801984 0 1431655765 1765801984 0 1431655765 1766850560 1 1431655765 1498415104 5 1431655765 1498415104 21 1431655765 1498415104 21 1431655765 1498415104 21 1431655765 1498415104 85 1431655765 1498415104 341 1431655765 1498415104 341 1431655765 1498415104 1365 1431655765 1498415104 1365 1431655765 1431306240 1365 1431655765 1431306240 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!blackPawnImage	^((ColorForm	extent: 40@40	depth: 1	fromArray: #( 0 0 15360 0 32256 0 32256 0 32256 0 32256 0 32256 0 15360 0 65280 0 262080 0 65280 0 32256 0 32256 0 65280 0 65280 0 65280 0 130944 0 262080 0 262080 0 524256 0 524256 0 524256 0 524256 0 524256 0 524256 0 524256 0 262080 0 262080 0 262080 0 130944 0 65280 0 65280 0 524256 0 4194300 0 8388606 0 16777215 0 33554431 2147483648 33554431 2147483648 33554431 2147483648 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032)  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!blackQueenImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 0 0 0 5242880 0 0 5242880 0 0 1048576 0 320 4194324 0 320 5242900 0 64 5242896 0 64 5242896 0 64 5242896 0 80 5242960 0 83886160 5242960 0 83886160 5242960 1310720 16777300 5243216 1310720 4194388 22282576 1048576 4194388 22282576 4194304 5242964 22282576 4194304 5505109 22283600 20971520 1310805 22283600 88080384 1376341 22283600 88080384 1392725 1096029520 356515840 1392725 1096029520 356515840 1396821 1096029520 1430257664 1397845 1431655761 1426063360 349269 1431655761 1426063360 349525 1431655765 1426063360 349525 1431655765 1426063360 349525 1431655765 1426063360 349525 1521112405 1426063360 88746 2773854890 1409286144 91477 1453938005 2483027968 27285 1436898666 2415919104 23125 1521112410 1342177280 6826 2773854890 1073741824 5461 1431655765 1073741824 21845 1431655765 1342177280 21845 1431655765 1342177280 0 0 0 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!blackRookImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 357826560 0 349184 357826645 1073741824 349184 357826645 1073741824 349184 357826645 1073741824 349525 1431655765 1073741824 436906 2863311530 1073741824 349526 1431721301 1073741824 1366 1431721296 0 1366 1431721296 0 1366 1431721296 0 1366 1431721296 0 1366 1431721296 0 1706 2863311504 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1706 2863311504 0 1366 1431721296 0 1366 1431721296 0 1366 1431721296 0 1366 1431721296 0 1366 1431721296 0 1706 2863311504 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1706 2863311504 0 23210 2863311525 0 27306 2863311529 0 87381 1431655765 1073741824 436906 2863311530 2415919104 436906 2863311530 2415919104 349525 1431655765 1342177280 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'parts bin' stamp: 'ar 8/13/2001 22:33'!descriptionForPartsBin	^ self partName: 	'Chess'		categories:		#('Games')		documentation:	'A fine game of chess'! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!whiteBishopImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 16842752 0 0 88424448 0 0 88424448 0 0 89473024 0 0 378966016 0 0 1520865280 0 1 1789240320 0 1 2842256384 0 5 2842321920 0 6 2505462784 0 22 2505479168 0 26 2842338304 0 26 2842338304 0 26 2842338304 0 26 2863309824 0 26 2863309824 0 26 2863309824 0 26 2863309824 0 26 2863305728 0 22 2863304704 0 6 2863288320 0 5 2863284224 0 1 1431650304 0 1 1431650304 0 1 1768505344 0 1 1768505344 0 1 1768505344 0 1 1431650304 0 5 2863284224 0 5 1431654400 0 0 104857600 0 0 374341632 0 0 1498677248 0 87381 1701139797 1073741824 1419946 2488969898 1409286144 349525 1343575381 1342177280 1310720 0 335544320 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!whiteKingImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 22020096 0 0 93585408 0 0 111411200 0 0 93585408 0 0 362020864 0 1397760 447021077 1409286144 5940480 425263450 2768240640 23767376 429458858 2839543808 94721684 425268885 1448083456 110536037 426072410 2794455040 379234921 1499818410 2777939968 442149466 1431676586 2846097408 443198102 2526451305 1772355584 443116133 2842319449 1772355584 443111785 2841270937 2846097408 443193769 1785293465 2577661952 442866090 1789504149 1503920128 443110826 1785309845 2846097408 376083882 1499048598 2845048832 106603946 2573838938 2777677824 110799274 2594548330 2794455040 110799210 2594613610 2794455040 93760106 2523310506 2521825280 27699802 2774968746 2587885568 23440026 2795939242 1497366528 6908570 2795939497 1694498816 5925546 2795940521 2751463424 1463637 1453675861 2483027968 371301 2506447274 1342177280 87641 2590415189 1073741824 26261 1431655845 0 21850 2774182229 0 21930 2505484885 0 21866 2842339669 0 22165 1431655829 0 21850 2863311189 0 21845 1431655765 0 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!whiteKnightImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 1073741824 0 16 1342177280 0 20 1342177280 0 5 1430257664 0 6 2857713664 0 6 2862956544 0 22 2863223808 0 346 2863306048 0 1445 1789569360 0 22166 1521134164 0 91813 1789569685 0 367274 2863245989 1073741824 1469098 2862983845 1342177280 1682090 2863049385 1342177280 5679786 2863048362 1409286144 22718890 2861996714 1409286144 27961706 2775210410 2499805184 95070809 1432708522 2499805184 111503701 22455978 2503999488 378889472 27957930 2773483520 374969344 94988970 2773483520 88428544 106343082 2773483520 84295680 359312042 2840592384 344064 1521134250 2840592384 1 1789569706 2840592384 1 2863311530 2840854528 5 2863311530 2857631744 22 2863311530 2857631744 26 2863311530 2857631744 90 2863311530 2857631744 106 2863311530 2857631744 362 2863311530 2857631744 1450 2863311530 2857631744 1706 2863311530 2857631744 5802 2863311530 2857631744 6826 2863311530 2857631744 23210 2863311530 2857631744 21845 1431655765 1431568384 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!whitePawnImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 357826560 0 0 446955520 0 0 1520762880 0 0 1789460480 0 0 1520762880 0 0 378798080 0 0 1431633920 0 1 1789476864 0 21 2863289344 0 85 1431655680 0 0 446955520 0 0 1520762880 0 0 1789460480 0 0 1789460480 0 1 1789476864 0 5 2863288320 0 6 2863304704 0 22 2863305728 0 26 2863309824 0 90 2863310080 0 106 2863311104 0 106 2863311104 0 106 2863311104 0 90 2863310080 0 26 2863309824 0 26 2863309824 0 22 2863305728 0 6 2863304704 0 5 2863288320 0 1 1789476864 0 0 1789460480 0 341 1520784704 0 1450 2505484880 0 22186 2863311509 0 92842 2863311529 1073741824 109226 2863311530 1073741824 109226 2863311530 1073741824 87381 1431655765 1073741824 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!whiteQueenImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 5242880 0 0 22282240 0 0 5242880 0 64 5242896 0 336 5242964 0 336 5242964 0 64 5242896 0 64 5242896 0 80 5242960 0 80 22282320 0 83886160 27525200 1310720 352321620 27525456 1376256 88080484 27525520 1376256 20971620 27525520 5242880 5242981 27526544 5242880 5505129 27526800 22020096 6553705 27526800 93323264 6619241 1101272720 105906176 6881386 1168448144 373293056 5849194 1185487504 440401920 1724522 1453939344 1514143744 1740906 2527685265 1782579200 1741930 2527685265 2856321024 1746282 2863311509 2856321024 1747306 2863311510 2856321024 1485482 2863311530 2839543808 436906 2863311530 2835349504 436906 2505403050 2835349504 365909 1515869525 1694498816 87466 2773854885 1409286144 21850 2841029205 1342177280 21866 2505403029 1342177280 21845 1521112405 1342177280 27306 2863311530 2415919104 27306 2863311530 2415919104 92842 2863311530 2483027968 87381 1431655765 1409286144 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!whiteRookImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 357892096 0 87360 447283221 1409286144 109120 447283226 2751463424 109120 447283226 2751463424 109141 1521046874 2751463424 109226 2863311530 2751463424 87381 1431655765 1409286144 426 1789553316 0 426 1789553316 0 426 1789553316 0 426 1789553316 0 426 1789553316 0 341 1431655764 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 341 1431655764 0 426 1789553316 0 426 1789553316 0 426 1789553316 0 426 1789553316 0 426 1789553316 0 341 1431655764 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 5461 1431655765 0 23210 2863311529 1073741824 27306 2863311530 1073741824 87381 1431655765 1342177280 371370 2863311530 2483027968 436906 2863311530 2751463424 349525 1431655765 1409286144 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph methodsFor: 'layout' stamp: 'ar 8/10/2001 11:50'!acceptDroppingMorph: aMorph event: anEvent	| destSquare sourceSquare |	sourceSquare _ aMorph valueOfProperty: #chessBoardSourceSquare.	aMorph removeProperty: #chessBoardSourceSquare.	destSquare _ self asSquare: aMorph center.	"!!!!!! ACTUAL MOVE HAPPENS INDIRECTLY !!!!!!"	(self atSquare: sourceSquare) addMorphCentered: aMorph.	destSquare ifNil:[^self].	self movePieceFrom: sourceSquare to: destSquare.	self showMovesAt: destSquare.! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 10/18/2001 21:01'!addButtonRow	| r m |	r _ AlignmentMorph newRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; color: Color transparent.	r addMorphBack: (self buttonName: '  New  ' action: #newGame).	r addMorphBack: (self buttonName: '  Help  ' action: #findBestMove).	r addMorphBack: (self buttonName: '  Play  ' action: #thinkAndMove).	r addMorphBack: (self buttonName: '  Auto  ' action: #autoPlay).	r addMorphBack: (self buttonName: '  Undo  ' action: #undoMove).	r addMorphBack: (self buttonName: '  Redo  ' action: #redoMove).	r addMorphBack: (self buttonName: '  Quit  ' action: #delete).	r disableTableLayout: true.	r align: r bounds topLeft with: self layoutBounds topLeft.	self addMorphFront: r.	m _ UpdatingStringMorph on: self selector: #statusString.	m useStringFormat.	m disableTableLayout: true.	m align: m bounds topLeft with: r fullBounds bottomLeft.	self addMorphFront: m.! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:34'!addSquares	| white black square index |	white _ Color white.	black _ Color lightGray.	index _ 0.	#(		(	' '	'a'	'b'	'c'	'd'	'e'	'f'	'g'	'h'	' ')		(	'1'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	' ')		(	'2'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	' ')		(	'3'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	' ')		(	'4'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	' ')		(	'5'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	' ')		(	'6'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	' ')		(	'7'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	' ')		(	'8'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	' ')		(	' '	' '	' '	' '	' '	' '	' '	' '	' '	' ')	) do:[:file|		file do:[:sq|		square _ self newSquare.		square borderWidth: 0.		(sq = 'W' or:[sq = 'B']) ifTrue:[			square color: (sq = 'W' ifTrue:[white] ifFalse:[black]).			square borderColor: Color red.			square setProperty: #squarePosition toValue: (index _ index + 1).			square setNameTo: 				(String with: ($a asInteger + (index - 1 bitAnd: 7)) asCharacter with: ($1 asInteger + (index -1 bitShift: -3)) asCharacter).			square on: #mouseEnter send: #showMoves:from: to: self.			square on: #mouseEnterDragging send: #dragSquareEnter:from: to: self.			square on: #mouseLeaveDragging send: #dragSquareLeave:from: to: self.		] ifFalse:["decoration"			square color: Color transparent.			sq = ' ' ifFalse:[				square addMorphCentered: (StringMorph contents: sq asUppercase font: Preferences windowTitleFont emphasis: 1).			].		].		square extent: 40@40.		self addMorphBack: square.	]].! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 8/10/2001 11:35'!addedPiece: piece at: square white: isWhite	| m |	m _ self newPiece: piece white: isWhite.	m on: #mouseDown send: #dragPiece:from: to: self.	m setProperty: #chessBoard toValue: self.	(self atSquare: square) removeAllMorphs; addMorphCentered: m.! !!ChessMorph methodsFor: 'drawing' stamp: 'ar 8/8/2001 23:59'!areasRemainingToFill: x	^x areasOutside: self bounds! !!ChessMorph methodsFor: 'geometry' stamp: 'ar 8/10/2001 11:46'!asSquare: aPoint	self squaresDo:[:sq| (sq bounds containsPoint: aPoint) ifTrue:[^sq valueOfProperty: #squarePosition]].	^nil! !!ChessMorph methodsFor: 'geometry' stamp: 'ar 8/10/2001 11:34'!atSquare: square	^submorphs detect:[:any| (any valueOfProperty: #squarePosition) = square] ifNone:[nil]! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 21:02'!autoPlay	autoPlay _ autoPlay not.	autoPlay ifTrue:[self thinkAndMove].! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 8/10/2001 12:25'!buttonFillStyle	| fill |	fill _ GradientFillStyle ramp: {		0.0 -> (Color r: 0.05 g: 0.5 b: 1.0). 		1.0 -> (Color r: 0.85 g: 0.95 b: 1.0)}.	fill origin: (0@0).	fill direction: 40@10.	fill radial: false.	^ fill! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 8/10/2001 12:18'!buttonName: aString action: aSymbol	^ SimpleButtonMorph new		target: self;		label: aString;		actionSelector: aSymbol;		color: (Color gray: 0.8);  "old color"		fillStyle: self buttonFillStyle;		borderWidth: 0;		borderColor: #raised.! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 10/18/2001 20:11'!completedMove: aMove white: aBool	board ifNil:[^self].	history addLast: aMove.	self validateGamePosition.! !!ChessMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:17'!defaultBorderColor"answer the default border color/fill style for the receiver"	^ #raised! !!ChessMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:17'!defaultBorderWidth"answer the default border width for the receiver"	^ 5! !!ChessMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:26'!defaultBounds	"answer the default bounds for the receiver"	^ 0 @ 0 corner: 410 @ 410! !!ChessMorph methodsFor: 'initialization' stamp: 'jam 3/9/2003 16:47'!defaultColor	"answer the receiver's default color"	| result |	result _ GradientFillStyle ramp: {0.0					-> (Color							r: 0.05							g: 0.5							b: 1.0). 1.0					-> (Color							r: 0.85							g: 0.95							b: 1.0)}.	result origin: self bounds origin;		 direction: self extent.	result radial: false.	^ result! !!ChessMorph methodsFor: 'drag and drop' stamp: 'ar 10/18/2001 20:11'!dragPiece: evt from: aMorph	board searchAgent isThinking ifTrue:[^self].	self submorphsDo:[:m| m borderWidth: 0].	aMorph setProperty: #chessBoardSourceSquare toValue: (aMorph owner valueOfProperty: #squarePosition).	evt hand grabMorph: aMorph.! !!ChessMorph methodsFor: 'drag and drop' stamp: 'ar 10/18/2001 20:11'!dragSquareEnter: evt from: aMorph	"Note: #wantsDroppedMorph: will validate move"	board ifNil:[^self].	evt hand hasSubmorphs ifFalse:[^self].	(self wantsDroppedMorph: evt hand firstSubmorph event: evt) ifFalse:[^self].	aMorph borderWidth: 1.! !!ChessMorph methodsFor: 'drag and drop' stamp: 'ar 10/18/2001 20:10'!dragSquareLeave: evt from: aMorph	board ifNil:[^self].	evt hand hasSubmorphs ifFalse:[^self].	aMorph borderWidth: 0.! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 20:18'!findBestMove	| move |	board searchAgent isThinking ifTrue:[^self].	Cursor wait showWhile:[move _ board searchAgent think].	self inform: 'I suggest: ', move printString.	^move! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 10/18/2001 20:13'!finishedGame: result	"		0 - white lost		0.5 - draw		1 - white won	"	board _ nil.! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 8/10/2001 11:33'!gameReset	self squaresDo:[:m| m removeAllMorphs; borderWidth: 0]! !!ChessMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:26'!initialize	"initialize the state of the receiver"	super initialize.	""	animateMove _ false.	autoPlay _ false.	self cornerStyle: #rounded.	self layoutPolicy: TableLayout new.	self listDirection: #leftToRight;		 wrapDirection: #bottomToTop.	self addSquares.	self addButtonRow.	self newGame! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 20:19'!movePieceFrom: sourceSquare to: destSquare	board ifNil:[^self].	board searchAgent isThinking ifTrue:[^self].	board movePieceFrom: sourceSquare to: destSquare.	board searchAgent startThinking.! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 10/18/2001 20:43'!movedPiece: piece from: sourceSquare to: destSquare	| sourceMorph destMorph sourcePos destPos w startTime nowTime deltaTime |	sourceMorph _ (self atSquare: sourceSquare) firstSubmorph.	destMorph _ self atSquare: destSquare.	animateMove ifTrue:[		sourcePos _ sourceMorph boundsInWorld center.		destPos _ destMorph boundsInWorld center.		(w _ self world) ifNotNil:[			w addMorphFront: sourceMorph.			sourceMorph addDropShadow.			sourceMorph shadowColor: (Color black alpha: 0.5).			deltaTime _ (sourcePos dist: destPos) * 10 asInteger.			startTime _ Time millisecondClockValue.			[nowTime _ Time millisecondClockValue.			nowTime - startTime < deltaTime] whileTrue:[				sourceMorph center: sourcePos + (destPos - sourcePos * (nowTime - startTime) // deltaTime) asIntegerPoint.				w displayWorldSafely].			sourceMorph removeDropShadow.		].	].	destMorph removeAllMorphs.	destMorph addMorphCentered: sourceMorph.	animateMove _ false.! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 22:38'!newGame	board ifNil:[board _ ChessBoard new].	board initialize.	board userAgent: self.	board initializeNewBoard.	history _ OrderedCollection new.	redoList _ OrderedCollection new.! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 8/10/2001 10:22'!newPiece: piece white: isWhite	| index selector m |	index _ piece.	isWhite ifFalse:[index _ index + 6].	selector _ #(			whitePawnImage		whiteKnightImage		whiteBishopImage		whiteRookImage		whiteQueenImage		whiteKingImage		blackPawnImage		blackKnightImage		blackBishopImage		blackRookImage		blackQueenImage		blackKingImage) at: index.	m _ ChessPieceMorph new image: (self class perform: selector).	m setProperty: #isWhite toValue: isWhite.	m setProperty: #piece toValue: piece.	^m! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 8/8/2001 22:53'!newSquare	^BorderedMorph new "or anyone alike"! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 20:13'!redoMove	"Redo the last undone move"	redoList isEmpty ifTrue:[^self].	board nextMove: redoList removeLast.! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 10/18/2001 20:47'!removedPiece: piece at: square	animateMove ifFalse:[		(self atSquare: square) removeAllMorphs.	].! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 8/9/2001 03:40'!replacedPiece: oldPiece with: newPiece at: square white: isWhite	self removedPiece: oldPiece at: square.	self addedPiece: newPiece at: square white: isWhite! !!ChessMorph methodsFor: 'other stuff' stamp: 'ar 8/10/2001 11:34'!rotateBoard	self listDirection = #leftToRight		ifTrue:[^self listDirection: #topToBottom; wrapDirection: #leftToRight].	self listDirection = #topToBottom		ifTrue:[^self listDirection: #rightToLeft; wrapDirection: #topToBottom].	self listDirection = #rightToLeft		ifTrue:[^self listDirection: #bottomToTop; wrapDirection: #rightToLeft].	self listDirection = #bottomToTop		ifTrue:[^self listDirection: #leftToRight; wrapDirection: #bottomToTop].! !!ChessMorph methodsFor: 'events' stamp: 'ar 10/18/2001 20:21'!showMoves: evt from: aMorph	| square |	square _ aMorph valueOfProperty: #squarePosition.	square ifNotNil:[^self showMovesAt: square].! !!ChessMorph methodsFor: 'events' stamp: 'ar 10/18/2001 20:13'!showMovesAt: square	| list |	board ifNil:[^self].	board searchAgent isThinking ifTrue:[^self].	self squaresDo:[:m| m borderWidth: 0].	list _ board activePlayer findValidMovesAt: square.	list isEmpty ifTrue:[^self].	(self atSquare: square) borderWidth: 1.	list do:[:move|		(self atSquare: move destinationSquare) borderWidth: 1.	].! !!ChessMorph methodsFor: 'geometry' stamp: 'ar 8/10/2001 11:34'!squaresDo: aBlock	^submorphs do:[:m| (m hasProperty: #squarePosition) ifTrue:[aBlock value: m]].! !!ChessMorph methodsFor: 'other stuff' stamp: 'ar 10/18/2001 20:10'!statusString	board ifNil:[^''].	^board statusString! !!ChessMorph methodsFor: 'stepping and presenter' stamp: 'ar 10/18/2001 21:02'!step	| move |	board searchAgent isThinking ifTrue:[		move _ board searchAgent thinkStep.		move ifNotNil:[			animateMove _ true.			board movePieceFrom: move sourceSquare 					to: move destinationSquare].	] ifFalse:[		autoPlay ifTrue:[board searchAgent startThinking].	].! !!ChessMorph methodsFor: 'testing' stamp: 'ar 8/12/2001 21:10'!stepTime	^0! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 20:19'!thinkAndMove	board searchAgent isThinking ifTrue:[^self].	board searchAgent startThinking.! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 20:11'!undoMove	"Undo the last move"	board ifNil:[^self].	history isEmpty ifTrue:[^self].	board undoMove: history removeLast.! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 10/18/2001 20:13'!undoMove: aMove white: aBool	board ifNil:[^self].	redoList addLast: aMove.	self validateGamePosition.! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 10/18/2001 20:23'!validateGamePosition	"This method does nothing but validating what you see (on screen) is what you get (from the board)."	| square piece isWhite p |	1 to: 64 do:[:idx|		square _ self atSquare: idx.		square hasSubmorphs 			ifTrue:[piece _ square firstSubmorph valueOfProperty: #piece.					isWhite _ square firstSubmorph valueOfProperty: #isWhite]			ifFalse:[piece _ 0. isWhite _ nil].		p _ board whitePlayer pieceAt: idx.		idx = board whitePlayer castlingRookSquare ifTrue:[p _ ChessPlayer rook].		isWhite == true ifTrue:[			p = piece ifFalse:[self error:'White broken'].		] ifFalse:[p = 0 ifFalse:[self error:'White broken']].		p _ board blackPlayer pieceAt: idx.		idx = board blackPlayer castlingRookSquare ifTrue:[p _ ChessPlayer rook].		isWhite == false ifTrue:[			p = piece ifFalse:[self error:'White broken'].		] ifFalse:[p = 0 ifFalse:[self error:'White broken']].	].! !!ChessMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/18/2001 20:11'!wantsDroppedMorph: aMorph event: anEvent	| sourceSquare destSquare |	(aMorph valueOfProperty: #chessBoard) == self ifFalse:[^false].	board ifNil:[^true].	sourceSquare _ aMorph valueOfProperty: #chessBoardSourceSquare.	destSquare _ self asSquare: aMorph bounds center.	destSquare ifNil:[^false].	^board activePlayer isValidMoveFrom: sourceSquare to: destSquare! !!ChineseCheckers class methodsFor: 'parts bin' stamp: 'sw 8/2/2001 01:21'!descriptionForPartsBin	^ self partName:	'ChineseCheckers'		categories:		#('Games')		documentation:	'Halma - the classic board game of Chinese Checkers, written by Dan Ingalls'! !!ChineseCheckers methodsFor: 'layout' stamp: 'ajh 2/15/2001 21:11'!acceptDroppingMorph: aPiece event: evt	| dropLoc |	dropLoc _ self boardLocAt: evt cursorPoint.	dropLoc = aPiece boardLoc ifTrue:  "Null move"		[^ aPiece rejectDropMorphEvent: evt].	(plannedMove _ (self allMovesFrom: aPiece boardLoc)				detect: [:move | move last = dropLoc]				ifNone: [nil])		ifNil: [^ aPiece rejectDropMorphEvent: evt.   "Not a valid move"].	super acceptDroppingMorph: aPiece event: evt.	movePhase _ 1.  "Start the animation if any."! !!ChineseCheckers methodsFor: 'menus' stamp: 'di 4/13/2000 13:23'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Include our modest command set in the ctrl-menu"	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	self addMenuItemsTo: aCustomMenu hand: aHandMorph! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 14:01'!addMenuItemsTo: aMenu hand: aHandMorph	aMenu add: 'new game' target: self action: #newGame.	aMenu add: 'reset...' target: self action: #reset.	animateMoves		ifTrue: [aMenu add: 'don''t animate moves' target: self action: #dontAnimateMoves]		ifFalse: [aMenu add: 'animate moves' target: self action: #animateMoves]! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/13/2000 14:18'!allMovesFrom: boardLoc  "boardLoc must be occupied"	| team stepMoves jumpDict |	team := self at: boardLoc.	stepMoves := (sixDeltas collect: [:d | boardLoc + d])		select: [:p | (self at: p) notNil and: [(self at: p) = 0]].	jumpDict := Dictionary new.	jumpDict at: boardLoc put: (Array with: boardLoc).	self jumpFor: team from: boardLoc havingVisited: jumpDict.	jumpDict removeKey: boardLoc.	^ (stepMoves collect: [:p | {boardLoc. p}]) , jumpDict values		reject:		[:move |  "Don't include any moves that land in other homes."		(self distFrom: move last to: self boardCenter) >= 5  "In a home..."			and: [(self distFrom: move last to: (homes atWrap: team+3)) > 3  "...not my goal..."			and: [(self distFrom: move last to: (homes at: team)) > 3  "...nor my home"]]]! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 13:36'!animateMoves	animateMoves _ true! !!ChineseCheckers methodsFor: 'accessing'!at: p	^ (board at: p x) at: p y! !!ChineseCheckers methodsFor: 'accessing'!at: p put: x	^ (board at: p x) at: p y put: x! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/12/2000 23:23'!bestMove: ply forTeam: team	| score bestScore bestMove |	bestScore := -999.	(teams at: team) do:		[:boardLoc |		(self allMovesFrom: boardLoc) do:			[:move |			score := self score: move for: team.			(score > -99 and: [ply > 0]) ifTrue: 				[score := score  "Add 0.7 * score of next move (my guess)"					+ (0 max: ((self score: ((self copyBoard makeMove: move)							bestMove: ply - 1 forTeam: team) for: team) * 0.7))].			score > bestScore ifTrue:				[bestScore := score.  bestMove := move]]].	^ bestMove! !!ChineseCheckers methodsFor: 'initialization'!board: b teams: t	board := b.	teams := t! !!ChineseCheckers methodsFor: 'board geometry'!boardCenter	^ 10@10! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 4/9/2000 10:00'!boardLocAt: cellPoint	| dx dy row col |	dx _ self width/15.0.  dy _ dx * 0.8660254037844385 "(Float pi / 3) sin".	row _ (cellPoint y - self position y) // dy + 1.	col _ (cellPoint x - self position x) / (dx/2.0) + 16 - row // 2.	^ row @ col! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 4/11/2000 17:18'!cellPointAt: boardLoc	| dx dy row col |	dx _ self width/15.0.  dy _ dx * 0.8660254037844385 "(Float pi / 3) sin".	row _ boardLoc x.	col _ boardLoc y.	^ self position + ((col*2+row-16*dx//2)@(row-1*dy)) asIntegerPoint! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/10/2000 08:27'!checkDoneAfter: move	| team locsAfterMove |	(team := self at: move first) = 0 ifTrue: [^ false].	(locsAfterMove _ (teams at: team) copy) replaceAll: move first with: move last.	^ self testDone: locsAfterMove for: team! !!ChineseCheckers methodsFor: 'initialization' stamp: 'di 4/9/2000 20:55'!copyBoard	"Return a copy of the board for the purpose of looking ahead one or more moves."	^ self copy		board: (board collect: [:row | row copy])		teams: (teams collect: [:team | team copy])! !!ChineseCheckers methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:18'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 0.6		g: 0.4		b: 0.0! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 3/13/2000 19:50'!distFrom: a to: b	"The six possible moves are: 1@0, 1@-1, 0@1, 0@-1, -1@0, -1@1."	| dx dy |	dx _ b x - a x.	dy _ b y - a y.	dx abs >= dy abs	ifTrue: ["Major change is in x-coord..."			dx >= 0			ifTrue: [(dy between: (0-dx) and: 0)						ifTrue: [^ dx  "no lateral motion"].					^ dx + ((0-dx) - dy max: dy - 0)  "added lateral dist"]			ifFalse: ["Reverse sign and rerun same code"					^ self distFrom: b to: a]]	ifFalse: ["Transpose and re-run same code"			^ self distFrom: a transposed to: b transposed]! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 13:36'!dontAnimateMoves	animateMoves _ false! !!ChineseCheckers methodsFor: 'drawing' stamp: 'di 8/10/2000 09:40'!drawOn: aCanvas 	| row1 row2 offset dotExtent |	super drawOn: aCanvas.   "Draw square board"	"Only draw rows in the clipping region"	dotExtent _ (self width//25) asPoint.	offset _ self pieceSize - dotExtent + 1 // 2.  "Offset of smaller dots rel to larger"	row1 _ (self boardLocAt: aCanvas clipRect topLeft) x max: 1.	row2 _ (self boardLocAt: aCanvas clipRect bottomRight) x min: board size.	row1 to: row2 do:		[:row | (board at: row) doWithIndex:			[:cell :i | cell ifNotNil:				[aCanvas fillOval: ((self cellPointAt: (row@i)) + offset extent: dotExtent)					color: (colors at: cell+1)]]]! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/12/2000 23:40'!endGameFor: team	"Return true if we are in the end game (all players within 1 of home triangle)."	| goalLoc |	goalLoc _ homes atWrap: team+3.  "Farthest cell across the board"	(teams at: team)		do: [:boardLoc | (self distFrom: boardLoc to: goalLoc) > 4 ifTrue: [^ false]].	^ true! !!ChineseCheckers methodsFor: 'geometry' stamp: 'di 4/11/2000 09:21'!extent: newExtent	| extraY |	extraY _ (newExtent x / 15.0 * 1.25) asInteger.	super extent: (newExtent x) @ (newExtent x + extraY).	self submorphsDo:		[:m | (m isKindOf: ChineseCheckerPiece) ifTrue:				[m position: (self cellPointAt: m boardLoc); extent: self pieceSize]]! !!ChineseCheckers methodsFor: 'event handling' stamp: 'sma 4/30/2000 09:23'!handlesMouseDown: evt	"Prevent stray clicks from picking up the whole game in MVC."	^ Smalltalk isMorphic not or: [evt yellowButtonPressed]! !!ChineseCheckers methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:19'!initialize	"Default creation is for one person against Squeak."	super initialize.	""	self extent: 382 @ 413.	animateMoves _ true.	self teams: #(2 5 ) autoPlay: {false. true}! !!ChineseCheckers methodsFor: 'parts bin' stamp: 'sw 6/28/2001 11:32'!initializeToStandAlone 	"Default creation is for one person against Squeak."	super initializeToStandAlone.	self extent: 382@413.	self color: (Color r: 0.6 g: 0.4 b: 0.0).	self borderWidth: 2.	animateMoves _ true.	self teams: #(2 5) autoPlay: {false. true}.! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/12/2000 20:36'!jumpFor: team from: loc havingVisited: dict	"Recursively explore all jumps from loc, leaving in dict	the prior position from which we got there"	"Fasten seatbelts..."	((((sixDeltas		collect: [:d | loc + d])		select: [:p | (self at: p) notNil and: [(self at: p) > 0]])		collect: [:p | p + (p - loc)])		select: [:p | (self at: p) notNil and: [(self at: p) = 0]])		do: [:p | (dict includesKey: p) ifFalse:			[dict at: p put: ((dict at: loc) copyWith: p).			self jumpFor: team from: p havingVisited: dict]]! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/10/2000 08:17'!makeMove: move	| team |	team := self at: move first.	self at: move last put: team.	self at: move first put: 0.	(teams at: team) replaceAll: move first with: move last! !!ChineseCheckers methodsFor: 'event handling' stamp: 'RAA 6/12/2000 08:57'!mouseDown: evt	| menu |	evt yellowButtonPressed ifFalse: [^ self].	menu _ MenuMorph new defaultTarget: self.	self addMenuItemsTo: menu hand: evt hand.	menu popUpEvent: evt in: self world.! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 13:32'!newGame	"Reset the board, with same teams."	| teamNumbers |	teamNumbers _ (1 to: 6) reject: [:i | (teams at: i) isEmpty].	self teams: teamNumbers		 autoPlay: (teamNumbers collect: [:i | autoPlay at: i]).! !!ChineseCheckers methodsFor: 'game sequence' stamp: 'di 4/13/2000 14:25'!nextTurn	(self testDone: (teams at: whoseMove) for: whoseMove) ifTrue:		[(self pieceAt: self turnIndicatorLoc) extent: self width asPoint//6; borderWidth: 2.		^ whoseMove _ 0.  "Game over."].		[whoseMove _ whoseMove\\6 + 1.	(teams at: whoseMove) isEmpty]  "Turn passes to the next player"		whileTrue: [].	(self pieceAt: self turnIndicatorLoc) color: (colors at: whoseMove+1)! !!ChineseCheckers methodsFor: 'drag and drop' stamp: 'di 4/8/2000 23:45'!okToPickUpPieceAt: boardLoc	^ (self at: boardLoc) = whoseMove and: [(autoPlay at: whoseMove) not]! !!ChineseCheckers methodsFor: 'drag and drop' stamp: 'di 4/9/2000 08:30'!pieceAt: boardLoc	self submorphsDo:		[:m | ((m isMemberOf: ChineseCheckerPiece) and: [m boardLoc = boardLoc])				ifTrue: [^ m]].	^ nil! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 4/11/2000 09:20'!pieceSize	^ self width asPoint // 20! !!ChineseCheckers methodsFor: 'printing' stamp: 'dgd 2/21/2003 23:14'!printOn: s 	"For testing only"	1 to: board size		do: 			[:row | 			s				cr;				next: row put: $ .			(board at: row) do: 					[:cell | 					s						space;						nextPut: (cell isNil ifTrue: [$-] ifFalse: [cell printString last])]]! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 13:31'!reset	"Reset the board, choosing anew how many teams."	| nPlayers nHumans |	nPlayers _ (SelectionMenu selections: (1 to: 6)) startUpWithCaption: 'How many players?'.	nPlayers ifNil: [nPlayers _ 2].	nHumans _ (SelectionMenu selections: (0 to: nPlayers)) startUpWithCaption: 'How many humans?'.	nHumans ifNil: [nHumans _ 1].	self teams: (#((1) (2 5) (2 4 6) (1 2 4 5) (1 2 3 4 6) (1 2 3 4 5 6)) at: nPlayers)		 autoPlay: ((1 to: nPlayers) collect: [:i | i > nHumans]).! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/13/2000 14:21'!score: move for: team	"Return the decrease in distance toward this team's goal"	| goal closerToGoal wasBack nowBack |	goal _ homes atWrap: team+3.	wasBack _ self distFrom: move first to: goal.	nowBack _ self distFrom: move last to: goal.	closerToGoal _ wasBack - nowBack.	closerToGoal < -1 ifTrue: [^ -99].  "Quick rejection if move backward more than 1"	(nowBack <= 3 and: [self checkDoneAfter: move]) ifTrue: [^ 999].	"Reward closerToGoal, but add bias to move those left far behind."	^ (closerToGoal*5) + wasBack! !!ChineseCheckers methodsFor: 'game sequence' stamp: 'di 4/11/2000 08:35'!showNextMoveSegment	"Display the current move in progress.  Starts with movePhase = 1.	Increments movePhase at each tick.  Ends by setting movePhase to 0."	| dot p1 p2 delta secondPhase line |	delta _ self width//40.	movePhase <= plannedMove size	ifTrue:		["First we trace the move with dots and lines..."		movePhase = 1 ifTrue: [pathMorphs _ OrderedCollection new].		p1 _ self cellPointAt: (plannedMove at: movePhase).		dot _ (ImageMorph new image: (Form dotOfSize: 7)) position: p1 + delta - (7//2).		self addMorph: dot.  pathMorphs addLast: dot.		movePhase > 1 ifTrue:			[p2 _ self cellPointAt: (plannedMove at: movePhase-1).			line _ PolygonMorph vertices: {p2 + delta. p1 + delta} color: Color black					borderWidth: 3 borderColor: Color black.			self addMorph: line.  pathMorphs addLast: line]]	ifFalse:		["...then we erase the path while moving the piece."		secondPhase _ movePhase - plannedMove size.		pathMorphs removeFirst delete.		secondPhase > 1 ifTrue:			[pathMorphs removeFirst delete.			self makeMove: {plannedMove at: secondPhase - 1. plannedMove at: secondPhase}.			(self pieceAt: (plannedMove at: secondPhase - 1))				position: (self cellPointAt: (plannedMove at: secondPhase));				setBoard: self loc: (plannedMove at: secondPhase).			self changed]].	(movePhase _ movePhase + 1) > (plannedMove size * 2)		ifTrue: [movePhase _ 0  "End of animated move"].! !!ChineseCheckers methodsFor: 'game sequence' stamp: 'dgd 2/21/2003 23:14'!step	whoseMove = 0 ifTrue: [^self].	"Game over."	plannedMove isNil 		ifTrue: 			[(autoPlay at: whoseMove) ifFalse: [^self].	"Waiting for a human."			plannedMove := (self endGameFor: whoseMove) 						ifTrue: 							["Look deeper at the end."							self bestMove: 2 forTeam: whoseMove]						ifFalse: [self bestMove: 1 forTeam: whoseMove].			movePhase := 1	"Start the animated move"].	animateMoves 		ifTrue: 			["Display the move in phases..."			movePhase > 0 ifTrue: [^self showNextMoveSegment]]		ifFalse: 			["... or skip the entire animated move if requested."			self makeMove: plannedMove.			(self pieceAt: plannedMove first)				position: (self cellPointAt: plannedMove last);				setBoard: self loc: plannedMove last.			self changed.			movePhase := 0].	plannedMove := nil.	"End the animated move"	self nextTurn! !!ChineseCheckers methodsFor: 'testing' stamp: 'di 4/12/2000 23:43'!stepTime	^ 200! !!ChineseCheckers methodsFor: 'initialization' stamp: 'di 4/12/2000 23:44'!teams: teamsPlaying autoPlay: ifAuto	"Initialize board, teams, steps, jumps"	| p q teamInPlay |	colors _ (#(gray) , #(red green blue cyan magenta yellow white) shuffled)				collect: [:c | Color perform: c].  "New set of colors each time."	self removeAllMorphs.  "eg, from previous game."	board := (1 to: 19) collect: [:i | Array new: 19].	sixDeltas := {0@1. -1@1. -1@0. 0@-1. 1@-1. 1@0}.	homes := {14@2. 18@6. 14@14. 6@18. 2@14. 6@6}.	teams := (1 to: 6) collect: [:i | OrderedCollection new].	autoPlay := (1 to: 6) collect: [:i | false].	1 to: 6 do:		[:team | p:= homes at: team.		(teamInPlay := teamsPlaying includes: team) ifTrue:			[autoPlay at: team put: (ifAuto at: (teamsPlaying indexOf: team))].		"Place empty cells in rhombus extending out from each		home, and occupied cells in active home triangles."		1 to: 5 do: [:i | q := p.			1 to: 5 do: [:j |				(teamInPlay and: [j <= (5 - i)])					ifTrue: [self at: q put: team.							(teams at: team) add: q.							self addMorph:								((ChineseCheckerPiece									newBounds: ((self cellPointAt: q) extent: self pieceSize)									color: (colors at: team+1))										setBoard: self loc: q)]					ifFalse: [self at: q put: 0].				q := q + (sixDeltas at: team).  "right,forward"].			p := p + (sixDeltas atWrap: team+1).  "left,forward"].		teams at: team put: (teams at: team) asArray].	whoseMove _ teamsPlaying first.	self addMorph:		((ChineseCheckerPiece			newBounds: ((self cellPointAt: self turnIndicatorLoc) extent: self pieceSize)			color: (colors at: whoseMove+1))				setBoard: self loc: self turnIndicatorLoc).	plannedMove _ nil.	self changed! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/12/2000 23:40'!testDone: teamLocs for: team	"Return true if we are done (all players in home triangle)."	| goalLoc |	goalLoc _ homes atWrap: team+3.	teamLocs		do: [:boardLoc | (self distFrom: boardLoc to: goalLoc) > 3 ifTrue: [^ false]].	^ true! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 4/9/2000 09:44'!turnIndicatorLoc	^ 16@11! !!ChineseCheckers methodsFor: 'dropping/grabbing' stamp: 'di 4/9/2000 10:44'!wantsDroppedMorph: aPiece event: evt	^ aPiece isKindOf: ChineseCheckerPiece! !!WordGameLetterMorph class methodsFor: 'new-morph participation' stamp: 'di 5/10/2000 07:42'!includeInNewMorphMenu	^ false! !!WordGameLetterMorph class methodsFor: 'class initialization' stamp: 'di 5/11/2000 07:15'!initialize  "WordGameLetterMorph initialize"	IDFont _ StrikeFont familyName: 'ComicPlain' size: 13.	IDHeight _ IDFont height.	LetterFont _ StrikeFont familyName: 'ComicBold' size: 19.	LetterHeight _ LetterFont height.! !!WordGameLetterMorph methodsFor: 'style inits' stamp: 'di 5/7/2000 17:00'!boxed	style _ #boxed! !!WordGameLetterMorph methodsFor: 'event handling' stamp: 'di 10/14/2000 22:36'!handlesKeyboard: evt	^ true! !!WordGameLetterMorph methodsFor: 'initialization' stamp: 'di 5/11/2000 07:33'!id2: idString	"Add further clue id for acrostic puzzles."	| idMorph |	idString ifNotNil:		[idMorph _ StringMorph contents: idString font: IDFont.		idMorph align: idMorph bounds topRight with: self bounds topRight + (-1@-1).		self addMorph: idMorph].! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'di 5/7/2000 13:42'!indexInQuote	^ indexInQuote! !!WordGameLetterMorph methodsFor: 'initialization' stamp: 'dgd 2/21/2003 23:15'!indexInQuote: qi id1: aString 	"Initialize me with the given index and an optional aString"	| idMorph y |	style = #boxed		ifTrue: [aString isNil				ifTrue: [self extent: 18 @ 16;						 borderWidth: 1]				ifFalse: [self extent: 26 @ 24;						 borderWidth: 1]]		ifFalse: [aString isNil				ifTrue: [self extent: 18 @ 16;						 borderWidth: 0]				ifFalse: [self extent: 18 @ 26;						 borderWidth: 0]].	qi		ifNil: [^ self color: Color gray].	"blank"	self color: self normalColor.	indexInQuote _ qi.	style == #underlined		ifTrue: [y _ self bottom - 2.			aString				ifNotNil: [y _ y - IDFont ascent + 2].			lineMorph _ PolygonMorph						vertices: {self left + 2 @ y. self right - 3 @ y}						color: Color gray						borderWidth: 1						borderColor: Color gray.			self addMorph: lineMorph.			aString				ifNil: [^ self].			idMorph _ StringMorph contents: aString font: IDFont.			idMorph align: idMorph bounds bottomCenter with: self bounds bottomCenter + (0 @ (IDFont descent - 1)).			self addMorphBack: idMorph]		ifFalse: [aString				ifNil: [^ self].			idMorph _ StringMorph contents: aString font: IDFont.			idMorph align: idMorph bounds topLeft with: self bounds topLeft + (2 @ -1).			self addMorph: idMorph			" 			World addMorph: (WordGameLetterMorph new boxed  			indexInQuote: 123 id1: '123';  			id2: 'H'; setLetter: $W).  			World addMorph: (WordGameLetterMorph new underlined  			indexInQuote: 123 id1: '123';  			setLetter: $W).  			World addMorph: (WordGameLetterMorph new underlined  			indexInQuote: 123 id1: nil;  			setLetter: $W). 			"]! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'dgd 2/21/2003 23:15'!isBlank	^indexInQuote isNil! !!WordGameLetterMorph methodsFor: 'event handling' stamp: 'di 5/9/2000 16:20'!keyboardFocusChange: boolean	| panel |	boolean ifFalse:		[panel _ self nearestOwnerThat: [:m | m respondsTo: #checkForLostFocus].		panel ifNotNil: [panel checkForLostFocus]]! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'di 5/7/2000 23:31'!letter	^ letter! !!WordGameLetterMorph methodsFor: 'linking' stamp: 'dgd 2/21/2003 23:15'!morphsInWordDo: aBlock 	aBlock value: self.	(successor isNil or: [successor isBlank]) ifTrue: [^self].	successor morphsInWordDo: aBlock! !!WordGameLetterMorph methodsFor: 'linking' stamp: 'di 5/7/2000 14:06'!nextTypeableLetter	successor ifNil: [^ self].	successor isBlank ifTrue: [^ successor nextTypeableLetter].	^ successor! !!WordGameLetterMorph methodsFor: 'initialization' stamp: 'di 5/8/2000 11:22'!normalColor	^ Color r: 1.0 g: 0.8 b: 0.2! !!WordGameLetterMorph methodsFor: 'style inits' stamp: 'di 5/7/2000 17:00'!plain	style _ #plain! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'di 5/7/2000 13:43'!predecessor	^ predecessor! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'di 5/7/2000 13:25'!predecessor: pred	predecessor _ pred! !!WordGameLetterMorph methodsFor: 'linking' stamp: 'di 5/7/2000 14:19'!previousTypeableLetter	predecessor ifNil: [^ self].	predecessor isBlank ifTrue: [^ predecessor previousTypeableLetter].	^ predecessor! !!WordGameLetterMorph methodsFor: 'initialization' stamp: 'di 5/7/2000 23:58'!setLetter: aLetter	^ self setLetter: aLetter color: Color black! !!WordGameLetterMorph methodsFor: 'initialization' stamp: 'dgd 2/21/2003 23:15'!setLetter: aLetter color: aColor 	letterMorph ifNotNil: [letterMorph delete].	letter := aLetter.	letter ifNil: [^letterMorph := nil].	letterMorph := StringMorph contents: aLetter asString font: LetterFont.	letterMorph color: aColor.	style == #boxed 		ifTrue: 			[letterMorph align: letterMorph bounds bottomCenter				with: self bounds bottomCenter + (0 @ (LetterFont descent - 2))]		ifFalse: 			[lineMorph isNil 				ifTrue: 					[letterMorph align: letterMorph bounds bottomCenter						with: self bounds bottomCenter + (0 @ (LetterFont descent - 4))]				ifFalse: 					[letterMorph align: letterMorph bounds bottomCenter						with: self center x @ (lineMorph top + LetterFont descent)]].	self addMorphBack: letterMorph! !!WordGameLetterMorph methodsFor: 'linking' stamp: 'dgd 2/21/2003 23:15'!startOfWord	(predecessor isNil or: [predecessor isBlank]) ifTrue: [^self].	^predecessor startOfWord! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'di 5/7/2000 13:43'!successor	^ successor! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'di 5/7/2000 13:25'!successor: succ	successor _ succ! !!WordGameLetterMorph methodsFor: 'style inits' stamp: 'di 5/7/2000 17:01'!underlined	style _ #underlined! !!WordGameLetterMorph methodsFor: 'typing' stamp: 'di 5/8/2000 11:21'!unhighlight	(self isBlank or: [self color = self normalColor])		ifFalse: [self color: self normalColor]! !!CipherPanel class methodsFor: 'parts bin' stamp: 'sw 8/2/2001 01:21'!descriptionForPartsBin	^ self partName:	'Cipher'		categories:		#('Games')		documentation:	'The Cipher Panel: A playground for cryptograms, by Dan Ingalls'! !!CipherPanel class methodsFor: 'as yet unclassified' stamp: 'di 10/4/2000 10:42'!encode: aString	"CipherPanel encode: 'Now is the time for all good men to come to the aid of their country.'"	| dict repeat |	dict _ Dictionary new.	repeat _ true.	[repeat] whileTrue:		[repeat _ false.		($A to: $Z) with: ($A to: $Z) shuffled do:			[:a :b | a = b ifTrue: [repeat _ true].			dict at: a put: b]].	^ aString asUppercase collect: [:a | dict at: a ifAbsent: [a]]! !!CipherPanel class methodsFor: 'new-morph participation' stamp: 'di 5/10/2000 09:52'!includeInNewMorphMenu	^ true! !!CipherPanel class methodsFor: 'instance creation' stamp: 'di 5/10/2000 10:08'!new	"NOTE: Use newFromQuote: rather than new to create new CipherPanels"	^ self newFromQuote: self sampleString" Here are some other examples...World addMorph: (CipherPanel newFromQuote: 'BPFFXY LZY PK ROY RPBY PG XPAY HOYG EJCM SXJROYK FJG''R APR QCR PR''K EJC HOJ GYYF ROY LXRYMLRPJGK.  KJCMSY CGNGJHG')World addMorph: (CipherPanel newFromQuote: 'Y FRV TRK HJRH QVL QS HJL BPLRHLTH WZLRTXPLT YV ZYSL YT OQYVB MJRH WLQWZL TRK KQX FRVVQH OQ.')World addMorph: (CipherPanel newFromQuote: 'XI''H SAZRG: SDCIZCIZT EZDEAZ TD CDI SGZRIZ EGDPGZHH.')World addMorph: (CipherPanel newFromQuote: 'PY MOJ WPMMWJ MZGYR ZL MOJ GZSWH PM''R YZ RZZYJS HZYJ MOBY RBPH.')World addMorph: (CipherPanel newFromQuote: 'PYSLHYA DJP VBHHLXYAA BPY BGNBMA PLUVQ LX AQMGY; QVY HPLXSLHBG LXUPYCLYXQA BPY NBPK BXC DPLYXCGM AKLGYA.')World addMorph: (CipherPanel newFromQuote: 'U HWVS RJ AHOST RLO FOOQOST TJUSM AJIO LOVNC WUXRUSM VST HWVCUSM LVSTZVWW. -- TVNUT WORROEIVS VXROE LUA KGUSRGHWO-ZCHVAA LOVER JHOEVRUJS')"! !!CipherPanel class methodsFor: 'as yet unclassified' stamp: 'di 5/10/2000 10:06'!newFromQuote: encodedString	"Use this to creat new panels instead of new."	^ super new encodedQuote: encodedString! !!CipherPanel class methodsFor: 'as yet unclassified' stamp: 'asm 11/25/2003 22:20'!randomComment	"CipherPanel randomComment"	"Generate cryptic puzzles from method comments in the system"	| c s |	s := 'none'.	[s = 'none']		whileTrue: [s := ((c := SystemNavigation new allClasses atRandom) selectors						collect: [:sel | (c firstCommentAt: sel) asString])						detect: [:str | str size between: 100 and: 200]						ifNone: ['none' translated]].	^ s! !!CipherPanel class methodsFor: 'as yet unclassified' stamp: 'di 5/8/2000 11:58'!sampleString	^'E SGJC OSCVC LICGNV, ENGRCV, JEVEMAV. E SGJC OSEV QGVVEMA XMI [SMWWDHMML] ... EO''V HMALCIXKW OM SGJC VMNCOSEAR OSGO EAVQEICV GAL LIEJCV DMK. -- ZGIZIG VOICEVGAL'! !!CipherPanel class methodsFor: 'as yet unclassified' stamp: 'di 10/4/2000 10:45'!tedsHack  	"Generate cryptic puzzles from method comments in the system"	(self newFromQuote: (self encode: (self randomComment))) openInWorld"CipherPanel tedsHack"! !!CipherPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:21'!addMenuItemsTo: aMenu hand: aHandMorph 	aMenu		add: 'show cipher help' translated		target: self		action: #showHelpWindow.	aMenu		add: 'show cipher hints' translated		target: self		action: #showHintsWindow.	aMenu		add: 'clear cipher typing' translated		target: self		action: #clearTyping.	aMenu		add: 'enter a new cipher' translated		target: self		action: #enterANewCipher.	aMenu		add: 'quote from Squeak' translated		target: self		action: #squeakCipher! !!CipherPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:23'!buttonRow	| row aButton |	row := AlignmentMorph newRow color: self color;				 hResizing: #shrinkWrap;				 vResizing: #shrinkWrap.	#('show help' 'show hints' 'clear typing' 'enter a new cipher' 'quote from Squeak' )		with: #(#showHelpWindow #showHintsWindow #clearTyping #enterANewCipher #squeakCipher )		do: [:label :selector | 			aButton := SimpleButtonMorph new target: self.			aButton color: Color transparent;				 borderWidth: 1;				 borderColor: Color black.			aButton actionSelector: selector.			aButton label: label translated.			row addMorphBack: aButton.			row addTransparentSpacerOfSize: 3 @ 0].	^ row! !!CipherPanel methodsFor: 'menu' stamp: 'di 5/8/2000 10:46'!cipherStats	| letterCounts digraphs d digraphCounts |	letterCounts _ (quote copyWithout: Character space) asBag sortedCounts.	digraphs _ Bag new.	quote withIndexDo:		[:c :i |		i < quote size ifTrue:			[d _ quote at: i+1.			(c ~= Character space and: [d ~= Character space]) ifTrue:				[digraphs add: (String with: c with: d)]]].	digraphCounts _ digraphs sortedCounts.	^ String streamContents:		[:strm |		1 to: 10 do:			[:i |			strm cr; tab; nextPut: (letterCounts at: i) value.			strm tab; print: (letterCounts at: i) key.			(digraphCounts at: i) key > 1 ifTrue:				[strm tab; tab; tab; nextPutAll: (digraphCounts at: i) value.				strm tab; print: (digraphCounts at: i) key]]]! !!CipherPanel methodsFor: 'defaults' stamp: 'asm 11/25/2003 22:22'!clearTyping	self isClean		ifTrue: [^ self].	(self confirm: 'Are you sure you want to discard all typing?' translated)		ifFalse: [^ self].	super clearTyping! !!CipherPanel methodsFor: 'initialization' stamp: 'asm 11/25/2003 22:21'!encodedQuote: aString 	"World addMorph: CipherPanel new"	| morph prev |	aString isEmpty		ifTrue: [^ self].	(letterMorphs isNil			or: [self isClean])		ifFalse: [(self confirm: 'Are you sure you want to discard all typing?' translated)				ifFalse: [^ self]].	haveTypedHere := false.	quote := aString asUppercase.	prev := nil.	originalMorphs := quote asArray				collectWithIndex: [:c :i | WordGameLetterMorph new plain indexInQuote: i id1: nil;												setLetter: (quote at: i)].	letterMorphs := OrderedCollection new.	decodingMorphs := quote asArray				collectWithIndex: [:c :i | (quote at: i) isLetter						ifTrue: [morph := WordGameLetterMorph new underlined indexInQuote: i id1: nil.							morph								on: #mouseDown								send: #mouseDownEvent:letterMorph:								to: self.							morph								on: #keyStroke								send: #keyStrokeEvent:letterMorph:								to: self.							letterMorphs addLast: morph.							morph predecessor: prev.							prev								ifNotNil: [prev successor: morph].							prev := morph]						ifFalse: [WordGameLetterMorph new plain indexInQuote: i id1: nil;																setLetter: (quote at: i)]].	self color: originalMorphs first color.	self extent: 500 @ 500! !!CipherPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:23'!enterANewCipher	self clearTyping;		encodedQuote: (FillInTheBlank request: 'Type a cipher text to work on here below...' translated)! !!CipherPanel methodsFor: 'geometry' stamp: 'di 2/14/2001 13:50'!extent: newExtent 	"Lay out with word wrap, alternating bewteen decoded and encoded lines."	"Currently not tolerant of narrow (less than a word) margins"	| w h relLoc topLeft thisWord i m corner row firstWord |	self removeAllMorphs.	w _ originalMorphs first width - 1.  h _ originalMorphs first height * 2 + 10.	topLeft _ self position + self borderWidth + (0@10).	thisWord _ OrderedCollection new.	i _ 1.  firstWord _ true.  relLoc _ 0@0.  corner _ topLeft.	[i <= originalMorphs size] whileTrue:		[m _ originalMorphs at: i.		thisWord addLast: ((decodingMorphs at: i) position: topLeft + relLoc).		thisWord addLast: (m position: topLeft + relLoc + (0@m height)).		(m letter = Character space or: [i = originalMorphs size])			ifTrue: [self addAllMorphs: thisWord.					corner _ corner max: thisWord last bounds bottomRight.					thisWord reset.  firstWord _ false].		relLoc _ relLoc + (w@0).		(relLoc x + w) > newExtent x			ifTrue: [firstWord						ifTrue: ["No spaces -- force a line break"								thisWord removeLast; removeLast.								self addAllMorphs: thisWord.								corner _ corner max: thisWord last bounds bottomRight]						ifFalse: [i _ i - (thisWord size//2) + 1].					thisWord reset.  firstWord _ true.					relLoc _ 0@(relLoc y + h)]			ifFalse: [i _ i + 1]].	row _ self buttonRow. row fullBounds.	self addMorph: row.	super extent: (corner - topLeft) + (self borderWidth * 2) + (0@row height+10).	row align: row bounds bottomCenter with: self bounds bottomCenter - (0@2).! !!CipherPanel methodsFor: 'parts bin' stamp: 'sw 6/28/2001 17:58'!initializeToStandAlone 	super initializeToStandAlone.	self encodedQuote: self class sampleString! !!CipherPanel methodsFor: 'defaults' stamp: 'di 5/12/2000 00:52'!keyCharacter: aLetter atIndex: indexInQuote nextFocus: nextFocus	| encodedLetter |	encodedLetter _ quote at: indexInQuote.	originalMorphs with: decodingMorphs do:		[:e :d | e letter = encodedLetter ifTrue: [d setLetter: aLetter color: Color red]].! !!CipherPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:23'!showHelpWindow	((StringHolder new contents: 'The Cipher Panel displays an encrypted message.  The encryption is a simple substitution code;  each letter of the alphabet has been changed to a different one.You can solve the cipher by clicking above any letter in the message, and typing the letter you think it should be.  The Cipher Panel automatically makes the same substitution anywhere else that letter occurs in the encoded message.If you are having trouble, you can use the command menu to ''show cipher hints''.  That will display how many of each letter occurs, which is often a help in solving ciphers.' translated)		embeddedInMorphicWindowLabeled: 'About the Cipher Panel' translated)		setWindowColor: (Color				r: 1.0				g: 0.6				b: 0.0);		 openInWorld: self world extent: 389 @ 209! !!CipherPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:22'!showHintsWindow	((StringHolder new contents: 'Most bodies of english text follow a general pattern of letter usage.  The following are the most common letters, in approximate order of frequency:	E  T  A  O  N  I  R  S  HThe following are the most common digraphs:	EN  ER  RE  NT  TH  ON  INThe message you are trying to decode has the following specific statistics:' translated , self cipherStats , 'Good luck!!' translated)		embeddedInMorphicWindowLabeled: 'Some Useful Statistics' translated)		setWindowColor: (Color				r: 1.0				g: 0.6				b: 0.0);		 openInWorld: self world extent: 318 @ 326! !!CipherPanel methodsFor: 'menu' stamp: 'di 10/4/2000 10:48'!squeakCipher	self encodedQuote: (CipherPanel encode: (CipherPanel randomComment))! !!CrosticPanel class methodsFor: 'parts bin' stamp: 'sw 8/2/2001 12:46'!descriptionForPartsBin	^ self partName:	'Crostic'		categories:		#('Games')		documentation:	'The Crostic Panel: A classic word diagram game, by Dan Ingalls'! !!CrosticPanel class methodsFor: 'new-morph participation' stamp: 'di 5/11/2000 20:37'!includeInNewMorphMenu	^ true! !!CrosticPanel class methodsFor: 'instance creation' stamp: 'di 5/11/2000 20:37'!new	"NOTE: Use newFromFile: rather than new to create new CrosticPanels"	^ self newFromFile: (ReadStream on: self sampleFile)! !!CrosticPanel class methodsFor: 'instance creation' stamp: 'asm 11/25/2003 22:28'!newFromFile: aStream 	"World addMorph: CrosticPanel new"	"World addMorph: (CrosticPanel newFromFile: (FileStream 	readOnlyFileNamed: 'first.crostic'))"	| quoteWithBlanks citation clue numberLine numbers clues answers indexableQuote quotePanel crosticPanel buttonRow quoteWidth |	aStream next asciiValue = 31 & (aStream next asciiValue = 139)		ifTrue: ["It's gzipped..."			aStream skip: -2.			^ self newFromFile: aStream asUnZippedStream ascii].	aStream skip: -2.	quoteWithBlanks := aStream nextLine.	quoteWithBlanks := quoteWithBlanks asUppercase				select: [:c | c isLetter						or: [' -' includes: c]].	indexableQuote := quoteWithBlanks				select: [:c | c isLetter].	citation := aStream nextLine.	aStream nextLine.	clues := OrderedCollection new.	answers := OrderedCollection new.	[aStream atEnd]		whileFalse: [clue := aStream nextLine.			"Transcript cr; show: clue."			clues addLast: clue.			numberLine := aStream nextLine.			numbers := Scanner new scanTokens: numberLine.			answers addLast: numbers].	aStream close.	"Consistency check:"	(citation asUppercase			select: [:c | c isLetter])			= (String					withAll: (answers							collect: [:a | indexableQuote at: a first]))		ifFalse: [self error: 'mal-formed crostic file' translated].	crosticPanel := super new.	quotePanel := CrosticQuotePanel new				quote: quoteWithBlanks				answers: answers				cluesPanel: crosticPanel.	crosticPanel color: quotePanel firstSubmorph color;				quote: indexableQuote		clues: clues		answers: answers		quotePanel: quotePanel.	buttonRow := crosticPanel buttonRow.	quoteWidth := crosticPanel width + quotePanel firstSubmorph width max: buttonRow width.	quotePanel extent: quoteWidth @ 9999.	crosticPanel addMorph: quotePanel.	^ crosticPanel breakColumnAndResizeWithButtons: buttonRow! !!CrosticPanel class methodsFor: 'as yet unclassified' stamp: 'di 5/12/2000 15:12'!oldStyle	"return true if we should cross-index all the cells (takes more space)."	^ false! !!CrosticPanel class methodsFor: 'as yet unclassified' stamp: 'di 11/30/2000 10:15'!sampleFile 	"If you want to enter a new acrostic, follow this format exactly with regard to CRs and the like, and store it in a file.  Do not double the string quotes as here -- that is only because they are embedded in a string.  Finally, compress the file in the fileList (so it will be easy to transport and hard to read), and name it 'yourName.crostic' so that the 'open' button on the panel will recognize it."	^'Men and women do not feel the same way about dirt.  Women for some hormonal reason can see individual dirt molecules, whereas men tend not to notice them until they join together into clumps large enough to support commercial agriculture.Dave Barry''s Guide to MarriageBoccaccio''s collection of tales74 19 175 156 9 122 84 113 104Wooden instrument of Swiss herders67 184 153 103 14 142 148 54 3Evening service76 99 154 171 89 194 69Russian-born American anarchist (2 wds)159 102 177 25 186 134 128 82 50 62 11Apple-polish (2 wds)32 190 129 126 179 157 79 170Visual-gesture means of communication4 178 27 168 150 185 114Postponed contest173 58 77 65 8 124 85Groundbreaking invention98 15 116 162 112 37 92 155 70 187Material used to make English longbows132 195 28Gracile48 191 145 152Have the effrontery; experience a high (2 wds)164 61 137 33 17 45Florentine painter who experimented with perspective91 181 189 2 20 81 167Sondheim opus (3 wds)72 109 147 13 192 165 93 40 115 138 6 63Spanish rake108 56 44 133 193 29 125Emergence  as of an adult butterfly106 149 59 41 24 135 87 68Type of rifle (hyph)111 7 143 73 39 30 105 95 53Free of charge (3 wds)176 107 120 130 160 22 46 34 94 71Pie filling86 75 136 118 43Master filmmaker31 151 174 51 163 144Longtime sportswriter for the NY Herald tribune (2 wds)60 140 12 101 55 188 166 121Birthplace of Erasmus47 64 141 21 10 180 36 80 1Mae West classic (3 wds)127 123 161 110 183 5 139 97 88Element that glows blue in the dark100 90 35 182 146 117 169 26Sturm und Drang writer158 172 119 16 52 23Starfish or sea cucumber18 66 96 83 57 49 78 131 38 42'! !!CrosticPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:27'!addMenuItemsTo: aMenu hand: aHandMorph 	aMenu		add: 'show crostic help' translated		target: self		action: #showHelpWindow.	aMenu		add: 'show crostic hints' translated		target: self		action: #showHintsWindow.	aMenu		add: 'show crostic errors' translated		target: self		action: #showErrors.	aMenu		add: 'clear crostic typing' translated		target: self		action: #clearTyping.	aMenu		add: 'open crostic file...' translated		target: self		action: #openFile! !!CrosticPanel methodsFor: 'initialization' stamp: 'di 11/25/2000 19:17'!breakColumnAndResizeWithButtons: buttonRow	| indexToSplit yToSplit |	"The column of clues has been laid out, and the crostic panel has been resized to that width and embedded as a submorph.  This method breaks the clues in two, placing the long part to the left of the crostic and the short one below it."	yToSplit _ cluesPanel height + quotePanel height // 2 + self top.	indexToSplit _ cluesPanel submorphs findFirst: [:m | m bottom > yToSplit].	cluesCol2 _ AlignmentMorph newColumn color: self color;		hResizing: #shrinkWrap; vResizing: #shrinkWrap; layoutInset: 0;		cellPositioning: #topLeft.	cluesCol2 addAllMorphs: (cluesPanel submorphs copyFrom: indexToSplit + 1							to: cluesPanel submorphs size).	cluesPanel position: self position + self borderWidth + (0 @ 4).	quotePanel position: self position + (quotePanel width @ 0).	cluesCol2 position: self position + quotePanel extent + (0 @ 4).	self addMorph: cluesCol2.	self addMorph: buttonRow.	buttonRow align: buttonRow topLeft with: cluesCol2 bottomLeft.	self extent: 100@100; bounds: ((self fullBounds topLeft - self borderWidth asPoint)							corner: (self fullBounds bottomRight - (2@0))).! !!CrosticPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:27'!buttonRow	| row aButton |	row := AlignmentMorph newRow color: self color;				 hResizing: #shrinkWrap;				 vResizing: #shrinkWrap.	#('show help' 'show errors' 'show hints' 'clear' 'open...' )		with: #(#showHelpWindow #showErrors #showHintsWindow #clearTyping #openFile )		do: [:label :selector | 			aButton := SimpleButtonMorph new target: self.			aButton color: Color transparent;				 borderWidth: 1;				 borderColor: Color black.			aButton actionSelector: selector.			aButton label: label translated.			row addMorphBack: aButton.			row addTransparentSpacerOfSize: 3 @ 0].	^ row! !!CrosticPanel methodsFor: 'defaults' stamp: 'asm 11/25/2003 22:24'!clearTyping	self isClean		ifTrue: [^ self].	(self confirm: 'Are you sure you want to discard all typing?' translated)		ifFalse: [^ self].	super clearTyping.	quotePanel clearTyping! !!CrosticPanel methodsFor: 'defaults' stamp: 'di 5/11/2000 20:44'!highlight: morph	self unhighlight.	quotePanel unhighlight.	morph startOfWord morphsInWordDo:		[:m | m color: Color lightGreen.		(quotePanel letterMorphs at: m indexInQuote) color: Color lightMagenta].	morph color: Color green.	(quotePanel letterMorphs at: morph indexInQuote) color: Color magenta.! !!CrosticPanel methodsFor: 'parts bin' stamp: 'asm 11/25/2003 22:24'!initializeToStandAlone	| aStream quoteWithBlanks indexableQuote citation clue numberLine numbers buttonRow quoteWidth |	super initializeToStandAlone.	aStream := ReadStream on: self class sampleFile.	quoteWithBlanks := aStream nextLine.	quoteWithBlanks := quoteWithBlanks asUppercase				select: [:c | c isLetter						or: [' -' includes: c]].	indexableQuote := quoteWithBlanks				select: [:c | c isLetter].	citation := aStream nextLine.	aStream nextLine.	clues := OrderedCollection new.	answers := OrderedCollection new.	[aStream atEnd]		whileFalse: [clue := aStream nextLine.			"Transcript cr; show: clue."			clues addLast: clue.			numberLine := aStream nextLine.			numbers := Scanner new scanTokens: numberLine.			answers addLast: numbers].	aStream close.	"Consistency check:"	(citation asUppercase			select: [:c | c isLetter])			= (String					withAll: (answers							collect: [:a | indexableQuote at: a first]))		ifFalse: [self error: 'mal-formed crostic file' translated].	quotePanel := CrosticQuotePanel new				quote: quoteWithBlanks				answers: answers				cluesPanel: self.	self color: quotePanel firstSubmorph color;				quote: indexableQuote		clues: clues		answers: answers		quotePanel: quotePanel.	buttonRow := self buttonRow.	quoteWidth := self width + quotePanel firstSubmorph width max: buttonRow width.	quotePanel extent: quoteWidth @ 9999.	self addMorph: quotePanel.	self breakColumnAndResizeWithButtons: buttonRow! !!CrosticPanel methodsFor: 'defaults' stamp: 'di 5/11/2000 20:44'!keyCharacter: aLetter atIndex: indexInQuote nextFocus: nextFocus	(self letterMorphs at: indexInQuote) setLetter: aLetter.	(quotePanel letterMorphs at: indexInQuote) setLetter: aLetter.	self highlight: nextFocus! !!CrosticPanel methodsFor: 'defaults' stamp: 'di 5/11/2000 20:44'!lostFocus	self unhighlight.	quotePanel unhighlight! !!CrosticPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:26'!openFile	| stdFileMenuResult crostic file |	stdFileMenuResult := (StandardFileMenu new pattern: '*.crostic';				 oldFileFrom: FileDirectory default) startUpWithCaption: 'Select a Crostic File...' translated.	stdFileMenuResult		ifNil: [^ nil].	file := stdFileMenuResult directory readOnlyFileNamed: stdFileMenuResult name.	crostic := CrosticPanel newFromFile: file.	file close.	(self isClean			or: [self confirm: 'Is it OK to discard this crostic?' translated])		ifTrue: [self world				addMorphFront: (crostic position: self position).			self delete]		ifFalse: [self world addMorphFront: crostic]! !!CrosticPanel methodsFor: 'initialization' stamp: 'di 11/28/2000 10:40'!quote: indexableQuote clues: clueStrings answers: answerIndices quotePanel: panel	| row clue answer answerMorph letterMorph prev clueText clueStyle |	quote _ indexableQuote.	quotePanel _ panel.	clues _ clueStrings.	answers _ answerIndices.	cluesPanel _ AlignmentMorph newColumn color: self color;		hResizing: #shrinkWrap; vResizing: #shrinkWrap;		cellPositioning: #topLeft; layoutInset: 1.	letterMorphs _ Array new: quotePanel letterMorphs size.	clueStyle _ nil.	1 to: clues size do:		[:i |  clue _ clues at: i.  answer _ answers at: i.		row _ AlignmentMorph newRow cellPositioning: #bottomLeft.		clueText _ (TextMorph newBounds: (0@0 extent: 120@20) color: Color black)				string: (CrosticPanel oldStyle							ifTrue: [(($A to: $Z) at: i) asString , '.  ' , clue]							ifFalse: [clue])				fontName: 'ComicPlain' size: 13.		clueStyle ifNil: ["Make up a special style with decreased leading"						clueStyle _ clueText textStyle copy.						clueStyle gridForFont: 1 withLead: -2].		clueText text: clueText asText textStyle: clueStyle.  "All clues share same style"		clueText composeToBounds.		row addMorphBack: clueText.		answerMorph _ AlignmentMorph newRow layoutInset: 0.		prev _ nil.		answer do:			[:n | letterMorph _ WordGameLetterMorph new underlined						indexInQuote: n						id1: (CrosticPanel oldStyle ifTrue: [n printString] ifFalse: [nil]);						setLetter: Character space.			letterMorph on: #mouseDown send: #mouseDownEvent:letterMorph: to: self.			letterMorph on: #keyStroke send: #keyStrokeEvent:letterMorph: to: self.			letterMorph predecessor: prev.			prev ifNotNil: [prev successor: letterMorph].			prev _ letterMorph.			letterMorphs at: n put: letterMorph.			answerMorph addMorphBack: letterMorph].		answerMorph color: answerMorph firstSubmorph color.		row addMorphBack: answerMorph.row fullBounds.		row color: answerMorph firstSubmorph color.		cluesPanel addMorphBack: row].	self addMorph: cluesPanel.	self bounds: cluesPanel fullBounds.! !!CrosticPanel methodsFor: 'menu' stamp: 'di 5/12/2000 15:09'!showErrors	letterMorphs do:		[:m | (m letter ~= Character space and: [m letter ~= (quote at: m indexInQuote)])			ifTrue: [m color: Color red.					(quotePanel letterMorphs at: m indexInQuote) color: Color red]]! !!CrosticPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:26'!showHelpWindow	((StringHolder new contents: 'The Crostic Panel presents an acrostic puzzle for solution.  As you type in answers for the clues, the letters also get entered in the text of the hidden quote.  Conversely, as you guess words in the quote, those letters will fill in missing places in your answers.  In addition, the first letters of all the answers together form the author''s name and title of the work from which the quote is taken.If you wish to make up other acrostic puzzles, follow the obvious file format in the sampleFile method.  If you wish to print an acrostic to work it on paper, then change the oldStyle method to return true, and it will properly cross-index all the cells.Have fun.' translated)		embeddedInMorphicWindowLabeled: 'About the Crostic Panel' translated)		setWindowColor: (Color				r: 1.0				g: 0.6				b: 0.0);		 openInWorld: self world extent: 409 @ 207! !!CrosticPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:25'!showHintsWindow	| hints |	(self confirm: 'As hints, you will be given the five longest answers.Do you really want to do this?' translated)		ifFalse: [^ self].	hints := (answers				asSortedCollection: [:x :y | x size > y size]) asArray copyFrom: 1 to: 5.	((StringHolder new contents: 'The five longest answers are...' translated			, (String					streamContents: [:strm | 						hints							do: [:hint | strm cr;									nextPutAll: (hint											collect: [:i | quote at: i])].						strm cr; cr]) , 'Good luck!!' translated)		embeddedInMorphicWindowLabeled: 'Crostic Hints' translated)		setWindowColor: (Color				r: 1.0				g: 0.6				b: 0.0);		 openInWorld: self world extent: 198 @ 154! !!CrosticQuotePanel methodsFor: 'geometry' stamp: 'di 5/7/2000 11:59'!extent: newExtent	| w h nAcross relLoc topLeft |	w _ self firstSubmorph width - 1.  h _ self firstSubmorph height - 1.	nAcross _ newExtent x - (self borderWidth-1*2)-1 // w.	topLeft _ self position + self borderWidth - 1.	submorphs withIndexDo:		[:m :i | 		relLoc _ (i-1 \\ nAcross * w) @ (i-1 // nAcross * h).		m position: topLeft + relLoc].	super extent: ((w * nAcross + 1) @ (submorphs size - 1 // nAcross + 1 * h+1))					+ (self borderWidth - 1 * 2).! !!CrosticQuotePanel methodsFor: 'defaults' stamp: 'di 5/11/2000 09:37'!highlight: morph	self unhighlight.	cluesPanel unhighlight.	morph startOfWord morphsInWordDo:		[:m | m color: Color lightGreen.		(cluesPanel letterMorphs at: m indexInQuote) color: Color lightMagenta].	morph color: Color green.	(cluesPanel letterMorphs at: morph indexInQuote) color: Color magenta.! !!CrosticQuotePanel methodsFor: 'defaults' stamp: 'di 5/10/2000 09:25'!keyCharacter: aLetter atIndex: indexInQuote nextFocus: nextFocus	(self letterMorphs at: indexInQuote) setLetter: aLetter.	(cluesPanel letterMorphs at: indexInQuote) setLetter: aLetter.	self highlight: nextFocus! !!CrosticQuotePanel methodsFor: 'defaults' stamp: 'di 5/10/2000 08:49'!lostFocus	self unhighlight.	cluesPanel unhighlight! !!CrosticQuotePanel methodsFor: 'initialization' stamp: 'di 5/12/2000 00:07'!quote: quoteWithBlanks answers: theAnswers cluesPanel: panel	| n morph prev clueIxs |	cluesPanel _ panel.	self color: Color gray.	clueIxs _ Array new: quoteWithBlanks size.	theAnswers withIndexDo: [:a :i | a do: [:j | clueIxs at: j put: i]].	letterMorphs _ OrderedCollection new.	prev _ nil.	self addAllMorphs: (quoteWithBlanks asArray collect:		[:c |		c isLetter			ifTrue: [n _ letterMorphs size + 1.					morph _ WordGameLetterMorph new boxed.					CrosticPanel oldStyle						ifTrue: [morph indexInQuote: n id1: n printString.								morph id2: (($A to: $Z) at: (clueIxs at: n)) asString]						ifFalse: [morph indexInQuote: n id1: nil].					morph setLetter: Character space.					morph on: #mouseDown send: #mouseDownEvent:letterMorph: to: self.					morph on: #keyStroke send: #keyStrokeEvent:letterMorph: to: self.					letterMorphs addLast: morph]			ifFalse: [morph _ WordGameLetterMorph new boxed indexInQuote: nil id1: nil.					CrosticPanel oldStyle ifTrue: [morph extent: 26@24  "Oops"]].		morph predecessor: prev.		prev ifNotNil: [prev successor: morph].		prev _ morph]).! !!WordGamePanelMorph class methodsFor: 'new-morph participation' stamp: 'di 5/10/2000 07:41'!includeInNewMorphMenu	^ false! !!WordGamePanelMorph methodsFor: 'menus' stamp: 'di 5/9/2000 21:53'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Include our modest command set in the ctrl-menu"	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	self addMenuItemsTo: aCustomMenu hand: aHandMorph! !!WordGamePanelMorph methodsFor: 'menu' stamp: 'di 5/9/2000 22:07'!addMenuItemsTo: aCustomMenu hand: aHandMorph	"override with actual menu items"! !!WordGamePanelMorph methodsFor: 'events' stamp: 'di 5/10/2000 08:45'!checkForLostFocus	"Determine if the user has clicked outside this panel"	self activeHand ifNil: [^ self].	(self containsPoint: self activeHand position) ifFalse: [self lostFocus]! !!WordGamePanelMorph methodsFor: 'defaults' stamp: 'di 5/12/2000 00:28'!clearTyping	"Clear out all letters entered as a solution."	letterMorphs do: [:m | (m letter notNil and: [m letter isLetter])							ifTrue: [m setLetter: Character space]].	self unhighlight.! !!WordGamePanelMorph methodsFor: 'event handling' stamp: 'di 5/11/2000 22:38'!handlesMouseDown: event	"Absorb mouseDown so stray clicks will not pick up the panel"	^ true! !!WordGamePanelMorph methodsFor: 'defaults' stamp: 'di 5/10/2000 09:31'!highlight: morph	self unhighlight.	morph color: Color green! !!WordGamePanelMorph methodsFor: 'defaults' stamp: 'di 5/12/2000 00:53'!isClean	"Return true only if all cells are blank."	letterMorphs do:		[:m | (m letter notNil and: [m letter ~= $ ]) ifTrue: [^ false]].	^ true! !!WordGamePanelMorph methodsFor: 'defaults' stamp: 'di 5/10/2000 08:37'!keyCharacter: keyCharacter atIndex: indexOfAffectedMorph nextFocus: nextFocus	"Override with actual response"! !!WordGamePanelMorph methodsFor: 'events' stamp: 'aoy 2/15/2003 21:25'!keyStrokeEvent: evt letterMorph: morph 	"Handle typing.  Calls keyCharacter:atIndex:nextFocus: for further behavior."	| affectedMorph keyCharacter nextFocus |	evt keyCharacter = Character backspace 		ifTrue: 			["<delete> zaps the current selection if there has been no typing,				but it zaps the previous selection if there has been prior typing."			affectedMorph := haveTypedHere 						ifTrue: [morph previousTypeableLetter]						ifFalse: [morph]. 			keyCharacter := Character space.			nextFocus := morph previousTypeableLetter]		ifFalse: 			[affectedMorph := morph.			keyCharacter := evt keyCharacter asUppercase.			(keyCharacter isLetter or: [keyCharacter = Character space]) 				ifFalse: [^self].			haveTypedHere := true.			nextFocus := morph nextTypeableLetter.			nextFocus == morph 				ifTrue: 					["If hit end of a word, change backspace mode"					haveTypedHere := false]].	evt hand newKeyboardFocus: nextFocus.	self unhighlight.	nextFocus color: Color green.	self 		keyCharacter: keyCharacter		atIndex: affectedMorph indexInQuote		nextFocus: nextFocus! !!WordGamePanelMorph methodsFor: 'access' stamp: 'di 5/9/2000 22:27'!letterMorphs	^ letterMorphs! !!WordGamePanelMorph methodsFor: 'defaults' stamp: 'di 5/10/2000 08:44'!lostFocus	self unhighlight! !!WordGamePanelMorph methodsFor: 'events' stamp: 'di 5/10/2000 09:30'!mouseDownEvent: evt letterMorph: morph	haveTypedHere _ false.	evt hand newKeyboardFocus: morph.	self highlight: morph! !!WordGamePanelMorph methodsFor: 'defaults' stamp: 'di 5/12/2000 09:54'!unhighlight	letterMorphs do: [:m | m ifNotNil: [m unhighlight]]! !!MorphicGamesInfo methodsFor: 'introspection' stamp: 'asm 10/14/2005 14:41'!changesText	^'verison 7:  - added Andreas''s fix for http://bugs.impara.de/view.php?id=1591              - adeed njb''s fic for http://bugs.impara.de/view.php?id=1813version 6: included Rick McGeer''s Chess Castling Fixversion 5: included Atomic (some changes were needed to make it work in 3.7) and some Babel stuffversion 4: includes Andreas Raab''s rewrite of ChessConstants as declarative pool (update 5325)version 3: 	-added one change by the KCP team			-Chess its playing againversion 2: applied changes by the MCP team'! !!MorphicGamesInfo methodsFor: 'introspection' stamp: 'asm 6/25/2003 22:10'!postscriptText	"Executed after load"	^ 'Utilities informUser: ''Generating Games thumbnails in PartsBin, please wait...'' during: [	PartsBin clearThumbnailCache.	PartsBin cacheAllThumbnails.]."End ', self packageName, '"'! !!MorphicGamesInfo methodsFor: 'introspection' stamp: 'asm 4/20/2004 22:14'!readmeText	^'Morphic-Games has the games that were in the image before 3.6:Chess, Chinese Checkers, Cipher, Crostic, FreeCell, Mines, Same and Tetris.plus Atomic'! !!ChessMoveList methodsFor: 'accessing' stamp: 'ar 8/24/2001 16:32'!contents	^collection copyFrom: startIndex to: readLimit! !!ChessMoveList methodsFor: 'private' stamp: 'ar 8/24/2001 16:10'!on: aCollection from: firstIndex to: lastIndex	startIndex _ firstIndex.	^super on: aCollection from: firstIndex to: lastIndex.! !!ChessMoveList methodsFor: 'sorting' stamp: 'ar 8/24/2001 16:16'!sort: i to: j using: sorter	"Sort elements i through j of self to be nondescending according to sorter."	| di dij dj tt ij k l n |	"The prefix d means the data at that index."	(n _ j + 1  - i) <= 1 ifTrue: [^self].	"Nothing to sort." 	 "Sort di,dj."	di _ collection at: i.	dj _ collection at: j.	(sorter sorts: di before: dj) ifFalse:["i.e., should di precede dj?"		collection swap: i with: j.		tt _ di. di _ dj. dj _ tt].	n > 2 ifTrue:["More than two elements."		ij _ (i + j) // 2.  "ij is the midpoint of i and j."		 dij _ collection at: ij.  "Sort di,dij,dj.  Make dij be their median."		 (sorter sorts: di before: dij) ifTrue:["i.e. should di precede dij?"			(sorter sorts: dij before: dj) "i.e., should dij precede dj?"				ifFalse:[collection swap: j with: ij.					 	dij _ dj].		] ifFalse:[  "i.e. di should come after dij"			collection swap: i with: ij.			 dij _ di		].		n > 3 ifTrue:["More than three elements."			"Find k>i and l<j such that dk,dij,dl are in reverse order.			Swap k and l.  Repeat this procedure until k and l pass each other."			 k _ i.  l _ j.			[				[l _ l - 1.  k <= l and: [sorter sorts: dij before: (collection at: l)]]					whileTrue.  "i.e. while dl succeeds dij"				[k _ k + 1.  k <= l and: [sorter sorts: (collection at: k) before: dij]]					whileTrue.  "i.e. while dij succeeds dk"				k <= l			] whileTrue:[collection swap: k with: l]. 			"Now l<k (either 1 or 2 less), and di through dl are all less than 			or equal to dk through dj.  Sort those two segments."			self sort: i to: l using: sorter.			self sort: k to: j using: sorter]].! !!ChessMoveList methodsFor: 'sorting' stamp: 'ar 8/24/2001 16:32'!sortUsing: historyTable	^self sort: startIndex to: readLimit using: historyTable! !!ChessMoveList methodsFor: 'accessing' stamp: 'ar 8/24/2001 16:11'!startIndex	^startIndex! !!TetrisBoard class methodsFor: 'new-morph participation' stamp: 'RAA 1/7/2000 22:56'!includeInNewMorphMenu	^false! !!TetrisBoard methodsFor: 'as yet unclassified' stamp: 'RAA 1/7/2000 23:12'!cellSize	^12@12! !!TetrisBoard methodsFor: 'other' stamp: 'RAA 1/8/2000 13:20'!checkForFullRows	| targetY morphsInRow bonus |	self numRows to: 2 by: -1 do: [ :row |		targetY _ (self originForCell: 1@row) y.		[			morphsInRow _ self submorphsSatisfying: [ :each | each top = targetY].			morphsInRow size = self numColumns		] whileTrue: [			bonus _ (morphsInRow collect: [:each | each color]) asSet size = 1 				ifTrue: [1000] 				ifFalse: [100].			self score: score + bonus.			submorphs copy do: [ :each |				each top = targetY ifTrue: [					each delete				].				each top < targetY ifTrue: [					each position: each position + (0@self cellSize y)				].			].		].	].! !!TetrisBoard methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:07'!defaultBounds"answer the default bounds for the receiver"	^ 0 @ 0 extent: self numColumns @ self numRows * self cellSize + (1 @ 1)! !!TetrisBoard methodsFor: 'initialization' stamp: 'dgd 2/17/2003 19:38'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		  lightBlue! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 14:03'!dropAllTheWay	self running ifFalse: [^ self].	[currentBlock dropByOne] whileTrue: [		self score: score + 1	].! !!TetrisBoard methodsFor: 'data' stamp: 'RAA 1/8/2000 13:16'!emptyAt: aPoint	| cellOrigin |	(aPoint x between: 1 and: self numColumns) ifFalse: [^ false].	(aPoint y < 1) ifTrue: [^ true].	"handle early phases"	(aPoint y <= self numRows) ifFalse: [^ false].	cellOrigin _ self originForCell: aPoint.	^(self submorphsSatisfying: [ :each | each topLeft = cellOrigin]) isEmpty! !!TetrisBoard methodsFor: 'accessing' stamp: 'RAA 1/7/2000 22:34'!game: aTetris	game _ aTetris! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:17'!moveLeft	self running ifFalse: [^ self].	currentBlock moveDeltaX: -1 deltaY: 0 deltaAngle: 0.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:17'!moveRight	self running ifFalse: [^ self].	currentBlock moveDeltaX: 1 deltaY: 0 deltaAngle: 0.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 13:20'!newGame	self removeAllMorphs.	gameOver _ paused _ false.	delay _ 500.	currentBlock _ nil.	self score: 0.! !!TetrisBoard methodsFor: 'data' stamp: 'RAA 8/28/1999 23:29'!numColumns	^10	! !!TetrisBoard methodsFor: 'data' stamp: 'RAA 8/28/1999 23:30'!numRows	^27	! !!TetrisBoard methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 13:11'!originForCell: aPoint	^aPoint - (1@1) * self cellSize + self position! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:16'!pause	gameOver ifTrue: [^ self].	paused _ paused not.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:17'!rotateAntiClockWise	self running ifFalse: [^ self].	currentBlock moveDeltaX: 0 deltaY: 0 deltaAngle: -1.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:17'!rotateClockWise	self running ifFalse: [^ self].	currentBlock moveDeltaX: 0 deltaY: 0 deltaAngle: 1.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 8/28/1999 22:31'!running	^currentBlock notNil and: [paused not]! !!TetrisBoard methodsFor: 'accessing' stamp: 'RAA 1/7/2000 22:38'!score: aNumber	score _ aNumber.	game score: score.! !!TetrisBoard methodsFor: 'stepping and presenter' stamp: 'RAA 1/8/2000 15:59'!step	(self ownerThatIsA: HandMorph) ifNotNil: [^self].	paused ifTrue: [^ self]. 	currentBlock ifNil: [		currentBlock _ TetrisBlock new.		self addMorphFront: currentBlock.		currentBlock board: self.	] ifNotNil: [		currentBlock dropByOne ifFalse: [self storePieceOnBoard]	].! !!TetrisBoard methodsFor: 'testing' stamp: 'AM 7/26/1999 16:07'!stepTime	^ delay! !!TetrisBoard methodsFor: 'other' stamp: 'RAA 1/8/2000 13:59'!storePieceOnBoard	currentBlock submorphs do: [ :each |		self addMorph: each.		((each top - self top) // self cellSize y) < 3 ifTrue: [			paused _ gameOver _ true.		].	].	currentBlock delete.	currentBlock _ nil.	self checkForFullRows.	self score: score + 10.	delay _ delay - 2 max: 80.! !"Morphic-Games"!!NsGame commentStamp: 'sbw 11/8/2003 09:28' prior: 0!This is the main game morph for playing the game NsGame.To open the morph do	NsGame new openInWorldA game board will be presented.  There is an Instructions button which provides a number of details on how the game operates.The instructions are created using a GeeMailMorph.  To update the instructions, open them via the instructions button, extract the GeeMailMorph from the opened window and then edit the GeeMailMorph in the usual manner.  Once you have completed your changes to the GeeMailMorph, use the debug menu and save the morph in a file.  There were some issues with saving stand-alone GeeMailMorphs in Squeak 3.6 at the time this game was created so the change set includes 2 patches to support that operation.  After the morph is saved in a file, use the FileList and compress the morph file.  Once you have the file compressed, use the FileList and select the file and then choose to copy the name of the file to the Clipboard.  Perform the following line of Squeak code in a workspace with that full file name path.  The file path shown here is an example of course.	NsGame convertSavedMorphFile: 'Meine Welt:Users:steve:Develop:squeak:3.6:my GeeMailMorph.morph.gz'.A workspace window will be opened showing the hex converted ascii for binary contained in the compressed morph.  Copy the contents of that text window into the	NsGame class>>compressedEncodedInstructionsmethod.  You can test your new instructions after completing this step.!!NsGameTile commentStamp: 'sbw 11/8/2003 08:24' prior: 0!This is the top of the NsGame tiles hierarchy.The hierarchy is divided into the kinds of tiles, those having no connections, one connection, two connections, three connections or four.The game uses Forms for drawing the game pieces.  There are 2 states for each game piece (active or idle).  Each game piece also has forms to represent the tile in each of the 4 possible positions.  Note that for some (blank and cross) there is only one rotation position.Forms for each rotated position were used to account for possible errors in drawing symmetry.All forms are actually stored on class instance variables in the hierarchy.  Note that a class instance variable exists for each instance of a class and is not the same object as a class variable.The subclasses of this hierarchy contain an elegant model for defining only what is different between the game tile pieces.!!NsFourConnectionsGameTile commentStamp: 'sbw 11/8/2003 08:25' prior: 0!This tile piece abstract class is the super class of all game pieces that have 4 connections.  Pieces in this hierarchy do not rotate.!!NsCrossGameTile commentStamp: 'sbw 11/8/2003 08:25' prior: 0!The Cross game tile piece.!!NsNoConnectionsGameTile commentStamp: 'sbw 11/8/2003 08:25' prior: 0!This tile piece abstract class is the super class of all game pieces that have no connections.  Pieces in this hierarchy do not rotate.!!NsBlankGameTile commentStamp: 'sbw 11/8/2003 08:26' prior: 0!The Blank tile game piece.!!NsOneConnectionGameTile commentStamp: 'sbw 11/8/2003 08:26' prior: 0!This hierarchy includes only the game pieces having one connection.  Each piece can have 4 rotated positions.!!NsDestinationGameTile commentStamp: 'sbw 11/8/2003 08:27' prior: 0!An instance of this game piece is an end point for the power grid.  There may be more than one destination piece on a game board, depending on the size of the board.!!NsSourceGameTile commentStamp: 'sbw 11/8/2003 08:27' prior: 0!This is the power source for the game board or grid.  There is only one on any game board.!!NsThreeConnectionsGameTile commentStamp: 'sbw 11/8/2003 08:28' prior: 0!This hierarchy includes only the game pieces having three connections.  Each piece can have 4 rotated positions.!!NsTeeGameTile commentStamp: 'sbw 11/8/2003 08:28' prior: 0!The Tee shaped game piece.!!NsTwoConnectionsGameTile commentStamp: 'sbw 11/8/2003 08:29' prior: 0!This hierarchy includes only the game pieces having two connections.  Each piece can have 4 rotated positions because of possible errors in piece drawing symmetry.!!NsCornerGameTile commentStamp: 'sbw 11/8/2003 08:29' prior: 0!The corner piece.!!NsLineGameTile commentStamp: 'sbw 11/8/2003 08:29' prior: 0!The horizontal or vertical game tile.!!NsModel commentStamp: 'sbw 11/8/2003 08:30' prior: 0!The model contains the logic to the game.  It also contains each game piece and the state of all the counters.!!NsGameHelpWindow commentStamp: '<historical>' prior: 0!Provides help window for NS Game.!!TextStream methodsFor: '*nsTileGame' stamp: 'sbw 10/28/2003 14:02' prior: 58758820!nextPutAll: aCollection 	"Optimized access to get around Text at:Put: overhead"	| n |	n _ aCollection size.	position + n > writeLimit ifTrue: [		super nextPutAll: aCollection.		self skip: 0 - aCollection size.		^self nextPutAll: aCollection].	(aCollection isMemberOf: String) ifFalse: [^super nextPutAll: aCollection].	collection string		replaceFrom: position + 1		to: position + n		with: aCollection		startingAt: 1.	position _ position + n! !!NsGame class methodsFor: 'parts bin' stamp: 'sbw 11/10/2003 22:00'!descriptionForPartsBin	^ self		partName: 'NsGame'		categories: #('Games' )		documentation: 'A power-circuit tile game.'! !!NsGame class methodsFor: 'as yet unclassified' stamp: 'sbw 10/19/2003 17:04'!helpFor: aKey 	^ self rules at: aKey ifAbsent: ['?']! !!NsGame class methodsFor: 'instructions' stamp: 'sbw 6/13/2004 18:07'!helpWindow	NsGameHelpWindow openHelpWindow! !!NsGame class methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 18:29'!initializeNsGame postLoadOperation! !!NsGame class methodsFor: 'as yet unclassified' stamp: 'sbw 12/7/2003 15:23'!initializeHelp	"NsGame initializeHelp"	| dict |	dict _ Dictionary new.	dict at: 'EndGame' put: 'Ends game and closes window.';		 at: 'ConnectedCounter' put: 'Shows how many powered cells you have.  Counter turns yellow when all destination cells are powered.';		 at: 'MaxCounter' put: 'Shows the highest number of connected cells for this game.';		 at: 'TurnsCounter' put: 'Shows how many turns you have taken.';		 at: 'Help' put: 'Opens up help window';		 at: 'NewGame' put: 'Start a new game using the same size board.';		 at: 'NewSize' put: 'Starts a new game where you choose the grid size.';		 at: 'Restart' put: 'Start the existing game over again.  The Max counter is not reset when a game is restarted.';		 at: 'Colors' put: 'Edit the colors used by the game.  This button toggles the display between the game board and the colors control panel.';		at: 'LoadSave' put: 'Load a previously saved game or save the current game.  This button toggles the display between the game board and the load/save control panel,'.	self rules: dict! !!NsGame class methodsFor: 'as yet unclassified' stamp: 'sbw 12/14/2003 12:42'!postLoadOperation	"NsGame postLoadOperation"	NsGame initializeHelp.	NsGameTile initializeForms.	NsGameTile initializeColors.	Smalltalk addToStartUpList: NsModel.! !!NsGame class methodsFor: 'as yet unclassified' stamp: 'sbw 10/19/2003 16:51'!rules	Rules == nil ifTrue: [self initializeHelp].	^Rules! !!NsGame class methodsFor: 'as yet unclassified' stamp: 'sbw 10/19/2003 15:04'!rules: aDictionary	Rules _ aDictionary! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 11/28/2003 16:27'!addButtonToColumn: column buttonHeight: buttonHeight vOffset: vOffset selector: selector top: top 	| bottom |	bottom _ top + buttonHeight.	selector = #NONE		ifFalse: [self				addControl: (self perform: selector)				to: column				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (self windowPadding x @ top corner: self windowPadding x negated @ bottom)].	^ bottom + vOffset! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 12/7/2003 15:26'!addButtonsToColumn: column buttonHeight: buttonHeight offset: offset 	| vOffset top selectors |	top _ offset copy.	vOffset _ 5.	selectors _ #(#makeRestartButton #makeNewGameButton #makeNewSizeButton #makeEditColorsButton #makeHelpButton #makeLoadSaveButton #makeCloseGameButton ).	selectors		do: [:selector | top _ self						addButtonToColumn: column						buttonHeight: buttonHeight						vOffset: vOffset						selector: selector						top: top].	^ top! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/25/2003 06:54'!addControl: aMorph to: column fractions: fractions offsets: offsets	aMorph isNil		ifFalse: [column addMorph: aMorph		fullFrame: (LayoutFrame				fractions: (fractions)				offsets: (offsets))]! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/29/2003 20:05'!addMorphs	self		addMorph: self makeControls		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 0 @ 1)				offsets: (0 @ 0 corner: self controlPanelWidth @ 0)).	self		addMorph: self makeGameBoardMorph		fullFrame: (self boardMorphLayoutFrame)! !!NsGame methodsFor: 'widgets - counters' stamp: 'sbw 11/27/2003 10:52'!addPanelsToColumn: column panelHeight: countPanelHeight offset: offset	| vOffset top bottom |	vOffset _ 5.	top _ offset copy.	bottom _ top + countPanelHeight.	self		addControl: self makeMovesMorph		to: column		fractions: (0 @ 0 corner: 1 @ 0)		offsets: (self windowPadding x @ top corner: self windowPadding x negated @ bottom).	top _ bottom + vOffset.	bottom _ top + countPanelHeight.	self		addControl: self makeCountMorph		to: column		fractions: (0 @ 0 corner: 1 @ 0)		offsets: (self windowPadding x @ top corner: self windowPadding x negated @ bottom).	top _ bottom + vOffset.	bottom _ top + countPanelHeight.	self		addControl: self makeMaxMorph		to: column		fractions: (0 @ 0 corner: 1 @ 0)		offsets: (self windowPadding x @ top corner: self windowPadding x negated @ bottom).	^ bottom + vOffset! !!NsGame methodsFor: 'widgets' stamp: 'sbw 12/7/2003 17:20'!boardMorph	^ board! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/29/2003 20:04'!boardMorphLayoutFrame	^LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (self controlPanelWidth @ self windowPadding y corner: self windowPadding negated)! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 11/29/2003 20:10'!buildColorsMorph	| colorsMorph buttonMorph colorsTableMorph |	colorsTableMorph _ self editColorsControlMorph.	buttonMorph _ self resetColorsButtonMorph.	colorsMorph _ AlignmentMorph newColumn beTransparent.	colorsMorph addMorphBack: colorsTableMorph;		 addMorphBack: buttonMorph.	buttonMorph color: Color transparent.	^ colorsMorph! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 22:24'!buildLoadSaveMorph	| theMorph saveButton loadButton deleteButton |	saveButton _ self saveGameButtonMorph.	loadButton _ self loadGameButtonMorph.	deleteButton _ self deleteGamesButtonMorph.	theMorph _ AlignmentMorph newColumn beTransparent.	theMorph addTransparentSpacerOfSize: 10 @ 10;		 addMorphBack: loadButton;		 addTransparentSpacerOfSize: 10 @ 10;		 addMorphBack: saveButton;		 addTransparentSpacerOfSize: 10 @ 10;		addMorphBack: deleteButton;		addTransparentSpacerOfSize: 10 @ 10.	saveButton color: Color transparent.	loadButton color: Color transparent.	deleteButton color: Color transparent.	^ theMorph! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/25/2003 06:26'!calculatedExtent	| pt |	pt _ self gameModel renderFormSize + self windowExtra.	^ pt x		@ (pt y max: 380)! !!NsGame methodsFor: 'events' stamp: 'sbw 11/27/2003 10:09'!click: evt forMorph: aSketchMorph 	| selectedCell |	selectedCell _ self selectedCellClicked: evt forMorph: aSketchMorph.	selectedCell isNil		ifFalse: [Sensor shiftPressed				ifTrue: [self gameModel rotateCellRight: selectedCell forMorph: aSketchMorph]				ifFalse: [self gameModel rotateCellLeft: selectedCell forMorph: aSketchMorph].			self gameModel updateMoves.			self gameModel update.			self gameModel renderCellsOn: aSketchMorph form.			aSketchMorph layoutChanged]! !!NsGame methodsFor: 'events' stamp: 'sbw 12/7/2003 22:04'!closeGame	"Use the following preferences check to decide if we are a Squeak image 	running the game morph."	Preferences cmdDotEnabled		ifTrue: [self delete]		ifFalse: [(self confirm: 'Really quit?')				ifTrue: [Smalltalk quitPrimitive]]! !!NsGame methodsFor: 'widgets' stamp: 'sbw 12/7/2003 17:38'!colorsMorph	^self submorphNamed: 'colors'! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/26/2003 17:42'!controlPanelWidth	^ 100! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 11/25/2003 06:26'!currentColor: key 	^ NsGameTile colors at: key! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 11/25/2003 06:26'!currentColor: key new: newColor 	NsGameTile colors at: key put: newColor.	self updateColors! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/25/2003 06:26'!defaultBounds	"answer the default bounds for the receiver"	^ 0 @ 0 corner: self calculatedExtent! !!NsGame methodsFor: 'accessing' stamp: 'sbw 11/28/2003 13:40'!defaultGameSize	^7 @ 11 ! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 22:29'!deleteGames	| list choice deleteList |	self hideLoadSaveButtons.	deleteList _ OrderedCollection new.	list _ (FileDirectory default fileNamesMatching: '*.ns') asOrderedCollection.	list size = 0		ifTrue: [self inform: 'No files found to delete.']		ifFalse: [list size = 1				ifTrue: [deleteList add: list first]				ifFalse: [list addFirst: 'All saved games'.					list addLast: 'Cancel'.					choice _ PopUpMenu withCaption: 'Delete a saved game file.' chooseFrom: list.					(choice = 0							or: [choice = list size])						ifFalse: [choice = 1								ifTrue: [2										to: list size - 1										do: [:index | deleteList												add: (list at: index)]]								ifFalse: [deleteList										add: (list at: choice)]]].			deleteList				do: [:fn | FileDirectory default deleteFileNamed: fn].			deleteList size > 0 ifTrue: [self inform: 'Deleted files = ', deleteList size printString]].	self showLoadSaveButtons! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 22:20'!deleteGamesButtonMorph	| btn labelMorph am |	btn _ PluggableButtonMorph				on: self				getState: nil				action: #deleteGames.	btn name: 'deleteGames'.	labelMorph _ StringMorph contents: '  Delete Saved Game(s)  '.	btn label: labelMorph;		 setBalloonText: 'Delete saved game files.'.	self setButtonAttributes: btn.	am _ AlignmentMorph newRow wrapCentering: #topLeft;				 cellPositioning: #topLeft;				 hResizing: #shrinkWrap;				 vResizing: #spaceFill;				 borderWidth: 0;				 layoutInset: 5;				 color: Color white.	am addMorphBack: btn.	^ am! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 12/7/2003 17:46'!editColors	self boardMorph visible		ifTrue: [self hideBoard.			self showColors]		ifFalse: [self isLoadSaveMorphVisible ifFalse: [self hideColors.			self showBoard]]! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 12/7/2003 17:32'!editColorsControlMorph	| tags tag tableMorph row swatch stringMorph |	tags _ NsGameTile colorTags.	tableMorph _ AlignmentMorph newColumn beTransparent.	NsGameTile editableColorKeys		do: [:key | 			tag _ tags at: key.			row _ AlignmentMorph newRow beTransparent.			swatch _ ColorSwatch new target: self;						 getSelector: #currentColor:;						 putSelector: #currentColor:new:;						 argument: key;						 extent: 40 @ 20;						 setBalloonText: 'click here to change the color';						 yourself.			swatch useRoundedCorners; borderStyle: (BorderStyle complexAltInset width: 2).			row addTransparentSpacerOfSize: 4 @ 0.			row addMorphBack: swatch.			row addTransparentSpacerOfSize: 6 @ 0.			stringMorph _ StringMorph contents: tag.			stringMorph color: self stringColor.			row addMorphBack: stringMorph.			row addTransparentSpacerOfSize: 4 @ 0.			tableMorph addMorphBack: row].	^ tableMorph! !!NsGame methodsFor: 'accessing' stamp: 'sbw 11/25/2003 06:24'!gameModel	^ gameModel! !!NsGame methodsFor: 'accessing' stamp: 'sbw 11/25/2003 06:24'!gameModel: anNsModel 	gameModel _ anNsModel! !!NsGame methodsFor: 'events' stamp: 'sbw 11/25/2003 06:27'!help	^ NsGame helpWindow! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 12/7/2003 17:20'!hideBoard	(self boardMorph) hide! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 12/7/2003 17:39'!hideColors	| m |	m _ self colorsMorph.	m isNil		ifFalse: [m hide]! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 17:49'!hideLoadSave	| m |	m _ self loadSaveMorph.	m isNil		ifFalse: [m hide]! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 22:21'!hideLoadSaveButtons	| m loadBtn saveBtn delBtn |	m _ self loadSaveMorph.	loadBtn _ m submorphNamed: 'loadGame'.	saveBtn _ m submorphNamed: 'saveGame'.	delBtn _ m submorphNamed: 'deleteGames'.	((loadBtn isNil			or: [saveBtn isNil]) or: [delBtn isNil])		ifFalse: [loadBtn hide.			saveBtn hide.			delBtn hide]! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 11/25/2003 06:27'!initialExtent	"Extent used for colors window."	^ 250 @ 200! !!NsGame methodsFor: 'initialization' stamp: 'sbw 11/28/2003 13:40'!initialize	self		gameModel: (NsModel new: (self defaultGameSize) gameMorph: self).	super initialize.	self layoutPolicy: ProportionalLayout new.	self setWindowColors.	self addMorphs! !!NsGame methodsFor: 'widgets' stamp: 'sbw 12/7/2003 17:44'!isColorsMorphVisible	| m |	m _ self colorsMorph.	m isNil ifTrue: [^false].	^m visible! !!NsGame methodsFor: 'widgets' stamp: 'sbw 12/7/2003 17:45'!isLoadSaveMorphVisible	| m |	m _ self loadSaveMorph.	m isNil		ifTrue: [^ false].	^ m visible! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 22:34'!loadGame	| fileName fStream assoc list choice didIt |	self hideLoadSaveButtons.	didIt _ false.	list _ FileDirectory default fileNamesMatching: '*.ns'.	list size = 0		ifTrue: [self inform: 'No files found to load']		ifFalse: [list size = 1				ifTrue: [fileName _ list first]				ifFalse: [choice _ PopUpMenu withCaption: 'Select a saved game file.' chooseFrom: list.					choice = 0						ifTrue: [fileName _ nil]						ifFalse: [fileName _ list at: choice]].					fileName isNil						ifFalse: [fStream _ FileDirectory default readOnlyFileNamed: fileName.							assoc _ self gameModel loadPiecesFrom: fStream.							fStream close.							self gameModel restartWith: self boardMorph usingPositions: assoc value.							self gameModel initialPositions: assoc value.							didIt _ true]].	self showLoadSaveButtons.	didIt		ifTrue: [self loadSave]! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 21:27'!loadGameButtonMorph	| btn labelMorph am |	btn _ PluggableButtonMorph				on: self				getState: nil				action: #loadGame.	btn name: 'loadGame'.	labelMorph _ StringMorph contents: '  Load Previously Saved Game  '.	btn label: labelMorph;		 setBalloonText: 'Load a previously saved game.  This will destroy the current game.'.	self setButtonAttributes: btn.	am _ AlignmentMorph newRow wrapCentering: #topLeft;				 cellPositioning: #topLeft;				 hResizing: #shrinkWrap;				 vResizing: #spaceFill;				 borderWidth: 0;				 layoutInset: 5;				 color: Color white.	am addMorphBack: btn.	^ am! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 17:48'!loadSave	self boardMorph visible		ifTrue: [self hideBoard.  self showLoadSave]		ifFalse: [self isColorsMorphVisible				ifFalse: [self hideLoadSave. self showBoard]]! !!NsGame methodsFor: 'widgets' stamp: 'sbw 12/7/2003 17:40'!loadSaveMorph	^ self submorphNamed: 'loadSave'! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 11/28/2003 16:20'!makeButtonNamed: label action: actionSymbol helpKey: helpKey	| btn labelMorph |	btn _ PluggableButtonMorph				on: self				getState: nil				action: actionSymbol.	labelMorph _ StringMorph contents: label.	btn label: labelMorph;				setBalloonText: (NsGame helpFor: helpKey).	self setButtonAttributes: btn.	^ btn! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 12/4/2003 02:19'!makeCloseGameButton	^ self		makeButtonNamed: 'End Game'		action: #closeGame		helpKey: 'EndGame'! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/27/2003 11:03'!makeControls	| column countPanelHeight buttonHeight top |	column _ RectangleMorph new borderWidth: 0;				 color: Color transparent;				 layoutPolicy: ProportionalLayout new.	column name: 'controls'.	countPanelHeight _ 40.	buttonHeight _ 24.	top _ self				addPanelsToColumn: column				panelHeight: countPanelHeight				offset: self windowPadding y.	top _ self				addButtonsToColumn: column				buttonHeight: buttonHeight				offset: top.	^ column! !!NsGame methodsFor: 'widgets - counters' stamp: 'sbw 11/25/2003 06:32'!makeCountMorph	count _ LedMorph new digits: 3;				 extent: 3 * 10 @ 15;								setBalloonText: (NsGame helpFor: 'ConnectedCounter').	count color: NsGameTile ledColor.	^ self wrapPanel: count label: 'Connected:'! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 11/28/2003 16:21'!makeEditColorsButton	^ self		makeButtonNamed: 'Colors'		action: #editColors		helpKey: 'Colors'! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/25/2003 06:28'!makeGameBoardMorph	board _ SketchMorph withForm: self gameModel renderCells.	board name: 'board'.	self registerSelectedBoardEvents.	^ board! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 11/28/2003 16:22'!makeHelpButton	^ self		makeButtonNamed: 'Instructions'		action: #help		helpKey: 'Help'! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 12/7/2003 15:22'!makeLoadSaveButton	^ self		makeButtonNamed: 'Load/Save'		action: #loadSave		helpKey: 'LoadSave'! !!NsGame methodsFor: 'widgets - counters' stamp: 'sbw 11/25/2003 06:32'!makeMaxMorph	max _ LedMorph new digits: 3;				 extent: 3 * 10 @ 15;								setBalloonText: (NsGame helpFor: 'MaxCounter').	max color: NsGameTile ledColor.	^ self wrapPanel: max label: 'Max:'! !!NsGame methodsFor: 'widgets - counters' stamp: 'sbw 11/25/2003 06:32'!makeMovesMorph	moves _ LedMorph new digits: 3;				 extent: 3 * 10 @ 15;								setBalloonText: (NsGame helpFor: 'TurnsCounter').	moves color: NsGameTile ledColor.	^ self wrapPanel: moves label: 'Turns:'! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 11/28/2003 16:22'!makeNewGameButton	^ self		makeButtonNamed: 'New Game'		action: #newGame		helpKey: 'NewGame'! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 11/28/2003 16:23'!makeNewSizeButton	^ self		makeButtonNamed: 'New Size'		action: #newSize		helpKey: 'NewSize'! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 11/28/2003 16:23'!makeRestartButton	^ self		makeButtonNamed: 'Restart'		action: #restart		helpKey: 'Restart'! !!NsGame methodsFor: 'events' stamp: 'sbw 12/7/2003 20:46'!newGame	self boardMorph visible ifFalse: [^self].	self newGameOfSize: self gameModel extent! !!NsGame methodsFor: 'events' stamp: 'sbw 12/7/2003 17:21'!newGameOfSize: aPoint 	self		gameModel: (NsModel new: aPoint gameMorph: self).	self boardMorph newForm: self gameModel renderCells.	self registerSelectedBoardEvents! !!NsGame methodsFor: 'events' stamp: 'sbw 4/26/2004 22:26'!newSize	| choices index point initial choiceStrings reply menu |	self boardMorph visible		ifFalse: [^ self].	initial := {7. 8. 9. 10. 11. 12. 13}.	choices := OrderedCollection new.	choices add: 'enter value'.	initial		do: [:x | 			choices add: x @ x.			x < 9				ifTrue: [choices add: x @ (x + 1);						 add: x @ (x + 2);						 add: x @ (x + 3);						 add: x @ (x + 4)]].	choiceStrings := choices				collect: [:x | x isPoint						ifTrue: [x = self defaultGameSize								ifTrue: [x printString , ' DEFAULT']								ifFalse: [x printString]]						ifFalse: [x]].	menu _ EmphasizedMenu selections: choiceStrings.	menu				emphases: (choices						collect: [:it | it = self gameModel extent								ifTrue: [#bold]								ifFalse: [#normal]]).	reply _ menu startUpWithCaption: 'Choose new game size'.	reply isNil		ifFalse: [index := choiceStrings indexOf: reply.			index = 1				ifTrue: [point := self promptForNewSize.					point isNil						ifTrue: [^ self]]				ifFalse: [point := choices at: index].			self newGameOfSize: point.			self extent: self calculatedExtent]! !!NsGame methodsFor: 'events' stamp: 'sbw 11/25/2003 06:29'!promptForNewSize	| prompt array x y |	prompt _ FillInTheBlank request: 'Enter x@y dimensions'.	prompt isEmpty		ifTrue: [^ nil].	array _ prompt findTokens: $@.	x _ array first asNumber.	y _ array second asNumber.	^ x @ y! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 21:52'!promptForSaveFileName: initial	| continue default reply trialName choice |	continue _ true.	default _ initial.	[continue] whileTrue: [	reply _ FillInTheBlank request: 'File name (.ns will be appended)?' initialAnswer: default.	reply isEmpty		ifTrue: [^ nil].	trialName _ reply, '.ns'.	continue _ FileDirectory default fileExists: trialName.	continue ifTrue: [		choice _ PopUpMenu withCaption: 'File "', reply, '" already exists' chooseFrom:			{'Overwrite it'. 'Try a new name'. 'Cancel'}.		choice = 0 ifTrue: [^nil].		choice = 3 ifTrue: [^nil].		choice = 1 ifTrue: [^trialName].		choice = 2 ifTrue: [default _ reply]		]	].	^trialName! !!NsGame methodsFor: 'events' stamp: 'sbw 12/7/2003 17:21'!registerSelectedBoardEvents	self boardMorph		on: #mouseUp		send: #click:forMorph:		to: self! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 11/25/2003 06:29'!resetColors	NsGameTile initializeColors.	self updateColors! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 12/7/2003 18:19'!resetColorsButtonMorph	| btn labelMorph am |	btn _ PluggableButtonMorph				on: self				getState: nil				action: #resetColors.	labelMorph _ StringMorph contents: '  Reset to defaults  '.	btn label: labelMorph;		 setBalloonText: 'Reset to using default colors'.	self setButtonAttributes: btn.	am _ AlignmentMorph newRow wrapCentering: #topLeft;				 cellPositioning: #topLeft;				 hResizing: #shrinkWrap;				 vResizing: #spaceFill;				 borderWidth: 0;				 layoutInset: 5;				 color: Color white.	am addMorphBack: btn.	^ am! !!NsGame methodsFor: 'events' stamp: 'sbw 12/7/2003 20:46'!restart	self boardMorph visible ifFalse: [^self].	self gameModel restartWith: self boardMorph! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 22:27'!saveGame	| fileName fStream |	fileName _ self promptForSaveFileName: self saveGameFileName.	fileName isNil		ifTrue: [^ self].	fStream _ FileDirectory default forceNewFileNamed: fileName.	self gameModel savePiecesOn: fStream.	fStream close.! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 20:37'!saveGameButtonMorph	| btn labelMorph am |	btn _ PluggableButtonMorph				on: self				getState: nil				action: #saveGame.	btn name: 'saveGame'.	labelMorph _ StringMorph contents: '  Save Current Game  '.	btn label: labelMorph;		 setBalloonText: 'Save the current game to a file.'.	self setButtonAttributes: btn.	am _ AlignmentMorph newRow wrapCentering: #topLeft;				 cellPositioning: #topLeft;				 hResizing: #shrinkWrap;				 vResizing: #spaceFill;				 borderWidth: 0;				 layoutInset: 5;				 color: Color white.	am addMorphBack: btn.	^ am! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 21:40'!saveGameFileName	^ 'saved'! !!NsGame methodsFor: 'events' stamp: 'sbw 11/27/2003 10:27'!selectedCellClicked: evt forMorph: aSketchMorph 	| clickPosn cellSize selectedCell guess1 guess2 guess3 tolerance |	clickPosn _ evt cursorPoint - aSketchMorph position.	cellSize _ aSketchMorph extent // self gameModel extent.	tolerance _ 1.	guess1 _ clickPosn // cellSize.	guess1 _ guess1 + 1.	guess2 _ clickPosn - tolerance // cellSize.	guess2 _ guess2 + 1.	guess3 _ clickPosn + tolerance // cellSize.	guess3 _ guess3 + 1.	selectedCell _ nil.	(guess1 = guess2			and: [guess1 = guess3])		ifTrue: [((guess1 x > 0 and: [guess1 x <= self gameModel extent x]) and: [guess1 y > 0 and: [guess1 y <= self gameModel extent y]]) ifTrue: [			selectedCell _ guess1]].	^ selectedCell! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 11/25/2003 06:29'!setButtonAttributes: btn 	btn useRoundedCorners; hResizing: #spaceFill; onColor: Color transparent offColor: Color transparent; borderWidth: 2; borderColor: #raised; fillWithRamp: self windowColorRamp oriented: 0.1 @ 0.8.	btn label color: Color white! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/28/2003 17:09'!setWindowColors	self setWindowColorsOn: self! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/28/2003 17:09'!setWindowColorsOn: target	target borderWidth: 4;				borderColor: (Color				r: 0.369				g: 0.369				b: 0.505);		 useRoundedCorners.	target fillWithRamp: self windowColorRamp oriented: 0.4 @ 0.35! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 12/7/2003 17:19'!showBoard	self boardMorph show! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 12/7/2003 17:40'!showColors	| m |	m _ self colorsMorph.	m isNil		ifTrue: [m _ self wrapPanel: self buildColorsMorph label: 'Colors'.			m name: 'colors'.			self addMorph: m fullFrame: self boardMorphLayoutFrame].	m show! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 12/7/2003 17:40'!showControls	(self colorsMorph) show! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 17:52'!showLoadSave	| m |	m _ self loadSaveMorph.	m isNil		ifTrue: [m _ self wrapPanel: self buildLoadSaveMorph label: 'Load/Save'.			m name: 'loadSave'.			self addMorph: m fullFrame: self boardMorphLayoutFrame].	m show! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 22:22'!showLoadSaveButtons	| m loadBtn saveBtn delBtn |	m _ self loadSaveMorph.	loadBtn _ m submorphNamed: 'loadGame'.	saveBtn _ m submorphNamed: 'saveGame'.	delBtn _ m submorphNamed: 'deleteGames'.	((loadBtn isNil				or: [saveBtn isNil])			or: [delBtn isNil])		ifFalse: [loadBtn show.			saveBtn show.			delBtn show]! !!NsGame methodsFor: 'widgets' stamp: 'sbw 12/7/2003 17:09'!stringColor	^Color				r: 0.84				g: 1.0				b: 0.8! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 12/7/2003 17:19'!updateColors	NsGameTile updateColors.	(self boardMorph)		newForm: gameModel renderCells! !!NsGame methodsFor: 'events' stamp: 'sbw 11/25/2003 06:30'!updateCounters	count isNil		ifFalse: [count value: self gameModel currentCount.			count highlighted: self gameModel circuitComplete].	max isNil		ifFalse: [max value: self gameModel maxConnected.			max highlighted: self gameModel allTilesActive].	moves isNil		ifFalse: [moves value: self gameModel moves].	^ self gameModel circuitComplete! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/25/2003 06:25'!windowColorRamp	^ {0.0		-> (Color				r: 0.7				g: 0.7				b: 1.0). 1.0		-> (Color				r: 0.3				g: 0.3				b: 0.4)}! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/26/2003 17:23'!windowExtra	^ self controlPanelWidth @ 0 + ((self windowPadding) * 2)! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/26/2003 17:22'!windowPadding	^ 10 @ 10! !!NsGame methodsFor: 'widgets - counters' stamp: 'sbw 12/7/2003 17:09'!wrapPanel: anLedPanel label: aLabel 	"wrap an LED panel in an alignmentMorph with a label above it"	| a strM |	a _ AlignmentMorph newColumn wrapCentering: #topLeft;				 cellPositioning: #topLeft;				 hResizing: #spaceFill;				 vResizing: #shrinkWrap;				 borderWidth: 2;				 layoutInset: 5;				 color: Color transparent;				 useRoundedCorners;								borderStyle: (BorderStyle complexAltInset width: 2).	a addMorph: anLedPanel.	strM _ StringMorph contents: aLabel.	strM color: self stringColor.	a addMorph: strM.	^ a! !!NsCrossGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:09'!hasForms	^ true! !!NsCrossGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:35'!initializeActiveForms	| orientationForm line |	self activeCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self fullHorizontalMiddleLine: true.	line displayOn: orientationForm.	line _ self fullVerticalMiddleLine: true.	line displayOn: orientationForm.	self activeCachedForms at: 1 put: orientationForm! !!NsCrossGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:33'!initializeIdleForms	| orientationForm line |	self idleCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self fullHorizontalMiddleLine: false.	line displayOn: orientationForm.	line _ self fullVerticalMiddleLine: false.	line displayOn: orientationForm.	self idleCachedForms at: 1 put: orientationForm! !!NsCrossGameTile class methodsFor: 'constants' stamp: 'sbw 12/7/2003 14:30'!partCode	^1! !!NsCrossGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:39'!tileName	^'Cross'! !!NsFourConnectionsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:18'!maxConnections	^ 4! !!NsFourConnectionsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:19'!maxOrientations	^ 1! !!NsFourConnectionsGameTile methodsFor: 'neighbors' stamp: 'sbw 10/17/2003 14:15'!neighborDeltas	^OrderedCollection		with: -1@0		with: 0@-1		with: 1@0		with: 0@1! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 4/27/2004 22:46'!activeCachedForms	ActiveCachedForms isNil ifTrue: [self initializeActiveForms].	^ ActiveCachedForms! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:05'!activeCachedForms: aDictionary 	ActiveCachedForms _ aDictionary! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 04:54'!activeLineColor	^self colors at: 'activeLineColor'! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 21:49'!activeLineColorString	^ 'Active Line Color'! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 04:55'!backgroundColor	^ self colors at: 'backgroundColor'! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 21:49'!backgroundColorString	^ 'Background Color'! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 04:56'!borderColor	^ self colors at: 'borderColor'! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 21:50'!borderColorString	^ 'Border Color'! !!NsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:15'!borderWidth	^ 2! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 04:57'!boxColor	^ self colors at: 'boxColor'! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 21:50'!boxColorString	^'Box Color'! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/15/2003 06:40'!colorTags	| dict selector value |	dict _ Dictionary new.	self editableColorKeys		do: [:key | 			selector _ (key , 'String') asSymbol.			value _ self perform: selector.			dict at: key put: value].	^ dict! !!NsGameTile class methodsFor: 'accessing' stamp: 'sbw 11/13/2003 04:52'!colors	Colors == nil ifTrue: [self initializeColors].	^ Colors! !!NsGameTile class methodsFor: 'accessing' stamp: 'sbw 11/13/2003 04:51'!colors: dict	Colors _ dict! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:50'!displayForms	"NsGameTile displayForms"	| xPos yPos form maxPos |	yPos _ 10.	maxPos _ 0.	(self allSubclasses		select: [:cls | cls hasForms])		do: [:subclass | 			xPos _ 10.			1				to: subclass maxOrientations				do: [:index | 					form _ subclass activeCachedForms at: index.					form displayAt: xPos @ yPos.					xPos + form extent x > maxPos						ifTrue: [maxPos _ xPos + form extent x].					xPos _ xPos + 10 + self extent x].			yPos _ yPos + 10 + self extent y].	yPos _ 10.	(self allSubclasses		select: [:cls | cls hasForms])		do: [:subclass | 			xPos _ maxPos  + 10.			1				to: subclass maxOrientations				do: [:index | 					form _ subclass idleCachedForms at: index.					form displayAt: xPos @ yPos.					xPos _ xPos + 10 + self extent x].			yPos _ yPos + 10 + self extent y]! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:53'!eastLineSegment: beActive 	| line lineFillForm x1 y1 p1 x2 y2 p2 |	line _ Line new.	lineFillForm _ Form extent: self lineWidth @ self lineWidth depth: self formDepth.	lineFillForm		fillColor: (beActive				ifTrue: [self activeLineColor]				ifFalse: [self idleLineColor]).	line form: lineFillForm.	x1 _ self extent x // 2.	y1 _ self extent y // 2 - (self lineWidth // 2).	p1 _ x1 @ y1.	line beginPoint: p1.	x2 _ self extent x.	y2 _ y1.	p2 _ x2 @ y2.	line endPoint: p2.	^ line! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/15/2003 06:40'!editableColorKeys	^(OrderedCollection new)		add: 'activeLineColor';		add: 'backgroundColor';		add: 'borderColor';		add: 'boxColor';		add: 'idleLineColor';		yourself! !!NsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:16'!extent	^ 30 @ 30! !!NsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:16'!formDepth	^ 16! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:16'!fullHorizontalMiddleLine: beActive 	| line lineFillForm x1 y1 p1 x2 y2 p2 |	line _ Line new.	lineFillForm _ Form extent: self lineWidth @ self lineWidth depth: self formDepth.	lineFillForm		fillColor: (beActive				ifTrue: [self activeLineColor]				ifFalse: [self idleLineColor]).	line form: lineFillForm.	x1 _ 0.	y1 _ self extent y // 2 - (self lineWidth // 2).	p1 _ x1 @ y1.	line beginPoint: p1.	x2 _ self extent x.	y2 _ y1.	p2 _ x2 @ y2.	line endPoint: p2.	^ line! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:17'!fullVerticalMiddleLine: beActive 	| line lineFillForm x1 y1 p1 x2 y2 p2 |	line _ Line new.	lineFillForm _ Form extent: self lineWidth @ self lineWidth depth: self formDepth.	lineFillForm		fillColor: (beActive				ifTrue: [self activeLineColor]				ifFalse: [self idleLineColor]).	line form: lineFillForm.	x1 _ self extent x // 2 - (self lineWidth // 2).	y1 _ 0.	p1 _ x1 @ y1.	line beginPoint: p1.	x2 _ x1.	y2 _ self extent y.	p2 _ x2 @ y2.	line endPoint: p2.	^ line! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:08'!hasForms	^false! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 4/27/2004 22:47'!idleCachedForms	IdleCachedForms isNil ifTrue: [self initializeIdleForms].	^ IdleCachedForms! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:05'!idleCachedForms: aDictionary 	IdleCachedForms _ aDictionary! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 04:57'!idleLineColor	^ self colors at: 'idleLineColor'! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 21:50'!idleLineColorString	^'Idle Line Color'! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:17'!initializeActiveForms	^ self subclassResponsibility! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 12/7/2003 17:35'!initializeColors	"NsGameTile initializeColors"	| dict |	dict _ Dictionary new.	dict		at: 'activeLineColor'		put: (Color				r: 0.972				g: 0.595				b: 0.349);				at: 'backgroundColor'		put: (Color				r: 0.8				g: 0.8				b: 0.8);		 at: 'borderColor' put: Color white;		 at: 'boxColor' put: Color blue;				at: 'idleLineColor'		put: (Color r: 0.376 g: 0.376 b: 0.513);				at: 'ledColor'		put: (Color				r: 0.674				g: 0.674				b: 0.96).	self colors: dict! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:49'!initializeForms	"NsGameTile initializeForms"	(self allSubclasses		select: [:cls | cls hasForms])		do: [:subclass | 			subclass initializeActiveForms.			subclass initializeIdleForms]! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:17'!initializeIdleForms	^ self subclassResponsibility! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 04:58'!ledColor	^self colors at: 'ledColor'! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 21:51'!ledColorString	^'LED Color'! !!NsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:18'!lineWidth	^ 2! !!NsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:18'!maxConnections	^ self subclassResponsibility! !!NsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:18'!maxOrientations	^ self subclassResponsibility! !!NsGameTile class methodsFor: 'accessing' stamp: 'sbw 12/7/2003 15:10'!newTileMatchingPartCode: anInteger 	| clsToUse |	clsToUse _ NsGameTile allSubclasses		detect: [:cls | cls partCode = anInteger]		ifNone: [^nil].	^clsToUse new! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:56'!northLineSegment: beActive 	| line lineFillForm x1 y1 p1 x2 y2 p2 |	line _ Line new.	lineFillForm _ Form extent: self lineWidth @ self lineWidth depth: self formDepth.	lineFillForm		fillColor: (beActive				ifTrue: [self activeLineColor]				ifFalse: [self idleLineColor]).	line form: lineFillForm.	x1 _ self extent x // 2 - (self lineWidth // 2).	y1 _ 0.	p1 _ x1 @ y1.	line beginPoint: p1.	x2 _ x1.	y2 _ self extent y // 2.	p2 _ x2 @ y2.	line endPoint: p2.	^ line! !!NsGameTile class methodsFor: 'constants' stamp: 'sbw 12/7/2003 15:07'!partCode	^0! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:57'!southLineSegment: beActive 	| line lineFillForm x1 y1 p1 x2 y2 p2 |	line _ Line new.	lineFillForm _ Form extent: self lineWidth @ self lineWidth depth: self formDepth.	lineFillForm		fillColor: (beActive				ifTrue: [self activeLineColor]				ifFalse: [self idleLineColor]).	line form: lineFillForm.	x1 _ self extent x // 2 - (self lineWidth // 2).	y1 _ self extent y // 2.	p1 _ x1 @ y1.	line beginPoint: p1.	x2 _ x1.	y2 _ self extent y.	p2 _ x2 @ y2.	line endPoint: p2.	^ line! !!NsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:38'!tileName	^ self subclassResponsibility! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 05:01'!updateColors	self initializeForms! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:54'!westLineSegment: beActive 	| line lineFillForm x1 y1 p1 x2 y2 p2 |	line _ Line new.	lineFillForm _ Form extent: self lineWidth @ self lineWidth depth: self formDepth.	lineFillForm		fillColor: (beActive				ifTrue: [self activeLineColor]				ifFalse: [self idleLineColor]).	line form: lineFillForm.	x1 _ 0.	y1 _ self extent y // 2 - (self lineWidth // 2).	p1 _ x1 @ y1.	line beginPoint: p1.	x2 _ self extent x // 2.	y2 _ y1.	p2 _ x2 @ y2.	line endPoint: p2.	^ line! !!NsGameTile methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:23'!active	active isNil ifTrue: [self active: false].	^active! !!NsGameTile methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:23'!active: aBoolean	active _ aBoolean! !!NsGameTile methodsFor: 'testing' stamp: 'sbw 10/26/2003 08:04'!canBeActive	^true! !!NsGameTile methodsFor: 'accessing' stamp: 'sbw 10/16/2003 15:03'!form	^self active		ifTrue: [self class activeCachedForms at: self orientation]		ifFalse: [self class idleCachedForms at: self orientation]! !!NsGameTile methodsFor: 'accessing' stamp: 'sbw 10/16/2003 09:18'!form: aForm	form _ aForm! !!NsGameTile methodsFor: 'testing' stamp: 'sbw 10/17/2003 14:05'!isSource	^false! !!NsGameTile methodsFor: 'neighbors' stamp: 'sbw 10/17/2003 15:20'!neighborDeltas	^  OrderedCollection new! !!NsGameTile methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:22'!orientation	orientation isNil ifTrue: [self orientation: 1].	^orientation! !!NsGameTile methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:22'!orientation: int	orientation _ int! !!NsGameTile methodsFor: 'printing' stamp: 'sbw 10/18/2003 13:20'!printOn: aStream 	super printOn: aStream.	aStream 		cr; nextPutAll: '  ' , self class tileName;		cr; nextPutAll: '  Active: ', self active printString;		cr; nextPutAll: '  Orientation: ', self orientation printString! !!NsGameTile methodsFor: 'events' stamp: 'sbw 10/17/2003 13:56'!rotateLeft	| value |	value _ self orientation.	value _ value + 1.	value > self class maxOrientations		ifTrue: [value _ 1].	self orientation: value! !!NsGameTile methodsFor: 'events' stamp: 'sbw 10/17/2003 13:56'!rotateRight	| value |	value _ self orientation.	value _ value - 1.	value < 1		ifTrue: [value _ self class maxOrientations].	self orientation: value! !!NsBlankGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:09'!hasForms	^ true! !!NsBlankGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:35'!initializeActiveForms	| orientationForm |	self activeCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	self activeCachedForms at: 1 put: orientationForm! !!NsBlankGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:34'!initializeIdleForms	| orientationForm |	self idleCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	self idleCachedForms at: 1 put: orientationForm! !!NsBlankGameTile class methodsFor: 'constants' stamp: 'sbw 12/7/2003 14:30'!partCode	^2! !!NsBlankGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:40'!tileName	^ 'Empty'! !!NsBlankGameTile methodsFor: 'testing' stamp: 'sbw 10/26/2003 08:04'!canBeActive	^ false! !!NsNoConnectionsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:19'!maxConnections	^ 0! !!NsNoConnectionsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:20'!maxOrientations	^ 1! !!NsDestinationGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:10'!hasForms	^ true! !!NsDestinationGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:35'!initializeActiveForms	| orientationForm line |	self activeCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self eastLineSegment: true.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self boxColor		innerColor: self activeLineColor.	self activeCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self northLineSegment: true.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self boxColor		innerColor: self activeLineColor.	self activeCachedForms at: 2 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self westLineSegment: true.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self boxColor		innerColor: self activeLineColor.	self activeCachedForms at: 3 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self southLineSegment: true.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self boxColor		innerColor: self activeLineColor.	self activeCachedForms at: 4 put: orientationForm! !!NsDestinationGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:34'!initializeIdleForms	| orientationForm line |	self idleCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self eastLineSegment: false.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self boxColor		innerColor: self idleLineColor.	self idleCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self northLineSegment: false.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self boxColor		innerColor: self idleLineColor.	self idleCachedForms at: 2 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self westLineSegment: false.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self boxColor		innerColor: self idleLineColor.	self idleCachedForms at: 3 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self southLineSegment: false.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self boxColor		innerColor: self idleLineColor.	self idleCachedForms at: 4 put: orientationForm! !!NsDestinationGameTile class methodsFor: 'constants' stamp: 'sbw 12/7/2003 14:30'!partCode	^3! !!NsDestinationGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:40'!tileName	^ 'Destination'! !!NsOneConnectionGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 21:07'!fillBoxesOn: aForm outerColor: outerColor innerColor: innerColor 	| rect |	rect _ (0 @ 0 extent: aForm extent)				insetBy: 7.	aForm fill: rect fillColor: outerColor.	rect _ (0 @ 0 extent: aForm extent)				insetBy: 11.	aForm fill: rect fillColor: innerColor! !!NsOneConnectionGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:21'!maxConnections	^ 1! !!NsOneConnectionGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:21'!maxOrientations	^ 4! !!NsOneConnectionGameTile methodsFor: 'neighbors' stamp: 'sbw 10/17/2003 14:33'!neighborDeltas	| delta |	delta _ 1 @ 0.	self orientation = 2		ifTrue: [delta _ 0 @ -1].	self orientation = 3		ifTrue: [delta _ -1 @ 0].	self orientation = 4		ifTrue: [delta _ 0 @ 1].	^ OrderedCollection with: delta! !!NsSourceGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:09'!hasForms	^ true! !!NsSourceGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:35'!initializeActiveForms	| orientationForm line |	self activeCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self eastLineSegment: true.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self activeLineColor		innerColor: self boxColor.	self activeCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self northLineSegment: true.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self activeLineColor		innerColor: self boxColor.	self activeCachedForms at: 2 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self westLineSegment: true.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self activeLineColor		innerColor: self boxColor.	self activeCachedForms at: 3 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self southLineSegment: true.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self activeLineColor		innerColor: self boxColor.	self activeCachedForms at: 4 put: orientationForm! !!NsSourceGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:34'!initializeIdleForms	| orientationForm line |	self idleCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self eastLineSegment: false.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self idleLineColor		innerColor: self boxColor.	self idleCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self northLineSegment: false.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self idleLineColor		innerColor: self boxColor.	self idleCachedForms at: 2 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self westLineSegment: false.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self idleLineColor		innerColor: self boxColor.	self idleCachedForms at: 3 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self southLineSegment: false.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self idleLineColor		innerColor: self boxColor.	self idleCachedForms at: 4 put: orientationForm! !!NsSourceGameTile class methodsFor: 'constants' stamp: 'sbw 12/7/2003 14:31'!partCode	^4! !!NsSourceGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:41'!tileName	^ 'Source'! !!NsSourceGameTile methodsFor: 'accessing' stamp: 'sbw 10/16/2003 21:06'!active	^true! !!NsSourceGameTile methodsFor: 'accessing' stamp: 'sbw 10/17/2003 14:12'!active: aBoolean 	"ignored"	active _ true! !!NsSourceGameTile methodsFor: 'testing' stamp: 'sbw 10/17/2003 14:04'!isSource	^true! !!NsTeeGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:10'!hasForms	^ true! !!NsTeeGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:36'!initializeActiveForms	| orientationForm line |	self activeCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self eastLineSegment: true.	line displayOn: orientationForm.	line _ self northLineSegment: true.	line displayOn: orientationForm.	line _ self southLineSegment: true.	line displayOn: orientationForm.	self activeCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self northLineSegment: true.	line displayOn: orientationForm.	line _ self westLineSegment: true.	line displayOn: orientationForm.	line _ self eastLineSegment: true.	line displayOn: orientationForm.	self activeCachedForms at: 2 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self westLineSegment: true.	line displayOn: orientationForm.	line _ self southLineSegment: true.	line displayOn: orientationForm.	line _ self northLineSegment: true.	line displayOn: orientationForm.	self activeCachedForms at: 3 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self southLineSegment: true.	line displayOn: orientationForm.	line _ self eastLineSegment: true.	line displayOn: orientationForm.	line _ self westLineSegment: true.	line displayOn: orientationForm.	self activeCachedForms at: 4 put: orientationForm! !!NsTeeGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:34'!initializeIdleForms	| orientationForm line |	self idleCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self eastLineSegment: false.	line displayOn: orientationForm.	line _ self northLineSegment: false.	line displayOn: orientationForm.	line _ self southLineSegment: false.	line displayOn: orientationForm.	self idleCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self northLineSegment: false.	line displayOn: orientationForm.	line _ self westLineSegment: false.	line displayOn: orientationForm.	line _ self eastLineSegment: false.	line displayOn: orientationForm.	self idleCachedForms at: 2 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self westLineSegment: false.	line displayOn: orientationForm.	line _ self southLineSegment: false.	line displayOn: orientationForm.	line _ self northLineSegment: false.	line displayOn: orientationForm.	self idleCachedForms at: 3 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self southLineSegment: false.	line displayOn: orientationForm.	line _ self eastLineSegment: false.	line displayOn: orientationForm.	line _ self westLineSegment: false.	line displayOn: orientationForm.	self idleCachedForms at: 4 put: orientationForm! !!NsTeeGameTile class methodsFor: 'constants' stamp: 'sbw 12/7/2003 14:31'!partCode	^5! !!NsTeeGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:41'!tileName	^ 'Tee'! !!NsTeeGameTile methodsFor: 'neighbors' stamp: 'sbw 10/17/2003 14:35'!neighborDeltas	| delta1 delta2 delta3 |	delta1 _ 0 @ 1.	delta2 _ 1 @ 0.	delta3 _ 0 @ -1.	self orientation = 2		ifTrue: [delta1 _ 1 @ 0.			delta2 _ 0 @ -1.			delta3 _ -1 @ 0].	self orientation = 3		ifTrue: [delta1 _ 0 @ -1.			delta2 _ -1 @ 0.			delta3 _ 0 @ 1].	self orientation = 4		ifTrue: [delta1 _ 0 @ 1.			delta2 _ 1 @ 0.			delta3 _ -1@ 0].	^ OrderedCollection		with: delta1		with: delta2		with: delta3! !!NsThreeConnectionsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:21'!maxConnections	^ 3! !!NsThreeConnectionsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:22'!maxOrientations	^ 4! !!NsCornerGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:10'!hasForms	^ true! !!NsCornerGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:36'!initializeActiveForms	| orientationForm line |	self activeCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self eastLineSegment: true.	line displayOn: orientationForm.	line _ self northLineSegment: true.	line displayOn: orientationForm.	self activeCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self northLineSegment: true.	line displayOn: orientationForm.	line _ self westLineSegment: true.	line displayOn: orientationForm.	self activeCachedForms at: 2 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self westLineSegment: true.	line displayOn: orientationForm.	line _ self southLineSegment: true.	line displayOn: orientationForm.	self activeCachedForms at: 3 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self southLineSegment: true.	line displayOn: orientationForm.	line _ self eastLineSegment: true.	line displayOn: orientationForm.	self activeCachedForms at: 4 put: orientationForm! !!NsCornerGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:35'!initializeIdleForms	| orientationForm line |	self idleCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self eastLineSegment: false.	line displayOn: orientationForm.	line _ self northLineSegment: false.	line displayOn: orientationForm.	self idleCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self northLineSegment: false.	line displayOn: orientationForm.	line _ self westLineSegment: false.	line displayOn: orientationForm.	self idleCachedForms at: 2 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self westLineSegment: false.	line displayOn: orientationForm.	line _ self southLineSegment: false.	line displayOn: orientationForm.	self idleCachedForms at: 3 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self southLineSegment: false.	line displayOn: orientationForm.	line _ self eastLineSegment: false.	line displayOn: orientationForm.	self idleCachedForms at: 4 put: orientationForm! !!NsCornerGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 11:46'!maxOrientations	^ 4! !!NsCornerGameTile class methodsFor: 'constants' stamp: 'sbw 12/7/2003 14:31'!partCode	^6! !!NsCornerGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:41'!tileName	^ 'Corner'! !!NsCornerGameTile methodsFor: 'neighbors' stamp: 'sbw 10/17/2003 15:11'!neighborDeltas	| delta1 delta2 |	delta1 _ 1 @ 0.	delta2 _ 0 @ -1.	self orientation = 2		ifTrue: [delta1 _ -1 @ 0.			delta2 _ 0 @ -1].	self orientation = 3		ifTrue: [delta1 _ 0 @ 1.			delta2 _ -1 @ 0].	self orientation = 4		ifTrue: [delta1 _ 0 @ 1.			delta2 _ 1 @ 0].	^ OrderedCollection with: delta1 with: delta2! !!NsLineGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:10'!hasForms	^ true! !!NsLineGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:36'!initializeActiveForms	| orientationForm line |	self activeCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self fullHorizontalMiddleLine: true.	line displayOn: orientationForm.	self activeCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self fullVerticalMiddleLine: true.	line displayOn: orientationForm.	self activeCachedForms at: 2 put: orientationForm! !!NsLineGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:35'!initializeIdleForms	| orientationForm line |	self idleCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self fullHorizontalMiddleLine: false.	line displayOn: orientationForm.	self idleCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self fullVerticalMiddleLine: false.	line displayOn: orientationForm.	self idleCachedForms at: 2 put: orientationForm! !!NsLineGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 11:46'!maxOrientations	^ 2! !!NsLineGameTile class methodsFor: 'constants' stamp: 'sbw 12/7/2003 14:31'!partCode	^7! !!NsLineGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:41'!tileName	^ 'Line'! !!NsLineGameTile methodsFor: 'neighbors' stamp: 'sbw 10/17/2003 14:33'!neighborDeltas	| delta1 delta2 |	delta1 _ 1 @ 0.	delta2 _ -1 @ 0.	self orientation = 2		ifTrue: [delta1 _ 0 @ -1.			delta2 _ 0 @ 1].	^ OrderedCollection with: delta1 with: delta2! !!NsTwoConnectionsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:22'!maxConnections	^ 2! !!NsModel class methodsFor: 'example' stamp: 'sbw 10/16/2003 21:55'!example: aPoint	"NsModel example: 5@6"	| model |	model _ self new: aPoint.	model renderCells displayAt: 10 @ 10! !!NsModel class methodsFor: 'instance creation' stamp: 'sbw 10/18/2003 10:33'!new: anExtent 	"NsModel new: 5@5"	| model |	model _ self new.	model initialize: anExtent.	^ model! !!NsModel class methodsFor: 'instance creation' stamp: 'sbw 10/18/2003 10:31'!new: anExtent gameMorph: aMorph	"NsModel new: 5@5"	| model |	model _ self new.	model initialize: anExtent gameMorph: aMorph.	^ model! !!NsModel class methodsFor: 'randomization' stamp: 'sbw 10/16/2003 14:32'!randomNumberGenerator	RandomNumberGenerator isNil ifTrue: [		RandomNumberGenerator _ Random new.		RandomNumberGenerator seed: Time totalSeconds].	^RandomNumberGenerator! !!NsModel class methodsFor: 'randomization' stamp: 'sbw 12/14/2003 12:37'!reSeed	self randomNumberGenerator seed: Time totalSeconds! !!NsModel class methodsFor: 'randomization' stamp: 'sbw 12/14/2003 12:41'!startUp	self reSeed! !!NsModel methodsFor: 'testing' stamp: 'sbw 10/26/2003 08:05'!allTilesActive	^ (self pieces		select: [:each | each active]) size = (self pieces select: [:each | each canBeActive]) size! !!NsModel methodsFor: 'testing' stamp: 'sbw 10/18/2003 10:17'!circuitComplete	^(self destinationAddresses reject: [:addr | (self pieces at: addr) active]) isEmpty! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:08'!currentCount	^currentCount! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:08'!currentCount: int	currentCount _ int! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:12'!destinationAddresses	^destinationAddresses! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:12'!destinationAddresses: aColl	destinationAddresses _ aColl! !!NsModel methodsFor: 'testing' stamp: 'sbw 10/17/2003 15:02'!doesNextAddress: nextAddress pointBackTo: currentAddress 	| piece deltas goodDeltas calculatedAddress |	piece _ self pieces at: nextAddress.	deltas _ piece neighborDeltas.	goodDeltas _ deltas				select: [:delta | 					calculatedAddress _ nextAddress + delta.					(self isAddressValid: calculatedAddress)						and: [calculatedAddress = currentAddress]].	^ goodDeltas notEmpty! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:12'!extent	^extent! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:12'!extent: aPoint	extent _ aPoint! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:29'!gameMorph	^gameMorph! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:29'!gameMorph: aMorph	gameMorph _ aMorph! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 13:10'!initialPositions	^initialPositions! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 13:10'!initialPositions: aCollection 	initialPositions _ aCollection! !!NsModel methodsFor: 'initialize' stamp: 'sbw 11/15/2003 06:27'!initialize: anExtent gameMorph: aMorph 	self gameMorph: aMorph.	self extent: anExtent.	self pieces: nil.	self maxConnected: 0.	self currentCount: 0.	self moves: 0.	self destinationAddresses: OrderedCollection new.	self populateWithRandomCells! !!NsModel methodsFor: 'initialize' stamp: 'sbw 10/16/2003 14:20'!initializePieces	self pieces: Dictionary new! !!NsModel methodsFor: 'testing' stamp: 'sbw 10/17/2003 14:39'!isAddressValid: aPoint	aPoint x = 0 ifTrue: [^false].	aPoint y = 0 ifTrue: [^false].	aPoint x > self extent x ifTrue: [^false].	aPoint y > self extent y ifTrue: [^false].	^true! !!NsModel methodsFor: 'persist' stamp: 'sbw 12/7/2003 20:12'!loadPiecesFrom: aStream 	| coll newSize dict lc pc or tile string pair |	aStream reset.	coll _ aStream contents findTokens: self tokenChar.	string _ coll removeFirst.	pair _ string findTokens: $@.	newSize _ Point x: pair first asInteger y: pair last asInteger.	dict _ Dictionary new.	[coll isEmpty]		whileFalse: [string _ coll removeFirst.			pair _ string findTokens: $@.			lc _ Point x: pair first asInteger y: pair last asInteger.			pc _ coll removeFirst asInteger.			or _ coll removeFirst asInteger.			tile _ NsGameTile newTileMatchingPartCode: pc.			tile orientation: or.			dict at: lc put: tile].	^ newSize -> dict! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:08'!maxConnected	^maxConnected! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:06'!maxConnected: int	maxConnected _ int! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:22'!moves	^moves! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:22'!moves: int	moves _ int! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:20'!pieces	pieces isNil		ifTrue: [self initializePieces].	^ pieces! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:00'!pieces: aCollection	pieces _ aCollection! !!NsModel methodsFor: 'logic' stamp: 'sbw 10/19/2003 10:37'!populateWithRandomCells	| count |	count _ self size // 50.	count < 1		ifTrue: [count _ 1].	^ self populateWithRandomCells: count! !!NsModel methodsFor: 'logic' stamp: 'sbw 10/19/2003 09:51'!populateWithRandomCells: numberOfDestinations 	| howMany address cell |	howMany _ self size.	sourceAddress _ self randomCellAddress.	self pieces at: sourceAddress put: NsSourceGameTile new.	numberOfDestinations		timesRepeat: [address _ self randomUnusedCellAddress.			self destinationAddresses add: address.			self pieces at: address put: NsDestinationGameTile new].	howMany _ howMany - 1 - numberOfDestinations.	howMany		timesRepeat: [address _ self randomUnusedCellAddress.			cell _ self randomCell.			self pieces at: address put: cell].	self initialPositions: Dictionary new.	self pieces		keysDo: [:addr | self initialPositions at: addr put: (self pieces at: addr) deepCopy]! !!NsModel methodsFor: 'logic' stamp: 'sbw 12/7/2003 17:03'!randomCell	| random percentLine percentCorner percentTee percentCross |	percentLine _ 60.	percentCorner _ 40.	percentTee _ 79.	percentCross _ 20.	random _ self class randomNumberGenerator nextInt: 200.	random < percentLine		ifTrue: [^ NsLineGameTile new].	random < (percentLine + percentCorner)		ifTrue: [^ NsCornerGameTile new].	random < (percentLine + percentCorner + percentTee)		ifTrue: [^ NsTeeGameTile new].	random < (percentLine + percentCorner + percentTee + percentCross)		ifTrue: [^ NsCrossGameTile new].	^ NsBlankGameTile new! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:32'!randomCellAddress	| xPos yPos |	xPos _ self class randomNumberGenerator nextInt: self extent x.	yPos _ self class randomNumberGenerator nextInt: self extent y.	^ xPos @ yPos! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:45'!randomUnusedCellAddress	| random |	[random _ self randomCellAddress.	self pieces includesKey: random] whileTrue.	^ random! !!NsModel methodsFor: 'drawing' stamp: 'sbw 10/16/2003 15:08'!renderBordersOn: aForm	! !!NsModel methodsFor: 'drawing' stamp: 'sbw 10/16/2003 21:03'!renderCells	| renderForm |	renderForm _ Form extent: self renderFormSize depth: NsGameTile formDepth.	renderForm fillColor: NsGameTile borderColor.	self renderCellsOn: renderForm.	^ renderForm! !!NsModel methodsFor: 'drawing' stamp: 'sbw 10/18/2003 10:07'!renderCellsOn: aForm 	| standardExtent offset location piece |	self update.	standardExtent _ NsGameTile extent.	self pieces		keysDo: [:address | 			offset _ address - 1.			location _ offset * standardExtent.			location _ location + (address * NsGameTile borderWidth).			piece _ self pieces at: address.			piece form displayOn: aForm at: location]! !!NsModel methodsFor: 'drawing' stamp: 'sbw 10/16/2003 15:11'!renderFormSize	| basic addX addY |	basic _ self extent * NsGameTile extent.	addX _ (self extent x + 1) * (NsGameTile borderWidth).	addY _ (self extent y + 1) * (NsGameTile borderWidth).	^basic + (addX@addY)! !!NsModel methodsFor: 'events' stamp: 'sbw 12/7/2003 15:16'!restartWith: aMorph 	self restartWith: aMorph usingPositions: self initialPositions! !!NsModel methodsFor: 'events' stamp: 'sbw 12/7/2003 15:15'!restartWith: aMorph usingPositions: dict	dict		keysDo: [:addr | self pieces at: addr put: (dict at: addr) deepCopy].	self currentCount: 0.	self moves: -1.	self updateMoves.	self update.	self renderCellsOn: aMorph form.	aMorph layoutChanged! !!NsModel methodsFor: 'events' stamp: 'sbw 10/17/2003 14:00'!rotateCellLeft: aPoint forMorph: aSketchMorph 	(self pieces at: aPoint) rotateLeft.! !!NsModel methodsFor: 'events' stamp: 'sbw 10/17/2003 14:00'!rotateCellRight: aPoint forMorph: aSketchMorph 	(self pieces at: aPoint) rotateRight.! !!NsModel methodsFor: 'persist' stamp: 'sbw 12/7/2003 14:41'!saveInitialPositionsOn: aStream 	self savePieces: self initialPositions on: aStream! !!NsModel methodsFor: 'persist' stamp: 'sbw 12/7/2003 20:08'!savePiece: pc at: loc on: strm 	strm nextPutAll: loc printString;		 nextPut: self tokenChar;		 nextPutAll: pc class partCode printString;		 nextPut: self tokenChar;		 nextPutAll: pc orientation printString! !!NsModel methodsFor: 'persist' stamp: 'sbw 12/7/2003 19:50'!savePieces: dict on: aStream 	aStream nextPutAll: self extent printString.	dict		keysAndValuesDo: [:k :v | 			aStream nextPut: self tokenChar.			self				savePiece: v				at: k				on: aStream]! !!NsModel methodsFor: 'persist' stamp: 'sbw 12/7/2003 14:50'!savePiecesOn: aStream 	self savePieces: self pieces on: aStream! !!NsModel methodsFor: 'logic' stamp: 'sbw 10/19/2003 09:51'!size	^self extent x * self extent y! !!NsModel methodsFor: 'persist' stamp: 'sbw 12/7/2003 19:48'!tokenChar	^$.! !!NsModel methodsFor: 'events' stamp: 'sbw 11/15/2003 06:26'!update	self updateActiveStates.	self currentCount: (self pieces			select: [:each | each active]) size - 1.	self currentCount > self maxConnected		ifTrue: [self maxConnected: self currentCount].	self updateCounters! !!NsModel methodsFor: 'events' stamp: 'sbw 10/17/2003 15:05'!updateActiveStates	| sourcePieceAddress eachPiece |	sourcePieceAddress _ self pieces keys				detect: [:address | (self pieces at: address) isSource]				ifNone: [].	self pieces keys		do: [:address | 			eachPiece _ self pieces at: address.			eachPiece active: false].	"The source will always answer true to active."	self updateActiveStatesForNeighborsAt: sourcePieceAddress! !!NsModel methodsFor: 'events' stamp: 'sbw 10/17/2003 14:57'!updateActiveStatesForNeighborsAt: address	| rootPiece deltas nextAddress nextPiece |	rootPiece _ self pieces at: address.	rootPiece active		ifFalse: [^ self].	deltas _ rootPiece neighborDeltas.	deltas		do: [:delta | 			nextAddress _ address + delta.			(self isAddressValid: nextAddress)				ifTrue: [nextPiece _ self pieces at: nextAddress.					nextPiece active						ifFalse: [(self doesNextAddress: nextAddress pointBackTo: address)								ifTrue: [nextPiece active: true.									self updateActiveStatesForNeighborsAt: nextAddress]]]]! !!NsModel methodsFor: 'events' stamp: 'sbw 11/15/2003 06:23'!updateCounters	self gameMorph isNil		ifFalse: [self gameMorph updateCounters]! !!NsModel methodsFor: 'events' stamp: 'sbw 11/15/2003 06:23'!updateMoves	self moves: self moves + 1.	self updateCounters! !!HandMorph methodsFor: '*nsTileGame-objects from disk' stamp: 'sbw 11/8/2003 07:06' prior: 51333524!objectForDataStream: refStrm 	"I am about to be written on an object file. Write a path to me in the 	other system instead."	| dp |	refStrm project isNil ifFalse: [(refStrm project world hands includes: self)		ifTrue: [^ self]].	"owned by the project"	dp _ DiskProxy				global: #World				selector: #primaryHand				args: #().	refStrm replace: self with: dp.	^ dp"Note, when this file is loaded in an MVC project, this will return nil. 	The MenuItemMorph that has this in a field will have that item not 	work. Maybe warn the user at load time?"! !!NsGameHelpWindow class methodsFor: 'instructions' stamp: 'sbw 1/4/2005 22:25'!compressedEncodedInstructions	^ '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w8FRWy6CU1BItFTpCohqlFqq7KXlpXh3HuXpKggoolJ2FZNot81iLaK3FVBZkB5Yy+JzdMqOMih3em1a4aN1BcfiSJkjx/ZDJNqHhroMjwklBIef8wo1/rqF/4K8DloUDlunhbXXwh7lrH68DWqDbz2Fw0VlMwL1Vr99AYXpty+gp3Toc0dACi3sujNFiv5a2umt5Df9X8jvdCv5nQ7ID0ug39Y68QJle4XgqJk/6vYK83i7RnV7BUq4tolLHaku1J6nhOu3iw3WSIEXaif5L+32pfBtF2vUNlUI0jZBaC2Fb7vYB7UDv6O2rRS+7WJ5r4O4tjYZ8KXwbRc7HIepWoqwtlL4tovlvXTXaCny20rh2y62STtcvR6fadvFrtUOV0/h2y6W++ITWqk+bSOFb7vYoCdxeEtL8WBbKbTtYoOYFL/XUtzeVgptu9igf+Dqdi3FkLZS+LaLjcVhkJbilbZS+LaLHawero6VbrtYFCN4VFtbavhS+LaL5Y0Wpra1XawvhW+7WLe6Z6xM0b2tFBx5Bg7bcPC1R++2UnDkpSprCP5GS7HEf7OEeWqHDf6aN8XVb5bg1+VlwpXKXgPEXegQs4wOsZmtbpbQH/u/flGNQ5PfHgSc66L/7fshBMf05rrxIdifC5+XfPunLwT99IWgf10IAi0dw7BuxOFmHO7BIR6HHBycOMzGYQMOL+KwF4d3cfgWB6Hbd0B+t+wbdd+B4KgudLi7myTk/5X7DrQLNAdXmIcUbfUzB79nHlKtutAH373vx9sy8O++LQO/20apk/abRW3NE0ZRU/14hKiueswkqiofFRXl24zC69kSKcq9WzmkquZR4fZu6iamlm8wiqneTUbhnLoeh40RorSMwpxl60yi1LVWOJxNRlFS2hAhih31BlFcurKbsDtWGEWhfaVJFBStELbC5UaRX7DMKKy2pb4rk8jLXyIs1sVGkZu3yCzy8xZRuGWhWeTlLqCw7HkDRU7WXJE9ZY7IypwtpmTMEpmTZ9JvBj2cI3KyZ4r0tCo+W3Jniwmp5SI7a7qYkllrFJMnVUbyB//T08r5o/RpaW6jmDhxqhEAmAGAGQAYtNu7RU3Vk1z5cs8jYqp7MwBA/UUZaYlcnnXC5d4gUSgtW2dAqJGCNhkAilGC4nCtN4nikiaCotEo7CUN3UVR8Wr6rQIa9FtBSK02AikTQBJFJQRNYfEyA54ZEZFxMwI3I4Az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'! !!NsGameHelpWindow class methodsFor: 'instructions' stamp: 'sbw 1/4/2005 22:20'!convertSavedMorphFile: fileName 	"Save the BookMorph, compress it in FileList and then copy the file  	name (path) for this method. Copy the ASCII text into the  	#compressedEncodedInstructions method."	| fileStream encoded |	fileStream _ FileStream oldFileNamed: fileName.	encoded _ Base64MimeConverter mimeEncode: fileStream.	fileStream close.	encoded contents openInWorkspaceWithTitle: 'Copy this to #compressedEncodedInstructions'! !!NsGameHelpWindow class methodsFor: 'as yet unclassified' stamp: 'sbw 6/13/2004 17:42'!includeInNewMorphMenu	^false! !!NsGameHelpWindow class methodsFor: 'instructions' stamp: 'sbw 6/13/2004 18:06'!instructions	| encodedTutorial zippedString data rwStream |	encodedTutorial _ self compressedEncodedInstructions.	zippedString _ Base64MimeConverter mimeDecode: encodedTutorial as: String.	data _ zippedString unzipped.	rwStream _ RWBinaryOrTextStream with: data.	rwStream reset; fileInAnnouncing: 'Building instructions...'.	^ SmartRefStream scannedObject! !!NsGameHelpWindow class methodsFor: 'instructions' stamp: 'sbw 1/4/2005 22:45'!modifyHelpBookMorph: aBookMorph	aBookMorph configureForKids.	aBookMorph showPageControls: {		#spacer.		#variableSpacer.		{'previous page'. 		#previousPage.			'Previous page' translated}.		#variableSpacer.		{'next page'.		#nextPage.				'Next page' translated}.		#spacer.		#variableSpacer.		}! !!NsGameHelpWindow class methodsFor: 'instructions' stamp: 'sbw 1/4/2005 22:33'!openHelpWindow	"NsGameHelpWindow openHelpWindow"	| topView morph |	topView _ self labelled: 'NsGame Instructions'.	morph _ self instructions.	topView		addMorph: morph		frame: (0 @ 0 corner: 1 @ 1).	topView customizeForHelp.	morph borderColor: Color transparent;		 borderWidth: 0.	topView openInWorld.	topView extent: 505@475.	self modifyHelpBookMorph: morph! !!NsGameHelpWindow methodsFor: 'as yet unclassified' stamp: 'sbw 1/4/2005 22:30'!customizeForHelp	self		setWindowColor: (Color				r: 0.603				g: 0.603				b: 0.85).	self removeMenuBox; removeExpandBox; removeCollapseBox.! !!NsGameHelpWindow methodsFor: 'as yet unclassified' stamp: 'sbw 4/24/2004 20:49'!removeCollapseBox	collapseBox		ifNotNil: [collapseBox delete.			collapseBox := nil]! !!NsGameHelpWindow methodsFor: 'as yet unclassified' stamp: 'sbw 4/24/2004 20:49'!removeExpandBox	expandBox		ifNotNil: [expandBox delete.			expandBox := nil]! !"NsTileGame"!self fileInMonticelloZipVersionNamed: 'Games-Sokoban-sbw.9.mcz'.self fileInMonticelloZipVersionNamed: 'Morphic-Games-asm.1.mcz'.self fileInMonticelloZipVersionNamed: 'NsTileGame-sbw.17.mcz'.!----End fileIn of a stream----!PlayingCardDeck!Billete removeSelector: #startDrag:!Billete removeSelector: #mouseUp:!Billete removeSelector: #mouseLeaveDragging:!Billete removeSelector: #mouseEnterDragging:!Billete removeSelector: #handlesMouseOverDragging:!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 14:37' prior: 33638970!mouseDown: evt evt hand waitForClicksOrDrag: self event: evt selectors: { #click:. #doubleClick:. #firstClickTimedOut:. nil} threshold: 5! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 14:38' prior: 33639463!firstClickTimedOut: evt	"Start the Drag with the hand grabbing me"	evt hand grabMorph: self! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 14:38' prior: 34238134!firstClickTimedOut: evt	evt hand grabMorph: self! !Billete removeSelector: #doubleClick:!Billete removeSelector: #contenedor:!Billete removeSelector: #click:!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 14:39'!justDroppedInto: newOwner event: evt	(newOwner isKindOf: RectangleMorph)		ifFalse: ["Can't drop a card anywhere but on a deck"				self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt! !billete _ Billete new.!!SokobanWorld commentStamp: '<historical>' prior: 0!This is a modified version of the Sokoban game.Modified by Stephan B Wessels!!SokobanMorph commentStamp: '<historical>' prior: 0!This is a modified version of the Sokoban game.Modified by Stephan B Wessels!----STARTUP----{17 March 2011 . 2:59:30 pm} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!!SokobanWorld class methodsFor: 'constants' stamp: 'rhi 7/16/2003 11:09'!allButFree	^ String		with: self box		with: self boxAtGoal		"with: self free"		with: self goal		with: self player		with: self wall! !!SokobanWorld class methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!box	^ $$! !!SokobanWorld class methodsFor: 'constants' stamp: 'rhi 7/16/2003 11:08'!boxAtGoal	^ $*! !!SokobanWorld class methodsFor: 'constants' stamp: 'rhi 7/16/2003 11:12'!boxOrBoxAtGoal	^ String		with: self box		with: self boxAtGoal! !!SokobanWorld class methodsFor: 'private' stamp: 'rhi 7/14/2003 17:42'!extentOf: aSequenceableCollection	^ (aSequenceableCollection inject: 0 into: [:longest :each |		each size max: longest]) @ aSequenceableCollection size! !!SokobanWorld class methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!free	^ Character space! !!SokobanWorld class methodsFor: 'constants' stamp: 'rhi 7/15/2003 17:23'!freeOrGoal	^ String		with: self free		with: self goal! !!SokobanWorld class methodsFor: 'instance creation' stamp: 'rhi 7/16/2003 08:50'!fromFile: aString	"inspectIt: [self fromFile: '.\Screens\screen.1']"	^ self fromString: (FileStream fileNamed: aString) contentsOfEntireFile! !!SokobanWorld class methodsFor: 'instance creation' stamp: 'rhi 7/15/2003 18:48'!fromIndex: anInteger	"inspectIt: [self fromIndex: 1]"	^ self fromString: (self mazes at: anInteger) index: anInteger! !!SokobanWorld class methodsFor: 'instance creation' stamp: 'rhi 7/15/2003 18:48'!fromString: aString	"inspectIt: [self fromString: '    #####    #   #    #$  #  ###  $##  #  $ $ #### # ## #   #######   # ## #####  ..## $  $          ..###### ### #@##  ..#    #     #########    #######']"	^ self fromString: aString index: 0! !!SokobanWorld class methodsFor: 'instance creation' stamp: 'rhi 7/15/2003 18:50'!fromString: aString index: anInteger	| world |	(world _ self new)		maze: (self mazeFrom: aString);		walls: (self wallsFrom: aString);		extent: (self extentOf: world maze);		position: (self playerPositionIn: world maze);		index: anInteger;		moves: 0;		pushes: 0;		addPadding.	^ world! !!SokobanWorld class methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!goal	^ $.! !!SokobanWorld class methodsFor: 'private' stamp: 'rhi 7/14/2003 18:03'!mazeFrom: aString	^ aString findTokens: String crlf! !!SokobanWorld class methodsFor: 'mazes' stamp: 'rhi 7/15/2003 17:24'!mazes	"http://www.cs.ualberta.ca/~games/Sokoban/Mazes/Screens/"	^ IdentityDictionary new		at: 1 put: '    #####    #   #    #$  #  ###  $##  #  $ $ #### # ## #   #######   # ## #####  ..## $  $          ..###### ### #@##  ..#    #     #########    #######';		at: 2 put: '#############..  #     ####..  # $  $  ##..  #$####  ##..    @ ##  ##..  # #  $ ######## ##$ $ #  # $  $ $ $ #  #    #     #  ############';		at: 3 put: '        ########        #     @#        # $#$ ##        # $  $#        ##$ $ ########## $ # ####....  ## $  $  ###...    $  $   ##....  ##################';		at: 4 put: '           ########           #  ....#############  ....##    #  $ $   ....## $$$#$  $ #  ....##  $     $ #  ....## $$ #$ $ $#########  $ #     ### ##########    #    ###     $   ###  $$#$$  @##    #    #############';		at: 5 put: '        #####        #   #####        # #$##  #        #     $ ########## ###   ##....  ## $  $####....    $ $$ ###....  ##$  $ @##########  $  ##        # $ $  #        ### ## #          #    #          ######';		at: 6 put: '######  ####..  # ##@###..  ###   ##..     $$ ##..  # # $ ##..### # $ ##### $ #$  #   #  $# $ #   # $  $  #   #  ##   #   #########';		at: 7 put: '       ##### #######   #### # @## $$ ##    $      ##  $  ###   #### #####$#### $  ### ..## $ $ $ ...##    ###...## $$ # #...##  ### #########';		at: 8 put: '  ####  #  ###########  #    $   $ $ #  # $# $ #  $  #  #  $ $  #    #### $# #  #### ##@#$ $ $  ##   ##    $ #$#   # ##   $    $ $ $ ######  #########  #      #  #      #  #......#  #......#  #......#  ########';		at: 9 put: '          #######          #  ...#      #####  ...#      #      . .#      #  ##  ...#      ## ##  ...#     ### ########     # $$$ ## #####  $ $ #######   #$ $   #   ##@ $  $    $  $ ####### $$ $ #####     #      #     ########';		at: 10 put: ' ###  ###############@####       #   ## $$   $$  $ $ ...##  $$$#    $  #...## $   # $$ $$ #...####   #  $    #...##     # $ $ $ #...##    ###### ###...### #  #  $ $  #...##  ## # $$ $ $##..## ..# #  $      #.## ..# # $$$ $$$ #.###### #       # #.#    # ######### #.#    #           #.#    ###############';		at: 11 put: '          ####     #### #  #   ### @###$ #  ##      $  # ##  $ $$## ## #  #$##     # # # $ $$ # ### #   $ #  # $ #########    #  $$ #   ##### ## $         ##.    ###  #########.. ..# #####...#.##.....########';		at: 12 put: '#################              ## # ######     ## #  $ $ $ $#  ## #   $@$   ## ### #  $ $ $###...## #   $ $  ##...## ###$$$ $ ##...##     # ## ##...######   ## ##...#    #####     ###        #     #        #######';		at: 13 put: '   #########  ##   ##  ########     #  #    ####  $ #$ #  #  ... ## # $#@$## # #.#. ##  # #$  #    . . ## $    $ # # #.#. ##   ##  ##$ $ . . ## $ #   #  #$#.#. ### $  $   $  $... # #$ ######    ##  # #  #    ########## ####';		at: 14 put: '       ####### #######     # #     # $@$ # #$$ #   ######### # ###......##   # #   $......## # # # ###......     ###   #### ### #$###  #$   #  $  # ##  $ $$$  # $## ##   $ $ ###$$ # ######     $   # #    ### ###   # #      #     #   #      ########  #             ####';		at: 15 put: '   ########   #   #  #   #  $   # ### #$   #### #  $  ##$   # #  # @ $ # $# #  #      $ #### ## ####$##     # # $#.....# #   # #  $..**. $# #####  #.....#   ##   ### ######## $$  #  ##  #     #######   #     #####';		at: 16 put: '######   ###    #  ##### $  ####  ##  $$ $   $####@ #$    ## #  ##  $ $ ## # $  ## ## .# #  #$##$  #.# ###   $..##.#  #    #.*...#  # $$ #.....#  #  #########  #  #  ####';		at: 17 put: '   ##########   #..  #   #   #..      #   #..  #  ####  #######  #  ##  #            #  #  #  ##  #  ##### ##  #### ###  $  ##### #  ## # $  $  # $  ## @$  $   #   ###### ## #######   #    #   ######';		at: 18 put: '     ###########     #  .  #   #     # #.    @ # ##### ##..# ######  # ..###     #### $ #...   $ #  $ ##    .. ##  ## ## #####$##$# $ #   # #  ## #    #$ $$ # #  #  $ # #  # $## #  #               #  #  ###########  #  ####         ####';		at: 19 put: '  ######  #   @######### $   ##   ##    ##### $ #  ##    ## $ #  ##### ### $  $    # ### $ $ ### # ### #  $  # # ### # #$#   # ### ###   # # #######  $  #### # #....##    $    $   ..#.#####$  $# $   ....##       #  ## ....####################';		at: 20 put: '    ###############        #####     #   $  #@ ## #######$####  #### #    ## #  #$ ..## # $     #  #  #.## # $  #     #$ ..## #  ### ##     #.## ###  #  #  #$ ..## #    #  ####  #.## #$   $  $  #$ ..##    $ # $ $ #  #.##### $###    #$ ..#   #    $$ ###....#   #      ## ######   ########';		at: 21 put: '##########       ##       ###### #### #  ### #@##    ## $$$ $  $$##  # ## $  ##  # ##  $ ########  $$$ $#  # #   ##   ....# # #   # #.. .# #   # # ##...# ##### $  #...#     ##   #####      #####';		at: 22 put: '######     #####    #######  ######   $#  #  $  #   ##  $  $  $ # $ $  ###$ $   # @# $    ##  $ ########### ### #   #.......# $## ##  # ......#  ## #   $........$ ## # $ #.... ..#  ##  $ $####$#### $## $   ### $   $  ### $     $ $  $    ### ###### $ ##### ##         #       ####################';		at: 23 put: '    #######    #  #  ######### $#$ #  ###.. #  #  #   ##.. # $#$ #  $#####.  #     #$  #  ##..   $#  # $    ##..@#  #$ #$  #  ##.. # $#     $#  ##.. #  #$$#$  #  ###.. # $#  #  $#$  ##.. #  #  #   #   ###. ####  #####   # ####  ####   #####';		at: 24 put: '################..........  .#####..........$$.#  ############$ #   ###      $  $     $ ### ####   #  $ #  ##      #   ##  # ###  $#  # ##  ### ### $ #$###    ### #####  $ #  #  ### #####    $ ## #  # ## # $  #  $  $ $   # #  $  $#$$$  #   # #  #  $      ##### # @##  #  #  # ##############';		at: 25 put: '#####  ###############  #   ..#......##  # # ##### ...###$#    ........##   ##$######  ##### $ #     ######@ ###$ # $   ######  ##  $ #$$$##       ##      #    #$#$#### #### #$$$$$    ## #    $     #   ## #   ##        #### ######$###### $ ##        #    #   ###########    #####';		at: 26 put: ' ####### #  #  #######  #  #...####  $#  #...  ## $ #$$ ...  ##  $#  #... .##   # $##########$       $ $ ###  #  $$ #   # ######  ##$$@#      #      ##      ########';		at: 27 put: ' ################# #...   #    #   ####.....  $## # #$ ##......#  $  #    ##......#  #  # #  ########## $  $ $  #  #     #$##$ ##$## ##   $    # $    # #  ## ### #  ##$ # # $ $$     $  $  # # $    $##$ ###### #######  @ ##       ######';		at: 28 put: '         #####     #####   #    ## $  $  ######### $  $ $ ##.##       $$  ##..##  ###### ###.. ### #  #    #... ## $   #    #... ##@ #$ ## ####...#####  $ $$  ##..#   ##  $ $  $...#    # $$  $ #  .#    #   $ $  ####    ######   #         #####';		at: 29 put: '######   ### $  ########### # #       ######## #   $#$#@  #   ##  #      $ #   $ ##  ### ######### ###  ## ..*..... # #### ## *.*..*.* # ### $########## ##$ ##  $   $  $    $  ##  #   #   #   #  ####################';		at: 30 put: '       ###########       #   #     ######  #     $ $ ##   ##### $## # ### $ ##   # ## $  ## $  @$$ # ##$$$ ### ###   # ##    ### #   ### #####$### #     $  #....##  ### ## $ #....### $   $ #   #..$. ##  ## $ #  ##.... ######   ######...##    #####    #####';		at: 31 put: '  ####  #  ######### ##  ##  #   # #  $# $@$   #### #$  $  # $ $#  ####  $## #$ $     ##  #  # #   $$$  ## $    $  $## ##### $ $ #$#  #  ###  ###  ###$ # #  #....     # ####......####   #....####   #...##   #...#   #####';		at: 32 put: '      ####  #####  # ##     $### $  ## ####@$ $ # $  ##### ##   $# #....#$ $ # #....#   $# #....  $$ ## #... # $   # ######$ $  #      #   ###      #$ ###      #  #      ####';		at: 33 put: '##############     ##  ###   $   $ ##### ## $$ ##   $ #    ## $$$ # #####   # # $ ###  #  #  $ ## $# $#    ##   ..# ########.. $ #@##.....# $# ###....#  $ ####..##    #############';		at: 34 put: ' ######### #....   ## #.#.#  $ ####....# # @### ....#  #  ###     #$ ##$ ### ###  $    # #$  $ $ $#  # # #  $ $ ## # #  ###  ##  # #    ## ## ## #  $ #  $  # ###$ $   ###   #  #####   ####';		at: 35 put: '############ #######   #    # ###....##   $$#   @  .....##   # ###   # ....### ## ###  #  ....# # $ $     # # #### #  $ $##  #      ##### #  #### # ## ##  # #$   ## #    ## $  $  # ## #   ### # $ $    # #   ##  $ ## ## # ###### $$     $$  ### ## ### $  # #    # #    # ###### ######';		at: 36 put: '            ##########  ######   ##   ####  $ $ $ ## $   ## ## ##  ###   $ $     $  $ #### $  ## ##     ##  # ##### #####$$ # ##$##### @##     # # $  ###$### $  ## # $  #   ###  ### # $$ $ #   $$ # #     #   ##  # #######.. .###    #.........#    #.........#    ###########';		at: 37 put: '############......   ##########......   #  ##   ##..### $    $     ##... $ $ #   ##   ##...#$#####    #  ####    #   #$  #$ #  #  $$ $ $  $##  #  #  $   #$#$ ##$ #  ### ## #    ##  #   #  $ $ ## ######   #    $  $  #   ##   # #   #    #####@#####        ###';		at: 38 put: '      ########### @##     $  ##   $## $###$#...# # # $...  # # #. .# ## #   # #$ # #$  $    # #  ####### ####';		at: 39 put: '             ###### #############....###   ##     ##....##  $$##  $ @##....##      $$ $#  ....##  $ ## $$ # # ...##  $ ## $  #  ....### ##### ### ##.#####   $  $ ##   .  ## $###  # ##### ####   $   #       ##  $ #$ $ $###  ## $$$# $   # #####    #  $$ #######   ###     #####';		at: 40 put: '    ############    #          ##    #  # #$$ $  #    #$ #$#  ## @#   ## ## # $ # ##   #   $ #$  # #   #   # $   # #   ## $ $   ## #   #  #  ##  $ #   #    ## $$# #######$$   #   ##....#  #########.#... ###....   ##....   ##########';		at: 41 put: '           #####          ##   ##         ##     #        ##  $$  #       ## $$  $ #       # $    $ #####   #   $$ ######  ######## ##    ##.            $$$@##.# ####### ##   ###.# #######. #$ $###........... #    ###############  $ #             ##  ##              ####';		at: 42 put: '     ########  ####      ######  #    ## $ $   @#  # ## ##$#$ $ $##### ......#  $$ ###   ......#  #   ## # ......#$  $  ## #$...... $$# $ ##   ### ###$  $ #####  $  $  $  $ #  #  $  $  $  $ #  ######   ######       #####';		at: 43 put: '        #######    #####  #  ####    #   #   $    # #### #$$ ## ##  ###      # #  ## ####  ### $#$  $  $  ##...    # ##  #   ##...#    @ # ### ###...#  ###  $  $  ######### ##   #   #          #########';		at: 44 put: ' ##### #   # # # ####### #      $@###### # $ ##$ ###   # # #### $    $ # # ##### #  #$ ######  #### ##$      ##  $#  $  # ## ## ##         # #...# #######  ###  ...  #     #### # #...# #          # ### # #          #       #          #########';		at: 45 put: '##### #####...# #  #####...###  $  ##....## $  $#####....##   $  ####... ## $ $ ## ##    #  $  ##  ## # ### ##### $ # #$  $    ##  $ @ $    $  ##   # $ $$ $ ####  ######  #### ##    #######';		at: 46 put: '###########        ##### ###### #  ### # $ $ $  $ ##       #$   ####$  $$#  ###  #  ## # $##  ##$#   $ @#   #  $ $ ###   # #   $  #   # ##   # #  ##  ##### #  #         #  #.......###  #.......#  #########';		at: 47 put: '         #### #########  ####  $      $ ######   ## ##   ##...## #$$ $ $$#$##...## #   @   #   ...##  $# ###$$   ...## $  $$  $ ##....####$       #######  #  #######  ####';		at: 48 put: '  #########    #*.*#*.*#    #.*.*.*.#    #*.*.*.*#    #.*.*.*.#    #*.*.*.*#    ###   ###      #   #    ###### #######           ## $ $ $ $ $ ### $ $ $ $ ## #$ $ $ $ $#  #   $@$   #  #  #####  #  ####   ####';		at: 49 put: '       ####       #  ##       #   ##       # $$ ##     ###$  $ ##  ####    $   ####  # #####  ##    # #....$ ## #   $ ....# ##  $ # #.*..# ####  #### ### #  #### @$  ##$##     ### $     #       #  ##   #       ######### ';		at: 50 put: '      ############     ##..    #   #    ##..* $    $ #   ##..*.# # # $##   #..*.# # # $  #####...#  #    # ##  ## #          ## @$ $ ###  #   ### $   $   # #   ####$$   # # # # #  #   $   # # #####  # $# #####      #  #$   #   #    # #  #  ###   ##     #  #  #      #    ##  ####      ######';		at: 51 put: ' ######### #       # # $ $$ $#### #  $ ##.#   $$ ###.###   $ ##.#. $ ## #####...  $## $  ##...$   $    ##..###$### #@##..# #     ####### #######';		at: 52 put: '           ########           #......#   ####    #......#   #  #########...#   # $   $    #...#   #  # # # # #   ###### # # #@# #   ##   # ### ### ## ###    $ # $ $ $ # ## $$$  $   #     ##   # ###$###$## #### #  $   #     # ## $  # $ $ $ ### #  # ### ### ##   # $          #    #  ###########    ####';		at: 53 put: '##################  #                ## # $#   $ ##  $    # #    $###    # $$ # #.###     $ $ ##  ###...#  #  #    #$  ##..##$$#### $  #   ##...#      $ ##  ####...$  ###  #    # ###..  $#  ##   ##@ # ##.#              #  ##################';		at: 54 put: '#####################   #    #   #   #@## $      $   $   # ### ###..## ###     ##   #....#$#  $### ## $ #....#  $  $ $ ##   #....# # # $ $ ##   ##..##   #$#   ###$##    ##  #  #$###   $  $     #  #  ##   #    #   #     #####################';		at: 55 put: '#####################    @##      #   ###    ##    $    $ ###  ###....# # #  ####   #....# # # $   #### #...#  #       ###  ##.#     $   $ ###  $ $ ###  # # ##### $       # # $   ##### $  $# # # # $ #####         # #  ######################';		at: 56 put: '#####################  #  ##    #   @#####    $    # $###  ###$# $ ##$# $ $    ##   $#    $      #### ##   $ ###  #....## # $# # # # #....###    $ $ #  #....#####$ ###  $ #....#####  # $        #######      # #    ##########################';		at: 57 put: '#####################@     ###   #  #  ## # #  #  $  $     ######     # $ $#$# ##.#..#    ##$ $    ##.....    $   #   ###.....    ###$##$####.#..#    $    #   ######     #  #$  $ ######  #  $    $ $ ######  #  #  #  #  #####################';		at: 58 put: '######################...   ## #    #  ##....         $ ## ##....# # #$###$    ##...#    #       # ###.#  #$ #     $## ##  #  # $ $ ###  $ ##     $  $ #  # ## ### # ## #$$# $#  # ##  #   $ $ #      ###    #     #  #   @#####################';		at: 59 put: '#####################   #  #@# ##  ###### # #  $    $  ###### #    ###### $  ####   #  #....#  $$  ###$##$##....#      ##      #....##$##$###  $$  #....#      ## $  $  #  #  ###  ######  $   $    $  ###### #    #  #   ######################';		at: 60 put: '##################### #     #          ##       $  ## ### #######  ##   $  $   ###..##  # # $ # #  ##....  $     ##$# ###....  $#####   #$####..# #  #   #  $  ####.# #  $   $  # @###  $  $ #   #  ######       ###############################';		at: 61 put: '#####################     ###..###     ## $$  ###..###  $@ ##  # ##......#  $  ##     #......#  $  #####  ###..######$ ##   $$$ #..#    #  ## $#   $  $  $$ #$ ##  #  ## $  ##  #  ## $    $ ## $    $ ##  #  ##    ##  #  #####################';		at: 62 put: '#####################    #  # #  #  #  ## @# # ## $   $   ###### #    #  # $   ##    # ## #$ ## ## ##      $   $   $   ##..###$$## $##$ ## ##..#.#  # $   $ #  ##....# $$   ##$ #####....#  #####      ##...###        ##  #####################';		at: 63 put: '#####################....#       #  #  ##....# # $  $      ##.... ##  $# # $#$ ##...#   $   $#  $  ##..####  # $   $$  ##      #### #### ####        #   #     ## ##   #   $ # $ $ ## ##    $ ## $  $  ##     @#     #   # #####################';		at: 64 put: '#####################....###           ##....##### #  #$# ###....###   #$  $   ##....###    $  #$$####  #### $#  #$ $  ###  ####  $  $  #  ##@  ####$###$## $  ###        #  #  $  ###   ###  #  $  ############  #  #     #####################';		at: 65 put: '#####################     #     @#...####     #      ##...### # # ##$## ## ....##   $ #   $$$  ....####$### $$  ### ##.##     $  #    # #####  $  #  ###  # #  ### #$##    $  $$   ##   $ ##   #  # #  ##     #    #  #    #####################';		at: 66 put: '#####################     #  #...#@    ## #       ....#    ##  $  #   #....#   ## ##$#### ##....#  ## $   $  #  #...#  ## $$ #   #   # $$  ####  $$$#   $$  $  ## $  #  #    # $#  ##   $#  #       $  ##  #    #    #  #  #####################';		at: 67 put: '#########################@###.##...##  ######$  ..#...#    #####    ......#  $ ####  $ #.....## # ####  $$# #####  $ $ ### $# $    ##  $$  ###  #  #    # $  $ ###   $$ ### #$##   ### $#      $ $  $ #####    #    #    #######################';		at: 68 put: '#####################@     #   #       ### ### ##  #### # ###    # #  $$       ##  # # # $ # $ ## ###     $ #  #$$ #   ##  ###  #      ## ###..#.# $ #  $ #    ##..#.#  $ # ## $$  ##....##   $$  $  # ##.....##        #  #####################';		at: 69 put: '#####################  #      #   #   ### $# $ $ ##...$  $ ##  $  # ##....# $  ## ## $ ##....#   $ ## $    #....## $   ## $##  #...#       ##   $$$##$##  ### ### # #  #   #  #    ## $ #  $  ##       ##    #    #@       #####################';		at: 70 put: '#####################  #  # #    #  #  ##   $      $ $     ### #  #$###$##  ## ##   $     $  #  $  ## ###$##$#   # $   ## #   $ $  ###### $## $  $$ $  #@#.#...## #     #  # #.#...## ########## #.....##            #.....#####################';		at: 71 put: '#####################  #     #  ##    ### $#   $ #     ##  ## $  $  #..#     $ ## $ $  #....#   # ### $#  #......### $ ##   #  #....#  #$  ## $  ####..#   #   ### $   ## # # $  $##### $    $#@$ $#   #####   #       #   #####################';		at: 72 put: '#####################      ....#    #####      ....        ## # ##########     ## #$   #      ###..##  $   #$$###   #..## $ ### $   $   #..## $ #   $ $ #  ##..##  #  $$ # $ ##   ###@## $#  $  $     ####       ##   #  #######################';		at: 73 put: '#####################        #   #@ #  ## $$  #$$# # #  ## ##  # $ $ #$$ #     ### #  #  # # #  #  ##   ##       #     ##   # $ #   #   #  ## $ #$ #   #  $ #..###$ #  ####    #...##  $          #....##   #  #     #.....#####################';		at: 74 put: '#####################     #   #####    ### $  #   ####  $  ##### $$   #..#  #  ##  $  $  ##..#### ### $   ###....   $$ ##  #$#   ....# # $ ## #  # $ ..###$#   ## #   $ #..#   ##  ##   $#  ####   # $### #  #    @#      ######################';		at: 75 put: '#####################   #   #    #   #@##   $  $     # $ # ###$# $### #    $$# ##  #  #.###  #$ $  ##  #$#....#  # ### ## $  #.....##    # ###$  #.#....#$$ $  ##  ######..## #  # ##  $         $ ### ##   #   #        # #####################';		at: 76 put: '##################### # # #   #@##   # ##             $    ##  ##$# ##### $ # ####    ##.....#  #  ###$##$#.....###$#$ ##   # ##.....#  # ###  $    ##..##  #  ## $ #   $   $  $$$ ### $  $# #  #  $   ##   ##   #  #      #####################';		at: 77 put: '#####################    ##   #    #   ##  $  $     ## $   ### #####  .###### ## # ##  ##....#### #### ##$ ###..##     ##      #... .# $ $ ## $ ## ## . ### ##### # $    #.## # ## $ $ #   .#### ### #  ## # ##  #  #########  $##$   $ #      ##      $ #@#       #  ## ######       #######';		at: 78 put: '       ###########       #         #       #    $ $  ####### # $ ##### ##    ##### $  ##$##       $ $      ##          ## ## ##    ##@##### ## ##    ####   # ## ###....#      # $   ##....#      #     #######      #######';		at: 79 put: '##############           ## ### $$    ##   # $  $  ##  $####$####### $ ##        ######  $$ $        ...#### ## $$#     ...#  # ##   #     ...#  #      #     ...#  ###@#############    ###';		at: 80 put: '  ####################@##         ...##    #         ...## $  #         ...## $$ #         ...### $ ###$########## # ###  $ ###   $  $ ##  $ #  $ ## $  #    ##  $ #    ##    #    ############';		at: 81 put: '              #####     ##########   #     #        #   #     #  $ $    $$ #     # ##### ## $ #     #$$   #$## $ #     # ### # ##$  ####### ### $ $    ##....        ##   ##....        #######....        ############@##          ###';		at: 82 put: '    ###### ####    # #    ## # # $     #### #### #########  $   $ ##  ...##   $$ $$    ...##    $  $##  ...###@## ## ##  ...# ###  $  ######## #   $$  # #    #  # #########';		at: 83 put: '####### ##########     # #   ##  ## ### # #   $   ## # $ ###   $   ##   $$      ##$ ##    ####   ##  ##@############ #####..    #####$ #  #..    ####   #  #..       $$  #  #..    #### $ #  #..    #  #   #  ########  #####';		at: 84 put: '########     ###########     #    #  ### $   #   $ $  ##  $  #  $ ##  ## $$  ##$ $    ### #  ## ######### #  ##    ...##  #$       ...##   $$      ...##     ##@#  ...#################';		at: 85 put: '#############      #   ### $  $   #  ##########  #####      # #..  #     #### # #.####  ####    # #....    #  $ #### # ...#   # $$$#  #####.#### ##  $@$   ##     ##### $ #    ## #.# $      $###$ ## #.########  #  $ ## #..        ##  $ ## # ####### $ # #  ##   #     #       #######     ##########';		at: 86 put: '#################       #@ #   ## # # # # $  $$## #...# #$$$   ##  ...# # $  $$### ##.## # ##    ## #...     $    ## ## ###  ########    # ##########';		at: 87 put: '    ##### ####   ## ##### #  $    ###   # # $@$ $    $  # # #$######## ## # #  $  #     # # # $ $ # #   ### #  $# # ######  ##    #     ##    $ # ###   ###### ##  #....##    $     ....##         #....#################';		at: 88 put: '##############........#####...#### #  ######...#  ###    $ ##...$$     $ $  ##  .#  $ $# $  ###...# #$#   $  ##.# # $   $    ##.  #$###$####$###  #   $ $    # #  #  $@$  #  # #  # #### $  $# #  #    ###   # #  # $$ # ##### #  #    # #########';		at: 89 put: ' ################## #   $       ...#.## #       ####..... # # #######  #..... # # #    $ $ ##....## # #  $ # # ###...# # # $@$ $  ##### ### #  $  $ $$   $ ##  #$# $#   # $## ## ##    ## ## $ # ## # $# $ $  #     ## #         ######## ########$##   ##        #  $   #########    #####       ###  #         ####';		at: 90 put: '#####################..#    #          ##.$  $  #$$  $## $###.$#  ###  ## ##   ##  # $ #  $$   $   ## ###  # #  #$  #####  ## # $   #@ #   ## $    $  ##.##  $ ##  # $# $# $     ####  #  #  #   ###   ##  ######## #      ##           #  #.#.###$########$#   ...##    .*  #    ##.#.## .*...*   $  .....#####################';		yourself! !!SokobanWorld class methodsFor: 'mazes' stamp: 'rhi 7/16/2003 08:50'!mazesShow	"inspectIt: [self mazesShow]"	^ [	| morph |		self mazes do: [:str |			morph _ SokobanMorph forWorld: (SokobanWorld fromString: str).			(Delay forSeconds: 0.5) wait.			morph delete].	] fork! !!SokobanWorld class methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!player	^ $@! !!SokobanWorld class methodsFor: 'private' stamp: 'rhi 7/14/2003 17:42'!playerPositionIn: aSequenceableCollection	| row |	1 to: aSequenceableCollection size do: [:idx |		row _ aSequenceableCollection at: idx.		(row includes: self player)			ifTrue: [^ (row indexOf: self player) @ idx]].	self error: 'Player missing...'.! !!SokobanWorld class methodsFor: 'instance creation' stamp: 'rhi 7/15/2003 15:25'!random	"inspectIt: [self random]"	^ self fromIndex: self mazes size atRandom! !!SokobanWorld class methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!wall	^ $#! !!SokobanWorld class methodsFor: 'private' stamp: 'rhi 7/16/2003 12:10'!wallsFrom: aString	^ (self mazeFrom: aString) do: [:row |		row			replaceAll: self player with: self free;			replaceAll: self box with: self free;			replaceAll: self boxAtGoal with: self goal]! !!SokobanWorld methodsFor: 'private' stamp: 'sbw 3/27/2004 15:31'!addMove: aPoint withPushed: secondPoint 	self moveStack add: (Array with: aPoint with: secondPoint)! !!SokobanWorld methodsFor: 'private' stamp: 'rhi 7/14/2003 18:19'!addPadding	self		addPaddingTo: self maze;		addPaddingTo: self walls.! !!SokobanWorld methodsFor: 'private' stamp: 'rhi 7/14/2003 18:19'!addPaddingTo: aSequenceableCollection	| x row |	x _ self extent x.	1 to: aSequenceableCollection size do: [:idx |		row _ aSequenceableCollection at: idx.		aSequenceableCollection			at: idx			put: row, (String new: x - row size withAll: self free)].! !!SokobanWorld methodsFor: 'constants' stamp: 'rhi 7/15/2003 17:05'!allButFree	^ self class allButFree! !!SokobanWorld methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!box	^ self class box! !!SokobanWorld methodsFor: 'constants' stamp: 'rhi 7/16/2003 11:10'!boxAtGoal	^ self class boxAtGoal! !!SokobanWorld methodsFor: 'constants' stamp: 'rhi 7/16/2003 11:12'!boxOrBoxAtGoal	^ self class boxOrBoxAtGoal! !!SokobanWorld methodsFor: 'private' stamp: 'rhi 7/16/2003 11:13'!canMoveBy: aPoint	^ (self freeOrGoal includes: (self mazeAt: self position + aPoint))		or: [(self boxOrBoxAtGoal includes: (self mazeAt: self position + aPoint))			and: [self freeOrGoal includes: (self mazeAt: self position + aPoint + aPoint)]]! !!SokobanWorld methodsFor: 'derived accessing' stamp: 'rhi 7/16/2003 11:31'!done	^ self maze noneSatisfy: [:row | row includes: self box]! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 17:42'!extent	"^ <Point>"	^ extent! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 17:42'!extent: aPoint	extent _ aPoint.! !!SokobanWorld methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!free	^ self class free! !!SokobanWorld methodsFor: 'constants' stamp: 'rhi 7/14/2003 18:35'!freeOrGoal	^ self class freeOrGoal! !!SokobanWorld methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!goal	^ self class goal! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/15/2003 18:49'!index	"^ <Integer>"	^ index! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/15/2003 18:49'!index: anInteger	index _ anInteger.! !!SokobanWorld methodsFor: 'accessing' stamp: 'sbw 3/27/2004 15:46'!initializeMoveStack	moveStack := OrderedCollection new! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 17:42'!maze	"^ <SequenceableCollection of: <SequenceableCollection of: Character>>"	^ maze! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 17:42'!maze: aSequenceableCollection	maze _ aSequenceableCollection.! !!SokobanWorld methodsFor: 'derived accessing' stamp: 'rhi 7/14/2003 18:21'!mazeAt: aPoint	^ (self maze at: aPoint y) at: aPoint x! !!SokobanWorld methodsFor: 'derived accessing' stamp: 'rhi 7/14/2003 19:05'!mazeAt: aPoint put: aCharacter	^ (self maze at: aPoint y) at: aPoint x put: aCharacter! !!SokobanWorld methodsFor: 'private' stamp: 'rhi 7/16/2003 11:40'!move: aPoint to: anotherPoint	self		mazeAt: anotherPoint put: (			((self boxOrBoxAtGoal includes: (self mazeAt: aPoint))				and: [(self wallsAt: anotherPoint) = self goal])					ifTrue: [self boxAtGoal]					ifFalse: [self mazeAt: aPoint]);		mazeAt: aPoint put: (self wallsAt: aPoint).! !!SokobanWorld methodsFor: 'private' stamp: 'sbw 3/27/2004 15:30'!moveBy: aPoint 	| next secondPoint |	secondPoint := nil.	(self canMoveBy: aPoint)		ifTrue: [next := self position + aPoint.			(self boxOrBoxAtGoal					includes: (self mazeAt: next))				ifTrue: [secondPoint := next + aPoint.					self move: next to: secondPoint.					self pushes: self pushes + 1.					self playSoundForPush].			self move: self position to: next.			self position: next.			self moves: self moves + 1.			self addMove: aPoint withPushed: secondPoint.			self playSoundForMove]! !!SokobanWorld methodsFor: 'moving' stamp: 'rhi 7/15/2003 17:10'!moveDown	self flag: #rhi. "Direction not intuitive!! See moveUp..."	self moveBy: 0 @ 1.! !!SokobanWorld methodsFor: 'moving' stamp: 'sbw 3/27/2004 21:19'!moveDownFull	self moveFullBy: 0 @ 1! !!SokobanWorld methodsFor: 'private' stamp: 'sbw 3/27/2004 21:22'!moveFullBy: aPoint 	[self canMoveBy: aPoint] whileTrue: [		self moveBy: aPoint]! !!SokobanWorld methodsFor: 'moving' stamp: 'rhi 7/14/2003 19:54'!moveLeft	self moveBy: -1 @ 0.! !!SokobanWorld methodsFor: 'moving' stamp: 'sbw 3/27/2004 21:19'!moveLeftFull	self moveFullBy: -1 @ 0! !!SokobanWorld methodsFor: 'moving' stamp: 'rhi 7/14/2003 19:54'!moveRight	self moveBy: 1 @ 0.! !!SokobanWorld methodsFor: 'moving' stamp: 'sbw 3/27/2004 21:19'!moveRightFull	self moveFullBy: 1 @ 0! !!SokobanWorld methodsFor: 'accessing' stamp: 'sbw 3/27/2004 15:46'!moveStack	moveStack isNil		ifTrue: [self initializeMoveStack].	^ moveStack! !!SokobanWorld methodsFor: 'moving' stamp: 'rhi 7/15/2003 17:10'!moveUp	self flag: #rhi. "Direction not intuitive!! See moveDown..."	self moveBy: 0 @ -1.! !!SokobanWorld methodsFor: 'moving' stamp: 'sbw 3/27/2004 21:19'!moveUpFull	self moveFullBy: 0 @ -1! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 18:56'!moves	"^ <Integer>"	^ moves! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 18:56'!moves: anInteger	moves _ anInteger.! !!SokobanWorld methodsFor: 'private' stamp: 'rhi 7/17/2003 09:21'!playSoundForMove	"printIt: [SampledSound soundNames]"	"self playSoundNamed: 'scratch'."	"self playSoundNamed: 'scritch'."! !!SokobanWorld methodsFor: 'private' stamp: 'rhi 7/17/2003 09:21'!playSoundForPush	"printIt: [SampledSound soundNames]"	"self playSoundNamed: 'scratch'."	"self playSoundNamed: 'scritch'."! !!SokobanWorld methodsFor: 'private' stamp: 'sbw 3/27/2004 15:34'!playSoundForUndo	^ self! !!SokobanWorld methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!player	^ self class player! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/15/2003 17:10'!position	"^ <Point>"	^ position! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 17:42'!position: aPoint	position _ aPoint.! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 18:57'!pushes	"^ <Integer>"	^ pushes! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 18:57'!pushes: anInteger	pushes _ anInteger.! !!SokobanWorld methodsFor: 'private' stamp: 'sbw 3/27/2004 15:36'!removeLastItemFromMoves	^self moveStack removeLast! !!SokobanWorld methodsFor: 'moving' stamp: 'sbw 3/27/2004 15:44'!undo	| lastMove point next other |	self moveStack isEmpty		ifTrue: [^ self].	lastMove := self removeLastItemFromMoves.	point := lastMove first.	next := self position - point.	self move: self position to: next.	self position: next.	self moves: self moves + 1.	other := lastMove last.	other isNil		ifFalse: [self move: other to: other - point.			self pushes: self pushes - 1].	self playSoundForUndo! !!SokobanWorld methodsFor: 'constants' stamp: 'rhi 7/14/2003 17:42'!wall	^ self class wall! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 18:01'!walls	"^ <SequenceableCollection of: <SequenceableCollection of: Character>>"	^ walls! !!SokobanWorld methodsFor: 'accessing' stamp: 'rhi 7/14/2003 18:01'!walls: aSequenceableCollection	walls _ aSequenceableCollection.! !!SokobanWorld methodsFor: 'derived accessing' stamp: 'rhi 7/14/2003 18:21'!wallsAt: aPoint	^ (self walls at: aPoint y) at: aPoint x! !!SokobanWorld methodsFor: 'derived accessing' stamp: 'rhi 7/14/2003 19:06'!wallsAt: aPoint put: aCharacter	^ (self walls at: aPoint y) at: aPoint x put: aCharacter! !!SokobanMorph class methodsFor: 'private' stamp: 'sbw 4/14/2004 21:31'!boxField	| m fill |	m := EllipseMorph new extent: self fieldSize;				 color: Color blue muchLighter;				 borderWidth: 0;				 borderColor: (Color r: 0.595 g: 0.595 b: 0.599).	fill := GradientFillStyle ramp: {0.0					-> (Color							r: 0.767							g: 0.767							b: 1.0). 1.0					-> (Color							r: 0.233							g: 0.233							b: 0.0)}.	fill origin: m topLeft.	fill direction: 23 @ 24.	fill radial: true.	m fillStyle: fill.	^ m! !!SokobanMorph class methodsFor: 'private' stamp: 'sbw 4/14/2004 21:43'!controlsHeight	^ self fieldSize x min: 18! !!SokobanMorph class methodsFor: 'parts bin' stamp: 'rhi 7/16/2003 09:20'!descriptionForPartsBin	^ self		partName: 'Sokoban'		categories: #('Games')		documentation: 'A tricky logic puzzle, created by Hiroyuki Imabayashi in 1982.'! !!SokobanMorph class methodsFor: 'private' stamp: 'sbw 4/14/2004 21:43'!fieldSize	^ 28@28! !!SokobanMorph class methodsFor: 'accessing' stamp: 'rhi 7/15/2003 17:18'!fields	^ Fields! !!SokobanMorph class methodsFor: 'accessing' stamp: 'rhi 7/15/2003 17:18'!fields: anIdentityDictionary	Fields _ anIdentityDictionary.! !!SokobanMorph class methodsFor: 'instance creation' stamp: 'rhi 7/16/2003 10:06'!forIndex: anInteger	"doIt: [(self forIndex: 1) openInWorld]"	^ self basicNew initializeForIndex: anInteger! !!SokobanMorph class methodsFor: 'instance creation' stamp: 'rhi 7/16/2003 10:06'!forWorld: aSokobanWorld	"doIt: [(self forWorld: (SokobanWorld fromFile: '.\Screens\screen.1')) openInWorld]"	"doIt: [(self forWorld: (SokobanWorld fromIndex: 1)) openInWorld]"	^ self basicNew initializeForWorld: aSokobanWorld! !!SokobanMorph class methodsFor: 'private' stamp: 'rhi 7/15/2003 17:17'!freeField	^ Morph new		extent: self fieldSize;		color: Color white! !!SokobanMorph class methodsFor: 'private' stamp: 'sbw 3/27/2004 19:21'!goalField	| m |	^ (m := BorderedMorph new) extent: self fieldSize;		 color: Color paleYellow darker;		 borderWidth: 1;		 borderColor: m color darker! !!SokobanMorph class methodsFor: 'class initialization' stamp: 'rhi 7/16/2003 11:43'!initFields	self fields: (IdentityDictionary new		at: SokobanWorld free put: [self freeField];		at: SokobanWorld wall put: [self wallField];		at: SokobanWorld box put: [self boxField];		at: SokobanWorld boxAtGoal put: [self boxField];		at: SokobanWorld goal put: [self goalField];		at: SokobanWorld player put: [self playerField];		yourself).! !!SokobanMorph class methodsFor: 'class initialization' stamp: 'rhi 7/16/2003 08:45'!initialize	"doIt: [self initialize]"	super initialize.	self initFields.! !!SokobanMorph class methodsFor: 'private' stamp: 'sbw 4/14/2004 21:38'!playerField	| m fill |	m := StarMorph new extent: self fieldSize;				 color: Color lightBlue darker darker;				 borderWidth: 0;				 borderColor: Color darkGray.	fill := GradientFillStyle ramp: {0.0->(Color r: 0.972 g: 0.878 b: 0.349).				1.0->(Color r: 0.972 g: 0.408 b: 0.317)}.	fill origin: m topLeft.	fill direction: 0 @ 21.	fill radial: false.	m fillStyle: fill.	^ m! !!SokobanMorph class methodsFor: 'instance creation' stamp: 'rhi 7/16/2003 10:05'!random	"doIt: [self random openInWorld]"	^ self new! !!SokobanMorph class methodsFor: 'private' stamp: 'sbw 3/27/2004 19:22'!wallField	| m |	^ (m := BorderedMorph new) extent: self fieldSize;		 color: Color paleGreen darker;		 borderWidth: 1;		 borderColor: m color darker;		 borderRaised! !!SokobanMorph methodsFor: 'private' stamp: 'sbw 3/27/2004 19:32'!addControlsWidth: anInteger 	| controls |	controls := Morph new color: Color darkGray;				 borderWidth: 0;				 height: self controlsHeight;				 width: anInteger;				 hResizing: #spaceFill;				 vResizing: #rigid;				 listDirection: #leftToRight;				 cellInset: 1;				 changeTableLayout;				 addMorph: self buildScores;								addMorph: (self						buildButtonForm: self downArrow						action: #moveDown						target: self);								addMorph: (self						buildButtonForm: self upArrow						action: #moveUp						target: self);								addMorph: (self						buildButtonForm: self rightArrow						action: #moveRight						target: self);								addMorph: (self						buildButtonForm: self leftArrow						action: #moveLeft						target: self);								addMorph: ((self						buildButtonLabel: 'z'						action: #undo						target: self						balloonText: 'undo')						color: Color lightGreen);								addMorph: ((self						buildButtonLabel: '?'						action: #help						target: self						balloonText: 'Help')						color: Color lightBlue);								addMorph: ((self						buildButtonLabel: 'X'						action: #quit						target: self						balloonText: 'Quit')						color: Color lightRed).	"addMorph: (Morph new  	color: Color black;  	height: self controlsHeight;  	hResizing: #spaceFill;  	vResizing: #rigid);"	self		addMorph: (controls position: self topLeft x @ (self bottomLeft y - self controlsHeight))! !!SokobanMorph methodsFor: 'moving etc' stamp: 'sbw 4/20/2004 22:18'!again	| position |	(self confirm: 'Really start over?')		ifTrue: [	position := self position.	self delete; initializeForIndex: self sworld index; position: position; openInWorld]! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/15/2003 20:08'!buildButtonForm: aForm action: aSymbol target: anObject	| button |	(button _ IconicButton new)		labelGraphic: aForm;		actionSelector: aSymbol;		target: anObject;		actWhen: #buttonDown;		color: Color black;		borderWidth: 0;		height: self controlsHeight;		layoutInset: 3;		hResizing: #rigid;		vResizing: #rigid;		cornerStyle: #square;		changeTableLayout.	^ button! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/16/2003 13:06'!buildButtonLabel: aString action: aSymbol target: anObject	| button |	(button _ SimpleButtonMorph new)		label: aString asText allBold;		actionSelector: aSymbol;		target: anObject;		actWhen: #buttonDown;		color: Color black;		borderWidth: 0;		height: self controlsHeight;		layoutInset: 3;		hResizing: #rigid;		vResizing: #rigid;		cornerStyle: #square;		changeTableLayout.	(button findA: StringMorph) color: Color black.	^ button! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/16/2003 13:11'!buildButtonLabel: aString action: aSymbol target: anObject balloonText: anotherString	^ (self buildButtonLabel: aString action: aSymbol target: anObject)		setBalloonText: anotherString! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/16/2003 11:59'!buildScores	^ TextMorph new		contents:			' Maze ', self sworld index printString,			' ¥ ', self sworld moves printString, ' Moves',			' ¥ ', self sworld pushes printString, ' Pushes';		color: Color white;		backgroundColor: Color transparent;		lock! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/15/2003 19:05'!controlsHeight	^ self class controlsHeight! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/15/2003 20:18'!cross	^ Form		extent: 9@9		depth: 16		fromArray: #( 65537 0 0 1 65536 65537 65536 0 65537 65536 1 65537 1 65537 0 0 65537 65537 65536 0 0 1 65537 0 0 0 65537 65537 65536 0 1 65537 1 65537 0 65537 65536 0 65537 65536 65537 0 0 1 65536)		offset: 0@0! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/15/2003 20:08'!downArrow	^ Form		extent: 9@9		depth: 16		fromArray: #( 14253 862794605 862794605 862729101 934150144 14221 724182793 654911241 654913323 931987456 0 793519881 722086698 652880586 862781440 0 931998474 654977834 648621835 0 0 12107 654911209 717895565 0 0 13164 654976681 789250048 0 0 14254 722085546 929890304 0 0 0 860630796 934150144 0 0 0 934098861 0 0)		offset: 0@0! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/15/2003 10:00'!fieldFor: aCharacter	^ (self fields at: aCharacter) value! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/14/2003 20:37'!fieldSize	^ self class fieldSize! !!SokobanMorph methodsFor: 'derived accessing' stamp: 'rhi 7/15/2003 17:20'!fields	^ self class fields! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/19/2003 18:38'!forceDestroyAndRedraw	| x y topLeftX topLeftY |	self flag: #rhi. "Apologies not only to Morphic fans..."	self removeAllMorphs.	self color: (self sworld done ifTrue: [Color veryVeryLightGray] ifFalse: [Color lightGray]).	topLeftX _ self topLeft x.	topLeftY _ self topLeft y.	y _ 0.	self sworld maze do: [:row |		x _ 0.		row do: [:col |			(self sworld allButFree includes: col) ifTrue: [				(col ~= self sworld goal					and: [(self sworld wallsAt: (x + 1) @ (y + 1)) = self sworld goal])						ifTrue: [self							addMorph: ((self fieldFor: self sworld goal)								position: (x * self fieldSize x + topLeftX)									@ (y * self fieldSize y + topLeftY))].				self					addMorph: ((self fieldFor: col)						position: (x * self fieldSize x + topLeftX)							@ (y * self fieldSize y + topLeftY))].			x _ x + 1].		y _ y + 1].	self addControlsWidth: self width.! !!SokobanMorph methodsFor: 'event handling' stamp: 'rhi 7/14/2003 20:05'!handlesKeyboard: aMorphicEvent	^ true! !!SokobanMorph methodsFor: 'event handling' stamp: 'rhi 7/14/2003 18:08'!handlesMouseOver: aMorphicEvent	^ true! !!SokobanMorph methodsFor: 'moving etc' stamp: 'sbw 3/27/2004 21:19'!help	((StringHolder new contents: 'The game was apparently invented in the early 1980s by Thinking Rabbit, a computer games company in the town of Takarazuka, Japan. The game design is said to have won first prize in a computer games contest. Because of the simplicity and elegance of the rules, and the intellectually challenging complexity of the composed problems, Sokoban quickly became a popular pastime. The object of Sokoban is to push all stones (or boxes) in a maze, such as the one to the right, to the designated goal areas. The player controls the man and the man can only push stones and only one at a time. The restriction of only being able to push the stones makes this game challenging: One can create unsolvable positions. Players will soon learn that this is the main obstacle in solving problems. Advanced players also try to find shorter and shorter solutions, measured in stone pushes and man moves. (http://www.cs.ualberta.ca/~games/Sokoban/)Key mappings:---Cursor left -> move left (control key down moves as far left as possible)Cursor right -> move right (control key down moves as far right as possible)Cursor up -> move up (control key down moves as far up as possible)Cursor down -> move down (control key down moves as far down as possible)--a -> again (same maze)h -> helpn -> next (another maze, next in line)p -> previous (another maze, previous in line)r -> random (another maze, random selection)g - select a game numberz -> undo last move--q -> quit')		embeddedInMorphicWindowLabeled: 'About Sokoban') setWindowColor: Color veryLightGray;		 openInWorld! !!SokobanMorph methodsFor: 'initialization' stamp: 'rhi 7/16/2003 12:33'!initialize	self initializeForIndex: 1.! !!SokobanMorph methodsFor: 'initialization' stamp: 'rhi 7/16/2003 10:07'!initializeForIndex: anInteger	self initializeForWorld: (SokobanWorld fromIndex: anInteger).! !!SokobanMorph methodsFor: 'initialization' stamp: 'sbw 3/27/2004 19:26'!initializeForWorld: aSokobanWorld 	super initialize.	self sworld: aSokobanWorld;		 extent: self fieldSize x * aSokobanWorld extent x @ (self fieldSize y * aSokobanWorld extent y + self controlsHeight);		 center: World center;		 initializeMoveStack;		 forceDestroyAndRedraw! !!SokobanMorph methodsFor: 'initialization' stamp: 'sbw 3/27/2004 15:48'!initializeMoveStack	self sworld initializeMoveStack! !!SokobanMorph methodsFor: 'initialization' stamp: 'rhi 7/16/2003 12:33'!initializeRandom	self initializeForWorld: SokobanWorld random.! !!SokobanMorph methodsFor: 'event handling' stamp: 'sbw 3/27/2004 21:16'!keyStroke: aKeyboardEvent 	| char accel |	accel := aKeyboardEvent controlKeyPressed.	char := aKeyboardEvent keyCharacter.	char = Character arrowLeft		ifTrue: [^ accel				ifTrue: [self moveLeftFull]				ifFalse: [self moveLeft]].	char = Character arrowRight		ifTrue: [^ accel				ifTrue: [self moveRightFull]				ifFalse: [self moveRight]].	char = Character arrowUp		ifTrue: [^ accel				ifTrue: [self moveUpFull]				ifFalse: [self moveUp]].	char = Character arrowDown		ifTrue: [^ accel				ifTrue: [self moveDownFull]				ifFalse: [self moveDown]].	char asLowercase = $a		ifTrue: [^ self again].	char asLowercase = $h		ifTrue: [^ self help].	char asLowercase = $n		ifTrue: [^ self next].	char asLowercase = $p		ifTrue: [^ self previous].	char asLowercase = $q		ifTrue: [^ self quit].	char asLowercase = $r		ifTrue: [^ self random].	char asLowercase = $z		ifTrue: [^ self undo].	char asLowercase = $g		ifTrue: [^ self selectGame].	^ super keyStroke: aKeyboardEvent! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/15/2003 20:08'!leftArrow	^ Form		extent: 9@11		depth: 16		fromArray: #( 0 0 0 0 934084608 0 0 0 934162252 864813056 0 0 14221 724249354 862715904 0 0 793520938 722021130 864813056 0 864824106 654977802 722086666 864813056 13164 722085641 722086666 722086666 864878592 12043 646523626 722086698 722086666 864878592 14254 858532522 648685290 722086666 864878592 0 14221 789260970 650717962 864878592 0 0 13132 717892331 934084608 0 0 0 932000621 0)		offset: 8@0! !!SokobanMorph methodsFor: 'event handling' stamp: 'rhi 7/14/2003 18:08'!mouseEnter: aMorphicEvent        aMorphicEvent hand newKeyboardFocus: self.! !!SokobanMorph methodsFor: 'moving etc' stamp: 'rhi 7/14/2003 20:39'!moveDown	self sworld moveDown.	self forceDestroyAndRedraw.! !!SokobanMorph methodsFor: 'moving etc' stamp: 'sbw 3/27/2004 21:17'!moveDownFull	self sworld moveDownFull.	self forceDestroyAndRedraw! !!SokobanMorph methodsFor: 'moving etc' stamp: 'rhi 7/14/2003 20:39'!moveLeft	self sworld moveLeft.	self forceDestroyAndRedraw.! !!SokobanMorph methodsFor: 'moving etc' stamp: 'sbw 3/27/2004 21:17'!moveLeftFull	self sworld moveLeftFull.	self forceDestroyAndRedraw! !!SokobanMorph methodsFor: 'moving etc' stamp: 'rhi 7/14/2003 20:39'!moveRight	self sworld moveRight.	self forceDestroyAndRedraw.! !!SokobanMorph methodsFor: 'moving etc' stamp: 'sbw 3/27/2004 21:18'!moveRightFull	self sworld moveRightFull.	self forceDestroyAndRedraw! !!SokobanMorph methodsFor: 'moving etc' stamp: 'rhi 7/14/2003 20:40'!moveUp	self sworld moveUp.	self forceDestroyAndRedraw.! !!SokobanMorph methodsFor: 'moving etc' stamp: 'sbw 3/27/2004 21:18'!moveUpFull	self sworld moveUpFull.	self forceDestroyAndRedraw! !!SokobanMorph methodsFor: 'moving etc' stamp: 'rhi 7/16/2003 11:22'!next	| position |	position _ self position.	self		delete;		initializeForIndex: ((self sworld index + 1) min: self sworld class mazes size);		position: position;		openInWorld.! !!SokobanMorph methodsFor: 'moving etc' stamp: 'rhi 7/16/2003 12:12'!previous	| position |	position _ self position.	self		delete;		initializeForIndex: ((self sworld index - 1) max: 1);		position: position;		openInWorld.! !!SokobanMorph methodsFor: 'moving etc' stamp: 'sbw 3/27/2004 20:24'!quit	(self confirm: 'Really quit?') ifTrue: [self delete]! !!SokobanMorph methodsFor: 'moving etc' stamp: 'rhi 7/16/2003 12:34'!random	| position |	position _ self position.	self		delete;		initializeRandom;		position: position;		openInWorld.! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/15/2003 20:07'!rightArrow	^ Form		extent: 9@11		depth: 16		fromArray: #( 934084608 0 0 0 0 864825164 934150144 0 0 0 862726922 724252557 0 0 0 864824074 722021162 793509888 0 0 864824074 722086666 654977834 864813056 0 864889610 722086666 722085641 722088812 0 864889610 722086698 722086634 646524683 0 864889610 722085610 648686250 858535854 0 864889610 650717866 789264269 0 0 934095595 717894476 0 0 0 13165 931987456 0 0 0)		offset: 0@0! !!SokobanMorph methodsFor: 'private' stamp: 'sbw 3/27/2004 21:04'!selectGame	| upperLimit defaultNextIndex response selected position |	upperLimit := self sworld class mazes size.	defaultNextIndex := self sworld index + 1 min: upperLimit.	response := FillInTheBlank request: 'Choose game # (1 to ', upperLimit printString, ')' initialAnswer: defaultNextIndex printString.	response isEmptyOrNil ifTrue: [^self].	selected := response asNumber.	(selected < 1 or: [selected > upperLimit]) ifTrue: [^self].	position := self position.	self delete;		initializeForIndex: selected; position: position; openInWorld! !!SokobanMorph methodsFor: 'accessing' stamp: 'rhi 7/14/2003 22:52'!sworld	"^ <SokobanWorld>"	^ sworld! !!SokobanMorph methodsFor: 'accessing' stamp: 'rhi 7/14/2003 22:53'!sworld: aSokobanWorld	sworld _ aSokobanWorld.! !!SokobanMorph methodsFor: 'moving etc' stamp: 'sbw 3/27/2004 15:24'!undo	self sworld undo.	self forceDestroyAndRedraw! !!SokobanMorph methodsFor: 'private' stamp: 'rhi 7/15/2003 20:07'!upArrow	^ Form		extent: 9@8		depth: 16		fromArray: #( 0 0 932001709 0 0 0 14254 793457484 0 0 0 13197 654912266 931987456 0 0 12107 654912266 862715904 0 0 931998474 722020105 724252557 0 0 793455401 724183850 724187021 0 14221 724182761 652879594 652816171 931987456 0 791422634 717892298 648686282 862781440)		offset: 0@0! !"Games-Sokoban"!!PlayingCardMorph commentStamp: '<historical>' prior: 0!This class displays images from the PlayingCard class as morphs.  It attempts to be space-efficient by only producing its images on demand.!!ChineseCheckerPiece commentStamp: '<historical>' prior: 0!I represent a player piece for Chinese Checkers.  Mostly I act as an ellipse, but my special methods ensure that I cannot be picked up or dropped except in the proper circumstances.Structure: myBoard		a ChineseCheckers morph boardLoc		my current logical position on the board.!!FreeCellBoard commentStamp: '<historical>' prior: 0!The model of a freecell game.  Holds the stacks of cards.cardDeck		lastCardDeck		freeCells		homeCells		stacks		array of CardDecks of the columns of cards.----Hardness: a number from 1 to 10000.  	After dealing, count down the number.  For each count, go to next column, pick a ramdom card (with same generator as deck) and move it one place in its stack.  This is a kind of bubble sort.  Interesting that the slowness of bubble sort is a plus -- gives fine gradation in the hardness.	Moving a card:  Move red cards to deep half, black to shallow (or vice versa).  Within a color, put low cards deep and high cards shallow.  	If speed is an issue, move several steps at once, decrementing counter. 		(May make it easier?  If running columns, need a way to make harder in other ways.)!!SameGame commentStamp: '<historical>' prior: 0!See SameGame>>helpString for an explanation of how to play!!SameGameBoard commentStamp: '<historical>' prior: 0!I am an MxN array of SameGameTiles, and implement most of the logic to play the SameGame, including adjacent tile selection and removal.!!Tetris commentStamp: '<historical>' prior: 0!This is a port of JTetris.java 1.0.0.How to start:choose new morph.../Games/TetrisHow to play:1) using buttons2) using keyboard:	drop - spacebar	move to left - left arrow	move to right - right arrow	rotate clockwise - up arrow	rotate anticlockwise - down arrowNOTE: mouse must be over Tetris!!ChessBoard commentStamp: '<historical>' prior: 0!This class represents the chess board itself.!!ChessHistoryTable commentStamp: '<historical>' prior: 0!This class is a history table for our 'killer heuristic'. It remembers moves that have proven effective in the past and is later used to prioritize newly generated moves according to the effectiveness of the particular move in the past.!!ChessMove commentStamp: '<historical>' prior: 0!I represent a particular move in the chess game.!!ChessMoveGenerator commentStamp: '<historical>' prior: 0!This class generates moves for any given board. It's speed is critical - for each new position all moves need to be generated in that position. It may be worthwhile to make give this class a little plugin support at some time.!!ChessPlayer commentStamp: '<historical>' prior: 0!This class represents a player in the game, including its pieces and the current value of the player's position.!!ChessPlayerAI commentStamp: '<historical>' prior: 0!I am the AI that will beat you eventually. Well, maybe not today ... BUT MY TIME WILL COME!!!!!!!!ChessTTEntry commentStamp: '<historical>' prior: 0!This class represents an entry in the transposition table, storing the value (plus some maintenance information) of some position.!!ChessTranspositionTable commentStamp: '<historical>' prior: 0!The transposition table is a lookup cache for positions in a game that occur through transpositions in move. As an example, the same position is obtained by the moves:	1. e2-e4		Nb8-c6	2. d2-d4and	1. d2-d4		Nb8-c6	2. e2-e4An extremely large number of search branches can be cut off immediately by recognizing that the current position is just the transposition of another one. The transposition table is one of the techniques that actually make modern chess programs good enough to compete with or even beat humans.!!PlayingCard commentStamp: '<historical>' prior: 0!This class assembles card images from their parts.  The images are broken down so that the image data is very compact, and the code is written to display properly at all color depths.  The method imageData may be removed after initialization to save space, but must be re-built prior to fileOut if you wish to retain the images.To use in morphic, one can simply put these forms into ImageMorphs (see example in buildImage).  However it should be possible to define a subclass of ImageMorph that simply creates playingCard instances on the fly whenever the image form is needed.  This would avoid storing all the images.!!SameGameTile commentStamp: '<historical>' prior: 0!I am a single tile for the SameGame.  I act much like a switch.!!AtomicGame commentStamp: '<historical>' prior: 0!Atomic is game where you have to build chemical molecules using given atoms.!!ChessMorph commentStamp: '<historical>' prior: 0!This class defines the user interface for a fine game of chess.!!ChineseCheckers commentStamp: '<historical>' prior: 0!An implementation of Chinese Checkers by Dan Ingalls.  April 9, 2000.board:  A 19x19 rhombic array, addressed by row@col points, in which is imbedded the familiar six-pointed layout of cells.  A cell outside the board is nil (-).  - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - 5 - - - - -    - - - - - - - - - - - - 5 5 - - - - -     - - - - - - - - - - - 5 5 5 - - - - -      - - - - - - - - - - 5 5 5 5 - - - - -       - - - - - 6 6 6 6 0 0 0 0 0 4 4 4 4 -        - - - - - 6 6 6 0 0 0 0 0 0 4 4 4 - -         - - - - - 6 6 0 0 0 0 0 0 0 4 4 - - -          - - - - - 6 0 0 0 0 0 0 0 0 4 - - - -           - - - - - 0 0 0 0 0 0 0 0 0 - - - - -            - - - - 1 0 0 0 0 0 0 0 0 3 - - - - -             - - - 1 1 0 0 0 0 0 0 0 3 3 - - - - -              - - 1 1 1 0 0 0 0 0 0 3 3 3 - - - - -               - 1 1 1 1 0 0 0 0 0 3 3 3 3 - - - - -                - - - - - 2 2 2 2 - - - - - - - - - -                 - - - - - 2 2 2 - - - - - - - - - - -                  - - - - - 2 2 - - - - - - - - - - - -                   - - - - - 2 - - - - - - - - - - - - -                    - - - - - - - - - - - - - - - - - - -Cells within the board contain 0 if empty, or a team number (1..6) if occupied by a piece of that team.  An extra border of nils around the whole reduces bounds checking to a nil test.sixDeltas:  An array giving the x@y deltas for the 6 valid steps in CCW order from a given cell.  For team 1 they are: in fr, fl, l, bl, br, r.  To get, eg fl for a given team, use (sixDeltas atWrap: team+1).teams:  An array of six teams, each of which is an array of the x@y locations of the 10 pieces.homes:  The x@y coordinates of the six home points, namely 14@2, 18@6, 14@14, 6@18, 2@14, 6@6.  The goal, or farthest point in destination triangle, is thus (homes atWrap: teamNo+3).autoPlay:  An array of booleans, parallel to teams, where true means that Squeak will make the moves for the corresponding team.whoseMove:  A team number specifying whose turn it is next.  Set to 0 when game is over.plannedMove:  If not nil, it means the board is in a state where it is animating the next move to be made so that it can be seen.movePhase:  Holds the state of display of the planned move so that, eg, it can appear one jump at a time.  Advances from 1 to (plannedMove size * 2).A move is an array of locs which are the path of the move.Once the morph is open, the menu command 'reset...' allows you to reset the board and change the number of players.  The circle at turnIndicatorLoc indicates the color of the team whose turn it is.  If it is a human, play waits for drag and drop of a piece of that color.The current strategy is very simple: generate all moves, score them and pick the best.  Beyond this, it will look ahead a number of moves, but this becomes very expensive without pruning.  Pruning would help the speed of play, especially in the end game where we look a little deeper.  A more effective strategy would consider opponents' possible moves as well, but this is left as an exercise for the serious programmer.!!WordGameLetterMorph commentStamp: '<historical>' prior: 0!WordGameLetterMorph implements letter boxes for type-in and display of letter in word games.  Several variant displays are supported, depending on the setting of style, and blanks can be displayed as black boxes or empty letter boxes.Default support for type-in is distributed between this class and WordGamePaneMorphletter			the Character stored in this morph.				Can be either blank or nil as well as a letter.indexInQuote	a retained copy of the index of this character				Facilitates responses to, eg, clicking or typing in this box.				If indexInQuote==nil, then this is displayed as a black boxpredecessor		another LetterMorph or nil				Used for linked typing and, eg, word selectionsuccessor		another LetterMorph or nil				Used for linked typing and, eg, word selectionstyle			a Symbol, one of #(plain boxed underlined)				Boxed and underlined display further depends on whether				the id strings are nil or not.				Each format has an associated default sizeThe following two variables are also submorphs, as are the id strings if present.letterMorph		a StringMorph for displaying the letter				Used when changing the letter to be displayedlineMorph		a PolygonMorph used to display the underline				and also to place the id string in underlined format!!WordGamePanelMorph commentStamp: '<historical>' prior: 0!WordGamePanelMorph provides some default support for clicking and typing in a panel with letterMorphs.letterMorphs		a collection of LetterMorphs					Useful in referring specifically to active letterMorphs					when submorphs may contain other morphshaveTypedHere		a Boolean used to determine how backspace should be handled!!CipherPanel commentStamp: '<historical>' prior: 0!The CipherPanel, as its name suggests, is a tool for decoding simple substitution codes, such as are presented on the puzzle pages of many Sunday newspapers.  Most of the capability is inherited from the two WordGame classes used.  To try it out, choose newMorph/Games/CipherPanel in a morphic project, or execute, in any project:	CipherPanel new openInWorld!!CrosticPanel commentStamp: '<historical>' prior: 0!The CrosticPanel, as its name suggests, is a tool for decoding acrostic puzzles, such as are presented on the puzzle pages of some Sunday newspapers.  Much of the capability is inherited from the two WordGame classes used.  To try it out, choose newMorph/Games/CrosticPanel in a morphic project, or execute, in any project:	CrosticPanel new openInWorldThe instance variables of this class include...	letterMorphs (in superclass)  a collection of all the letterMorphs in this panel	quote		a string, being the entire quote in uppercase with no blanks	clues		a collection of the clue strings	answers		a collection of the answer indices.				For each answer, this is an array of the indices into the quote string.The final structure of a CrosticPanel is as follows	self					a CrosticPanel			the overall holder		quotePanel		a CrosticQuotePanel		holds the grid of letters from the quote		cluesPanel		an AlignmentMorph		holds most of the clue rows		cluesCol2		an AlignmentMorph		holds the rest of the clue rowsEach clue row is a horizontal AlignmentMorph with a textMorph and another alignmentMorph full of the letterMorphs for the answer.!!MorphicGamesInfo commentStamp: 'asm 7/5/2003 15:59' prior: 0!to create the package:in a 5325 image	-file in SARBuilderSARPackageDumper 	fileOutPackageNamed: 'Morphic-Games' 					as: (FileDirectory default nextNameFor: 'Morphic-Games' extension: 'sar')!!ChessMoveList commentStamp: '<historical>' prior: 0!An optimized representation of a set of moves - mainly there to avoid excessive allocation (and garbage collections) in a few critical places.!!ChessPieceMorph methodsFor: 'dropping/grabbing' stamp: 'ar 8/10/2001 11:35'!wantsToBeDroppedInto: aMorph	^aMorph isKindOf: ChessMorph! !!PlayingCardMorph class methodsFor: 'access' stamp: 'djp 10/17/1999 18:39'!cardSize	" a real hack, but I don't want to muck with Dan's class "	^71@96.! !!PlayingCardMorph class methodsFor: 'access' stamp: 'djp 10/17/1999 18:32'!height	^self cardSize y! !!PlayingCardMorph class methodsFor: 'new-morph participation' stamp: 'di 1/16/2000 10:40'!includeInNewMorphMenu	^false! !!PlayingCardMorph class methodsFor: 'access' stamp: 'djp 10/15/1999 07:14'!suits	^ #(clubs diamonds hearts spades)! !!PlayingCardMorph class methodsFor: 'testing' stamp: 'djp 10/17/1999 18:24'!test    "Display all cards in the deck"	"MessageTally spyOn: [20 timesRepeat: [PlayingCardMorph test]]"	| table row |	table _ AlignmentMorph newColumn.	self suits do: [:suit | 		row _ AlignmentMorph newRow.		table addMorph: row.		1 to: 13 do: [:cn |			row addMorph: 			(PlayingCardMorph the: cn of: suit)]].	table openInWorld.! !!PlayingCardMorph class methodsFor: 'initialize-release' stamp: 'di 10/18/1999 23:45'!the: cardNumber of: suit	^ self new 		image: (PlayingCard the: cardNumber of: suit) cardForm;		cardNumber: cardNumber suitNumber: (self suits indexOf: suit)! !!PlayingCardMorph class methodsFor: 'access' stamp: 'djp 10/17/1999 18:32'!width	^self cardSize x! !!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'di 12/12/2000 11:47'!aboutToBeGrabbedBy: aHand	"I'm about to be grabbed by the hand.  If other cards are above me in a deck,	then move them from the deck to being submorphs of me"	| i |	super aboutToBeGrabbedBy: aHand.	self removeProperty: #undoGrabCommand.  "So it won't interfere with overall move"	self board captureStateBeforeGrab.	i _ owner submorphs indexOf: self ifAbsent: [^ self].	i = 1 ifTrue: [^ self].	(owner submorphs copyFrom: 1 to: i-1) do:		[:m | m class = self class ifTrue: [self addMorphBack: m]].! !!PlayingCardMorph methodsFor: 'access' stamp: 'di 10/21/1999 21:41'!board	^ owner owner owner! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/24/1999 03:11'!cardDeck	^self owner! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!cardNumber	^cardNumber! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!cardNumber: c suitNumber: s	cardNumber _ c.	suitNumber _ s.! !!PlayingCardMorph methodsFor: 'event handling' stamp: 'RAA 2/12/2001 19:22'!click: evt		"since we really want to know about double-clicks before making our move, ignore this and wait until #firstClickTimedOut: arrives"! !!PlayingCardMorph methodsFor: 'event handling' stamp: 'djp 10/24/1999 03:12'!doubleClick: evt	^self cardDeck doubleClickOnCard: self! !!PlayingCardMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 14:14'!firstClickTimedOut: evt 	| root popUp |	root := owner rootForGrabOf: self.	root isNil 		ifTrue: 			["Display hidden card in front"			popUp := self copy.			self board owner owner addMorphFront: popUp.			self world displayWorld.			(Delay forMilliseconds: 750) wait.			popUp delete]		ifFalse: [evt hand grabMorph: root]! !!PlayingCardMorph methodsFor: 'event handling' stamp: 'di 10/19/1999 00:01'!handlesMouseDown: evt	^ true! !!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 20:05'!justDroppedInto: newOwner event: evt	(newOwner isKindOf: PlayingCardDeck)		ifFalse: ["Can't drop a card anywhere but on a deck"				self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt! !!PlayingCardMorph methodsFor: 'event handling' stamp: 'jcg 9/21/2001 13:25'!mouseDown: evt	"Do nothing upon mouse-down except inform the hand to watch for a double-click; wait until an ensuing click:, doubleClick:, or drag: message gets dispatched"	evt hand waitForClicksOrDrag: self event: evt selectors: { #click:. #doubleClick:. #firstClickTimedOut:. nil} threshold: 5! !!PlayingCardMorph methodsFor: 'printing' stamp: 'djp 10/17/1999 20:27'!printOn: aStream	aStream		print: cardNumber;		nextPutAll: ' of ';		print: (self class suits at: suitNumber).! !!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'di 12/12/2000 14:52'!slideBackToFormerSituation: evt	super slideBackToFormerSituation: evt.	self board removeProperty: #stateBeforeGrab.	self hasSubmorphs ifTrue:		["Just cancelled a drop of multiple cards -- have to unload submorphs"		self submorphs reverseDo: [:m | owner addMorphFront: m]].! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!suit	^self class suits at: suitNumber! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!suitColor	^#(black red red black) at: suitNumber! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!suitNumber	^suitNumber! !!TetrisBlock class methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 15:29'!flipShapes: anArray	^OrderedCollection new 		add: anArray;		add: (anArray collect: [ :each | each y negated @ each x]);		add: (anArray collect: [ :each | each x negated @ each y negated]);		add: (anArray collect: [ :each | each y @ each x negated]);		yourself	! !!TetrisBlock class methodsFor: 'new-morph participation' stamp: 'RAA 1/8/2000 11:55'!includeInNewMorphMenu	^false! !!TetrisBlock class methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 15:32'!shapeChoices	^ ShapeChoices ifNil: [		ShapeChoices _ {			{ {  0 @ 0 .  1 @ 0 .  0 @ 1 .  1 @ 1  } }.	"square - one is sufficient here"			self flipShapes: {  0 @  0 . -1 @  0 .  1 @  0 .  0 @ -1  }.	"T"			{ 				{  0 @ 0 . -1 @ 0 .  1 @ 0 .  2 @ 0  }.				{  0 @ 0 .  0 @-1 .  0 @ 1 .  0 @ 2  } 	"long - two are sufficient here"			}.			self flipShapes: { 0 @ 0 .  0 @ -1 .  0 @  1 .  1 @  1  }.	"L"			self flipShapes: { 0 @ 0 .  0 @ -1 .  0 @  1 . -1 @  1  }.	"inverted L"			self flipShapes: { 0 @ 0 . -1 @  0 .  0 @ -1 .  1 @ -1  }.	"S"			self flipShapes: {  0 @ 0 .  1 @ 0 .  0 @ -1 . -1 @ -1  } "Z"		}.	]! !!TetrisBlock methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 15:58'!board: theBoard	board _ theBoard.	4 timesRepeat: [		self addMorph: (			RectangleMorph new				color: color;				extent: board cellSize;				borderRaised		 )	].	self positionCellMorphs.! !!TetrisBlock methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:07'!defaultBounds"answer the default bounds for the receiver"	^ (2 @ 2) negated extent: 1 @ 1! !!TetrisBlock methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Tetris colors atRandom! !!TetrisBlock methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 12:37'!dropByOne 	^self moveDeltaX: 0 deltaY: 1 deltaAngle: 0! !!TetrisBlock methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:50'!initialize	"initialize the state of the receiver"	super initialize.	""		"keep this puppy out of sight"	shapeInfo _ self class shapeChoices atRandom.	baseCellNumber _ 4 atRandom + 2 @ 1.	angle _ 4 atRandom! !!TetrisBlock methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 13:56'!moveDeltaX: deltaX deltaY: deltaY deltaAngle: deltaAngle 	| delta |	delta _ deltaX @ deltaY.	(shapeInfo atWrap: angle + deltaAngle) do: [ :offsetThisCell | 		(board emptyAt: baseCellNumber + offsetThisCell + delta) ifFalse: [^ false]	].	baseCellNumber _ baseCellNumber + delta.	angle _ angle + deltaAngle - 1 \\ 4 + 1.	self positionCellMorphs.	^ true ! !!TetrisBlock methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 13:41'!positionCellMorphs	(shapeInfo atWrap: angle) withIndexDo: [ :each :index |		(submorphs at: index)			position: (board originForCell: baseCellNumber + each)	].	fullBounds _ nil.	self changed.	 ! !!ChineseCheckerPiece class methodsFor: 'new-morph participation' stamp: 'di 4/9/2000 11:17'!includeInNewMorphMenu	^ false! !!ChineseCheckerPiece methodsFor: 'accessing' stamp: 'di 4/9/2000 08:31'!boardLoc	^ boardLoc! !!ChineseCheckerPiece methodsFor: 'event handling' stamp: 'di 4/11/2000 08:36'!handlesMouseDown: evt	^ true! !!ChineseCheckerPiece methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 20:02'!justDroppedInto: newOwner event: evt	newOwner == myBoard ifFalse:		["Only allow dropping into my board."		^self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt! !!ChineseCheckerPiece methodsFor: 'event handling' stamp: 'di 4/9/2000 09:27'!mouseDown: evt	((owner isKindOf: ChineseCheckers)		and: [owner okToPickUpPieceAt: boardLoc])		ifTrue: [evt hand grabMorph: self]! !!ChineseCheckerPiece methodsFor: 'accessing' stamp: 'di 4/11/2000 08:34'!setBoard: aBoard loc: aBoardLoc	myBoard _ aBoard.	boardLoc _ aBoardLoc! !!FreeCell class methodsFor: 'parts bin' stamp: 'sw 8/2/2001 12:50'!descriptionForPartsBin	^ self partName:	'FreeCell'		categories:		#('Games')		documentation:	'A unique solitaire card game'! !!FreeCell class methodsFor: 'class initialization' stamp: 'djp 10/24/1999 14:50'!initialize	Statistics _ FreeCellStatistics new.! !!FreeCell methodsFor: 'actions' stamp: 'djp 10/31/1999 21:17'!autoMovingHome	elapsedTimeDisplay pause.	autoMoveRecursionCount _ autoMoveRecursionCount + 1.! !!FreeCell methodsFor: 'accessing' stamp: 'djp 10/31/1999 19:28'!board	board ifNil: 		[board _ FreeCellBoard new			target: self;			actionSelector: #boardAction:].	^board! !!FreeCell methodsFor: 'actions' stamp: 'djp 10/31/1999 21:35'!boardAction: actionSymbol	actionSymbol = #cardMovedHome 	ifTrue: [^self cardMovedHome].	actionSymbol = #autoMovingHome	ifTrue: [^self autoMovingHome].! !!FreeCell methodsFor: 'private' stamp: 'ar 11/9/2000 21:16'!buildButton: aButton target: aTarget label: aLabel selector: aSelector	"wrap a button or switch in an alignmentMorph to provide some space around the button"	| a |	aButton 		target: aTarget;		label: aLabel;		actionSelector: aSelector;		borderColor: #raised;		borderWidth: 2;		color: Color gray.	a _ AlignmentMorph newColumn		wrapCentering: #center; cellPositioning: #topCenter;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: Color transparent;		layoutInset: 1.	a addMorph: aButton.	^ a! !!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 15:30'!cardMovedHome	cardsRemainingDisplay value: (cardsRemainingDisplay value - 1).	autoMoveRecursionCount _ autoMoveRecursionCount - 1 max: 0.	cardsRemainingDisplay value = 0 		ifTrue: [self gameWon]		ifFalse: [autoMoveRecursionCount = 0 ifTrue: [elapsedTimeDisplay continue]].! !!FreeCell methodsFor: 'visual properties' stamp: 'RAA 3/3/2000 23:28'!colorNearBottom	^Color r: 0.0 g: 0.455 b: 0.18! !!FreeCell methodsFor: 'visual properties' stamp: 'RAA 3/4/2000 10:26'!colorNearTop	^ (Color r: 0.304 g: 0.833 b: 0.075)! !!FreeCell methodsFor: 'accessing' stamp: 'djp 10/24/1999 21:36'!currentGame	^self board cardDeck seed! !!FreeCell methodsFor: 'user interface' stamp: 'RAA 3/3/2000 23:29'!defaultBackgroundColor	^Color r: 0.365 g: 1.0 b: 0.09! !!FreeCell methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:27'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!FreeCell methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:26'!defaultColor	"answer the default color/fill style for the receiver"	^ self colorNearTop! !!FreeCell methodsFor: 'visual properties' stamp: 'RAA 3/4/2000 17:01'!fillStyle	myFillStyle ifNil: [		myFillStyle _ GradientFillStyle ramp: {			0.0 -> self colorNearTop. 			1.0 -> self colorNearBottom		}.	].	^myFillStyle		origin: self position;		direction: (self width // 2)@self height! !!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 16:20'!gameLost	state _ #lost.	elapsedTimeDisplay stop.	cardsRemainingDisplay highlighted: true; flash: true.	Statistics gameLost: self currentGame! !!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 16:20'!gameWon	state _ #won.	elapsedTimeDisplay stop; highlighted: true; flash: true.	Statistics gameWon: self currentGame! !!FreeCell methodsFor: 'actions' stamp: 'asm 11/24/2003 22:49'!help	| window helpMorph |	window := SystemWindow labelled: 'FreeCell Help' translated.	window model: self.	helpMorph := (PluggableTextMorph new editString: self helpText) lock.	window		addMorph: helpMorph		frame: (0 @ 0 extent: 1 @ 1).	window openInWorld! !!FreeCell methodsFor: 'accessing' stamp: 'asm 11/24/2003 22:48'!helpText	^ 'The objective of FreeCell is to move all of the cards to the four "home cells" in the upper right corner.  Each home cell will hold one suit and must be filled sequentially starting with the Ace.There are four "free cells" in the upper left corner that can each hold one card.  Cards can be moved from the bottom of a stack to a free cell or to another stack.  When moving a card to another stack, it must have a value that is one less than the exposed card and of a different color.' translated! !!FreeCell methodsFor: 'actions' stamp: 'di 12/12/2000 13:08'!inAutoMove	"Return true if an automove sequence is in progress"	^ autoMoveRecursionCount > 0! !!FreeCell methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:27'!initialize	"initialize the state of the receiver"	super initialize.	""	Statistics newSession.	autoMoveRecursionCount _ 0.	self listDirection: #topToBottom.	self wrapCentering: #center;		 cellPositioning: #topCenter.	self vResizing: #shrinkWrap.	self hResizing: #shrinkWrap.	self		 addMorph: self makeControls;		 addMorph: self board;		 newGame! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!makeCardsRemainingDisplay	cardsRemainingDisplay := LedMorph new digits: 2;				 extent: 2 * 10 @ 15.	^ self wrapPanel: cardsRemainingDisplay label: 'Cards Left: ' translated! !!FreeCell methodsFor: 'initialization' stamp: 'ar 11/9/2000 21:17'!makeControlBar	^AlignmentMorph newRow		color: self colorNearBottom;		borderColor: #inset;		borderWidth: 2;		layoutInset: 0;		hResizing: #spaceFill; vResizing: #shrinkWrap; wrapCentering: #center; cellPositioning: #leftCenter;		yourself.! !!FreeCell methodsFor: 'initialization' stamp: 'djp 10/24/1999 14:38'!makeControls	^self makeControlBar		addMorph: AlignmentMorph newVariableTransparentSpacer;		addMorph: self makeHelpButton;		addMorph: self makeQuitButton;		addMorph: self makeStatisticsButton;		addMorph: self makeGameNumberDisplay;		addMorph: self makePickGameButton;		addMorph: self makeSameGameButton;		addMorph: self makeNewGameButton;		addMorph: self makeElapsedTimeDisplay;		addMorph: self makeCardsRemainingDisplay;		yourself.! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!makeElapsedTimeDisplay	elapsedTimeDisplay := LedTimerMorph new digits: 3;				 extent: 3 * 10 @ 15.	^ self wrapPanel: elapsedTimeDisplay label: 'Elapsed Time: ' translated! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!makeGameNumberDisplay	gameNumberDisplay := LedMorph new digits: 5;				 extent: 5 * 10 @ 15.	^ self wrapPanel: gameNumberDisplay label: 'Game #: ' translated! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!makeHelpButton	^ self		buildButton: SimpleButtonMorph new		target: self		label: 'Help' translated		selector: #help! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!makeNewGameButton	^ self		buildButton: SimpleButtonMorph new		target: self		label: 'New game' translated		selector: #newGame! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!makePickGameButton	^ self		buildButton: SimpleButtonMorph new		target: self		label: 'Pick game' translated		selector: #pickGame! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:48'!makeQuitButton	^ self		buildButton: SimpleButtonMorph new		target: self		label: 'Quit' translated		selector: #quit! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:48'!makeSameGameButton	^ self		buildButton: SimpleButtonMorph new		target: self		label: 'Same game' translated		selector: #sameGame! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:48'!makeStatisticsButton	^ self		buildButton: SimpleButtonMorph new		target: self		label: 'Statistics' translated		selector: #statistics! !!FreeCell methodsFor: 'user interface' stamp: 'th 12/15/1999 15:20'!modelSleep	"When fixing #contains: calls beware of reinventing #includes:"	(#(newGame sameGame pickGame won lost ) includes: state)		ifTrue: [elapsedTimeDisplay pause]! !!FreeCell methodsFor: 'user interface' stamp: 'th 12/15/1999 15:22'!modelWakeUp	"Maybe less performant but more readable"	(#(won lost) includes: state)		ifFalse: [elapsedTimeDisplay resume]! !!FreeCell methodsFor: 'actions' stamp: 'di 1/16/2000 10:35'!newGame	Collection initialize.	self newGameNumber: nil.	state _ #newGame! !!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 16:21'!newGameNumber: aSeedOrNil 	cardsRemainingDisplay value ~~ 0 ifTrue: [self gameLost].	cardsRemainingDisplay flash: false; highlighted: false; value: 52.	elapsedTimeDisplay flash: false; highlighted: false.	"board handles nil case"	self board pickGame: aSeedOrNil.	elapsedTimeDisplay reset; start.	gameNumberDisplay value: self currentGame! !!FreeCell methodsFor: 'initialization' stamp: 'djp 10/31/1999 18:48'!openInWindowLabeled: aString inWorld: aWorld	^(super openInWindowLabeled: aString inWorld: aWorld)		model: self;		yourself! !!FreeCell methodsFor: 'actions' stamp: 'th 12/15/1999 15:05'!pickGame	| seed |	seed _ self promptForSeed.	seed isNil ifTrue: [^ self].	self newGameNumber: seed.	state _ #pickGame! !!FreeCell methodsFor: 'actions' stamp: 'asm 11/24/2003 22:50'!promptForSeed	| ss ii hh |	[hh := board hardness				ifNil: [0].	ss := FillInTheBlank request: 'Pick a game number between 1 and 32000.orset the hardness of the next game by typing ''H 30''.Above 100 is very hard.  Zero is standard game.Current hardness is: ' translated , hh printString.	"Let the user cancel."	ss isEmpty		ifTrue: [^ nil].	ss := ss withoutQuoting.	ss first asLowercase == $h		ifTrue: ["Set the hardness"			[ii := ss numericSuffix]				on: Error				do: [ii := 0].			board hardness: ii.			^ nil].	[ii := ss asNumber asInteger]		on: Error		do: [ii := 0].	ii between: 1 and: 32000] whileFalse.	^ ii! !!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 15:35'!quit	cardsRemainingDisplay value ~~ 0 ifTrue: [self gameLost].	self owner == self world		ifTrue: [self delete]		ifFalse: [self owner delete].	Statistics close! !!FreeCell methodsFor: 'actions' stamp: 'th 12/15/1999 15:03'!sameGame	self newGameNumber: self currentGame.	state _ #sameGame.! !!FreeCell methodsFor: 'actions' stamp: 'djp 10/24/1999 15:07'!statistics	Statistics display! !!FreeCell methodsFor: 'private' stamp: 'ar 11/9/2000 21:17'!wrapPanel: anLedPanel label: aLabel	"wrap an LED panel in an alignmentMorph with a label to its left"	| a |	a _ AlignmentMorph newRow		wrapCentering: #center; cellPositioning: #leftCenter;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 0;		layoutInset: 5;		color: Color transparent.	a addMorph: anLedPanel.	a addMorph: (StringMorph contents: aLabel). 	^ a! !!FreeCellBoard class methodsFor: 'new-morph participation' stamp: 'di 1/16/2000 10:39'!includeInNewMorphMenu	^false! !!FreeCellBoard methodsFor: 'actions' stamp: 'th 12/9/1999 19:10'!acceptCard: aCard onStack: aDeck	" assumes that number of cards was check at drag time, need to reduce count if dropping	into an empty stack"	aCard hasSubmorphs 		ifTrue: [			aDeck ifEmpty: [				(aCard submorphCount+1) > (self maxDraggableStackSize: true)					ifTrue: [^false]]]		ifFalse: [^ nil].	^nil.! !!FreeCellBoard methodsFor: 'actions' stamp: 'th 12/15/1999 16:17'!acceptSingleCard: aCard on: aDeck 	"Home cells and free cells don't accept multiple cards on a home cell, 	defer to deck for other cases"	aCard hasSubmorphs		ifTrue: [^ false]		ifFalse: [^ nil]! !!FreeCellBoard methodsFor: 'accessing' stamp: 'djp 10/16/1999 16:21'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!FreeCellBoard methodsFor: 'hardness' stamp: 'tk 3/30/2001 11:53'!addHardness	| cnt rand pileInd pile |	"post process the layout of cards to make it harder.  See class comment."	hardness ifNil: [^ self].	cnt _ hardness.	rand _ Random new seed: cardDeck seed.  "Same numbers but different purpose"	pileInd _ 1. 	[(cnt _ cnt - 1) > 0] whileTrue: [		pile _ stacks atWrap: (pileInd _ pileInd + 1).		cnt _ cnt - (self makeHarder: pile rand: rand toDo: cnt)].  "mostly 0, but moves cards"! !!FreeCellBoard methodsFor: 'private' stamp: 'RAA 3/4/2000 10:48'!autoMoveCardsHome	| first |	first _ false.	(self stacks, self freeCells) do: [:deck |		self homeCells do: [ :homeCell |			deck hasCards ifTrue: [				(homeCell repelCard: deck topCard) ifFalse: [					(self isPlayableCardInHomeCells: deck topCard) ifTrue: [						first ifFalse: [ " trigger autoMoving event on first move."							first _ true.							self performActionSelector: #autoMovingHome						].						self visiblyMove: deck topCard to: homeCell.					]				]			]		]	].! !!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 11:54'!captureStateBeforeGrab	self removeProperty: #stateBeforeGrab.	self setProperty: #stateBeforeGrab toValue: self capturedState! !!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 11:50'!capturedState	self valueOfProperty: #stateBeforeGrab ifPresentDo: [:st | ^ st].	^ {	freeCells collect: [:deck | deck submorphs].		homeCells collect: [:deck | deck submorphs].		stacks collect: [:deck | deck submorphs] }! !!FreeCellBoard methodsFor: 'layout' stamp: 'ar 11/20/2000 19:08'!cardCell	^PlayingCardDeck new		layout: #pile; 		listDirection: #topToBottom;		enableDragNDrop;		color: Color transparent;		borderColor: (Color gray alpha: 0.5);		borderWidth: 2;		layoutBounds: (0@0 extent: PlayingCardMorph width @ PlayingCardMorph height);		yourself! !!FreeCellBoard methodsFor: 'accessing' stamp: 'djp 10/11/1999 15:51'!cardDeck	^cardDeck! !!FreeCellBoard methodsFor: 'actions' stamp: 'th 12/15/1999 16:15'!cardMoved	"Free cells and stacks do nothing special here - yet - th 12/15/1999 	16:15 "	self autoMoveCardsHome! !!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/31/1999 22:02'!cardMovedHome	self autoMoveCardsHome.	self performActionSelector: #cardMovedHome.! !!FreeCellBoard methodsFor: 'layout' stamp: 'RAA 3/3/2000 23:33'!cellsRow	| row |	row := (AlignmentMorph newRow)		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		color: Color transparent;		addAllMorphs: self freeCells;		addMorphBack: self cellsRowSpacer;		addAllMorphs: self homeCells;		yourself.	^row! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/17/1999 18:25'!cellsRowSpacer	| column |	column := (AlignmentMorph newColumn)		vResizing: #rigid;		hResizing: #rigid;		color: Color transparent;		extent: PlayingCardMorph cardSize;		yourself.	^column! !!FreeCellBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:27'!defaultColor	"answer the default color/fill style for the receiver"	^ Color green! !!FreeCellBoard methodsFor: 'actions' stamp: 'RAA 3/4/2000 17:07'!doubleClickInStack: aDeck OnCard: aCard	"if there is an empty free cell, move the card there. otherwise try for an empty stack"	aCard == aDeck topCard ifFalse: [^self].	freeCells do: [:freeCell |		freeCell ifEmpty: [			self visiblyMove: aCard to: freeCell.			^ aCard		]	].	stacks do: [ :each |		each ifEmpty: [			self visiblyMove: aCard to: each.			^ aCard		]	].! !!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/24/1999 03:08'!dragCard: aCard fromHome: aCardDeck	^nil		"don't allow any cards to be dragged from a home cell"! !!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/24/1999 00:46'!dragCard: aCard fromStack: aCardDeck	| i cards |	cards _ aCardDeck cards.	i _ cards indexOf: aCard ifAbsent: [^ nil].	i > (self maxDraggableStackSize: false) ifTrue: [^ nil].	[i > 1] whileTrue:		[(aCardDeck inStackingOrder: (cards at: i-1) 					onTopOf: (cards at: i)) ifFalse: [^ nil].		i _ i-1].	^ aCard! !!FreeCellBoard methodsFor: 'drawing' stamp: 'RAA 3/4/2000 17:02'!drawOn: aCanvas	"we don't have anything to draw, but we need a color so the inset border of one of our submorphs will work"! !!FreeCellBoard methodsFor: 'layout' stamp: 'th 12/15/1999 16:14'!freeCell	| freeCell |	freeCell _ self cardCell.	freeCell stackingPolicy: #single;	 emptyDropPolicy: #any;	 target: self;	 cardDroppedSelector: #cardMoved;	 acceptCardSelector: #acceptSingleCard:on:.	^ freeCell! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 16:41'!freeCells	^freeCells ifNil: [freeCells := (1 to: 4) collect: [:i | self freeCell]]! !!FreeCellBoard methodsFor: 'accessing' stamp: 'tk 3/30/2001 13:08'!hardness	^ hardness! !!FreeCellBoard methodsFor: 'accessing' stamp: 'tk 3/30/2001 13:08'!hardness: integer	hardness _ integer	"or nil"! !!FreeCellBoard methodsFor: 'layout' stamp: 'th 12/15/1999 16:12'!homeCell	| homeCell |	homeCell _ self cardCell.	homeCell stackingPolicy: #straight;	 stackingOrder: #ascending;	 emptyDropPolicy: #inOrder;	 target: self;	 cardDroppedSelector: #cardMovedHome;	 cardDraggedSelector: #dragCard:fromHome:;	 acceptCardSelector: #acceptSingleCard:on:.	^ homeCell! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 16:41'!homeCells	^homeCells ifNil: [homeCells := (1 to: 4) collect: [:i | self homeCell]]! !!FreeCellBoard methodsFor: 'actions' stamp: 'di 12/12/2000 13:08'!inAutoMove	"Return true if an automove sequence is in progress"	^ owner inAutoMove! !!FreeCellBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:31'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;	  hResizing: #shrinkWrap;	  vResizing: #rigid;	  height: 500;	  layout! !!FreeCellBoard methodsFor: 'private' stamp: 'RAA 3/4/2000 17:11'!isPlayableCardInHomeCells: aPlayingCard	| unplayedOther topsThisColor topsOtherColor unplayedSame | 	" are all cards that could be played on this card if it stayed on the stack present in the	home cells?"	aPlayingCard cardNumber <= 2 ifTrue: [^true].	"special case for Aces and 2's"	topsThisColor _ OrderedCollection new.	topsOtherColor _ OrderedCollection new.	self homeCells do: [ :deck |		deck hasCards ifTrue: [			(aPlayingCard suitColor == deck topCard suitColor 					ifTrue: [topsThisColor] ifFalse: [topsOtherColor]) add: deck topCard cardNumber.		]	].	unplayedOther _ topsOtherColor size < 2 ifTrue: [1] ifFalse: [topsOtherColor min + 1].	unplayedSame _ topsThisColor size < 2 ifTrue: [1] ifFalse: [topsThisColor min + 1].	unplayedOther > (aPlayingCard cardNumber - 1) ifTrue: [^true].	unplayedOther < (aPlayingCard cardNumber - 1) ifTrue: [^false].	^unplayedSame >= (unplayedOther - 1)! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 18:27'!layout	self 		addMorphBack: self cellsRow;		addMorphBack: self stacksRow.! !!FreeCellBoard methodsFor: 'hardness' stamp: 'tk 3/30/2001 12:22'!makeHarder: pile rand: rand toDo: cnt	| deepColor ind thisPile thisCard otherCard |	"Move cards in a stack to make it harder.  Pick a card from the pile.  Only consider moving it deeper (toward last of pile)."	deepColor _ stacks first cards last suitColor.	ind _ ((pile cards size - 1) atRandom: rand).	"front card"	thisPile _ pile cards.  "submorphs array. We will stomp it."	thisCard _ thisPile at: ind.	otherCard _ thisPile at: ind+1.	"Move deepColor cards deeper, past cards of the other color"	(thisCard suitColor == deepColor) & (otherCard suitColor ~~ deepColor) ifTrue: [		thisPile at: ind put: otherCard.		thisPile at: ind+1 put: thisCard.		^ 0].	"single moves for now.  Make multiple when it's too slow this way"	"When colors the same, move low numbered cards deeper, past high cards"	(thisCard suitColor == otherCard suitColor) ifTrue: [		(thisCard cardNumber < otherCard cardNumber) ifTrue: [			thisPile at: ind put: otherCard.			thisPile at: ind+1 put: thisCard.			^ 0]].	"single moves for now.  Make multiple when it's too slow this way"	^ 0! !!FreeCellBoard methodsFor: 'private' stamp: 'djp 10/24/1999 00:50'!maxDraggableStackSize: dropIntoEmptyStack	"Note: dropIntoEmptyStack, means one less empty stack to work with.		This needs to be reevaluated at time of drop."	"Not super smart - doesn't use stacks that are buildable though not empty"	| nFree nEmptyStacks |	nFree _ (freeCells select: [:d | d hasCards not]) size.	nEmptyStacks _ (stacks select: [:d | d hasCards not]) size.	dropIntoEmptyStack ifTrue: [nEmptyStacks _ nEmptyStacks - 1].	^ (1 + nFree) * (2 raisedTo: nEmptyStacks)! !!FreeCellBoard methodsFor: 'private' stamp: 'dgd 2/22/2003 18:45'!performActionSelector: actionSymbol 	(target notNil and: [actionSelector notNil]) 		ifTrue: [target perform: actionSelector with: actionSymbol]! !!FreeCellBoard methodsFor: 'initialization' stamp: 'asm 11/24/2003 23:13'!pickGame: aSeedOrNil 	| sorted msg |	cardDeck := PlayingCardDeck newDeck.	aSeedOrNil == 1		ifTrue: ["Special case of game 1 does a time profile playing the entire 			(trivial) game."			sorted := cardDeck submorphs						asSortedCollection: [:a :b | a cardNumber >= b cardNumber].			cardDeck removeAllMorphs; addAllMorphs: sorted.			self resetBoard.			self world doOneCycle.			Utilities				informUser: 'Game #1 is a special casefor performance analysis' translated				during: [msg := self world firstSubmorph.					msg align: msg topRight with: owner bottomRight.					MessageTally						spyOn: [sorted last owner doubleClickOnCard: sorted last]]]		ifFalse: [aSeedOrNil				ifNotNil: [cardDeck seed: aSeedOrNil].			cardDeck shuffle.			self resetBoard]! !!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 12:14'!rememberUndoableAction: aBlock named: caption	self inAutoMove ifTrue: [^ aBlock value].	^ super rememberUndoableAction: aBlock named: caption! !!FreeCellBoard methodsFor: 'initialization' stamp: 'tk 3/30/2001 12:20'!resetBoard	self purgeAllCommands.	self resetFreeCells;		resetHomeCells;		resetStacks;		addHardness;		changed.! !!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/16/1999 20:06'!resetFreeCells	freeCells do: [:deck | deck removeAllCards]! !!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/16/1999 20:06'!resetHomeCells	homeCells do: [:deck | deck removeAllCards]! !!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/16/1999 20:06'!resetStacks	| card stackStream stack |	stacks do: [:deck | deck removeAllCards].	stackStream _ ReadStream on: stacks.	[card _ cardDeck deal.	card notNil] whileTrue: [		stack _ stackStream next ifNil: [stackStream reset; next].		stack addCard: card].! !!FreeCellBoard methodsFor: 'card in a stack' stamp: 'ar 11/9/2000 20:55'!stack	^ PlayingCardDeck new color: Color transparent;	 layout: #stagger;	 listDirection: #topToBottom;	 enableDragNDrop;	 stackingPolicy: #altStraight;	 stackingOrder: #descending;	 emptyDropPolicy: #any;	 target: self;	 cardDroppedSelector: #cardMoved;	 cardDraggedSelector: #dragCard:fromStack:;	 acceptCardSelector: #acceptCard:onStack:;	 cardDoubleClickSelector: #doubleClickInStack:OnCard:! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 16:41'!stacks	^stacks ifNil: [stacks:= (1 to: 8) collect: [:i | self stack]]! !!FreeCellBoard methodsFor: 'layout' stamp: 'ar 11/20/2000 18:58'!stacksRow	| row |	row := (AlignmentMorph newRow)		vResizing: #spaceFill;		hResizing: #spaceFill;		wrapCentering: #topLeft;		cellPositioning: #topLeft;		color: Color transparent;		yourself.	self stacks do: [:stack |		row 			addMorphBack: AlignmentMorph newVariableTransparentSpacer;			addMorphBack: stack].	row addMorphBack: AlignmentMorph newVariableTransparentSpacer.	^row! !!FreeCellBoard methodsFor: 'accessing' stamp: 'djp 10/16/1999 15:33'!target: anObject	target _ anObject! !!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 08:12'!undoFromCapturedState: st	freeCells with: st first do: [:deck :morphs | deck removeAllMorphs; addAllMorphs: morphs].	homeCells with: st second do: [:deck :morphs | deck removeAllMorphs; addAllMorphs: morphs].	stacks with: st third do: [:deck :morphs | deck removeAllMorphs; addAllMorphs: morphs]! !!FreeCellBoard methodsFor: 'private' stamp: 'di 12/12/2000 13:09'!visiblyMove: aCard to: aCell	| p1 p2 nSteps |	self inAutoMove ifFalse: [self captureStateBeforeGrab].	owner owner addMorphFront: aCard.	p1 _ aCard position.	p2 _ aCell position.	nSteps _ 10.	1 to: nSteps-1 do: "Note final step happens with actual drop"		[:i | aCard position: ((p2*i) + (p1*(nSteps-i))) // nSteps.		self world displayWorld].	aCell acceptDroppingMorph: aCard event: nil! !!Mines class methodsFor: 'parts bin' stamp: 'ar 11/25/2001 14:59'!descriptionForPartsBin	^ self partName: 	'Mines'		categories:		#('Games')		documentation:	'Find those mines'! !!Mines methodsFor: 'access' stamp: 'DAS 7/8/2001 15:25'!board	board ifNil:		[board _ MinesBoard new			target: self;			actionSelector: #selection].	^ board! !!Mines methodsFor: 'initialize' stamp: 'DAS 7/8/2001 14:16'!buildButton: aButton target: aTarget label: aLabel selector: aSelector	"wrap a button or switch in an alignmentMorph to allow a row of buttons to fill space"	| a |	aButton 		target: aTarget;		label: aLabel;		actionSelector: aSelector;		borderColor: #raised;		borderWidth: 2;		color: color.	a _ AlignmentMorph newColumn		wrapCentering: #center; cellPositioning: #topCenter;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: color.	a addMorph: aButton.	^ a! !!Mines methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:34'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ #raised! !!Mines methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!Mines methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:28'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!Mines methodsFor: 'actions' stamp: 'DAS 7/8/2001 14:38'!help: helpState	helpState		ifTrue: [self addMorphBack: self helpText]		ifFalse: [helpText delete]! !!Mines methodsFor: 'access' stamp: 'asm 11/25/2003 22:31'!helpString	^ 'Mines is a quick and dirty knock-off of the Minesweeper game found on Windows. I used this to teach myself Squeak. I liberally borrowed from the <SameGame> example, so the code should look pretty familiar, though like any project it has rapidly ...morphed... to reflect my own idiosyncracies. Note especially the lack of any idiomatic structure to the code - I simply haven''t learned them yet.Mines is a very simple, yet extremely frustrating, game to play. The rules are just this: there are 99 mines laid down on the board. Find them without ""finding"" them. Your first tile is free - click anywhere. The tiles will tell you how many mines are right next to it, including the diagonals. If you uncover the number ''2'', you know that there are two mines hidden in the adjacent tiles. If you think you have found a mine, you can flag it by either ''shift'' clicking, or click with the ''yellow'' mouse button. Once you have flagged all of the mines adjacent to a numbered tile, you can click on the tile again to uncover the rest. Of course, you could be wrong about those too... You win once you have uncovered all of the tiles that do not contain mines. Good luck...David A. Smithdastrs@bellsouth.net' translated! !!Mines methodsFor: 'access' stamp: 'DAS 7/8/2001 14:45'!helpText	helpText ifNil:		[helpText _ PluggableTextMorph new			width: self width; "board width;"			editString: self helpString].	^ helpText! !!Mines methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:34'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;	  wrapCentering: #center;		 cellPositioning: #topCenter;	  vResizing: #shrinkWrap;	  hResizing: #shrinkWrap;	  layoutInset: 3;	  addMorph: self makeControls;	  addMorph: self board.	helpText _ nil.	self newGame! !!Mines methodsFor: 'initialize' stamp: 'asm 11/25/2003 22:29'!makeControls	| row |	row := AlignmentMorph newRow color: color;				 borderWidth: 2;				 layoutInset: 3.	row borderColor: #inset.	row hResizing: #spaceFill;		 vResizing: #shrinkWrap;		 wrapCentering: #center;		 cellPositioning: #leftCenter;		 extent: 5 @ 5.	row		addMorph: (self				buildButton: SimpleSwitchMorph new				target: self				label: '  Help  ' translated				selector: #help:).	row		addMorph: (self				buildButton: SimpleButtonMorph new				target: self				label: '  Quit  ' translated				selector: #delete).	"row 	addMorph: (self 	buildButton: SimpleButtonMorph new 	target: self 	label: ' Hint '  translated	selector: #hint)."	row		addMorph: (self				buildButton: SimpleButtonMorph new				target: self				label: '  New game  ' translated				selector: #newGame).	minesDisplay := LedMorph new digits: 2;				 extent: 2 * 10 @ 15.	row		addMorph: (self wrapPanel: minesDisplay label: 'Mines:' translated).	timeDisplay := LedTimerMorph new digits: 3;				 extent: 3 * 10 @ 15.	row		addMorph: (self wrapPanel: timeDisplay label: 'Time:' translated).	^ row! !!Mines methodsFor: 'access' stamp: 'DAS 7/13/2001 03:28'!minesDisplay	^ minesDisplay! !!Mines methodsFor: 'actions' stamp: 'DAS 7/13/2001 03:49'!newGame	timeDisplay value: 0; flash: false.	timeDisplay stop.	timeDisplay reset.	minesDisplay value: 99.	self board resetBoard.! !!Mines methodsFor: 'access' stamp: 'DAS 7/13/2001 03:40'!timeDisplay	^ timeDisplay! !!Mines methodsFor: 'initialize' stamp: 'DAS 7/8/2001 14:25'!wrapPanel: anLedPanel label: aLabel	"wrap an LED panel in an alignmentMorph with a label to its left"	| a |	a _ AlignmentMorph newRow		wrapCentering: #center; cellPositioning: #leftCenter;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 0;		layoutInset: 3;		color: color lighter.	a addMorph: anLedPanel.	a addMorph: (StringMorph contents: aLabel). 	^ a! !!MinesBoard class methodsFor: 'new-morph participation' stamp: 'das 7/24/2001 00:11'!includeInNewMorphMenu	^false! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/8/2001 15:32'!actionSelector	^ actionSelector! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/8/2001 15:32'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/13/2001 01:50'!adjustTiles	"reset tiles"	| newSubmorphs count r c |	submorphs do: "clear out all of the tiles."		[:m | m privateOwner: nil].	newSubmorphs _ OrderedCollection new.	r _ 0.	c _ 0.	count _ columns * rows.	1 to: count do:				[:m |				newSubmorphs add:					(protoTile copy						position: self position + (self protoTile extent * (c @ r));						actionSelector: #tileClickedAt:newSelection:modifier:;						arguments: (Array with: (c+1) @ (r+1));						target: self;						privateOwner: self).				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]].	submorphs _ newSubmorphs asArray.! !!MinesBoard methodsFor: 'actions' stamp: 'das 7/22/2001 19:34'!blowUp	owner timeDisplay stop.	self submorphsDo:		[:m |		m isMine ifTrue:				[m switchState: true.].		].	flashCount _ 2.	gameOver _ true.! !!MinesBoard methodsFor: 'actions' stamp: 'das 7/22/2001 19:45'!clearMines: location	| al tile |	(self countFlags: location) = (self findMines: location) ifTrue:		[		{-1@-1. -1@0. -1@1. 0@1. 1@1. 1@0. 1@-1. 0@-1} do:			[:offsetPoint |			al _ location + offsetPoint.			((al x between: 1 and: columns) and: [al y between: 1 and: rows]) ifTrue: [				tile _ self tileAt: al.				(tile mineFlag or: [tile switchState]) ifFalse:[		   		self stepOnTile: al].].].		].! !!MinesBoard methodsFor: 'actions' stamp: 'das 7/22/2001 19:45'!countFlags: location	| al at flags |	flags _ 0.	{-1@-1. -1@0. -1@1. 0@1. 1@1. 1@0. 1@-1. 0@-1} do:		[:offsetPoint |		al _ location + offsetPoint.		((al x between: 1 and: columns) and: [al y between: 1 and: rows]) ifTrue:			[at _ self tileAt: al.			(at mineFlag ) ifTrue:				[flags _ flags+1]]].		^flags.! !!MinesBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:34'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ #inset! !!MinesBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!MinesBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:28'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!MinesBoard methodsFor: 'geometry' stamp: 'DAS 7/8/2001 19:38'!extent: aPoint	"constrain the extent to be a multiple of the protoTile size during resizing"	super extent: (aPoint truncateTo: protoTile extent).! !!MinesBoard methodsFor: 'actions' stamp: 'DAS 7/10/2001 14:58'!findMines: location	| al at mines |	mines _ 0.	{-1@-1. -1@0. -1@1. 0@1. 1@1. 1@0. 1@-1. 0@-1} do:		[:offsetPoint |		al _ location + offsetPoint.		((al x between: 1 and: columns) and: [al y between: 1 and: rows]) ifTrue:			[at _ self tileAt: al.			(at isMine ) ifTrue:				[mines _ mines+1]]].		^mines.! !!MinesBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:06'!initialize	"initialize the state of the receiver"	super initialize.	""	target _ nil.	actionSelector _ #selection.	arguments _ #().	""	self layoutPolicy: nil;	  hResizing: #rigid;	  vResizing: #rigid.	""	rows _ self preferredRows.	columns _ self preferredColumns.	flashCount _ 0.	""	self extent: self protoTile extent * (columns @ rows).	self adjustTiles.	self resetBoard! !!MinesBoard methodsFor: 'preferences' stamp: 'DAS 7/8/2001 15:41'!preferredColumns	^ 30! !!MinesBoard methodsFor: 'preferences' stamp: 'DAS 7/9/2001 01:25'!preferredMines	^ 99! !!MinesBoard methodsFor: 'preferences' stamp: 'DAS 7/8/2001 15:41'!preferredRows	^ 16! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/9/2001 13:19'!protoTile	protoTile ifNil: [protoTile _ MinesTile new].	^ protoTile! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/8/2001 15:40'!protoTile: aTile	protoTile _ aTile! !!MinesBoard methodsFor: 'initialization' stamp: 'di 11/26/2001 21:24'!resetBoard	gameStart _ false.	gameOver _ false.	[flashCount = 0] whileFalse: [self step].	flashCount _ 0.	tileCount _ 0.	Collection initialize.  "randomize the Collection class"	self purgeAllCommands.	self submorphsDo: "set tiles to original state."		[:m | m privateOwner: nil.  "Don't propagate all these changes..."		m mineFlag: false.		m disabled: false.		m switchState: false.		m isMine: false.		m privateOwner: self].	self changed  "Now note the change in bulk"! !!MinesBoard methodsFor: 'actions' stamp: 'das 7/22/2001 19:47'!selectTilesAdjacentTo: location	| al at mines |"	{-1@0. 0@-1. 1@0. 0@1} do:"	{-1@-1. -1@0. -1@1. 0@1. 1@1. 1@0. 1@-1. 0@-1} do:		[:offsetPoint |		al _ location + offsetPoint.		((al x between: 1 and: columns) and: [al y between: 1 and: rows]) ifTrue:			[at _ self tileAt: al.			(at switchState not and: [at disabled not]) ifTrue:				[				mines _ (self tileAt: al) nearMines.				at mineFlag ifTrue: [at mineFlag: false.].  "just in case we flagged it as a mine."				at switchState: true.				tileCount _ tileCount + 1.				mines=0 ifTrue: [self selectTilesAdjacentTo: al]]]]! !!MinesBoard methodsFor: 'initialization' stamp: 'das 7/22/2001 19:49'!setMines: notHere	| count total c r sm |	count _ 0.	total _ self preferredMines.	[count < total] whileTrue:[		c _ columns atRandom.		r _ rows atRandom.		c@r = notHere ifFalse: [			sm _ self tileAt: c@r.			sm isMine ifFalse: [				"sm color: Color red lighter lighter lighter lighter."				sm isMine: true.				count _ count + 1.]]		].	1 to: columns do: [ :col |		1 to: rows do: [ :row |			(self tileAt: col @ row) nearMines: (self findMines: (col @ row))			]].			! !!MinesBoard methodsFor: 'stepping and presenter' stamp: 'DAS 7/14/2001 18:16'!step	flashCount = 0 ifFalse: [		self submorphsDo:			[:m |				m color: m color negated.].			flashCount _ flashCount - 1.			].! !!MinesBoard methodsFor: 'actions' stamp: 'das 7/22/2001 19:46'!stepOnTile: location	| mines tile |	tile _ self tileAt: location.	tile mineFlag ifFalse:[		tile isMine ifTrue: [tile color: Color gray darker darker. self blowUp. ^false.]			ifFalse:[				mines _ self findMines: location.				tile switchState: true.				tileCount _ tileCount + 1.				mines = 0 ifTrue: 					[self selectTilesAdjacentTo: location]].		tileCount = ((columns*rows) - self preferredMines) ifTrue:[ gameOver _ true. flashCount _ 2. 	owner timeDisplay stop.].		^ true.] 		ifTrue: [^ false.]! !!MinesBoard methodsFor: 'testing' stamp: 'DAS 7/14/2001 18:12'!stepTime	^ 300! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/8/2001 15:31'!target	^ target! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/8/2001 15:31'!target: anObject	target _ anObject! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/10/2001 14:59'!tileAt: aPoint	^ submorphs at: (aPoint x + ((aPoint y - 1) * columns))! !!MinesBoard methodsFor: 'actions' stamp: 'das 7/22/2001 19:55'!tileClickedAt: location newSelection: isNewSelection modifier: mod	| tile |	"self halt."	gameOver ifTrue: [^ false].	tile _ self tileAt: location.	isNewSelection ifFalse: [		mod ifTrue: [				tile mineFlag: ((tile mineFlag) not).				tile mineFlag ifTrue: [owner minesDisplay value: (owner minesDisplay value - 1)]						ifFalse: [owner minesDisplay value: (owner minesDisplay value + 1)].				^ true.].		gameStart ifFalse: [ 			self setMines: location.			gameStart _ true. 			owner timeDisplay start.].		^ self stepOnTile: location.		]	ifTrue:[ self clearMines: location.].! !!PlayingCardDeck class methodsFor: 'new-morph participation' stamp: 'di 1/16/2000 10:38'!includeInNewMorphMenu	^false! !!PlayingCardDeck class methodsFor: 'instance creation' stamp: 'djp 10/15/1999 11:01'!newDeck	^self new newDeck! !!PlayingCardDeck class methodsFor: 'instance creation' stamp: 'djp 10/15/1999 09:53'!newSuit: suit	^self new newSuit: suit! !!PlayingCardDeck class methodsFor: 'symbols' stamp: 'djp 10/10/1999 18:06'!suits	^{#Clubs. #Diamonds. #Hearts. #Spades}! !!PlayingCardDeck class methodsFor: 'symbols' stamp: 'djp 10/17/1999 18:05'!values	^#(Ace),((2 to: 9) collect: [:i | i printString asSymbol]), #(Jack Queen King)! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'th 12/10/1999 16:07'!acceptCard: aCard default: aBoolean 	"if target and acceptCardSelector are both not nil, send to target, if not  	nil answer  	else answer aBoolean"	"Rewrote this a little (SmallLint calls this 'intention revealing')-th"	^ (target isNil or: [acceptCardSelector isNil])		ifTrue: [aBoolean]		ifFalse: [(target				perform: acceptCardSelector				with: aCard				with: self)				ifNil: [aBoolean]]! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 01:40'!acceptCardSelector: aSymbolOrString	acceptCardSelector _ self nilOrSymbol: aSymbolOrString.! !!PlayingCardDeck methodsFor: 'layout' stamp: 'asm 11/25/2003 22:37'!acceptDroppingMorph: aMorph event: evt 	target		rememberUndoableAction: [target inAutoMove				ifFalse: [target removeProperty: #stateBeforeGrab].			self addMorph: aMorph.			aMorph hasSubmorphs				ifTrue: ["Just dropped a sub-deck of cards"					aMorph submorphs						reverseDo: [:m | self addMorphFront: m]].			(target notNil					and: [cardDroppedSelector notNil])				ifTrue: [target perform: cardDroppedSelector]]		named: 'move card' translated! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/15/1999 11:07'!addCard: aPlayingCard	self addMorph: aPlayingCard! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 03:13'!cardDoubleClickSelector: aSymbolOrString	cardDoubleClickSelector _ self nilOrSymbol: aSymbolOrString.! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 01:39'!cardDraggedSelector: aSymbolOrString	cardDraggedSelector _ self nilOrSymbol: aSymbolOrString.! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 17:27'!cardDroppedSelector: aSymbolOrString	cardDroppedSelector _ self nilOrSymbol: aSymbolOrString.! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/15/1999 10:46'!cards	^submorphs! !!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'dgd 2/22/2003 13:37'!deal	| card |	^ self cards notEmpty 		ifTrue: 			[card := self topCard.			card delete.			card]		ifFalse: [nil]! !!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'djp 10/10/1999 18:48'!deal: anInteger	^(1 to: anInteger) collect: [:i | self deal]! !!PlayingCardDeck methodsFor: 'events' stamp: 'dgd 2/22/2003 18:49'!doubleClickOnCard: aCard 	(target notNil and: [cardDoubleClickSelector notNil]) 		ifTrue: 			[^target 				perform: cardDoubleClickSelector				with: self				with: aCard]! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 13:14'!emptyDropNotOk: aPlayingCard	^(self emptyDropOk: aPlayingCard) not! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 13:15'!emptyDropOk: aPlayingCard	emptyDropPolicy = #any 			ifTrue: [^true].	emptyDropPolicy = #inOrder			ifTrue: [^self inStackingOrder: aPlayingCard].	emptyDropPolicy = #anyClub 		ifTrue: [^aPlayingCard suit = #club].	emptyDropPolicy = #anyDiamond		ifTrue: [^aPlayingCard suit = #diamond].	emptyDropPolicy = #anyHeart		ifTrue: [^aPlayingCard suit = #heart].	emptyDropPolicy = #anySpade		ifTrue: [^aPlayingCard suit = #spade].! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 13:18'!emptyDropPolicy: aSymbol	"#any #inOrder #anyClub #anyDiamond #anyHeart #anySpade"	emptyDropPolicy _ aSymbol! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 19:41'!hasCards	^self hasSubmorphs! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 13:10'!ifEmpty: aBlock	self hasSubmorphs not ifTrue: [^aBlock value]! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 02:17'!ifEmpty: aBlock1 ifNotEmpty: aBlock2	self hasSubmorphs not 		ifTrue: [^aBlock1 value]		ifFalse: [^aBlock2 value]! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 21:54'!inStackingOrder: aPlayingCard	^self inStackingOrder: aPlayingCard event: nil! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'di 10/19/1999 15:45'!inStackingOrder: aCard event: evt	self hasSubmorphs 		ifTrue: [^ self inStackingOrder: aCard onTopOf: self topCard]		ifFalse: [stackingOrder = #ascending ifTrue: [^ aCard cardNumber = 1].				stackingOrder = #descending ifTrue: [^ aCard cardNumber = 13]].	^ false.! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'di 10/21/1999 22:03'!inStackingOrder: aCard onTopOf: cardBelow	| diff |	(stackingPolicy = #altStraight and: [aCard suitColor = cardBelow suitColor]) ifTrue: [^ false].	(stackingPolicy = #straight and: [aCard suit ~= cardBelow suit]) ifTrue: [^ false].	diff _ aCard cardNumber - cardBelow cardNumber.	stackingOrder = #ascending 	ifTrue: [^ diff = 1].	stackingOrder = #descending	ifTrue: [^ diff = -1].	^ false.! !!PlayingCardDeck methodsFor: 'initialization' stamp: 'ar 11/20/2000 19:11'!initialize	super initialize.	self cellPositioning: #topLeft.	self reverseTableCells: true.	self layout: #grid.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	borderWidth _ 0.	self layoutInset: 0.	stackingPolicy _ #stagger.	stackingOrder _ #ascending.	emptyDropPolicy _ #any.	self newSeed.	^self! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/15/1999 12:43'!insertionIndexFor: aMorph	"Return the index at which the given morph should be inserted into the submorphs of the receiver."	^1! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'ar 11/20/2000 18:43'!layout: aSymbol	" #grid #pile #stagger"	layout _ aSymbol.	layout == #grid 		ifTrue:[self maxCellSize: SmallInteger maxVal].	layout == #pile 		ifTrue:[self maxCellSize: 0].	layout == #stagger 		ifTrue:[self maxCellSize: self staggerOffset].! !!PlayingCardDeck methodsFor: 'initialization' stamp: 'djp 10/17/1999 18:25'!newDeck	| cards |	cards := OrderedCollection new: 52.	PlayingCardMorph suits 		do: [:suit | 1 to: 13			do: [:cardNo | cards add: (PlayingCardMorph the: cardNo of: suit)]].	self addAllMorphs: cards.	^self! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/23/1999 22:44'!newSeed	seed _ (1 to: 32000) atRandom! !!PlayingCardDeck methodsFor: 'initialization' stamp: 'djp 10/17/1999 18:25'!newSuit: suit	| cards |	cards := OrderedCollection new: 13.	1 to: 13 do: [:cardNo | cards add: (PlayingCardMorph the: cardNo of: suit)].	self addAllMorphs: cards.	^self! !!PlayingCardDeck methodsFor: 'private' stamp: 'djp 10/16/1999 17:27'!nilOrSymbol: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^nil]		ifFalse: [^aSymbolOrString asSymbol]! !!PlayingCardDeck methodsFor: 'printing' stamp: 'dgd 2/22/2003 13:38'!printOn: aStream 	| cards |	cards := self cards.	aStream nextPutAll: 'aCardDeck('.	cards size > 1 		ifTrue: 			[cards allButLast do: 					[:card | 					aStream						print: card;						nextPutAll: ', ']].	cards notEmpty ifTrue: [aStream print: cards last].	aStream nextPut: $)! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 20:05'!removeAllCards	self removeAllMorphs! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'th 12/10/1999 18:34'!repelCard: aCard 	stackingPolicy = #none ifTrue: [^ self repelCard: aCard default: true].	stackingPolicy = #single ifTrue: [^ self ifEmpty: [self repelCard: aCard default: false]			ifNotEmpty: [true]].	(stackingPolicy = #altStraight or: [stackingPolicy = #straight])		ifTrue: [self ifEmpty: [^ self repelCard: aCard default: (self emptyDropNotOk: aCard)]				ifNotEmpty: [(self inStackingOrder: aCard onTopOf: self topCard)						ifFalse: [^ self repelCard: aCard default: true]]].	^ false! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 04:09'!repelCard: aCard default: aBoolean		^(self acceptCard: aCard default: aBoolean not) not! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 02:20'!repelsMorph: aMorph event: evt	(aMorph isKindOf: PlayingCardMorph) 		ifTrue: [^self repelCard: aMorph]		ifFalse: [^true]! !!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'ar 11/12/2000 22:40'!reverse	self invalidRect: self fullBounds.	submorphs _ submorphs reversed.	self layoutChanged.! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'dgd 2/22/2003 18:49'!rootForGrabOf: aCard 	self hasSubmorphs ifFalse: [^nil].	(target notNil and: [cardDraggedSelector notNil]) 		ifTrue: 			[^target 				perform: cardDraggedSelector				with: aCard				with: self]		ifFalse: [^self firstSubmorph]! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/23/1999 22:22'!seed		^seed! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/23/1999 22:21'!seed: anInteger		seed _ anInteger! !!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'ar 11/12/2000 22:40'!shuffle	self invalidRect: self fullBounds.	submorphs _ submorphs shuffledBy: (Random new seed: seed).	self layoutChanged.! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/15/1999 16:39'!stackingOrder: aSymbol	"#ascending #descending"	stackingOrder _ aSymbol! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 00:08'!stackingPolicy	^ stackingPolicy! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 00:08'!stackingPolicy: aSymbol	"#straight #altStraight #single #none"	stackingPolicy _ aSymbol! !!PlayingCardDeck methodsFor: 'layout' stamp: 'djp 10/15/1999 11:25'!staggerOffset	^18! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 20:20'!subDeckStartingAt: aCard	| i subDeck |	i _ submorphs indexOf: aCard ifAbsent: [^ aCard].	i = 1 ifTrue: [^aCard].	subDeck _ PlayingCardDeck new.	(submorphs copyFrom: 1 to: i-1) do:			[:m | m class = aCard class ifTrue: [subDeck addMorphBack: m]].	^subDeck.	! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 17:21'!target: anObject	target _ anObject! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 19:24'!topCard	^self firstSubmorph! !!SameGame class methodsFor: 'parts bin' stamp: 'sw 8/2/2001 12:52'!descriptionForPartsBin	^ self partName:	'Same'		categories:		#('Games')		documentation:	'A board game implementedby Tim Olson, based on a game originally written for UNIX by Eiji Fukumoto.'! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 18:07'!board	board ifNil:		[board _ SameGameBoard new			target: self;			actionSelector: #selection].	^ board! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 16:19'!board: aSameGameBoard	board _ aSameGameBoard! !!SameGame methodsFor: 'initialization' stamp: 'ar 11/9/2000 21:21'!buildButton: aButton target: aTarget label: aLabel selector: aSelector	"wrap a button or switch in an alignmentMorph to allow a row of buttons to fill space"	| a |	aButton 		target: aTarget;		label: aLabel;		actionSelector: aSelector;		borderColor: #raised;		borderWidth: 2;		color: color.	a _ AlignmentMorph newColumn		wrapCentering: #center; cellPositioning: #topCenter;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: color.	a addMorph: aButton.	^ a! !!SameGame methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:30'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!SameGame methodsFor: 'actions' stamp: 'tao 5/18/1998 19:45'!help: helpState	helpState		ifTrue: [self addMorphBack: self helpText]		ifFalse: [helpText delete]! !!SameGame methodsFor: 'access' stamp: 'asm 11/25/2003 22:40'!helpString	^ 'The object of SameGame is to maximize your score by removing tiles from the board.  Tiles are selected and removed by clicking on a tile that has at least one adjacent tile of the same color (where adjacent is defined as up, down, left, or right).The first click selects a group of adjacent tiles, a second click in that group will remove it from the board, sliding tiles down and right to fill the space of the removed group.  If you wish to select a different group, simply click on it instead.The score increases by "(selection - 2) squared", so you want to maximize the selection size as much as possible.  However, making small strategic selections may allow you to increase the size of a later selection.If you are having a hard time finding a group, the "Hint" button will find one and select it for you (although it is likely not the best group to select!!).When there are no more groups available, the score display will flash with your final score.  Your final score is reduced by 1 for each tile remaining on the board.  If you manage to remove all tiles, your final score is increased by a bonus of 5 times the number of tiles on a full board.Come on, you can beat that last score!!  Click "New game"  ;-)SameGame was originally written by Eiji Fukumoto for UNIX and X; this version is based upon the same game concept, but was rewritten from scratch.' translated! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 19:43'!helpText	helpText ifNil:		[helpText _ PluggableTextMorph new			width: board width;			editString: self helpString].	^ helpText! !!SameGame methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:02'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;	  wrapCentering: #center;		 cellPositioning: #topCenter;	  vResizing: #shrinkWrap;	  hResizing: #shrinkWrap;	  layoutInset: 3;	  addMorph: self makeControls;	  addMorph: self board.	helpText _ nil.	self newGame! !!SameGame methodsFor: 'initialization' stamp: 'ar 11/9/2000 21:22'!makeControls	| row |	row _ AlignmentMorph newRow		color: color;		borderWidth: 0;		layoutInset: 3.	row hResizing: #spaceFill; vResizing: #shrinkWrap; wrapCentering: #center; cellPositioning: #leftCenter; extent: 5@5.	row addMorph:		(self			buildButton: SimpleSwitchMorph new			target: self			label: 'Help'			selector: #help:).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self			label: 'Quit'			selector: #delete).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self board			label: 'Hint'			selector: #hint).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self			label: 'New game'			selector: #newGame).	selectionDisplay _ LedMorph new		digits: 2;		extent: (2*10@15).	row addMorph: (self wrapPanel: selectionDisplay label: 'Selection:').	scoreDisplay _ LedMorph new		digits: 4;		extent: (4*10@15).	row addMorph: (self wrapPanel: scoreDisplay label: 'Score:').	^ row! !!SameGame methodsFor: 'actions' stamp: 'tao 5/18/1998 18:35'!newGame	scoreDisplay value: 0; flash: false.	selectionDisplay value: 0.	self board resetBoard.! !!SameGame methodsFor: 'access' stamp: 'di 9/12/2000 08:07'!scoreDisplay	^ scoreDisplay! !!SameGame methodsFor: 'actions' stamp: 'aoy 2/15/2003 21:40'!selection	"a selection was made on the board; get its count and update the displays"	| count score |	count := self board selectionCount.	count = 0 		ifTrue: 			[score := scoreDisplay value + (selectionDisplay value - 2) squared.			board findSelection ifNil: 					[count := board tilesRemaining.					score := count = 0 						ifTrue: [score + (5 * board rows * board columns)]						ifFalse: [score - count].					scoreDisplay flash: true].			scoreDisplay value: score].	selectionDisplay value: count! !!SameGame methodsFor: 'initialization' stamp: 'ar 11/9/2000 21:22'!wrapPanel: anLedPanel label: aLabel	"wrap an LED panel in an alignmentMorph with a label to its left"	| a |	a _ AlignmentMorph newRow		wrapCentering: #center; cellPositioning: #leftCenter;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 0;		layoutInset: 3;		color: color lighter.	a addMorph: anLedPanel.	a addMorph: (StringMorph contents: aLabel). 	^ a! !!SameGameBoard class methodsFor: 'new-morph participation' stamp: 'di 1/16/2000 10:37'!includeInNewMorphMenu	^false! !!SameGameBoard methodsFor: 'layout' stamp: 'tao 5/15/1998 14:15'!acceptDroppingMorph: aMorph event: evt	"Allow the user to set the protoTile just by dropping it on this morph."	self protoTile: aMorph.	self removeAllMorphs.! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!actionSelector	^ actionSelector! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 17:00'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!SameGameBoard methodsFor: 'private' stamp: 'ar 11/20/2000 19:26'!adjustTiles	"add or remove new protoTile submorphs to fill out my new bounds"	| newSubmorphs requiredSubmorphs count r c |	columns _ self width // protoTile width.	rows _ self height // protoTile height.	requiredSubmorphs _ rows * columns.	newSubmorphs _ OrderedCollection new.	r _ 0.	c _ 0.	self submorphCount > requiredSubmorphs		ifTrue: "resized smaller -- delete rows or columns"			[count _ 0.			submorphs do:				[:m | 				count < requiredSubmorphs					ifTrue:						[m position: self position + (protoTile extent * (c @ r)).						m arguments: (Array with: c @ r).						newSubmorphs add: m]					ifFalse: [m privateOwner: nil].				count _ count + 1.				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]]]		ifFalse: "resized larger -- add rows or columns"			[submorphs do:				[:m |				m position: self position + (self protoTile extent * (c @ r)).				m arguments: (Array with: c @ r).				newSubmorphs add: m.				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]].			1 to: (requiredSubmorphs - self submorphCount) do:				[:m |				newSubmorphs add:					(protoTile copy						position: self position + (self protoTile extent * (c @ r));						actionSelector: #tileClickedAt:newSelection:;						arguments: (Array with: c @ r);						target: self;						privateOwner: self).				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]]].	submorphs _ newSubmorphs asArray.! !!SameGameBoard methodsFor: 'undo' stamp: 'dgd 2/22/2003 13:36'!capturedState	"Note the state stored in the second element is an array of associations	from submorph index to a shallowCopy of the morph, but only for those	morphs that change.  Therefore the capturedState record *first* delivers	all the morphs, and *then* computes the difference and stores this back.	In the end, both undo and redo records follow this format."	| prior state oldMorphs priorChanges newChanges |	(prior := self valueOfProperty: #priorState) isNil 		ifTrue: 			[state := { 						self shallowCopy.	"selection, etc."						self submorphs collect: [:m | m shallowCopy].	"state of all tiles"						owner scoreDisplay flash.	"score display"						owner scoreDisplay value}.			self setProperty: #priorState toValue: state.			^state].	oldMorphs := prior second.	priorChanges := OrderedCollection new.	newChanges := OrderedCollection new.	1 to: oldMorphs size		do: 			[:i | 			(oldMorphs at: i) color = (submorphs at: i) color 				ifFalse: 					[priorChanges addLast: i -> (oldMorphs at: i).					newChanges addLast: i -> (submorphs at: i) shallowCopy]].	self removeProperty: #priorState.	prior at: 2 put: priorChanges asArray.	"Store back into undo state.2"	^{ 		self shallowCopy.	"selection, etc."		newChanges asArray.	"state of tiles that changed"		owner scoreDisplay flash.	"score display"		owner scoreDisplay value}! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 12:01'!collapseColumn: col fromRow: row	| targetTile sourceTile |	(targetTile _ self tileAt: col@row) disabled ifTrue:		[row - 1 to: 0 by: -1 do:			[:r |			(sourceTile _ self tileAt: col@r) disabled ifFalse:				[targetTile color: sourceTile color.				targetTile disabled: false.				sourceTile disabled: true.				^ true]]].	^ false! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 18:47'!collapseColumns: columnsToCollapse	| columnsToRemove |	columnsToRemove _ OrderedCollection new.	columnsToCollapse do:		[:c |		rows - 1 to: 0 by: -1 do: [:r | self collapseColumn: c fromRow: r].		(self tileAt: c@(rows-1)) disabled ifTrue: [columnsToRemove add: c]].	self world displayWorld.	columnsToRemove reverseDo: [:c | self removeColumn: c].! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:45'!columns	^ columns! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!columns: newColumns	self extent: self protoTile extent * (newColumns @ rows)! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!columns: newColumns rows: newRows	self extent: self protoTile extent * (newColumns @ newRows)! !!SameGameBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:39'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!SameGameBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:30'!defaultColor	"answer the default color/fill style for the receiver"	^ Color gray! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 11:38'!deselectSelection	selection ifNotNil:		[selection do: [:loc | (self tileAt: loc) setSwitchState: false; color: selectionColor].		selection _ nil.		flash _ false]! !!SameGameBoard methodsFor: 'geometry' stamp: 'ar 11/20/2000 19:28'!extent: aPoint	"constrain the extent to be a multiple of the protoTile size during resizing"	super extent: (aPoint truncateTo: protoTile extent).	self adjustTiles.! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 18:52'!findSelection	"find a possible selection and return it, or nil if no selection"	| tile k testTile |	0 to: rows-1 do:		[:r |		0 to: columns-1 do:			[:c |			tile _ self tileAt: c@r.			tile disabled  ifFalse:				[k _ tile color.				c+1 < columns ifTrue:					[testTile _ self tileAt: (c+1)@r.					(testTile disabled not and: [testTile color = k]) ifTrue: [^ tile]].				r+1 < rows ifTrue:					[testTile _ self tileAt: c@(r+1).					(testTile disabled not and: [testTile color = k]) ifTrue: [^ tile]]]]].	 ^ nil			! !!SameGameBoard methodsFor: 'actions' stamp: 'ar 10/25/2000 23:13'!hint	"find a possible selection and select it"	| tile |	self deselectSelection.	tile _ self findSelection.	tile ifNotNil: [tile mouseDown: MouseButtonEvent new]! !!SameGameBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:12'!initialize	"initialize the state of the receiver"	super initialize.	target _ nil.	actionSelector _ #selection.	arguments _ #().	self layoutPolicy: nil.	self hResizing: #rigid.	self vResizing: #rigid.	rows _ self preferredRows.	columns _ self preferredColumns.	palette _ (Color wheel: self preferredTileTypes + 1) asOrderedCollection.	flashColor _ palette removeLast.	flash _ false.	self extent: self protoTile extent * (columns @ rows).	self resetBoard! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:24'!preferredColumns	^ 20! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:24'!preferredRows	^ 10! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:34'!preferredTileTypes	^ 5! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:47'!protoTile	protoTile ifNil: [protoTile _ SameGameTile new].	^ protoTile! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:48'!protoTile: aTile	protoTile _ aTile! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 15:54'!removeColumn: column	| sourceTile |	column+1 to: columns-1 do:		[:c |		0 to: rows-1 do:			[:r |			sourceTile _ self tileAt: c@r.			(self tileAt: c-1@r)				color: sourceTile color;				disabled: sourceTile disabled]].	0 to: rows-1 do:		[:r | (self tileAt: columns-1@r) disabled: true]! !!SameGameBoard methodsFor: 'actions' stamp: 'asm 11/25/2003 22:41'!removeSelection	selection		ifNil: [^ self].	self		rememberUndoableAction: [selection				do: [:loc | (self tileAt: loc) disabled: true;						 setSwitchState: false].			self collapseColumns: (selection					collect: [:loc | loc x]) asSet asSortedCollection.			selection := nil.			flash := false.			(target notNil					and: [actionSelector notNil])				ifTrue: [target perform: actionSelector withArguments: arguments]]		named: 'remove selection' translated! !!SameGameBoard methodsFor: 'initialization' stamp: 'di 12/12/2000 15:03'!resetBoard	Collection initialize.  "randomize"	selection _ nil.	self purgeAllCommands.	self submorphsDo:		[:m |		m disabled: false.		m setSwitchState: false.		m color: palette atRandom].! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:45'!rows	^ rows! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!rows: newRows	self extent: self protoTile extent * (columns @ newRows)! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 11:37'!selectTilesAdjacentTo: location	| al at |	{-1@0. 0@-1. 1@0. 0@1} do:		[:offsetPoint |		al _ location + offsetPoint.		((al x between: 0 and: columns - 1) and: [al y between: 0 and: rows - 1]) ifTrue:			[at _ self tileAt: al.			(at color = selectionColor and: [at switchState not and: [at disabled not]]) ifTrue:				[selection add: al.				at setSwitchState: true.				self selectTilesAdjacentTo: al]]]! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:56'!selectionCount	^ selection isNil		ifTrue: [0]		ifFalse: [selection size]! !!SameGameBoard methodsFor: 'stepping and presenter' stamp: 'tao 5/17/1998 11:38'!step	| newColor |	selection ifNotNil:		[newColor _ flash			ifTrue: [selectionColor]			ifFalse: [flashColor].		selection do: [:loc | (self tileAt: loc) color: newColor].		flash _ flash not]! !!SameGameBoard methodsFor: 'testing' stamp: 'tao 5/18/1998 11:16'!stepTime	^ 500! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!target	^ target! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!target: anObject	target _ anObject! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 10:31'!tileAt: aPoint	^ submorphs at: (aPoint x + (aPoint y * columns) + 1)! !!SameGameBoard methodsFor: 'actions' stamp: 'dgd 2/22/2003 18:51'!tileClickedAt: location newSelection: isNewSelection 	| tile |	isNewSelection 		ifTrue: 			[self deselectSelection.			tile := self tileAt: location.			selectionColor := tile color.			selection := OrderedCollection with: location.			self selectTilesAdjacentTo: location.			selection size = 1 				ifTrue: [self deselectSelection]				ifFalse: 					[(target notNil and: [actionSelector notNil]) 						ifTrue: [target perform: actionSelector withArguments: arguments]]]		ifFalse: [self removeSelection]! !!SameGameBoard methodsFor: 'private' stamp: 'di 7/1/1998 00:04'!tilesRemaining	^ (submorphs reject: [:m | m disabled]) size! !!SameGameBoard methodsFor: 'undo' stamp: 'di 12/12/2000 16:44'!undoFromCapturedState: st 	self copyFrom: st first.	st second do: [:assn | (submorphs at: assn key) copyFrom: assn value].	selection ifNotNil:		[selection do: [:loc | (self tileAt: loc) setSwitchState: false; color: selectionColor].		selection _ nil].	owner scoreDisplay flash: st third.  "score display"	owner scoreDisplay value: st fourth.	self changed.! !!Tetris class methodsFor: 'as yet unclassified' stamp: 'RAA 1/7/2000 23:19'!colors	^{		Color r: 0.5 g: 0 b: 0.		Color r: 0 g: 0.5 b: 0.		Color r: 0 g: 0 b: 0.5.		Color r: 0.5 g: 0.5 b: 0.		Color r: 0.5 g: 0 b: 0.5.		Color r: 0 g: 0.5 b: 0.5	}! !!Tetris class methodsFor: 'parts bin' stamp: 'sw 8/2/2001 12:53'!descriptionForPartsBin	^ self partName:	'Tetris'		categories:		#('Games')		documentation:	'Tetris, yes Tetris'! !!Tetris methodsFor: 'initialization' stamp: 'RAA 1/8/2000 14:38'!buildButtonTarget: aTarget label: aLabel selector: aSelector help: aString	^self rowForButtons		addMorph: (			SimpleButtonMorph new 				target: aTarget;				label: aLabel;				actionSelector: aSelector;				borderColor: #raised;				borderWidth: 2;				color: color		)! !!Tetris methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!Tetris methodsFor: 'event handling' stamp: 'ar 9/15/2000 22:58'!handlesKeyboard: evt	^true! !!Tetris methodsFor: 'event handling' stamp: 'am 8/28/1999 14:22'!handlesMouseOver: evt	^ true! !!Tetris methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:26'!initialize	"initialize the state of the receiver"	super initialize.	""	board _ TetrisBoard new game: self.	self listDirection: #topToBottom;	  wrapCentering: #center;	  vResizing: #shrinkWrap;	  hResizing: #shrinkWrap;	  layoutInset: 3;	  addMorphBack: self makeGameControls;		 addMorphBack: self makeMovementControls;		 addMorphBack: self showScoreDisplay;		 addMorphBack: board.	board newGame! !!Tetris methodsFor: 'event handling' stamp: 'RAA 1/8/2000 15:42'!keyStroke: evt	| charValue |	charValue _ evt keyCharacter asciiValue.	charValue = 28 ifTrue: [board moveLeft].	charValue = 29 ifTrue: [board moveRight].	charValue = 30 ifTrue: [board rotateClockWise].	charValue = 31 ifTrue: [board rotateAntiClockWise].	charValue = 32 ifTrue: [board dropAllTheWay].! !!Tetris methodsFor: 'initialization' stamp: 'asm 11/25/2003 22:45'!makeGameControls	^ self rowForButtons		addMorph: (self				buildButtonTarget: self				label: 'Quit' translated				selector: #delete				help: 'quit' translated);				addMorph: (self				buildButtonTarget: board				label: 'Pause' translated				selector: #pause				help: 'pause' translated);				addMorph: (self				buildButtonTarget: board				label: 'New game' translated				selector: #newGame				help: 'new game' translated)! !!Tetris methodsFor: 'initialization' stamp: 'asm 11/25/2003 22:45'!makeMovementControls	^ self rowForButtons		addMorph: (self				buildButtonTarget: board				label: '->'				selector: #moveRight				help: 'move to the right' translated);				addMorph: (self				buildButtonTarget: board				label: ' ) '				selector: #rotateClockWise				help: 'rotate clockwise' translated);				addMorph: (self				buildButtonTarget: board				label: ' | '				selector: #dropAllTheWay				help: 'drop' translated);				addMorph: (self				buildButtonTarget: board				label: ' ( '				selector: #rotateAntiClockWise				help: 'rotate anticlockwise' translated);				addMorph: (self				buildButtonTarget: board				label: '<-'				selector: #moveLeft				help: 'move to the left' translated)! !!Tetris methodsFor: 'event handling' stamp: 'ar 9/15/2000 23:07'!mouseEnter: evt        evt hand newKeyboardFocus: self! !!Tetris methodsFor: 'initialization' stamp: 'ar 11/9/2000 21:24'!rowForButtons	^AlignmentMorph newRow		color: color;		borderWidth: 0;		layoutInset: 3;		vResizing: #shrinkWrap;		wrapCentering: #center! !!Tetris methodsFor: 'events' stamp: 'RAA 1/7/2000 22:37'!score: anInteger	scoreDisplay value: anInteger! !!Tetris methodsFor: 'initialization' stamp: 'asm 11/25/2003 22:45'!showScoreDisplay	^ self rowForButtons hResizing: #shrinkWrap;				addMorph: (self wrapPanel: ((scoreDisplay := LedMorph new) digits: 5;					 extent: 4 * 10 @ 15) label: 'Score:' translated)! !!Tetris methodsFor: 'initialization' stamp: 'RAA 1/8/2000 14:38'!wrapPanel: anLedPanel label: aLabel	"wrap an LED panel in an alignmentMorph with a label to its left"	^self rowForButtons		color: color lighter;		addMorph: anLedPanel;		addMorph: (StringMorph contents: aLabel)! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'RM 9/16/2004 14:34'!initialize	"ChessConstants initialize"	self initializePieceConstants.	self initializeCastlingConstants.	self initializePieceValues.	self initializeMoves.	self initializeCenterScores.	self initializeBishopMovers.	self initializeRookMovers.	self initializeSquareConstants.! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'RM 9/16/2004 19:38'!initializeBishopMovers.	BishopMovers _ Set new.	BishopMovers add:Bishop.	BishopMovers add:Queen.! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:15'!initializeBishopMoves	"ChessPlayer initialize"	| index moveList1 moveList2 moveList3 moveList4 px py |	BishopMoves _ Array new: 64 withAll: #().	0 to: 7 do:[:j|		0 to: 7 do:[:i|			index _ (j * 8) + i + 1.			moveList1 _ moveList2 _ moveList3 _ moveList4 _ #().			1 to: 7 do:[:k|				px _ i + k. py _ j - k.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList1 _ moveList1 copyWith: (py * 8) + px + 1].				px _ i - k. py _ j - k.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList2 _ moveList2 copyWith: (py * 8) + px + 1].				px _ i + k. py _ j + k.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList3 _ moveList3 copyWith: (py * 8) + px + 1].				px _ i - k. py _ j + k.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList4 _ moveList4 copyWith: (py * 8) + px + 1].			].			BishopMoves at: index put: {moveList1. moveList2. moveList3. moveList4}.		].	].! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:09'!initializeCastlingConstants	CastlingDone _ 1.	CastlingDisableKingSide _ 2.	CastlingDisableQueenSide _ 4.	CastlingDisableAll _ CastlingDisableQueenSide bitOr: CastlingDisableKingSide.	CastlingEnableKingSide _ CastlingDone bitOr: CastlingDisableKingSide.	CastlingEnableQueenSide _ CastlingDone bitOr: CastlingDisableQueenSide.! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:16'!initializeCenterScores	"ChessPlayer initialize"	PieceCenterScores _ Array new: 6.	1 to: 6 do:[:i| PieceCenterScores at: i put: (ByteArray new: 64)].	PieceCenterScores at: Knight put:		#(			-4	0	0	0	0	0	0	-4			-4	0	2	2	2	2	0	-4			-4	2	3	2	2	3	2	-4			-4	1	2	5	5	2	2	-4			-4	1	2	5	5	2	2	-4			-4	2	3	2	2	3	2	-4			-4	0	2	2	2	2	0	-4			-4	0	0	0	0	0	0	-4		).	PieceCenterScores at: Bishop put:		#(			-2	-2	-2	-2	-2	-2	-2	-2			-2	0	0	0	0	0	0	-2			-2	0	1	1	1	1	0	-2			-2	0	1	2	2	1	0	-2			-2	0	1	2	2	1	0	-2			-2	0	1	1	1	1	0	-2			-2	0	0	0	0	0	0	-2			-2	-2	-2	-2	-2	-2	-2	-2		).	PieceCenterScores at: Queen put:		#(			-3	0	0	0	0	0	0	-3			-2	0	0	0	0	0	0	-2			-2	0	1	1	1	1	0	-2			-2	0	1	2	2	1	0	-2			-2	0	1	2	2	1	0	-2			-2	0	1	1	1	1	0	-2			-2	0	0	0	0	0	0	-2			-3	0	0	0	0	0	0	-3		).! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:15'!initializeKingMoves	"ChessPlayer initialize"	| index px py moveList |	KingMoves _ Array new: 64 withAll: #().	0 to: 7 do:[:j|		0 to: 7 do:[:i|			index _ (j * 8) + i + 1.			moveList _ #().			#( (-1 -1) (0 -1) (1 -1) (-1 0) (1 0) (-1 1) (0 1) (1 1)) do:[:spec|				px _ i + spec first.				py _ j + spec last.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList _ moveList copyWith: (py * 8) + px + 1]].			KingMoves at: index put: moveList		].	].! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:14'!initializeKnightMoves	"ChessPlayer initialize"	| index px py moveList |	KnightMoves _ Array new: 64 withAll: #().	0 to: 7 do:[:j|		0 to: 7 do:[:i|			index _ (j * 8) + i + 1.			moveList _ #().			#( (-2 -1) (-1 -2) (1 -2) (2 -1) (-2 1) (-1 2) (1 2) (2 1)) do:[:spec|				px _ i + spec first.				py _ j + spec last.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList _ moveList copyWith: (py * 8) + px + 1]].			KnightMoves at: index put: moveList		].	].! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:11'!initializeMoves	"ChessPlayer initialize"	self initializeKnightMoves.	self initializeRookMoves.	self initializeBishopMoves.	self initializeKingMoves.! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:09'!initializePieceConstants	EmptySquare := 0.	Pawn := 1.	Knight := 2.	Bishop := 3.	Rook := 4.	Queen := 5.	King := 6.! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:14'!initializePieceValues	PieceValues _ Array new: 6.	PieceValues at: Pawn put: 100.	PieceValues at: Knight put: 300.	PieceValues at: Bishop put: 350.	PieceValues at: Rook put: 500.	PieceValues at: Queen put: 900.	PieceValues at: King put: 2000.! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'RM 9/16/2004 19:38'!initializeRookMovers.	RookMovers _ Set new.	RookMovers add:Rook.	RookMovers add:Queen.! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:14'!initializeRookMoves	"ChessPlayer initialize"	| index moveList1 moveList2 moveList3 moveList4 px py |	RookMoves _ Array new: 64 withAll: #().	0 to: 7 do:[:j|		0 to: 7 do:[:i|			index _ (j * 8) + i + 1.			moveList1 _ moveList2 _ moveList3 _ moveList4 _ #().			1 to: 7 do:[:k|				px _ i + k. py _ j.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList1 _ moveList1 copyWith: (py * 8) + px + 1].				px _ i. py _ j + k.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList2 _ moveList2 copyWith: (py * 8) + px + 1].				px _ i - k. py _ j.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList3 _ moveList3 copyWith: (py * 8) + px + 1].				px _ i. py _ j - k.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList4 _ moveList4 copyWith: (py * 8) + px + 1].			].			RookMoves at: index put: {moveList1. moveList2. moveList3. moveList4}.		].	].! !!ChessConstants class methodsFor: 'pool initialization' stamp: 'RM 9/16/2004 14:34'!initializeSquareConstants	A1_1. B1_2. C1_3. D1_4. E1_5. F1_6. G1_7. H1_8.	A2_9. B2_10. C2_11. D2_12. E2_13. F2_14. G2_15. H2_16.	A3_17. B3_18. C3_19. D3_20. E3_21. F3_22. G3_23. H3_24.	A4_25. B4_26. C4_27. D4_28. E4_29. F4_30. G4_31. H4_32.	A5_33. B5_34. C5_35. D5_36. E5_37. F5_38. G5_39. H5_40.	A6_41. B6_42. C6_43. D6_44. E6_45. F6_46. G6_47. H6_48.	A7_49. B7_50. C7_51. D7_52. E7_53. F7_54. G7_55. H7_56.	A8_57. B8_58. C8_59. D8_60. E8_61. F8_62. G8_63. H8_64.! !!AtomicMap class methodsFor: 'enumerating' stamp: 'grp 12/29/2001 11:46'!E	^ 1 @ 0.! !!AtomicMap class methodsFor: 'enumerating' stamp: 'grp 12/29/2001 11:46'!N	^ 0 @ -1.! !!AtomicMap class methodsFor: 'enumerating' stamp: 'grp 12/29/2001 11:46'!NE	^  1 @ -1.! !!AtomicMap class methodsFor: 'enumerating' stamp: 'grp 12/29/2001 11:47'!NW	^  -1 @ -1! !!AtomicMap class methodsFor: 'enumerating' stamp: 'grp 12/29/2001 11:47'!S	^ 0 @ 1.	! !!AtomicMap class methodsFor: 'enumerating' stamp: 'grp 12/29/2001 11:47'!SE	^  1 @ 1.! !!AtomicMap class methodsFor: 'enumerating' stamp: 'grp 12/29/2001 11:47'!SW	^  -1 @ 1.! !!AtomicMap class methodsFor: 'enumerating' stamp: 'grp 12/29/2001 11:47'!W	^-1 @ 0.! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 8/1/2002 21:31'!atomPosition: indexes 	^ self atomSize  * indexes + self borderSpace! !!AtomicMap methodsFor: 'access properties' stamp: 'GP 4/14/2003 22:45'!atomSize	^ mapStyle		isSmallScreen ifTrue: [14 @ 14]		ifFalse: [28 @ 28]! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 7/29/2002 23:49'!borderSpace	^ 10 @ 5! !!AtomicMap methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:09'!buildLayout: aOwnerPanel 	| style beginning item object newPos newBound |	style _ AtomicMapStyle new.	beginning _ aOwnerPanel bounds bottomLeft.	1		to: layout rowCount		do: [:r | 1				to: layout columnCount				do: [:c | 					item _ layout at: r at: c.					object _ self createComponents: item .					object						ifNotNil: [object mapStyle: style.							newPos _ self atomPosition: r @ c - 1.							newBound _ newPos corner: newPos + self atomSize.							newBound _ newBound translateBy: beginning.							object bounds: newBound.							aOwnerPanel addMorphBack: object]]]! !!AtomicMap methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:09'!buildLayoutForPreview: aOwnerPanel 	| style beginning item object newPos newBound |	style _ AtomicMapStyle newForPreview.	beginning _ aOwnerPanel bounds topRight.	1		to: layout rowCount		do: [:r | 1				to: layout  columnCount				do: [:c | 					item _ layout at: r at: c.					object _ self createComponentsForPreview: item ..					object						ifNotNil: ["Specially for preview"							object mapStyle: style.							previewExtent _ previewExtent max: object previewPosition.							newPos _ self atomPosition: object previewPosition - 1.							newBound _ newPos corner: newPos + self atomSize.							newBound _ newBound translateBy: beginning.							object bounds: newBound.							aOwnerPanel addMorph: object]]]! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 8/21/2002 21:25'!createAtoms: aDescriptor 	"Returns the atom with the predefined setting"	| atomKind requiredClass items previewX previewY |	atomKind _ aDescriptor at: 1.	"get the class"	requiredClass _ self getClassOf: atomKind.	requiredClass		ifNotNil: ["preview position"			previewX _ aDescriptor at: 2.			previewY _ aDescriptor at: 3.			"removes used settings"			items _ ((aDescriptor copyWithout: atomKind)						copyWithout: previewX)						copyWithout: previewY.			"builds the atom"			^ ((requiredClass new				links: (self extractLinks: items))				forcedLinks: (self extractForcedLinks: items))				previewPosition: previewX @ previewY].	"Shows an error"	self log: 'Unknown Atom kind: ' , atomKind asString.	^ nil! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 8/21/2002 21:26'!createComponents: aDescriptor	"Spaces"	aDescriptor = 0		ifTrue: [^ nil].	"Bricks"	aDescriptor = 1		ifTrue: [^ AtomicBrick new].	"Atom"	(aDescriptor isKindOf: Array)		ifTrue: [^ self createAtoms: aDescriptor].	"Nothing"	^ nil! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 8/21/2002 21:26'!createComponentsForPreview: aDescriptor 	"Atom"	(aDescriptor isKindOf: Array)		ifTrue: [^ self createAtoms: aDescriptor].	"Nothing"	^ nil! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 9/20/2001 23:47'!createLayout"Returns and Array2D with the kind of molecules to be created"	self subclassResponsibility! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 6/2/2002 17:43'!extractForcedLinks: aSymbolList 	| result requiredClass |	result _ Bag new.	aSymbolList		do: [:item | 						requiredClass _ self getClassOf: item.			requiredClass				ifNotNil: [result add: requiredClass]].	^ result! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 8/5/2002 11:34'!extractLinks: aSymbolList 	| result link |	result _ Bag new.	aSymbolList		do: [:item | 			link _ nil.			"Create a link depending the kind"			item = #n				ifTrue: [link _ AtomicMap N].			item = #ne				ifTrue: [link _ AtomicMap NE].			item = #e				ifTrue: [link _ AtomicMap E].			item = #se				ifTrue: [link _ AtomicMap SE].			item = #s				ifTrue: [link _ AtomicMap S].			item = #sw				ifTrue: [link _ AtomicMap SW].			item = #w				ifTrue: [link _ AtomicMap W].			item = #nw				ifTrue: [link _ AtomicMap NW].			link								ifNotNil: [result add: link]].	^ result! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 5/1/2002 13:06'!getClassOf: aItem	"Which class is related to it"	aItem = #H		ifTrue: [^ AtomicHydrogen ].	aItem = #C		ifTrue: [^ AtomicCarbon ].	aItem = #O		ifTrue: [^ AtomicOxygen ].	aItem = #F		ifTrue: [^ AtomicFluor ].	aItem = #N		ifTrue: [^ AtomicNitrogen ].	aItem = #-		ifTrue: [^ AtomicLink ].^ nil.! !!AtomicMap methodsFor: 'initialization' stamp: 'grp 8/21/2002 21:16'!initialize	layout _ self createLayout.mapStyle _ AtomicMapStyle new.	previewExtent _ 0 @ 0! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 12/30/2001 17:06'!levelName	"Return the name of this level"	self subclassResponsibility! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 8/21/2002 23:14'!mapStyle^mapStyle! !!AtomicMap methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:32'!neededSize	^ self atomSize * (layout rowCount@layout columnCount) + (self borderSpace * 2)! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 8/1/2002 21:32'!previewNeededSize	^ self atomSize * previewExtent  + (self borderSpace * 2)! !!AtomicMap methodsFor: 'access properties' stamp: 'grp 8/1/2002 21:14'!record^	self subclassResponsibility! !!AtomicMap01 methodsFor: 'access properties' stamp: 'asm 4/20/2004 20:17'!createLayout	layout _ Matrix  rows: 9 columns:11.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 1 0 0 0 0 0 0 1 ).	layout atRow: 3 put: #(1 0 #(#H 3 1 #w) 1 0 0 0 0 0 0 1 ).	layout atRow: 4 put: #(1 0 1 1 0 0 0 0 0 0 1 ).	layout atRow: 5 put: #(1 0 1 0 0 1 0 1 1 1 1 ).	layout atRow: 6 put: #(1 0 0 0 0 1 0 #(#O 2 1 #w #e #H) 0 0 1 ).	layout atRow: 7 put: #(1 1 1 0 1 0 0 0 0 0 1 ).	layout atRow: 8 put: #(1 #(#H 1 1 #e) 0 0 0 0 1 0 0 0 1 ).	layout atRow: 9 put: #(1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap01 methodsFor: 'access properties' stamp: 'asm 4/20/2004 20:43'!levelName	^ 'Water' translated! !!AtomicMap01 methodsFor: 'access properties' stamp: 'grp 7/30/2002 16:54'!record	^ 15! !!AtomicMap02 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:37'!createLayout	layout _ Matrix  rows: 11 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 0 1 0 0 1 0 0 0 0 1 ).	layout atRow: 3 put: #(1 0 1 0 0 1 #(#H 3 2 #w) 1 0 0 0 0 1 ).	layout atRow: 4 put: #(1 0 0 1 0 0 0 1 #(#C 2 2 #n #e #s #w) 0 1 0 1 ).	layout atRow: 5 put: #(1 0 0 0 0 0 0 1 1 1 1 0 1 ).	layout atRow: 6 put: #(1 0 0 0 0 0 0 0 1 #(#H 1 2 #e) 1 0 1 ).	layout atRow: 7 put: #(1 0 #(#H 2 1 #s) 0 0 1 0 0 1 0 0 0 1 ).	layout atRow: 8 put: #(1 0 1 1 1 1 1 0 0 0 0 1 1 ).	layout atRow: 9 put: #(1 0 #(#H 2 3 #n C) 0 1 0 1 1 0 0 0 1 0 ).	layout atRow: 10 put: #(1 1 1 1 1 0 0 1 0 0 0 1 0 ).	layout atRow: 11 put: #(0 0 0 0 0 0 0 1 1 1 1 1 0 ).	^ layout! !!AtomicMap02 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:37'!levelName	^ 'Methane' translated! !!AtomicMap02 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:02'!record	^ 32! !!AtomicMap03 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:37'!createLayout	layout _ Matrix  rows: 12 columns:13.		layout atRow: 1 put: #(0 0 0 0 0 0 0 0 0 1 1 1 1 ).	layout atRow: 2 put: #(1 1 1 1 0 0 0 0 0 1 0 0 1 ).	layout atRow: 3 put: #(1 0 0 1 0 0 0 0 0 1 0 0 1 ).	layout atRow: 4 put: #(1 0 0 1 1 0 0 0 1 1 0 #(#O 3 2 #w #e) 1 ).	layout atRow: 5 put: #(1 0 0 #(#H 2 3 #n) 1 1 1 1 1 0 0 0 1 ).	layout atRow: 6 put: #(1 0 1 0 1 0 #(#C 2 2 #n #e #s #w) 1 0 0 0 0 1 ).	layout atRow: 7 put: #(1 0 0 0 0 0 0 1 0 #(#H 4 2 #w #O) 0 0 1 ).	layout atRow: 8 put: #(1 0 0 1 0 1 0 0 0 1 0 0 1 ).	layout atRow: 9 put: #(1 #(#H 2 1 #s) 0 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 10 put: #(1 0 0 0 1 0 1 0 0 0 1 0 1 ).	layout atRow: 11 put: #(1 1 1 1 1 1 #(#H 1 2 #e) 0 0 0 1 0 1 ).	layout atRow: 12 put: #(0 0 0 0 0 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap03 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:38'!levelName	^ 'Methanol' translated! !!AtomicMap03 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:09'!record	^ 30! !!AtomicMap04 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:38'!createLayout	layout _ Matrix  rows: 11 columns:11.	layout atRow: 1 put: #(1 1 1 0 0 0 0 0 1 1 1 ).	layout atRow: 2 put: #(1 0 1 0 0 0 0 0 1 0 1 ).	layout atRow: 3 put: #(1 #(#H 1 3 #ne) 1 1 1 1 1 1 1 0 1 ).	layout atRow: 4 put: #(1 0 0 0 0 0 0 1 0 0 1 ).	layout atRow: 5 put: #(1 1 0 0 #(#C 3 2 #ne #se #w #w) 0 1 0 0 0 1 ).	layout atRow: 6 put: #(1 0 1 0 0 0 0 #(#H 4 1 #sw) 1 #(#C 2 2 #nw #e #e #sw) 1 ).	layout atRow: 7 put: #(1 0 0 0 1 0 0 0 0 1 1 ).	layout atRow: 8 put: #(1 0 0 1 0 0 0 0 #(#H 4 3 #nw) #(#H 1 1 #se) 1 ).	layout atRow: 9 put: #(1 0 1 1 1 1 1 1 1 0 1 ).	layout atRow: 10 put: #(1 0 1 0 0 0 0 0 1 0 1 ).	layout atRow: 11 put: #(1 1 1 0 0 0 0 0 1 1 1 ).	^ layout! !!AtomicMap04 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:38'!levelName	^ 'Ethylene' translated! !!AtomicMap04 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:13'!record	^ 70! !!AtomicMap05 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:39'!createLayout	layout _ Matrix  rows: 11 columns:12.	layout atRow: 1 put: #(0 1 1 1 1 1 1 1 1 1 0 0 ).	layout atRow: 2 put: #(0 1 #(#H 5 1 #sw) 1 0 1 0 1 0 1 0 0 ).	layout atRow: 3 put: #(0 1 0 1 0 1 0 1 0 1 1 1 ).	layout atRow: 4 put: #(1 1 #(#H 2 3 #n) 0 #(#C 4 2 #ne #se #w #w) 1 #(#H 3 1 #s) 1 0 1 0 1 ).	layout atRow: 5 put: #(1 #(#H 2 1 #s) 0 #(#H 1 2 #e) 0 0 0 1 #(#C 3 2 #n #e #e #w) 1 0 1 ).	layout atRow: 6 put: #(1 0 1 0 0 0 0 0 0 1 0 1 ).	layout atRow: 7 put: #(1 0 1 #(#C 2 2 #n #e #s #w) 1 0 0 0 0 0 0 1 ).	layout atRow: 8 put: #(1 0 1 0 1 0 1 0 0 0 1 1 ).	layout atRow: 9 put: #(1 1 1 0 1 #(#H 5 3 #nw) 1 0 1 0 1 0 ).	layout atRow: 10 put: #(0 0 1 0 1 0 1 0 1 0 1 0 ).	layout atRow: 11 put: #(0 0 1 1 1 1 1 1 1 1 1 0 ).	^ layout! !!AtomicMap05 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:39'!levelName	^ 'Propylene (Propene)' translated! !!AtomicMap05 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:17'!record	^ 68! !!AtomicMap06 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:39'!createLayout	layout _ Matrix  rows: 12 columns:12.	layout atRow: 1 put: #(0 0 0 0 0 1 1 1 1 1 0 0 ).	layout atRow: 2 put: #(0 0 0 0 0 1 #(#H 2 3 #n) #(#C 2 2 #n #s #e #w) 0 1 0 0 ).	layout atRow: 3 put: #(0 1 1 1 1 1 0 1 0 1 0 0 ).	layout atRow: 4 put: #(0 1 0 0 0 0 0 0 #(#H 3 3 #n) 1 0 0 ).	layout atRow: 5 put: #(0 1 1 1 #(#H 2 1 #s) 0 0 0 1 1 0 0 ).	layout atRow: 6 put: #(0 0 0 1 0 1 #(#H 1 2 #e) 1 0 1 1 1 ).	layout atRow: 7 put: #(0 0 0 1 1 #(#H 3 1 #s) 0 0 0 1 0 1 ).	layout atRow: 8 put: #(1 1 1 1 0 #(#C 3 2 #n #s #e #w) 0 0 0 0 0 1 ).	layout atRow: 9 put: #(1 0 #(#O 4 2 #e #w #C #H) 0 0 0 0 1 0 0 0 1 ).	layout atRow: 10 put: #(1 1 1 1 1 0 1 0 0 1 0 1 ).	layout atRow: 11 put: #(0 0 0 1 0 0 0 0 1 0 #(#H 5 2 #w) 1 ).	layout atRow: 12 put: #(0 0 0 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap06 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:39'!levelName	^ 'Ethanol (Ethylic alcohol)' translated! !!AtomicMap06 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:20'!record	^ 50! !!AtomicMap07 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:39'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(0 0 0 1 1 1 0 1 1 1 0 0 0 ).	layout atRow: 2 put: #(0 0 0 1 #(#H 1 2 #e) 1 1 1 0 1 0 0 0 ).	layout atRow: 3 put: #(0 0 0 1 #(#H 2 3 #n) 0 1 0 0 1 0 0 0 ).	layout atRow: 4 put: #(1 1 1 1 0 0 0 0 #(#H 3 1 #s) 1 1 1 1 ).	layout atRow: 5 put: #(1 0 0 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 6 put: #(1 1 0 0 0 0 0 0 0 0 0 1 1 ).	layout atRow: 7 put: #(0 1 1 0 0 0 1 0 0 0 1 1 0 ).	layout atRow: 8 put: #(1 1 0 #(#C 2 2 #n #s #e #w) 0 #(#C 3 2 #n #s #e #w) 0 0 0 0 #(#O 3 3 #n #s #C #H) 1 1 ).	layout atRow: 9 put: #(1 0 #(#H 4 1 #s) 0 0 0 0 #(#C 4 2 #n #s #e #w) 0 0 0 0 1 ).	layout atRow: 10 put: #(1 1 1 1 #(#H 2 1 #s) 0 0 0 #(#H 3 4 #n) 1 1 1 1 ).	layout atRow: 11 put: #(0 0 0 1 #(#H 5 2 #w) 0 1 0 #(#H 4 3 #n) 1 0 0 0 ).	layout atRow: 12 put: #(0 0 0 1 0 1 1 1 0 1 0 0 0 ).	layout atRow: 13 put: #(0 0 0 1 1 1 0 1 1 1 0 0 0 ).	^ layout! !!AtomicMap07 methodsFor: 'access properties' stamp: 'grp 1/5/2002 20:07'!levelName	^ 'Iso-Propanol (Isopropylic alcohol)'.! !!AtomicMap07 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:23'!record	^ 50! !!AtomicMap08 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:40'!createLayout	layout _ Matrix  rows: 11 columns:11.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 3 put: #(1 0 1 1 0 0 0 1 1 0 1 ).	layout atRow: 4 put: #(1 #(#H 2 1 #s) 0 0 0 0 0 #(#C 2 2 #n #s #e #w) 0 0 1 ).	layout atRow: 5 put: #(1 0 1 1 1 0 1 1 1 0 1 ).	layout atRow: 6 put: #(1 #(#H 2 3 #n) 0 0 0 #(#H 1 2 #e) 0 0 0 0 1 ).	layout atRow: 7 put: #(1 #(#C 3 2 #n #e #e #w) 1 1 1 #(#H 3 1 #s) 1 1 1 0 1 ).	layout atRow: 8 put: #(1 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 9 put: #(1 0 1 1 0 0 0 1 1 0 1 ).	layout atRow: 10 put: #(1 0 0 #(#O 4 2 #w #w) 0 0 0 0 0 0 1 ).	layout atRow: 11 put: #(1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap08 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:40'!levelName	^ 'Ethyl-aldehyde (Ethanal)' translated! !!AtomicMap08 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:27'!record	^ 45! !!AtomicMap09 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:40'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(0 0 0 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(0 1 1 1 0 0 1 1 0 0 0 0 1 ).	layout atRow: 3 put: #(1 1 0 0 0 0 0 1 0 1 0 0 1 ).	layout atRow: 4 put: #(1 0 0 0 0 0 #(#O 3 3 #n #n) 1 0 1 1 1 1 ).	layout atRow: 5 put: #(1 0 1 #(#C 2 2 #n #s #e #w) 1 0 #(#H 2 3 #n) 0 #(#C 3 2 #e #w #s #s #O #C) 0 0 #(#H 2 1 #s) 1 ).	layout atRow: 6 put: #(1 0 1 #(#H 4 3 #n) 1 1 1 0 0 #(#H 1 2 #e) 0 0 1 ).	layout atRow: 7 put: #(1 1 1 0 0 #(#H 4 1 #s) 0 0 0 0 1 1 1 ).	layout atRow: 8 put: #(1 0 0 0 0 0 1 1 1 0 1 0 1 ).	layout atRow: 9 put: #(1 0 0 0 0 0 #(#C 4 2 #n #s #e #w) 0 1 0 1 0 1 ).	layout atRow: 10 put: #(1 1 1 1 0 1 0 0 0 0 0 #(#H 5 2 #w) 1 ).	layout atRow: 11 put: #(1 0 0 1 0 1 0 0 0 0 0 1 1 ).	layout atRow: 12 put: #(1 0 0 0 0 1 1 0 0 1 1 1 0 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 0 0 0 ).	^ layout! !!AtomicMap09 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:40'!levelName	^ 'Acetone' translated! !!AtomicMap09 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:30'!record	^ 50! !!AtomicMap10 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:41'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 3 put: #(1 1 1 0 0 1 1 1 0 0 1 1 1 ).	layout atRow: 4 put: #(1 0 0 0 0 0 1 0 0 0 0 0 1 ).	layout atRow: 5 put: #(1 0 1 1 1 0 0 0 1 1 1 0 1 ).	layout atRow: 6 put: #(1 0 1 #(#O 2 1 #s #s) 0 0 1 0 0 0 1 0 1 ).	layout atRow: 7 put: #(1 #(#H 1 2 #e #C) #(#O 3 2 #w #e) #(#C 2 2 #n #n #e #w ) #(#H 4 2 #w) 1 1 1 0 0 0 0 1 ).	layout atRow: 8 put: #(1 0 1 0 0 0 1 0 0 0 1 0 1 ).	layout atRow: 9 put: #(1 0 1 1 1 0 0 0 1 1 1 0 1 ).	layout atRow: 10 put: #(1 0 0 0 0 0 1 0 0 0 0 0 1 ).	layout atRow: 11 put: #(1 1 1 0 0 1 1 1 0 0 1 1 1 ).	layout atRow: 12 put: #(1 0 0 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap10 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:40'!levelName	^ 'Formic Acid' translated! !!AtomicMap10 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:31'!record	^ 25! !!AtomicMap11 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:41'!createLayout	layout _ Matrix  rows: 11 columns:11.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 0 1 0 0 0 1 0 1 ).	layout atRow: 3 put: #(1 0 #(#O 4 2 #e #w) 0 0 0 0 0 0 0 1 ).	layout atRow: 4 put: #(1 0 1 0 0 #(#H 5 2 #w O) 1 0 #(#H 1 2 #e) 0 1 ).	layout atRow: 5 put: #(1 #(#H 2 3 #n) 0 #(#C 2 2 #n #s #e #w) 0 0 0 0 0 0 1 ).	layout atRow: 6 put: #(1 0 0 0 1 0 0 0 1 0 1 ).	layout atRow: 7 put: #(1 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 8 put: #(1 0 1 0 #(#C 3 2 #n #n #e #w) 0 1 0 0 0 1 ).	layout atRow: 9 put: #(1 #(#O 3 1 #s #s) 0 0 0 0 0 #(#H 2 1 #s) 0 0 1 ).	layout atRow: 10 put: #(1 0 0 0 1 0 0 0 1 0 1 ).	layout atRow: 11 put: #(1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap11 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:41'!levelName	^ 'Acetic Acid' translated! !!AtomicMap11 methodsFor: 'access properties' stamp: 'grp 8/1/2002 20:38'!record	^ 49! !!AtomicMap12 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:41'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 3 put: #(1 0 0 0 1 0 0 #(#C 4 3 #ne #se #w #w) 1 0 0 0 1 ).	layout atRow: 4 put: #(1 #(#C 3 3 #e #e #nw #sw) 0 1 0 #(#H 6 1 #sw) 0 0 0 1 0 0 1 ).	layout atRow: 5 put: #(1 0 1 0 1 1 0 1 1 0 1 0 1 ).	layout atRow: 6 put: #(1 0 0 #(#H 1 5 #ne) 0 0 0 0 0 0 0 0 1 ).	layout atRow: 7 put: #(1 1 1 #(#H 3 5 #nw) 1 1 0 1 1 0 1 1 1 ).	layout atRow: 8 put: #(1 0 0 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 9 put: #(1 0 1 0 1 1 #(#H 1 3 #se) 1 1 0 1 0 1 ).	layout atRow: 10 put: #(1 0 0 1 #(#C 2 4 #ne #se #nw #sw) #(#H 2 2 #se) 0 0 0 1 #(#H 4 1 #se) 0 1 ).	layout atRow: 11 put: #(1 0 0 0 1 0 0 #(#H 5 4 #nw) 1 0 0 0 1 ).	layout atRow: 12 put: #(1 #(#C 5 2 #ne #se #nw #sw) 0 0 #(#H 6 3 #nw) 0 0 0 0 0 0 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap12 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:42'!levelName	^ 'Trans-Buthylene (Trans-Buthene)' translated! !!AtomicMap12 methodsFor: 'access properties' stamp: 'grp 8/1/2002 21:13'!record	^ 120! !!AtomicMap13 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:44'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 1 0 0 1 1 0 0 0 1 0 1 ).	layout atRow: 3 put: #(1 1 0 0 1 0 0 0 0 0 1 0 1 ).	layout atRow: 4 put: #(1 1 0 0 0 0 1 0 0 1 0 0 1 ).	layout atRow: 5 put: #(1 0 #(#H 3 4 #nw) 0 0 #(#H 1 2 #se) 1 0 #(#H 1 4 #ne) 0 0 #(#H 5 1 #sw) 1 ).	layout atRow: 6 put: #(1 1 1 0 0 0 0 1 0 1 0 0 1 ).	layout atRow: 7 put: #(1 0 0 1 0 0 0 0 0 0 1 1 1 ).	layout atRow: 8 put: #(1 0 #(#C 3 2 #e #e #nw #sw) 0 0 #(#C 2 3 #ne #se #nw #sw) 0 1 #(#C 4 2 #ne #se #w #w) 0 0 #(#C 5 3 #ne #se #nw #sw) 1 ).	layout atRow: 9 put: #(1 0 1 1 0 1 1 0 0 0 0 0 1 ).	layout atRow: 10 put: #(1 1 0 0 0 0 0 0 1 0 1 0 1 ).	layout atRow: 11 put: #(1 0 #(#H 6 2 #sw) 1 1 #(#H 6 4 #nw) 0 1 #(#H 4 4 #ne) 0 1 #(#H 2 1 #se) 1 ).	layout atRow: 12 put: #(1 0 1 0 0 0 0 1 0 1 0 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap13 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:42'!levelName	^ 'Cis-Buthylene (Cis-Buthene)' translated! !!AtomicMap13 methodsFor: 'access properties' stamp: 'grp 7/30/2002 14:05'!record^166! !!AtomicMap14 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:44'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 0 #(#C 2 2 #n #s #e #w O) 0 1 #(#O 3 2 #e #w) 0 0 0 #(#H 1 2 #e) 1 ).	layout atRow: 3 put: #(1 0 1 1 1 0 1 0 1 1 1 0 1 ).	layout atRow: 4 put: #(1 0 1 0 0 #(#H 2 3 #n) 1 0 0 0 1 0 1 ).	layout atRow: 5 put: #(1 0 1 0 0 0 1 0 0 0 1 0 1 ).	layout atRow: 6 put: #(1 0 0 0 0 0 1 0 0 0 0 0 1 ).	layout atRow: 7 put: #(1 1 1 1 #(#H 2 1 #s) 0 0 0 0 0 1 1 1 ).	layout atRow: 8 put: #(1 0 0 0 0 0 1 0 0 0 0 0 1 ).	layout atRow: 9 put: #(1 0 1 0 0 0 1 0 0 0 1 0 1 ).	layout atRow: 10 put: #(1 0 1 0 0 #(#H 5 2 #w) 1 0 0 #(#H 4 3 #n) 1 0 1 ).	layout atRow: 11 put: #(1 0 1 1 1 0 1 0 1 1 1 #(#H 4 1 #s) 1 ).	layout atRow: 12 put: #(1 0 0 0 0 #(#C 4 2 #n #s #e #w O) 1 0 0 0 0 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap14 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:42'!levelName	^ 'Di-Methyl-Ether' translated! !!AtomicMap14 methodsFor: 'access properties' stamp: 'grp 7/30/2002 17:02'!record	^ 35! !!AtomicMap15 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:44'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 #(#H 2 3 #n) #(#H 2 1 #s) 0 0 0 0 0 #(#C 2 2 #n #s #e #w) 0 1 ).	layout atRow: 3 put: #(1 0 1 0 0 1 1 1 1 0 1 1 1 ).	layout atRow: 4 put: #(1 1 1 #(#H 3 1 #s) 0 0 0 1 0 0 0 0 1 ).	layout atRow: 5 put: #(1 0 #(#H 6 2 #w) 0 0 1 0 0 0 0 0 #(#H 3 3 #n) 1 ).	layout atRow: 6 put: #(1 0 1 1 0 1 0 1 1 0 #(#H 4 3 #n) 0 1 ).	layout atRow: 7 put: #(1 0 1 0 0 1 0 0 1 0 1 1 1 ).	layout atRow: 8 put: #(1 1 1 0 #(#C 3 2 #n #s #e #w) 1 0 #(#O 5 3 #n #s) 0 #(#C 4 2 #n #s #e #w) 1 0 1 ).	layout atRow: 9 put: #(1 #(#H 1 2 #e) 0 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 10 put: #(1 #(#H 5 4 #n) 0 0 0 1 0 0 #(#H 4 1 #s) 0 0 0 1 ).	layout atRow: 11 put: #(1 0 0 1 1 1 #(#H 5 1 #s) 1 1 0 1 0 1 ).	layout atRow: 12 put: #(1 0 0 0 0 1 0 #(#C 5 2 #n #s #e #w) 0 0 1 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap15 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:42'!levelName	^ 'Buthanol (Buthylic alcohol)' translated! !!AtomicMap15 methodsFor: 'access properties' stamp: 'grp 7/30/2002 17:10'!record	^ 115! !!AtomicMap16 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:44'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 0 0 0 1 1 1 1 1 ).	layout atRow: 2 put: #(1 #(#H 5 3 #w) 0 #(#C 3 2 #n #s #ne #nw) 1 0 0 0 1 #(#H 2 4 #n) 0 #(#H 2 1 #se) 1 ).	layout atRow: 3 put: #(1 #(#H 4 1 #sw) 1 0 1 1 1 1 1 0 1 0 1 ).	layout atRow: 4 put: #(1 #(#H 3 5 #n) 0 0 0 0 1 0 0 0 0 0 1 ).	layout atRow: 5 put: #(1 1 1 0 1 0 0 #(#H 2 2 #s) 1 0 1 1 1 ).	layout atRow: 6 put: #(0 0 1 0 0 0 0 0 #(#H 4 4 #n) #(#C 2 3 #n #s #e #w) 1 0 0 ).	layout atRow: 7 put: #(0 0 1 1 0 0 0 0 0 1 1 0 0 ).	layout atRow: 8 put: #(0 0 1 #(#C 3 3 #n #s #e #w) 0 0 0 0 0 #(#H 4 2 #s) 1 0 0 ).	layout atRow: 9 put: #(1 1 1 0 1 0 0 0 1 0 1 1 1 ).	layout atRow: 10 put: #(1 0 0 0 0 0 1 0 #(#H 3 1 #s) 0 0 #(#H 1 3 #e) 1 ).	layout atRow: 11 put: #(1 0 1 #(#O 3 4 #n #s) 1 1 1 1 1 0 1 0 1 ).	layout atRow: 12 put: #(1 #(#C 4 3 #n #s #e #w) 0 0 1 0 0 0 1 0 0 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 0 0 0 1 1 1 1 1 ).	^ layout! !!AtomicMap16 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:42'!levelName	^ 'Tert-Buthanol (Tert-buthylic alcohol)' translated! !!AtomicMap16 methodsFor: 'access properties' stamp: 'grp 7/30/2002 17:17'!record	^ 135! !!AtomicMap17 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:44'!createLayout	layout _ Matrix  rows: 13 columns:11.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 1 0 #(#H 2 5 #n) 1 #(#C 2 2 #n #s #e #w) 0 1 0 1 ).	layout atRow: 3 put: #(1 0 #(#O 3 2 #e #w) 1 0 1 0 1 0 0 1 ).	layout atRow: 4 put: #(1 1 0 0 #(#C 2 3 #n #s #e #w) 0 0 0 0 1 1 ).	layout atRow: 5 put: #(1 0 1 0 0 0 0 0 1 0 1 ).	layout atRow: 6 put: #(1 0 #(#H 4 2 #w #O) 0 0 0 0 #(#H 1 2 #e) 0 0 1 ).	layout atRow: 7 put: #(1 1 1 1 #(#O 3 3 #e #w) 0 0 1 1 1 1 ).	layout atRow: 8 put: #(1 0 0 0 0 #(#H 1 3#e) #(#O 3 4 #e #w) 0 #(#H 1 4#e) 0 1 ).	layout atRow: 9 put: #(1 0 1 0 0 0 0 #(#C 2 4 #n #s #e #w) 1 0 1 ).	layout atRow: 10 put: #(1 1 0 0 0 0 0 #(#H 4 3 #w #O) 0 1 1 ).	layout atRow: 11 put: #(1 0 0 1 0 1 0 1 0 #(#H 2 1 #s) 1 ).	layout atRow: 12 put: #(1 0 1 0 #(#H 4 4 #w #O) 1 0 0 1 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap17 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:42'!levelName	^ 'Glycerin (1, 2, 3 - Propane - triol)' translated! !!AtomicMap17 methodsFor: 'access properties' stamp: 'grp 7/30/2002 19:23'!record	^ 90! !!AtomicMap18 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:44'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 3 put: #(1 0 0 0 0 1 #(#F 1 3 #n) 1 #(#F 1 1 #s) 0 0 0 1 ).	layout atRow: 4 put: #(1 #(#O 1 2 #n #s #e) 0 0 0 1 0 1 0 0 0 0 1 ).	layout atRow: 5 put: #(1 0 1 1 1 1 #(#O 4 2 #n #s #w) 1 1 1 1 0 1 ).	layout atRow: 6 put: #(1 #(#F 2 3 #n) 0 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 7 put: #(1 1 1 1 0 0 1 0 #(#F 3 3 #n) 1 1 1 1 ).	layout atRow: 8 put: #(1 #(#F 2 1 #s) 0 0 0 0 0 0 0 0 0 #(#F 3 1 #s) 1 ).	layout atRow: 9 put: #(1 0 1 1 1 1 0 1 1 1 1 0 1 ).	layout atRow: 10 put: #(1 0 0 #(#F 4 3 #n) 0 1 0 1 0 0 0 0 1 ).	layout atRow: 11 put: #(1 #(#F 4 1 #s) 0 0 0 1 0 1 0 0 0 #(#O 3 2 #n #s #e #w) 1 ).	layout atRow: 12 put: #(1 0 0 #(#O 2 2 #n #s #e #w) 0 0 0 0 0 0 0 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap18 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:42'!levelName	^ 'Poly-Tetra-Fluoro-Ethane' translated! !!AtomicMap18 methodsFor: 'access properties' stamp: 'grp 8/1/2002 16:28'!record	^ 59! !!AtomicMap19 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:44'!createLayout	layout _ Matrix  rows: 13 columns:15.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 1 1 #(#O 2 2 #n #s) 0 0 0 1 0 0 0 0 1 1 1 ).	layout atRow: 3 put: #(1 1 0 0 0 0 0 1 0 0 #(#O 1 1 #e #e) 0 #(#C 3 1 #s #e #e #w) 1 1 ).	layout atRow: 4 put: #(1 0 0 0 1 0 0 0 0 0 1 0 0 0 1 ).	layout atRow: 5 put: #(1 0 0 0 1 1 0 #(#C 2 1 #s #e #w #w) 0 1 1 0 0 0 1 ).	layout atRow: 6 put: #(1 0 0 0 0 1 1 0 1 1 0 0 0 0 1 ).	layout atRow: 7 put: #(1 1 1 #(#O 4 1 #w #w) 0 0 0 #(#O 3 2 #n #s) 0 0 0 0 1 1 1 ).	layout atRow: 8 put: #(1 0 0 0 0 1 1 0 1 1 0 0 0 0 1 ).	layout atRow: 9 put: #(1 0 0 0 1 1 0 #(#H 2 3 #n) 0 1 1 0 0 0 1 ).	layout atRow: 10 put: #(1 0 #(#H 3 3 #n) 0 1 0 0 0 0 0 1 0 0 0 1 ).	layout atRow: 11 put: #(1 1 0 0 0 0 0 1 0 0 0 0 0 1 1 ).	layout atRow: 12 put: #(1 1 1 0 0 0 0 1 0 0 0 0 1 1 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap19 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:42'!levelName	^ 'Malic Acid' translated! !!AtomicMap19 methodsFor: 'access properties' stamp: 'grp 8/1/2002 17:42'!record	^ 48! !!AtomicMap20 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:45'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 #(#O 2 2 #w #w) 0 0 0 0 1 0 0 0 0 #(#C 1 2 #n #s #e #e) 1 ).	layout atRow: 3 put: #(1 0 0 1 1 0 1 0 1 1 0 0 1 ).	layout atRow: 4 put: #(1 1 0 1 0 0 0 0 0 1 0 1 1 ).	layout atRow: 5 put: #(1 0 0 1 0 0 0 0 0 1 0 0 1 ).	layout atRow: 6 put: #(1 0 1 1 0 0 1 0 0 1 1 0 1 ).	layout atRow: 7 put: #(1 0 0 0 0 1 1 1 0 0 0 0 1 ).	layout atRow: 8 put: #(1 0 1 1 0 0 1 0 0 1 1 0 1 ).	layout atRow: 9 put: #(1 0 0 1 0 0 0 0 0 1 0 0 1 ).	layout atRow: 10 put: #(1 1 0 1 0 0 0 0 0 1 0 1 1 ).	layout atRow: 11 put: #(1 0 0 1 1 0 1 0 1 1 0 0 1 ).	layout atRow: 12 put: #(1 #(#H 1 3 #n) 0 0 0 0 1 0 0 0 0 #(#H 1 1  #s) 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap20 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Formaldehyde' translated! !!AtomicMap20 methodsFor: 'access properties' stamp: 'grp 8/1/2002 17:43'!record	^ 25! !!AtomicMap21 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:45'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 1 1 0 1 0 1 1 0 0 1 ).	layout atRow: 3 put: #(1 0 0 0 1 0 #(#H 2 3 #n) 0 1 0 0 0 1 ).	layout atRow: 4 put: #(1 0 0 0 0 #(#C 2 2 #n #s #e #w) 0 0 0 #(#C 5 2 #n #s #e #w) 0 #(#C 6 2 #n #s #e #w) 1 ).	layout atRow: 5 put: #(1 1 0 0 1 0 0 0 1 0 0 1 1 ).	layout atRow: 6 put: #(1 #(#O 4 2 #e #w) 0 1 1 #(#C 3 2 #n #n #e #w #C #O) 0 0 1 1 0 0 1 ).	layout atRow: 7 put: #(1 #(#H 7 2 #w) 0 0 0 0 1 0 0 0 0 0 1 ).	layout atRow: 8 put: #(1 0 0 1 1 0 0 0 1 1 0 0 1 ).	layout atRow: 9 put: #(1 1 0 0 1 #(#H 2 1 #s) #(#H 5 1 #s) 0 1 #(#H 5 3 #n) 0 1 1 ).	layout atRow: 10 put: #(1 0 0 0 #(#H 6 1 #s) 0 0 0 0 0 0 0 1 ).	layout atRow: 11 put: #(1 0 0 #(#O 3 1 #s #s) 1 0 0 #(#H 1 2 #e) 1 0 0 0 1 ).	layout atRow: 12 put: #(1 0 #(#H 6 3 #n) 1 1 0 1 0 1 1 0 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap21 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Ethylic Acetate' translated! !!AtomicMap21 methodsFor: 'access properties' stamp: 'grp 8/1/2002 21:23'!record	^ 115! !!AtomicMap22 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:45'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 1 0 0 #(#H 3 1 #sw) 1 0 0 1 0 0 1 1 ).	layout atRow: 3 put: #(1 0 0 0 1 0 0 1 0 0 0 0 1 ).	layout atRow: 4 put: #(1 0 0 0 0 0 0 0 0 1 0 0 1 ).	layout atRow: 5 put: #(1 #(#H 1 2 #e) 1 0 1 0 0 0 1 0 0 1 1 ).	layout atRow: 6 put: #(1 1 0 0 0 1 0 0 0 0 1 0 1 ).	layout atRow: 7 put: #(1 0 0 0 0 #(#N 2 2 #ne #se #w) 0 0 0 0 0 0 1 ).	layout atRow: 8 put: #(1 0 1 0 0 0 0 1 0 0 #(#H #3 3 nw) 1 1 ).	layout atRow: 9 put: #(1 1 0 0 1 0 0 0 1 0 1 0 1 ).	layout atRow: 10 put: #(1 0 0 1 0 0 0 0 0 0 0 0 1 ).	layout atRow: 11 put: #(1 0 0 0 0 1 0 0 1 0 0 0 1 ).	layout atRow: 12 put: #(1 1 0 0 1 0 0 1 0 0 0 1 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap22 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Ammonia' translated! !!AtomicMap22 methodsFor: 'access properties' stamp: 'grp 8/1/2002 18:04'!record	^ 27! !!AtomicMap23 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:45'!createLayout	layout _ Matrix  rows: 13 columns:15.	layout atRow: 1 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 #(#H 4 1 #s) 0 #(#H 3 1 #se) 0 0 1 0 0 #(#C 2 3 #n #s #e #w) 0 0 #(#H 2 4 #n) 1 ).	layout atRow: 3 put: #(1 #(#H 2 2 #s) 0 1 0 0 0 1 0 0 0 1 0 0 1 ).	layout atRow: 4 put: #(1 0 1 1 1 0 #(#H 1 3 #e) #(#H 3 2 #s) 0 0 1 1 1 0 1 ).	layout atRow: 5 put: #(1 0 #(#C 3 3 #n #s #e #w) 1 0 0 0 0 #(#H 3 4 #n) 0 0 1 0 0 1 ).	layout atRow: 6 put: #(1 0 0 0 0 0 0 0 #(#C 4 3 #n #s #e #w) 0 0 0 0 0 1 ).	layout atRow: 7 put: #(1 1 1 0 #(#H 5 2 #s) 0 0 #(#H 4 4 #n) 0 0 0 0 1 1 1 ).	layout atRow: 8 put: #(1 0 0 0 0 #(#C 5 3 #n #s #e #w) 0 0 0 0 0 0 0 #(#H 5 1 #sw) 1 ).	layout atRow: 9 put: #(1 #(#H 7 3 #w) 0 1 0 0 0 0 0 0 0 1 0 #(#C 4 2 #n #ne #s #nw) 1 ).	layout atRow: 10 put: #(1 0 1 1 1 0 0 0 0 #(#H 6 2 #s) 1 1 1 0 1 ).	layout atRow: 11 put: #(1 0 0 1 #(#H 5 4 #n) 0 0 1 #(#H 6 4 #n) 0 0 1 0 0 1 ).	layout atRow: 12 put: #(1 0 0 0 0 0 #(#C 6 3 #n #s #e #w) 1 0 0 0 0 0 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap23 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ '3-Methyl-Pentane' translated! !!AtomicMap23 methodsFor: 'access properties' stamp: 'grp 8/1/2002 18:10'!record	^ 90! !!AtomicMap24 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:46'!createLayout	layout _ Matrix  rows: 13 columns:11.	layout atRow: 1 put: #( 1 1 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #( 1 0 #(#H 2 1 #s) 1 0 #(#C 4 2 #e #s #s #w #H #O #C) 0 0 0 0 1 ).	layout atRow: 3 put: #( 1 0 1 1 #(#H 2 3 #n) 0 0 1 1 0 1 ).	layout atRow: 4 put: #( 1 0 0 0 0 0 #(#C 2 2 #n #s #e #w) 0 1 1 1 ).	layout atRow: 5 put: #( 1 0 0 1 1 1 0 0 0 0 1 ).	layout atRow: 6 put: #( 1 0 0 1 0 0 0 0 1 1 1 ).	layout atRow: 7 put: #(1 0 0 0 0 1 0 0 0 0 1 ).	layout atRow: 8 put: #(1 1 1 1 0 0 1 0 0 0 1 ).	layout atRow: 9 put: #(1 #(#H 5 2 #w) #(#H 3 1 #s) 0 0 0 0 0 1 0 1 ).	layout atRow: 10 put: #(1 0 0 1 0 #(#C 3 2 #n #s #e #w) #(#H 1 2 #e) 0 1 0 1 ).	layout atRow: 11 put: #(1 #(#O 4 3 #n #n) 1 1 0 0 1 0 1 #(#H 3 3 #n) 1 ).	layout atRow: 12 put: #(1 0 0 0 0 0 1 0 0 0 1 ).	layout atRow: 13 put: #(1  1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap24 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Propyl-Aldehide (Propanal)' translated! !!AtomicMap24 methodsFor: 'access properties' stamp: 'grp 8/1/2002 18:49'!record	^ 55! !!AtomicMap25 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:46'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(1 1 1 1 1 0 0 0 1 1 1 1 1 ).	layout atRow: 2 put: #(1 0 0 0 1 1 1 1 1 0 0 0 1 ).	layout atRow: 3 put: #(1 0 1 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 4 put: #(1 0 1 0 #(#C 2 2 #e #e #e #w) 1 0 0 0 1 0 0 1 ).	layout atRow: 5 put: #(1 1 1 1 0 1 1 1 #(#H 4 3 #n) 1 0 0 1 ).	layout atRow: 6 put: #(1 0 0 0 0 0 0 1 0 1 1 0 1 ).	layout atRow: 7 put: #(1 #(#H 4 1 #s) 1 0 0 0 0 0 0 0 1 0 1 ).	layout atRow: 8 put: #(1 1 1 1 0 1 1 1 1 0 0 0 1 ).	layout atRow: 9 put: #(1 0 1 0 0 0 0 1 0 0 0 0 1 ).	layout atRow: 10 put: #(1 0 0 0 1 0 0 0 0 0 1 0 1 ).	layout atRow: 11 put: #(1 0 0 1 1 1 0 #(#H 1 2 #e) 0 1 1 #(#C 4 2 #n #s #e #w) 1 ).	layout atRow: 12 put: #(1 0 #(#H 5 2 #w) 1 0 0 0 0 1 1 #(#C 3 2 #w #w #w #e) 0 1 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap25 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Propyne (Methyl-acetylene)' translated! !!AtomicMap25 methodsFor: 'access properties' stamp: 'grp 8/1/2002 18:55'!record	^ 65! !!AtomicMap26 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:46'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(0 0 1 1 1 1 1 1 1 1 0 0 0 ).	layout atRow: 2 put: #(0 0 1 0 0 1 0 0 0 1 0 0 0 ).	layout atRow: 3 put: #(1 1 1 0 0 #(#- 3 2 #e #w) 0 0 0 1 1 1 1 ).	layout atRow: 4 put: #(1 0 0 #(#H 5 1 #sw) 1 1 1 0 0 #(#C 5 4 #e #e #s #nw) 0 0 1 ).	layout atRow: 5 put: #(1 0 0 #(#H 5 5 #n) 0 0 0 #(#C 2 2  #e #s #s #nw) 1 0 0 0 1 ).	layout atRow: 6 put: #(1 1 1 1 0 1 0 0 1 #(#O 3 4 #ne #nw) 0 0 1 ).	layout atRow: 7 put: #(1 #(#O 6 4 #w #w) 0 0 0 1 0 1 1 1 0 0 1 ).	layout atRow: 8 put: #(1 0 0 0 0 0 0 0 0 0 0 #(#C 2 3 #n #n #se #sw #O) 1 ).	layout atRow: 9 put: #(1 1 0 1 1 1 1 0 0 0 0 1 1 ).	layout atRow: 10 put: #(1 #(#C 4 3 #n #n #se #sw #O) 0 1 0 #(#C 4 2 #ne #s #s #w) 0 0 0 1 0 0 1 ).	layout atRow: 11 put: #(1 0 0 0 0 0 1 0 0 1 0 0 1 ).	layout atRow: 12 put: #(1 1 1 1 0 #(#H 1 1 #se) 1 0 #(#H 1 4 #ne) 1 0 1 1 ).	layout atRow: 13 put: #(0 0 0 1 1 1 1 1 1 1 1 1 0 ).	^ layout! !!AtomicMap26 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Floating link' translated! !!AtomicMap26 methodsFor: 'access properties' stamp: 'grp 8/1/2002 19:21'!record	^ 105! !!AtomicMap27 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:47'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(0 1 1 1 1 1 1 1 0 0 0 0 0 ).	layout atRow: 2 put: #(0 1 0 0 0 0 0 1 0 0 0 0 0 ).	layout atRow: 3 put: #(0 1 0 0 #(#C 3 2 #n #se #w #w) 0 0 1 1 1 1 1 1 ).	layout atRow: 4 put: #(0 1 0 1 1 0 0 1 #(#H 5 2 #sw) 0 0 0 1 ).	layout atRow: 5 put: #(0 1 0 #(#O 1 3 #ne #se #C) #(#H 2 1 #s) 0 #(#C 3 4 #ne #s #w #w) 1 1 1 1 0 1 ).	layout atRow: 6 put: #(0 1 1 1 0 0 0 1 0 0 0 0 1 ).	layout atRow: 7 put: #(1 1 0 1 1 0 0 1 0 #(#C 2 4 #e #e #s #nw) 0 0 1 ).	layout atRow: 8 put: #(1 0 0 0 0 0 1 #(#H 3 1 #s) 0 1 0 0 1 ).	layout atRow: 9 put: #(1 0 0 0 0 0 0 0 0 1 #(#H 2 5 #n) 0 1 ).	layout atRow: 10 put: #(1 0 #(#C 2 2 #n #e #e #sw) #(#H 5 4 #nw) 1 #(#H 3 5 #n) 0 1 0 1 1 0 1 ).	layout atRow: 11 put: #(1 1 1 1 1 0 0 1 0 0 0 0 1 ).	layout atRow: 12 put: #(0 0 0 1 0 0 0 1 #(#C 4 3 #ne #se #sw #nw) 1 1 1 1 ).	layout atRow: 13 put: #(0 0 0 1 1 1 1 1 1 1 0 0 0 ).	^ layout! !!AtomicMap27 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Pyrane' translated! !!AtomicMap27 methodsFor: 'access properties' stamp: 'grp 8/1/2002 19:26'!record	^ 96! !!AtomicMap28 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:47'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(0 1 1 1 1 1 1 1 1 0 0 0 0 ).	layout atRow: 2 put: #(0 1 #(#H 2 5 #n) 0 0 0 0 0 1 1 1 1 1 ).	layout atRow: 3 put: #(0 1 1 0 0 #(#H 1 3 #e) 1 0 0 #(#H 4 5 #nw) 0 0 1 ).	layout atRow: 4 put: #(0 1 0 0 #(#C 3 2 #ne #se #nw #sw) 1 #(#H 1 2 #se) 1 1 1 #(#C 3 4 #ne #se #s #w) 0 1 ).	layout atRow: 5 put: #(0 1 0 0 0 0 0 0 0 1 1 1 1 ).	layout atRow: 6 put: #(0 1 0 0 0 0 0 0 0 0 1 0 0 ).	layout atRow: 7 put: #(0 1 1 #(#H 1 4 #e) 1 0 #(#H 4 1 #sw) 1 0 0 1 0 0 ).	layout atRow: 8 put: #(0 0 1 1 1 0 1 1 0 0 1 0 0 ).	layout atRow: 9 put: #(1 1 1 #(#C 2 4 #n #s #e #w) #(#H 3 5 #n) #(#C 2 3 #ne #s #w #nw) 0 0 0 0 1 1 1 ).	layout atRow: 10 put: #(1 #(#H 2 1 #se) 0 0 1 1 0 0 1 #(#H 5 4 #nw) 0 0 1 ).	layout atRow: 11 put: #(1 0 0 0 0 #(#C 4 3 #ne #se #nw #sw) 0 0 1 1 1 1 1 ).	layout atRow: 12 put: #(1 0 1 0 0 0 0 #(#H 5 2 #sw) 1 0 0 0 0 ).	layout atRow: 13 put: #(1 1 1 1 1 1 1 1 1 0 0 0 0 ).	^ layout! !!AtomicMap28 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Cyclo-Pentane' translated! !!AtomicMap28 methodsFor: 'access properties' stamp: 'grp 8/1/2002 19:37'!record	^ 132! !!AtomicMap29 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:47'!createLayout	layout _ Matrix  rows: 13 columns:13.	layout atRow: 1 put: #(0 0 1 1 1 1 1 1 1 1 1 0 0 ).	layout atRow: 2 put: #(0 0 1 0 0 0 0 0 0 0 1 0 0 ).	layout atRow: 3 put: #(0 0 1 0 #(#O 3 1 #e #se) 1 #(#N 6 6 #e #s #nw) 0 0 1 1 1 1 ).	layout atRow: 4 put: #(0 0 1 #(#C 3 4 #n #s #e #w) 1 #(#N 4 2 #ne #s #nw) 1 0 #(#O 5 1 #sw #w) 0 0 0 1 ).	layout atRow: 5 put: #(0 0 1 #(#O 1 6 #e #se) 1 0 0 0 #(#H 6 4 #w) 0 0 #(#O 2 7 #n #nw) 1 ).	layout atRow: 6 put: #(1 1 1 0 1 1 1 0 0 0 1 1 1 ).	layout atRow: 7 put: #(1 0 0 0 0 0 #(#N 2 6 #ne #s #w) 0 0 #(#O 4 3 #n #s) 0 #(#O 7 6 #sw #w) 1 ).	layout atRow: 8 put: #(1 0 #(#H 3 3 #s) 1 #(#H 2 4 #e) 0 #(#C 4 4 #n #s #e #w) 0 1 1 0 0 1 ).	layout atRow: 9 put: #(1 0 1 1 1 #(#- 4 1 #e #w) 1 0 0 1 1 1 1 ).	layout atRow: 10 put: #(1 #(#O 6 7 #n #ne) 1 1 0 0 1 #(#H 4 5 #n) 0 0 #(#O 5 5 #n #se) #(#O 3 5 #n #sw) 1 ).	layout atRow: 11 put: #(1 #(#C 5 4 #n #s #e #w) 0 0 0 0 1 1 0 0 1 1 1 ).	layout atRow: 12 put: #(1 1 1 1 1 1 1 #(#H 5 3 #s) 0 0 1 0 0 ).	layout atRow: 13 put: #(0 0 0 0 0 0 1 1 1 1 1 0 0 ).	^ layout! !!AtomicMap29 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Nitro-Glycerin' translated! !!AtomicMap29 methodsFor: 'access properties' stamp: 'grp 8/1/2002 19:44'!record	^ 140! !!AtomicMap30 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:47'!createLayout	layout _ Matrix  rows: 11 columns:11.	layout atRow: 1 put: #(0 0 1 1 1 1 1 1 1 1 1 ).	layout atRow: 2 put: #(0 0 1 0 0 0 0 #(#H 1 4 #ne) 0 0 1 ).	layout atRow: 3 put: #(0 0 1 0 0 1 0 1 0 0 1 ).	layout atRow: 4 put: #(0 0 1 #(#H 2 1 #s) 0 #(#C 2 3 #n #s #se #sw) 0 1 1 1 1 ).	layout atRow: 5 put: #(1 1 1 1 1 #(#C 2 2 #n #s #ne #nw) 0 1 #(#H 1 1 #se) 1 0 ).	layout atRow: 6 put: #(1 0 0 0 1 0 0 0 0 1 0 ).	layout atRow: 7 put: #(1 0 0 0 0 0 0 0 0 1 0 ).	layout atRow: 8 put: #(1 0 #(#H 2 4 #n) 0 1 1 1 #(#H 3 4 #nw) 0 1 1 ).	layout atRow: 9 put: #(1 1 1 #(#H 3 1 #sw) 0 0 0 1 0 0 1 ).	layout atRow: 10 put: #(1 0 0 0 0 0 0 0 0 0 1 ).	layout atRow: 11 put: #(1 1 1 1 1 1 1 1 1 1 1 ).	^ layout! !!AtomicMap30 methodsFor: 'access properties' stamp: 'asm 4/20/2004 21:43'!levelName	^ 'Ethane' translated! !!AtomicMap30 methodsFor: 'access properties' stamp: 'grp 8/1/2002 19:59'!record	^ 66! !!AtomicMapStyle class methodsFor: 'instance creation' stamp: 'asm 4/20/2004 20:27'!newForPreview	| this |	this _ super new.	this isPreview: true.^this.! !!AtomicMapStyle methodsFor: 'initialization' stamp: 'GP 4/14/2003 23:09'!initialize	smallScreen _ DisplayScreen actualScreenSize < (500 @ 500).	isPreview _ false! !!AtomicMapStyle methodsFor: 'access properties' stamp: 'grp 8/21/2002 19:51'!isPreview^	isPreview ! !!AtomicMapStyle methodsFor: 'access properties' stamp: 'grp 8/21/2002 19:51'!isPreview: aBooleanisPreview _ aBoolean.! !!AtomicMapStyle methodsFor: 'access properties' stamp: 'GP 4/14/2003 23:09'!isSmallScreen	^ smallScreen! !!ChessBoard class methodsFor: 'class initialization' stamp: 'ar 8/9/2001 23:44'!initialize	"ChessGame initialize"	self initializeHashKeys.! !!ChessBoard class methodsFor: 'class initialization' stamp: 'ar 10/18/2001 23:22'!initializeHashKeys	"ChessGame initialize"	| random |	HashKeys _ Array new: 12.	1 to: HashKeys size do:[:i| HashKeys at: i put: (WordArray new: 64)].	HashLocks _ Array new: 12.	1 to: HashLocks size do:[:i| HashLocks at: i put: (WordArray new: 64)].	random _ Random seed: 23648646.	1 to: 12 do:[:i|		1 to: 64 do:[:j|			(HashKeys at: i) at: j put: (random nextInt: SmallInteger maxVal) - 1.			(HashLocks at: i) at: j put: (random nextInt: SmallInteger maxVal) - 1.		].	].! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/8/2001 23:02'!activePlayer	^activePlayer! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/8/2001 22:41'!blackPlayer	^blackPlayer! !!ChessBoard methodsFor: 'copying' stamp: 'ar 8/9/2001 04:14'!copy	^self shallowCopy postCopy! !!ChessBoard methodsFor: 'copying' stamp: 'aoy 2/17/2003 01:15'!copyBoard: aBoard 	"Copy all volatile state from the given board"	whitePlayer copyPlayer: aBoard whitePlayer.	blackPlayer copyPlayer: aBoard blackPlayer.	activePlayer := aBoard activePlayer isWhitePlayer 				ifTrue: [whitePlayer]				ifFalse: [blackPlayer]. 	hashKey := aBoard hashKey.	hashLock := aBoard hashLock.	userAgent := nil! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/10/2001 06:15'!generator	^generator! !!ChessBoard methodsFor: 'hashing' stamp: 'ar 8/9/2001 23:45'!hashKey	^hashKey! !!ChessBoard methodsFor: 'hashing' stamp: 'ar 8/9/2001 23:45'!hashLock	^hashLock! !!ChessBoard methodsFor: 'initialize' stamp: 'ar 8/24/2001 18:04'!initialize	generator ifNil:[generator _ ChessMoveGenerator new initialize].	searchAgent ifNil:[searchAgent _ ChessPlayerAI new initialize].	self resetGame.! !!ChessBoard methodsFor: 'initialize' stamp: 'ar 8/9/2001 03:50'!initializeNewBoard	self resetGame.	whitePlayer addWhitePieces.	blackPlayer addBlackPieces.! !!ChessBoard methodsFor: 'moving' stamp: 'ar 10/18/2001 20:19'!movePieceFrom: sourceSquare to: destSquare	| move |	searchAgent isThinking ifTrue:[^self].	move _ (activePlayer findPossibleMovesAt: sourceSquare) contents		detect:[:any| any destinationSquare = destSquare].	self nextMove: move.	searchAgent activePlayer: activePlayer.! !!ChessBoard methodsFor: 'moving' stamp: 'aoy 2/17/2003 01:16'!nextMove: aMove 	activePlayer applyMove: aMove.	userAgent 		ifNotNil: [userAgent completedMove: aMove white: activePlayer isWhitePlayer].	activePlayer := activePlayer == whitePlayer 				ifTrue: [blackPlayer]				ifFalse: [whitePlayer].	activePlayer prepareNextMove ! !!ChessBoard methodsFor: 'moving' stamp: 'aoy 2/17/2003 01:16'!nullMove	activePlayer := activePlayer == whitePlayer 				ifTrue: [blackPlayer]				ifFalse: [whitePlayer]. 	activePlayer prepareNextMove! !!ChessBoard methodsFor: 'copying' stamp: 'ar 8/9/2001 17:35'!postCopy	whitePlayer == activePlayer ifTrue:[		whitePlayer _ whitePlayer copy.		blackPlayer _ blackPlayer copy.		activePlayer _ whitePlayer.	] ifFalse:[		whitePlayer _ whitePlayer copy.		blackPlayer _ blackPlayer copy.		activePlayer _ blackPlayer.	].	whitePlayer opponent: blackPlayer.	blackPlayer opponent: whitePlayer.	whitePlayer board: self.	blackPlayer board: self.	self userAgent: nil.! !!ChessBoard methodsFor: 'printing' stamp: 'ar 8/24/2001 18:25'!printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		print: hashKey; space; print: hashLock;		nextPut: $).! !!ChessBoard methodsFor: 'initialize' stamp: 'ar 8/24/2001 18:19'!resetGame	hashKey _ hashLock _ 0.	whitePlayer _ ChessPlayer new initialize.	blackPlayer _ ChessPlayer new initialize.	whitePlayer opponent: blackPlayer.	whitePlayer board: self.	blackPlayer opponent: whitePlayer.	blackPlayer board: self.	activePlayer _ whitePlayer.	searchAgent reset: self.	userAgent ifNotNil:[userAgent gameReset].! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:04'!searchAgent	^searchAgent! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:04'!searchAgent: anAgent	searchAgent _ anAgent.! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/12/2001 22:53'!statusString	^searchAgent statusString! !!ChessBoard methodsFor: 'moving' stamp: 'aoy 2/17/2003 01:17'!undoMove: aMove 	activePlayer := activePlayer == whitePlayer 				ifTrue: [blackPlayer]				ifFalse: [whitePlayer]. 	activePlayer undoMove: aMove.	userAgent 		ifNotNil: [userAgent undoMove: aMove white: activePlayer isWhitePlayer]! !!ChessBoard methodsFor: 'hashing' stamp: 'aoy 2/17/2003 01:17'!updateHash: piece at: square from: player 	| index |	index := player == whitePlayer ifTrue: [piece] ifFalse: [piece + 6].	hashKey := hashKey bitXor: ((HashKeys at: index) at: square). 	hashLock := hashLock bitXor: ((HashLocks at: index) at: square)! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/9/2001 03:49'!userAgent	^userAgent! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/24/2001 18:19'!userAgent: anObject	userAgent _ anObject.! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/8/2001 22:41'!whitePlayer	^whitePlayer! !!ChessHistoryTable class methodsFor: 'instance creation' stamp: 'ar 8/9/2001 17:50'!new	^self new: 4096+64! !!ChessHistoryTable methodsFor: 'accessing' stamp: 'ar 8/24/2001 16:18'!addMove: aMove	| index |	index _ (aMove sourceSquare bitShift: 6) + aMove destinationSquare.	self at: index put: (self at: index + 1)! !!ChessHistoryTable methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:18'!atAllPut: aPositiveInteger	"Fill the receiver, an indexable bytes or words object, with the given positive integer. The range of possible fill values is [0..255] for byte arrays and [0..(2^32 - 1)] for word arrays."	<primitive: 145>	self errorImproperStore.! !!ChessHistoryTable methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:18'!clear	self atAllPut: 0.! !!ChessHistoryTable methodsFor: 'sorting' stamp: 'ar 8/24/2001 16:18'!sorts: move1 before: move2	^(self at: (move1 sourceSquare bitShift: 6) + move1 destinationSquare) >		(self at: (move2 sourceSquare bitShift: 6) + move2 destinationSquare)! !!ChessMove class methodsFor: 'accessing' stamp: 'ar 8/9/2001 01:05'!basicMoveMask	^BasicMoveMask! !!ChessMove class methodsFor: 'accessing' stamp: 'ar 8/24/2001 23:07'!decodeFrom: encodedMove	^self new moveEncoded: encodedMove! !!ChessMove class methodsFor: 'class initialization' stamp: 'ar 8/9/2001 01:50'!initialize	"ChessMove initialize"	MoveNormal _ 1.	MoveDoublePush _ 2.	MoveCaptureEnPassant _ 3.	MoveCastlingKingSide _ 4.	MoveCastlingQueenSide _ 5.	MoveResign _ 6.	MoveStaleMate _ 7.	BasicMoveMask _ 15.	PromotionShift _ 4.	ExtractPromotionShift _  0 - PromotionShift.	EvalTypeAccurate _ 0.	EvalTypeUpperBound _ 1.	EvalTypeLowerBound _ 2.	NullMove _ 0.! !!ChessMove methodsFor: 'comparing' stamp: 'ar 8/7/2001 22:11'!= aMove	movingPiece = aMove movingPiece ifFalse:[^false].	capturedPiece = aMove capturedPiece ifFalse:[^false].	type = aMove type ifFalse:[^false].	sourceSquare = aMove sourceSquare ifFalse:[^false].	destinationSquare = aMove destinationSquare ifFalse:[^false].	^true! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/24/2001 22:48'!bestMove	^nil! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:19'!captureEnPassant: aPiece from: startSquare to: endSquare	movingPiece _ capturedPiece _ aPiece.	sourceSquare _ startSquare.	destinationSquare _ endSquare.	type _ MoveCaptureEnPassant.! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/7/2001 22:06'!capturedPiece	^capturedPiece! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:24'!capturedPiece: aValue	^capturedPiece _ aValue! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!checkMate: aPiece	movingPiece _ aPiece.	sourceSquare _ 0.	destinationSquare _ 0.	type _ MoveResign.	capturedPiece _ 0.! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/7/2001 22:06'!destinationSquare	^destinationSquare! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:24'!destinationSquare: aValue	^destinationSquare _ aValue! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!doublePush: aPiece from: startSquare to: endSquare	movingPiece _ aPiece.	sourceSquare _ startSquare.	destinationSquare _ endSquare.	type _ MoveDoublePush.	capturedPiece _ 0.! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/24/2001 22:48'!encodedMove	"Return an integer encoding enough of a move for printing"	^destinationSquare + 		(sourceSquare bitShift: 8) +		(movingPiece bitShift: 16) +		(capturedPiece bitShift: 24)! !!ChessMove methodsFor: 'comparing' stamp: 'ar 8/7/2001 22:12'!hash	^((movingPiece hash bitXor: capturedPiece hash) bitXor:		(sourceSquare hash bitXor: destinationSquare hash)) bitXor: type hash! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!init	movingPiece _ sourceSquare _ destinationSquare _ 1.	type _ MoveNormal.	capturedPiece _ 0.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!move: aPiece from: startSquare to: endSquare	movingPiece _ aPiece.	sourceSquare _ startSquare.	destinationSquare _ endSquare.	type _ MoveNormal.	capturedPiece _ 0.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!move: aPiece from: startSquare to: endSquare capture: capture	movingPiece _ aPiece.	sourceSquare _ startSquare.	destinationSquare _ endSquare.	capturedPiece _ capture.	type _ MoveNormal.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!moveCastlingKingSide: aPiece from: startSquare to: endSquare	movingPiece _ aPiece.	sourceSquare _ startSquare.	destinationSquare _ endSquare.	type _ MoveCastlingKingSide.	capturedPiece _ 0.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:19'!moveCastlingQueenSide: aPiece from: startSquare to: endSquare	movingPiece _ aPiece.	sourceSquare _ startSquare.	destinationSquare _ endSquare.	type _ MoveCastlingQueenSide.	capturedPiece _ 0.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/24/2001 23:08'!moveEncoded: encodedMove	destinationSquare _ encodedMove bitAnd: 255.	sourceSquare _ (encodedMove bitShift: -8) bitAnd: 255.	movingPiece _ (encodedMove bitShift: -16) bitAnd: 255.	capturedPiece _ (encodedMove bitShift: -24) bitAnd: 255.	type _ MoveNormal.! !!ChessMove methodsFor: 'printing' stamp: 'ar 8/9/2001 18:06'!moveString	^String streamContents:[:aStream|		aStream nextPutAll: (#('' 'N' 'B' 'R' 'Q' 'K') at: movingPiece).		aStream nextPutAll: (String with: ($a asInteger + (sourceSquare - 1 bitAnd: 7)) asCharacter with: ($1 asInteger + (sourceSquare -1 bitShift: -3)) asCharacter).		capturedPiece = 0 ifTrue:[			aStream nextPutAll: '-'.		] ifFalse:[			aStream nextPutAll: 'x'.			aStream nextPutAll: (#('' 'N' 'B' 'R' 'Q' 'K') at: capturedPiece).		].		aStream nextPutAll: (String with: ($a asInteger + (destinationSquare - 1 bitAnd: 7)) asCharacter with: ($1 asInteger + (destinationSquare -1 bitShift: -3)) asCharacter).	].! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/10/2001 02:32'!moveType	^type! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/10/2001 02:32'!moveType: aType	^type _ aType! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/7/2001 22:06'!movingPiece	^movingPiece! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:24'!movingPiece: aValue	^movingPiece _ aValue! !!ChessMove methodsFor: 'printing' stamp: 'ar 8/9/2001 15:38'!printOn: aStream	super printOn: aStream.	aStream nextPutAll:'('.	aStream nextPutAll: (#('' 'N' 'B' 'R' 'Q' 'K') at: movingPiece).	aStream nextPutAll: (String with: ($a asInteger + (sourceSquare - 1 bitAnd: 7)) asCharacter with: ($1 asInteger + (sourceSquare -1 bitShift: -3)) asCharacter).	capturedPiece = 0 ifTrue:[		aStream nextPutAll: '-'.	] ifFalse:[		aStream nextPutAll: 'x'.		aStream nextPutAll: (#('' 'N' 'B' 'R' 'Q' 'K') at: capturedPiece).	].	aStream nextPutAll: (String with: ($a asInteger + (destinationSquare - 1 bitAnd: 7)) asCharacter with: ($1 asInteger + (destinationSquare -1 bitShift: -3)) asCharacter).	aStream nextPutAll:')'.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!promote: move to: promotion	movingPiece _ move movingPiece.	capturedPiece _ move capturedPiece.	sourceSquare _ move sourceSquare.	destinationSquare _ move destinationSquare. 	type _ move moveType.	type _ type bitOr: (promotion bitShift: PromotionShift).! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:25'!promotion	^type bitShift: ExtractPromotionShift! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/7/2001 22:07'!sourceSquare	^sourceSquare! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:24'!sourceSquare: aValue	^sourceSquare _ aValue! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!staleMate: aPiece	movingPiece _ aPiece.	sourceSquare _ 0.	destinationSquare _ 0.	type _ MoveStaleMate.	capturedPiece _ 0.! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/9/2001 18:03'!value	^value! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/9/2001 18:03'!value: newValue	value _ newValue! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/10/2001 22:31'!attackSquares	^attackSquares! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/24/2001 15:58'!blackPawnCaptureAt: square direction: dir	| destSquare move piece |	destSquare _ square-8-dir.	piece _ itsPieces at: destSquare.	piece = 0 ifFalse:[		(move _ moveList at: (lastMoveIndex _ lastMoveIndex + 1))			move: Pawn from: square to: destSquare capture: piece.		piece = King ifTrue:[kingAttack _ move].		destSquare <= 8 "a promotion"			ifTrue:[self promotePawn: move].	].	"attempt an en-passant capture"	enpassantSquare = destSquare ifTrue:[		(moveList at: (lastMoveIndex _ lastMoveIndex + 1))			captureEnPassant: Pawn from: square to: destSquare.	].! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/24/2001 22:05'!blackPawnPushAt: square	| destSquare move |	"Try to push this pawn"	destSquare _ square-8.	(myPieces at: destSquare) = 0 ifFalse:[^self].	(itsPieces at: destSquare) = 0 ifFalse:[^self].	(move _ moveList at: (lastMoveIndex _ lastMoveIndex + 1))		move: Pawn from: square to: destSquare.	destSquare <= 8 "a promotion (can't be double-push so get out)"		ifTrue:[^self promotePawn: move].	"Try to double-push if possible"	square > 48 ifFalse:[^self].	destSquare _ square-16.	(myPieces at: destSquare) = 0 ifFalse:[^self].	(itsPieces at: destSquare) = 0 ifFalse:[^self].	(moveList at: (lastMoveIndex _ lastMoveIndex + 1))		doublePush: Pawn from: square to: destSquare.! !!ChessMoveGenerator methodsFor: 'support' stamp: 'RM 9/16/2004 19:28'!canCastleBlackKingSide	(castlingStatus bitAnd: CastlingEnableKingSide) = 0 ifFalse:[^false].	"Quickly check if all the squares are zero"	((myPieces at: G8) + (myPieces at: F8) + (itsPieces at: G8) + (itsPieces at: F8) = 0) ifFalse:[^false].	"Check for castling squares under attack..  See canCastleBlackQueenSide for details"	(self checkAttack:{H7. H6. H5. H4. H3. H2. H1} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{G7. G6. G5. G4. G3. G2. G1} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{F7. F6. F5. F4. F3. F2. F1} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{E7. E6. E5. E4. E3. E2. E1.} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{D8. C8. B8. A8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{G7. F6. E5. D4. C3. B2. A1} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{F7. E6. D5. C4. B3. A2} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{E7. D6. C5. B4. A3} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{D7. C6. B5. A4} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{F7. G6. H5} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{G7. H6} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{H7} fromPieces:BishopMovers) ifTrue:[^false].	(self checkUnprotectedAttack:{H7. G7. F7. E7. D7. C7. H6. G6. F6. E6. D6} fromPiece:Knight) ifTrue:[^false].	(self checkUnprotectedAttack:{H7. G7. F7. E7. D7} fromPiece:Pawn) ifTrue:[^false].	^true.					! !!ChessMoveGenerator methodsFor: 'support' stamp: 'RM 9/16/2004 19:26'!canCastleBlackQueenSide	(castlingStatus bitAnd: CastlingEnableQueenSide) = 0 ifFalse:[^false].	"Quickly check if all the squares are zero"	((myPieces at: B8) +  (myPieces at: C8) +  (myPieces at: D8) +		(itsPieces at: B8) + (itsPieces at: C8) + (itsPieces at: D8) 			= 0) ifFalse:[^false].	"Check to see if any of the squares involved in castling are under attack.  First	check for vertical (rook-like) attacks"	(self checkAttack:{A7. A6. A5. A4. A3. A2. A1} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{B7. B6. B5. B4. B3. B2. B1} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{C7. C6. C5. C4. C3. C2. C1} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{D7. D6. D5. D4. D3. D2. D1} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{E7. E6. E5. E4. E3. E2. E1} fromPieces:RookMovers) ifTrue:[^false].	"Check for a rook attack from the baseline"	(self checkAttack:{F8. G8. H8} fromPieces:RookMovers) ifTrue:[^false].	"Check for bishop attacks from the diagonals"	(self checkAttack:{B7. C6. D5. E4. F3. G2. H1} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{C7. D6. E5. F4. G3. H2} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{D7. E6. F5. G4. H3} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{E7. F6. G5. H4} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{F7. G6. H5} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{A7} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{B7. A6} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{C7. B6. A5} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{D7. C6. B5. A4} fromPieces:BishopMovers) ifTrue:[^false].	"Check for a knight attack"	(self checkUnprotectedAttack:{A7. B7. C7. D7. E7. F7. G7. A6. B6. C6. D6. E6. F6} fromPiece:Knight) ifTrue:[^false].	"check for a pawn attack"	(self checkUnprotectedAttack:{A7. B7. C7. D7. E7. F7} fromPiece:Pawn) ifTrue:[^false].	"check for a king attack"	(self checkUnprotectedAttack:{B7. C7. } fromPiece:King) ifTrue:[^false].	^true.! !!ChessMoveGenerator methodsFor: 'support' stamp: 'RM 9/16/2004 19:28'!canCastleWhiteKingSide	(castlingStatus bitAnd: CastlingEnableKingSide) = 0 ifFalse: [^false].	"Quickly check if all the squares are zero"	((myPieces at:G1) + (myPieces at:F1) + (itsPieces at:G1) + (itsPieces at:F1) = 0) ifFalse:[^false].	"Check for castling squares under attack..  See canCastleBlackQueenSide for details"	(self checkAttack:{H2. H3. H4. H5. H6. H7. H8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{G2. G3. G4. G5. G6. G7. G8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{F2. F3. F4. F5. F6. F7. F8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{E2. E3. E4. E5. E6. E7. E8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{A1. A2. A3. A4} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{G2. F3. E4. D5. C6. B7. A8} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{F2. E3. D4. C5. B6. A7} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{E2. D3. C4. B5. A6} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{D2. C3. B4. A5} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{F2. G3. H4} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{G2. H3} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{H2} fromPieces:BishopMovers) ifTrue:[^false].	(self checkUnprotectedAttack:{H2. G2. F2. E2. D2. C2. H3. G3. F3. E3. D3} fromPiece:Knight) ifTrue:[^false].	(self checkUnprotectedAttack:{H2. G2. F2. E2. D2} fromPiece:Pawn) ifTrue:[^false].	(self checkUnprotectedAttack:{G2} fromPiece:King) ifTrue:[^false].	^true.! !!ChessMoveGenerator methodsFor: 'support' stamp: 'RM 9/16/2004 19:28'!canCastleWhiteQueenSide	(castlingStatus bitAnd: CastlingEnableQueenSide) = 0 ifFalse: [^false].	"Quickly check if all the squares are zero"	((myPieces at:B1) + (myPieces at:C1) + (myPieces at:D1) +	 (itsPieces at:B1) + (itsPieces at:C1) + (itsPieces at:D1) = 0) ifFalse:[^false].	"Check for castling squares under attack..  See canCastleBlackQueenSide for details"	(self checkAttack:{A2. A3. A4. A5. A6. A7. A8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{B2. B3. B4. B5. B6. B7. B8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{C2. C3. C4. C5. C6. C7. C8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{D2. D3. D4. D5. D6. D7. D8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{E2. E3. E4. E5. E6. E7. E8} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{F1. G1. H1} fromPieces:RookMovers) ifTrue:[^false].	(self checkAttack:{B2. C3. D4. E5. F6. G7. H8} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{C2. D3. E4. F5. G6. H7} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{D2. E3. F4. G5. H6} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{E2. F3. G4. H5} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{F2. G3. H4} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{A2} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{B2. A3} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{C2. B3. A4} fromPieces:BishopMovers) ifTrue:[^false].	(self checkAttack:{D2. C3. B4. A5} fromPieces:BishopMovers) ifTrue:[^false].	(self checkUnprotectedAttack:{A2. B2. C2. D2. E2. F2. G2. A3. B3. C3. D3. E3. F3} fromPiece:Knight) ifTrue:[^false].	(self checkUnprotectedAttack:{A2. B2. C2. D2. E2. F2} fromPiece:Pawn) ifTrue:[^false].	(self checkUnprotectedAttack:{B2. C2} fromPiece:King) ifTrue:[^false].	^true.! !!ChessMoveGenerator methodsFor: 'support' stamp: 'RM 9/16/2004 19:37'!checkAttack:squares fromPieces:pieces	"check for an unprotected attack along squares by one of pieces.  Squares is a list of 	squares such that any piece in pieces can attack unless blocked by another piece.	E.g., a Bishop of Queen on the file  B7 C6 D5 E4 F3 G2 H1 can attack A8 unless blocked by	another piece.  To find out if A8 is under attack along B7 C6 D5 E4 F3 G2 H1, use	checkAttack:{B7. C6.D5. E4. F3. G2. H1} fromPieces:BishopMovers.  Note the order is important;	squares must be listed in increasing distance from the square of interest"	squares do:[:sqr|		"invariant: no piece has been seen on this file at all"		"one of my pieces blocks any attack"		(myPieces at:sqr) = 0 ifFalse:[^false].		"One of its pieces blocks an attack unless it is the kind of piece that can move along this		file: a Bishop or Queen for a diagonal and a Rook or Queen for a Horizontal or		Verrtical File"		(itsPieces at:sqr) = 0 ifFalse:[			^pieces includes:(itsPieces at:sqr).		].			].	"no pieces along file, no attack"	^false.		! !!ChessMoveGenerator methodsFor: 'support' stamp: 'RM 9/16/2004 19:38'!checkUnprotectedAttack:squares fromPiece:piece	"check to see if my opponent has a piece of type piece on any of squares.  In general, this	is used because that piece could launch an attack on me from those squares".	squares do:[:sqr|		(itsPieces at:sqr) = piece ifTrue:[^true].	].	^false.		! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 9/29/2005 10:39'!findAllPossibleMovesFor: player 	"Find all possible moves. This method does not check if the move is legal, e.g., if the king of the player is under attack after the move. If the opponent is check mate (e.g., the king could be taken in the next move) the method returns nil. If the game is stale mate (e.g., the receiver has no move left) this method returns an empty array."	| piece actions square |	myPlayer := player.	myPieces := player pieces.	itsPieces := player opponent pieces.	castlingStatus := player castlingStatus.	enpassantSquare := player opponent enpassantSquare.	firstMoveIndex = lastMoveIndex ifFalse: [self error: 'I am confused'].	kingAttack := nil.	myPlayer isWhitePlayer ifTrue:[		actions := #(moveWhitePawnAt: moveKnightAt: moveBishopAt: 					moveRookAt: moveQueenAt: moveWhiteKingAt:)	] ifFalse:[ 		actions := #(moveBlackPawnAt: moveKnightAt: moveBishopAt: 					moveRookAt: moveQueenAt: moveBlackKingAt:)	].	square := 0.	[square < 64] whileTrue:[		"Note: The following is only to skip empty fields efficiently.		It could well be replaced by going through each field and test it		for zero but this is *much* faster."		square := self skipEmptySquaresIn: myPieces							using: EmptyPieceMap							startingAt: square + 1.		square = 0 ifTrue: [^self moveList].		piece := myPieces at: square.		self perform: (actions at: piece) with: square.		kingAttack ifNotNil: [^self moveList].	].	^self moveList! !!ChessMoveGenerator methodsFor: 'public' stamp: 'dgd 2/22/2003 14:38'!findAttackSquaresFor: player 	"Mark all the fields of a board that are attacked by the given player.	The pieces attacking a field are encoded as (1 << Piece) so that we can	record all types of pieces that attack the square."	| move square piece attack list |	forceCaptures := false.	attackSquares ifNil: [attackSquares := ByteArray new: 64].	attackSquares atAllPut: 0.	list := self findAllPossibleMovesFor: player.		[move := list next.	move isNil] whileFalse: 				[square := move destinationSquare.				piece := move movingPiece.				attack := attackSquares at: square.				attack := attack bitOr: (1 bitShift: piece).				attackSquares at: square put: attack].	self recycleMoveList: list.	^attackSquares! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 15:59'!findPossibleMovesFor: player	"Find all possible moves. This method does not check if the move is legal, e.g., if the king of the player is under attack after the move. If the opponent is check mate (e.g., the king could be taken in the next move) the method returns nil. If the game is stale mate (e.g., the receiver has no move left) this method returns an empty array."	forceCaptures _ false.	^self findAllPossibleMovesFor: player.! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 20:58'!findPossibleMovesFor: player at: square	"Find all possible moves at the given square. This method does not check if the move is legal, e.g., if the king of the player is under attack after the move. If the opponent is check mate (e.g., the king could be taken in the next move) the method returns nil. If the game is stale mate (e.g., the receiver has no move left) this method returns an empty array."	| piece action |	forceCaptures _ false.	myPlayer _ player.	myPieces _ player pieces.	itsPieces _ player opponent pieces.	castlingStatus _ player castlingStatus.	enpassantSquare _ player opponent enpassantSquare.	firstMoveIndex = lastMoveIndex ifFalse:[self error:'I am confused'].	kingAttack _ nil.	piece _ myPieces at: square.	piece = 0 ifFalse:[		action _ #(movePawnAt:					moveKnightAt:					moveBishopAt:					moveRookAt:					moveQueenAt:					moveKingAt:) at: piece.		self perform: action with: square.	].	^self moveList! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 16:00'!findQuiescenceMovesFor: player	"Find all the quiescence moves (that is moves capturing pieces)"	forceCaptures _ true.	^self findAllPossibleMovesFor: player.! !!ChessMoveGenerator methodsFor: 'initialize' stamp: 'ar 8/24/2001 15:55'!initialize	EmptyPieceMap ifNil:[		EmptyPieceMap _ ByteArray new: 256.		2 to: 7 do:[:i| EmptyPieceMap at: i put: 1]].	streamList _ Array new: 100. "e.g., 100 plies"	1 to: streamList size do:[:i| streamList at: i put: (ChessMoveList on: #())].	moveList _ Array new: streamList size * 30. "avg. 30 moves per ply"	1 to: moveList size do:[:i| moveList at: i put: (ChessMove new init)].	firstMoveIndex _ lastMoveIndex _ streamListIndex _ 0.! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/10/2001 22:32'!kingAttack	^kingAttack! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/22/2001 15:19'!moveBishopAt: square	| moves |	moves _ BishopMoves at: square.	1 to: moves size do:[:i|		self movePiece: Bishop along: (moves at: i) at: square.	].! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/24/2001 21:30'!moveBlackKingAt: square	| capture |	(KingMoves at: square) do:[:destSquare|		(myPieces at: destSquare) = 0 ifTrue:[			capture _ itsPieces at: destSquare.			(forceCaptures and:[capture = 0]) ifFalse:[				(moveList at: (lastMoveIndex _ lastMoveIndex + 1))					move: King from: square to: destSquare capture: capture.				capture = King ifTrue:[kingAttack _ moveList at: lastMoveIndex].			].		].	].	forceCaptures ifTrue:[^self].	"now consider castling"	self canCastleBlackKingSide ifTrue:[		(moveList at: (lastMoveIndex _ lastMoveIndex + 1))			moveCastlingKingSide: King from: square to: square+2.	].	self canCastleBlackQueenSide ifTrue:[		(moveList at: (lastMoveIndex _ lastMoveIndex + 1))			moveCastlingQueenSide: King from: square to: square-2.	].! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/22/2001 15:22'!moveBlackPawnAt: square	"Pawns only move in one direction so check for which direction to use"	forceCaptures ifFalse:[self blackPawnPushAt: square].	(square bitAnd: 7) = 1		ifFalse:[self blackPawnCaptureAt: square direction: 1].	(square bitAnd: 7) = 0 		ifFalse:[self blackPawnCaptureAt: square direction: -1].! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/24/2001 21:32'!moveKingAt: square	myPlayer isWhitePlayer		ifTrue:[^self moveWhiteKingAt: square]		ifFalse:[^self moveBlackKingAt: square]! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/24/2001 15:56'!moveKnightAt: square	| capture moves destSquare |	moves _ KnightMoves at: square.	1 to: moves size do:[:i|		destSquare _ moves at: i.		(myPieces at: destSquare) = 0 ifTrue:[			capture _ itsPieces at: destSquare.			(forceCaptures and:[capture = 0]) ifFalse:[				(moveList at: (lastMoveIndex _ lastMoveIndex + 1))					move: Knight from: square to: destSquare capture: capture.				capture = King ifTrue:[kingAttack _ (moveList at: lastMoveIndex)].			].		].	].! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 16:37'!moveList	| list |	kingAttack ifNotNil:[		lastMoveIndex _ firstMoveIndex.		^nil].	list _ streamList at: (streamListIndex _ streamListIndex + 1).	list on: moveList from: firstMoveIndex+1 to: lastMoveIndex.	firstMoveIndex _ lastMoveIndex.	^list! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/22/2001 15:16'!movePawnAt: square	"Pawns only move in one direction so check for which direction to use"	myPlayer isWhitePlayer		ifTrue:[^self moveWhitePawnAt: square]		ifFalse:[^self moveBlackPawnAt: square]! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/24/2001 15:57'!movePiece: piece along: rayList at: square	| destSquare capture |	1 to: rayList size do:[:i|		destSquare _ rayList at: i.		(myPieces at: destSquare) = 0 ifFalse:[^self].		capture _ itsPieces at: destSquare.		(forceCaptures and:[capture = 0]) ifFalse:[			(moveList at: (lastMoveIndex _ lastMoveIndex + 1))				move: piece from: square to: destSquare capture: capture.			capture = King ifTrue:[kingAttack _ moveList at: lastMoveIndex].		].		capture = 0 ifFalse:[^self].	].! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/22/2001 15:19'!moveQueenAt: square	| moves |	moves _ RookMoves at: square.	1 to: moves size do:[:i|		self movePiece: Queen along: (moves at: i) at: square.	].	moves _ BishopMoves at: square.	1 to: moves size do:[:i|		self movePiece: Queen along: (moves at: i) at: square.	].! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/22/2001 15:19'!moveRookAt: square	| moves |	moves _ RookMoves at: square.	1 to: moves size do:[:i|		self movePiece: Rook along: (moves at: i) at: square.	].! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/24/2001 21:30'!moveWhiteKingAt: square	| capture |	(KingMoves at: square) do:[:destSquare|		(myPieces at: destSquare) = 0 ifTrue:[			capture _ itsPieces at: destSquare.			(forceCaptures and:[capture = 0]) ifFalse:[				(moveList at: (lastMoveIndex _ lastMoveIndex + 1))					move: King from: square to: destSquare capture: capture.				capture = King ifTrue:[kingAttack _ moveList at: lastMoveIndex].			].		].	].	forceCaptures ifTrue:[^self].	"now consider castling"	self canCastleWhiteKingSide ifTrue:[		(moveList at: (lastMoveIndex _ lastMoveIndex + 1))			moveCastlingKingSide: King from: square to: square+2.	].	self canCastleWhiteQueenSide ifTrue:[		(moveList at: (lastMoveIndex _ lastMoveIndex + 1))			moveCastlingQueenSide: King from: square to: square-2.	].! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/22/2001 15:22'!moveWhitePawnAt: square	"Pawns only move in one direction so check for which direction to use"	forceCaptures ifFalse:[self whitePawnPushAt: square].	(square bitAnd: 7) = 0 		ifFalse:[self whitePawnCaptureAt: square direction: 1].	(square bitAnd: 7) = 1 		ifFalse:[self whitePawnCaptureAt: square direction: -1].! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 21:25'!profileGenerationFor: player	| list |	Smalltalk garbageCollect.	MessageTally spyOn:[		1 to: 100000 do:[:i|			list _ self findPossibleMovesFor: player.			self recycleMoveList: list].	].! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/24/2001 15:57'!promotePawn: move	"Duplicate the given move and embed all promotion types"	(moveList at: (lastMoveIndex _ lastMoveIndex + 1)) promote: move to: Knight.	(moveList at: (lastMoveIndex _ lastMoveIndex + 1)) promote: move to: Bishop.	(moveList at: (lastMoveIndex _ lastMoveIndex + 1)) promote: move to: Rook.	move promote: move to: Queen.! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 16:31'!recycleMoveList: aChessMoveList	(streamList at: streamListIndex) == aChessMoveList ifFalse:[^self error:'I am confused'].	streamListIndex _ streamListIndex - 1.	firstMoveIndex _ lastMoveIndex _ aChessMoveList startIndex - 1.! !!ChessMoveGenerator methodsFor: 'private' stamp: 'ar 9/29/2005 10:46'!skipEmptySquaresIn: pieces using: aMap startingAt: startIndex	"Find the first empty (zero) square in pieces. The method is layed out so we can (re)use the a particularly effective String primitive (which requires the map argument) but the failure code will do the more natural search for zero instead of the actual primitive equivalent."	<primitive: 'primitiveFindFirstInString' module: 'MiscPrimitivePlugin'>	startIndex to: pieces size do:[:index|		(pieces at: index) = 0 ifFalse:[^index].	].	^0! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/24/2001 15:56'!whitePawnCaptureAt: square direction: dir	| destSquare move piece |	destSquare _ square+8+dir.	piece _ itsPieces at: destSquare.	piece = 0 ifFalse:[		(move _ moveList at: (lastMoveIndex _ lastMoveIndex + 1))			move: Pawn from: square to: destSquare capture: piece.		piece = King ifTrue:[kingAttack _ move].		destSquare > 56 "a promotion"			ifTrue:[self promotePawn: move].	].	"attempt an en-passant capture"	enpassantSquare = destSquare ifTrue:[		(moveList at: (lastMoveIndex _ lastMoveIndex + 1))			captureEnPassant: Pawn from: square to: destSquare.	].! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/24/2001 22:06'!whitePawnPushAt: square	"Pawns only move in one direction so check for which direction to use"	| destSquare move |	"Try to push this pawn"	destSquare _ square+8.	(myPieces at: destSquare) = 0 ifFalse:[^self].	(itsPieces at: destSquare) = 0 ifFalse:[^self].	(move _ moveList at: (lastMoveIndex _ lastMoveIndex + 1))		move: Pawn from: square to: destSquare.	destSquare > 56 "a promotion (can't be double-push so get out)"		ifTrue:[^self promotePawn: move].	"Try to double-push if possible"	square <= 16 ifFalse:[^self].	destSquare _ square+16.	(myPieces at: destSquare) = 0 ifFalse:[^self].	(itsPieces at: destSquare) = 0 ifFalse:[^self].	(moveList at: (lastMoveIndex _ lastMoveIndex + 1))		doublePush: Pawn from: square to: destSquare.! !!ChessPlayer class methodsFor: 'accessing' stamp: 'ar 8/9/2001 19:53'!king	^King! !!ChessPlayer class methodsFor: 'accessing' stamp: 'ar 8/10/2001 01:00'!rook	^Rook! !!ChessPlayer methodsFor: 'adding/removing' stamp: 'ar 8/8/2001 22:25'!addBlackPieces	self initialize.	49 to: 56 do:[:i| self addPiece: Pawn at: i].	self addPiece: Rook at: 57.	self addPiece: Knight at: 58.	self addPiece: Bishop at: 59.	self addPiece: Queen at: 60.	self addPiece: King at: 61.	self addPiece: Bishop at: 62.	self addPiece: Knight at: 63.	self addPiece: Rook at: 64.! !!ChessPlayer methodsFor: 'adding/removing' stamp: 'ar 8/24/2001 18:18'!addPiece: piece at: square	pieces at: square put: piece.	materialValue _ materialValue + (PieceValues at: piece).	positionalValue _ positionalValue + ((PieceCenterScores at: piece) at: square).	piece = Pawn ifTrue:[numPawns _ numPawns + 1].	board updateHash: piece at: square from: self.	self userAgent ifNotNil:[self userAgent addedPiece: piece at: square white: self isWhitePlayer].! !!ChessPlayer methodsFor: 'adding/removing' stamp: 'ar 8/8/2001 22:24'!addWhitePieces	self addPiece: Rook at: 1.	self addPiece: Knight at: 2.	self addPiece: Bishop at: 3.	self addPiece: Queen at: 4.	self addPiece: King at: 5.	self addPiece: Bishop at: 6.	self addPiece: Knight at: 7.	self addPiece: Rook at: 8.	9 to: 16 do:[:i| self addPiece: Pawn at: i].! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/10/2001 00:36'!applyCastleKingSideMove: move	self movePiece: move movingPiece from: move sourceSquare to: move destinationSquare.	self movePiece: Rook from: move sourceSquare+3 to: (castlingRookSquare _ move sourceSquare+1).	pieces at: castlingRookSquare put: King.	castlingStatus _ castlingStatus bitOr: CastlingDone.! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/10/2001 00:33'!applyCastleQueenSideMove: move	self movePiece: move movingPiece from: move sourceSquare to: move destinationSquare.	self movePiece: Rook from: move sourceSquare-4 to: (castlingRookSquare _ move sourceSquare-1).	pieces at: castlingRookSquare put: King.	castlingStatus _ castlingStatus bitOr: CastlingDone.! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/9/2001 01:58'!applyDoublePushMove: move	enpassantSquare _ (move sourceSquare + move destinationSquare) bitShift: -1.	"Above means: the field between start and destination"	^self movePiece: move movingPiece from: move sourceSquare to: move destinationSquare.! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/9/2001 22:26'!applyEnpassantMove: move	opponent removePiece: move capturedPiece at: move destinationSquare - 		(self isWhitePlayer ifTrue:[8] ifFalse:[-8]).	^self movePiece: move movingPiece from: move sourceSquare to: move destinationSquare! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/10/2001 02:46'!applyMove: move	"Apply the given move"	| action |	"Apply basic move"	action _ #(			applyNormalMove:			applyDoublePushMove:			applyEnpassantMove:			applyCastleKingSideMove:			applyCastleQueenSideMove:			applyResign:			applyStaleMate:		) at: (move moveType bitAnd: ChessMove basicMoveMask).	self perform: action with: move.	"Promote if necessary"	self applyPromotion: move.	"Maintain castling status"	self updateCastlingStatus: move.! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/9/2001 00:54'!applyNormalMove: move	| piece |	(piece _ move capturedPiece) = EmptySquare 		ifFalse:[opponent removePiece: piece at: move destinationSquare].	^self movePiece: move movingPiece from: move sourceSquare to: move destinationSquare.! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/9/2001 22:20'!applyPromotion: move	| piece |	piece _ move promotion.	piece = 0 ifFalse:[self replacePiece: move movingPiece with: piece at: move destinationSquare].! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/24/2001 18:18'!applyResign: move	"Give up."	self userAgent ifNotNil:[		self isWhitePlayer 			ifTrue:[self userAgent finishedGame: 0]			ifFalse:[self userAgent finishedGame: 1].	].! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/24/2001 18:18'!applyStaleMate: move	"Itsa draw."	self userAgent ifNotNil:[self userAgent finishedGame: 0.5].! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/8/2001 22:40'!board	^board! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/8/2001 22:40'!board: aBoard	board _ aBoard! !!ChessPlayer methodsFor: 'testing' stamp: 'dgd 2/22/2003 18:41'!canCastleKingSide	(castlingStatus bitAnd: CastlingEnableKingSide) = 0 ifFalse: [^false].	self isWhitePlayer 		ifTrue: 			[(pieces sixth) = 0 ifFalse: [^false].			pieces seventh = 0 ifFalse: [^false].			(opponent pieceAt: 6) = 0 ifFalse: [^false].			(opponent pieceAt: 7) = 0 ifFalse: [^false]]		ifFalse: 			[(pieces at: 62) = 0 ifFalse: [^false].			(pieces at: 63) = 0 ifFalse: [^false].			(opponent pieceAt: 62) = 0 ifFalse: [^false].			(opponent pieceAt: 63) = 0 ifFalse: [^false]].	^true! !!ChessPlayer methodsFor: 'testing' stamp: 'dgd 2/22/2003 18:41'!canCastleQueenSide	(castlingStatus bitAnd: CastlingEnableQueenSide) = 0 ifFalse: [^false].	self isWhitePlayer 		ifTrue: 			[pieces second = 0 ifFalse: [^false].			(pieces third) = 0 ifFalse: [^false].			pieces fourth = 0 ifFalse: [^false].			(opponent pieceAt: 2) = 0 ifFalse: [^false].			(opponent pieceAt: 3) = 0 ifFalse: [^false].			(opponent pieceAt: 4) = 0 ifFalse: [^false]]		ifFalse: 			[(pieces at: 58) = 0 ifFalse: [^false].			(pieces at: 59) = 0 ifFalse: [^false].			(pieces at: 60) = 0 ifFalse: [^false].			(opponent pieceAt: 58) = 0 ifFalse: [^false].			(opponent pieceAt: 59) = 0 ifFalse: [^false].			(opponent pieceAt: 60) = 0 ifFalse: [^false]].	^true! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/10/2001 00:52'!castlingRookSquare	^castlingRookSquare! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/24/2001 18:03'!castlingStatus	^castlingStatus! !!ChessPlayer methodsFor: 'copying' stamp: 'ar 8/9/2001 04:10'!copy	^self shallowCopy postCopy! !!ChessPlayer methodsFor: 'copying' stamp: 'ar 8/24/2001 18:02'!copyPlayer: aPlayer	"Copy all the volatile state from aPlayer"	castlingRookSquare _ aPlayer castlingRookSquare.	enpassantSquare _ aPlayer enpassantSquare.	castlingStatus _ aPlayer castlingStatus.	materialValue _ aPlayer materialValue.	numPawns _ aPlayer numPawns.	positionalValue _ aPlayer positionalValue.	pieces replaceFrom: 1 to: pieces size with: aPlayer pieces startingAt: 1.! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/9/2001 01:58'!enpassantSquare	^enpassantSquare! !!ChessPlayer methodsFor: 'evaluation' stamp: 'ar 8/10/2001 23:26'!evaluate	^self evaluateMaterial + self evaluatePosition! !!ChessPlayer methodsFor: 'evaluation' stamp: 'ar 8/9/2001 20:37'!evaluateMaterial	"Compute the board's material balance, from the point of view of the side	player.  This is an exact clone of the eval function in CHESS 4.5"	| total diff value |	self materialValue = opponent materialValue ifTrue:[^0]. "both sides are equal"	total _ self materialValue + opponent materialValue.	diff _ self materialValue - opponent materialValue.	value _ (2400 min: diff) + 		((diff * (12000 - total) * self numPawns) // (6400 * (self numPawns + 1))).	^value! !!ChessPlayer methodsFor: 'evaluation' stamp: 'ar 8/24/2001 16:02'!evaluatePosition	"Compute the board's positional balance, from the point of view of the side player."	^positionalValue - opponent positionalValue! !!ChessPlayer methodsFor: 'moves-general' stamp: 'ar 8/24/2001 16:04'!findPossibleMoves	"Find all possible moves. This method does not check if the move is legal, e.g., if the king of the player is under attack after the move. If the opponent is check mate (e.g., the king could be taken in the next move) the method returns nil. If the game is stale mate (e.g., the receiver has no move left) this method returns an empty array."	| moveList moves |	moveList _ board generator findPossibleMovesFor: self.	moveList ifNil:[^nil].	moves _ moveList contents collect:[:move| move copy].	board generator recycleMoveList: moveList.	^moves! !!ChessPlayer methodsFor: 'moves-general' stamp: 'ar 8/24/2001 16:06'!findPossibleMovesAt: square	"Find all possible moves at the given square. This method does not check if the move is legal, e.g., if the king of the player is under attack after the move. If the opponent is check mate (e.g., the king could be taken in the next move) the method returns nil. If the game is stale mate (e.g., the receiver has no move left) this method returns an empty array."	| moveList moves |	moveList _ board generator findPossibleMovesFor: self at: square.	moveList ifNil:[^nil].	moves _ moveList contents collect:[:move| move copy].	board generator recycleMoveList: moveList.	^moves! !!ChessPlayer methodsFor: 'moves-general' stamp: 'ar 8/24/2001 16:06'!findQuiescenceMoves	"Find all possible moves. This method does not check if the move is legal, e.g., if the king of the player is under attack after the move. If the opponent is check mate (e.g., the king could be taken in the next move) the method returns nil. If the game is stale mate (e.g., the receiver has no move left) this method returns an empty array."	| moveList moves |	moveList _ board generator findQuiescenceMovesFor: self.	moveList ifNil:[^nil].	moves _ moveList contents collect:[:move| move copy].	board generator recycleMoveList: moveList.	^moves! !!ChessPlayer methodsFor: 'moves-general' stamp: 'ar 8/10/2001 03:09'!findValidMoves	"Find all the valid moves"	| moveList |	moveList _ self findPossibleMoves ifNil:[^nil].	^moveList select:[:move| self isValidMove: move].! !!ChessPlayer methodsFor: 'moves-general' stamp: 'ar 8/10/2001 03:09'!findValidMovesAt: square	"Find all the valid moves"	| moveList |	moveList _ (self findPossibleMovesAt: square) ifNil:[^nil].	^moveList select:[:move| self isValidMove: move].! !!ChessPlayer methodsFor: 'initialize' stamp: 'ar 8/24/2001 18:20'!initialize	"ChessPlayer initialize"	pieces _ ByteArray new: 64.	materialValue _ 0.	positionalValue _ 0.	numPawns _ 0.	enpassantSquare _ 0.	castlingRookSquare _ 0.	castlingStatus _ 0.! !!ChessPlayer methodsFor: 'testing' stamp: 'ar 8/9/2001 19:45'!isValidMove: move	"Is the given move actually valid for the receiver?	If the receiver's king can't be taken after applying the move, it is."	| copy |	copy _ board copy.	copy nextMove: move.	^copy activePlayer findPossibleMoves notNil! !!ChessPlayer methodsFor: 'testing' stamp: 'ar 8/10/2001 02:47'!isValidMoveFrom: sourceSquare to: destSquare	| move |	move _ (self findValidMovesAt: sourceSquare)			detect:[:any| any destinationSquare = destSquare] ifNone:[nil].	^move notNil! !!ChessPlayer methodsFor: 'testing' stamp: 'ar 8/9/2001 01:23'!isWhitePlayer	^board whitePlayer == self! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/9/2001 17:56'!materialValue	^materialValue! !!ChessPlayer methodsFor: 'adding/removing' stamp: 'ar 8/24/2001 18:18'!movePiece: piece from: sourceSquare to: destSquare	| score |	score _ PieceCenterScores at: piece.	positionalValue _ positionalValue - (score at: sourceSquare).	positionalValue _ positionalValue + (score at: destSquare).	pieces at: sourceSquare put: 0.	pieces at: destSquare put: piece.	board updateHash: piece at: sourceSquare from: self.	board updateHash: piece at: destSquare from: self.	self userAgent ifNotNil:[self userAgent movedPiece: piece from: sourceSquare to: destSquare].! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/9/2001 17:56'!numPawns	^numPawns! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/8/2001 22:35'!opponent	^opponent! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/8/2001 22:35'!opponent: aPlayer	opponent _ aPlayer! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/10/2001 00:38'!pieceAt: square	"Return the piece at the given square"	^pieces at: square! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/10/2001 02:00'!pieces	^pieces! !!ChessPlayer methodsFor: 'evaluation' stamp: 'ar 8/24/2001 15:57'!positionalValue	"Evaluate our current position"	^positionalValue! !!ChessPlayer methodsFor: 'copying' stamp: 'ar 8/10/2001 05:16'!postCopy	pieces _ pieces clone.! !!ChessPlayer methodsFor: 'initialize' stamp: 'ar 8/10/2001 00:37'!prepareNextMove	"Clear enpassant square and reset any pending extra kings"	enpassantSquare _ 0.	castlingRookSquare = 0 ifFalse:[pieces at: castlingRookSquare put: Rook].	castlingRookSquare _ 0.! !!ChessPlayer methodsFor: 'adding/removing' stamp: 'ar 8/24/2001 18:18'!removePiece: piece at: square	pieces at: square put: 0.	materialValue _ materialValue - (PieceValues at: piece).	positionalValue _ positionalValue - ((PieceCenterScores at: piece) at: square).	piece = Pawn ifTrue:[numPawns _ numPawns - 1].	board updateHash: piece at: square from: self.	self userAgent ifNotNil:[self userAgent removedPiece: piece at: square].! !!ChessPlayer methodsFor: 'adding/removing' stamp: 'ar 8/24/2001 18:18'!replacePiece: oldPiece with: newPiece at: square	pieces at: square put: newPiece.	materialValue _ materialValue - (PieceValues at: oldPiece) + (PieceValues at: newPiece).	positionalValue _ positionalValue - ((PieceCenterScores at: oldPiece) at: square).	positionalValue _ positionalValue + ((PieceCenterScores at: newPiece) at: square).	oldPiece = Pawn ifTrue:[numPawns _ numPawns - 1].	newPiece = Pawn ifTrue:[numPawns _ numPawns + 1].	board updateHash: oldPiece at: square from: self.	board updateHash: newPiece at: square from: self.	self userAgent ifNotNil:[self userAgent replacedPiece: oldPiece with: newPiece at: square white: self isWhitePlayer].! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/9/2001 22:22'!undoCastleKingSideMove: move	self prepareNextMove. "in other words, remove extra kings"	self movePiece: move movingPiece from: move destinationSquare to: move sourceSquare.	self movePiece: Rook from: move sourceSquare+1 to: move sourceSquare+3.! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/9/2001 22:22'!undoCastleQueenSideMove: move	self prepareNextMove. "in other words, remove extra kings"	self movePiece: move movingPiece from: move destinationSquare to: move sourceSquare.	self movePiece: Rook from: move sourceSquare-1 to: move sourceSquare-4.! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/9/2001 22:24'!undoDoublePushMove: move	enpassantSquare _ 0.	self movePiece: move movingPiece from: move destinationSquare to: move sourceSquare.! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/10/2001 08:42'!undoEnpassantMove: move	self movePiece: move movingPiece from: move destinationSquare to: move sourceSquare.	opponent addPiece: move capturedPiece at: move destinationSquare - 		(self isWhitePlayer ifTrue:[8] ifFalse:[-8]).! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/10/2001 03:18'!undoMove: move	"Undo the given move"	| action |	self undoPromotion: move.	"Apply basic move"	action _ #(			undoNormalMove:			undoDoublePushMove:			undoEnpassantMove:			undoCastleKingSideMove:			undoCastleQueenSideMove:			undoResign:			undoStaleMate:		) at: (move moveType bitAnd: ChessMove basicMoveMask).	self perform: action with: move.! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/10/2001 08:41'!undoNormalMove: move	| piece |	self movePiece: move movingPiece from: move destinationSquare to: move sourceSquare.	(piece _ move capturedPiece) = EmptySquare 		ifFalse:[opponent addPiece: piece at: move destinationSquare].! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/9/2001 22:20'!undoPromotion: move	| piece |	piece _ move promotion.	piece = 0 ifFalse:[self replacePiece: piece with: move movingPiece at: move destinationSquare].! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/9/2001 22:27'!undoResign: move! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/9/2001 22:27'!undoStaleMate: move! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/9/2001 02:11'!updateCastlingStatus: move	"Cannot castle when king has moved"	(move movingPiece = King) 		ifTrue:[^castlingStatus _ castlingStatus bitOr: CastlingDisableAll].	"See if a rook has moved"	(move movingPiece = Rook) ifFalse:[^self].	self isWhitePlayer ifTrue:[		(move sourceSquare = 1) 			ifTrue:[^castlingStatus _ castlingStatus bitOr: CastlingDisableQueenSide].		(move sourceSquare = 8) 			ifTrue:[^castlingStatus _ castlingStatus bitOr: CastlingDisableKingSide].	] ifFalse:[		(move sourceSquare = 57) 			ifTrue:[^castlingStatus _ castlingStatus bitOr: CastlingDisableQueenSide].		(move sourceSquare = 64) 			ifTrue:[^castlingStatus _ castlingStatus bitOr: CastlingDisableKingSide].	].! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/24/2001 18:17'!userAgent	^board userAgent! !!ChessPlayerAI class methodsFor: 'class initialization' stamp: 'ar 8/12/2001 14:39'!initialize	"ChessPlayerAI initialize"	AlphaBetaGiveUp _ -29990.	AlphaBetaIllegal _ -31000.	AlphaBetaMaxVal _ 30000.	AlphaBetaMinVal _ -30000.	ValueAccurate _ 2.	ValueBoundary _ 4.	ValueLowerBound _ 4.	ValueUpperBound _ 5.	ValueThreshold _ 200.! !!ChessPlayerAI methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:15'!activePlayer: aPlayer	player _ aPlayer.	board _ player board.	generator _ board generator.	self reset.! !!ChessPlayerAI methodsFor: 'searching' stamp: 'dgd 2/22/2003 14:44'!copyVariation: move 	| av mv count |	count := 0.	av := variations at: ply + 1.	ply < 9 		ifTrue: 			[mv := variations at: ply + 2.			count := mv first.			av 				replaceFrom: 3				to: count + 2				with: mv				startingAt: 2].	av at: 1 put: count + 1.	av at: 2 put: move encodedMove! !!ChessPlayerAI methodsFor: 'initialize' stamp: 'ar 10/20/2001 14:28'!initialize	historyTable _ ChessHistoryTable new.	"NOTE: transposition table is initialized only when we make the first move. It costs a little to do all the entries and the garbage collections so we do it only when we *really* need it."	transTable _ nil.	random _ Random new.	nodesVisited _ ttHits _ alphaBetaCuts _ stamp _ 0.	variations _ Array new: 11.	1 to: variations size do:[:i| 		variations at: i put: (Array new: variations size).		(variations at: i) atAllPut: 0].	bestVariation _ Array new: variations size.	bestVariation atAllPut: 0.	activeVariation _ Array new: variations size.	activeVariation atAllPut: 0.	self reset.! !!ChessPlayerAI methodsFor: 'initialize' stamp: 'ar 10/18/2001 23:36'!initializeTranspositionTable	"Initialize the transposition table. Note: For now we only use 64k entries since they're somewhat space intensive. If we should get a serious speedup at some point we may want to increase the transposition table - 256k seems like a good idea; but right now 256k entries cost us roughly 10MB of space. So we use only 64k entries (2.5MB of space).	If you have doubts about the size of the transition table (e.g., if you think it's too small or too big) then modify the value below and have a look at ChessTranspositionTable>>clear which can print out some valuable statistics.	"	transTable _ ChessTranspositionTable new: 16. "1 << 16 entries"! !!ChessPlayerAI methodsFor: 'thinking' stamp: 'ar 10/18/2001 20:14'!isThinking	^myProcess notNil! !!ChessPlayerAI methodsFor: 'searching' stamp: 'dgd 2/22/2003 14:44'!mtdfSearch: theBoard score: estimate depth: depth 	"An implementation of the MTD(f) algorithm. See:		http://www.cs.vu.nl/~aske/mtdf.html	"	| beta move value low high goodMove |	value := estimate.	low := AlphaBetaMinVal.	high := AlphaBetaMaxVal.	[low >= high] whileFalse: 			[beta := value = low ifTrue: [value + 1] ifFalse: [beta := value].			move := self 						searchMove: theBoard						depth: depth						alpha: beta - 1						beta: beta.			stopThinking ifTrue: [^move].			move ifNil: [^move].			value := move value.			value < beta 				ifTrue: [high := value]				ifFalse: 					["NOTE: It is important that we do *NOT* return a move from a search which didn't reach the beta goal (e.g., value < beta). This is because all it means is that we didn't reach beta and the move returned is not the move 'closest' to beta but just one that triggered cut-off. In other words, if we'd take a move which value is less than beta it could mean that this move is a *LOT* worse than beta."					low := value.					goodMove := move.					activeVariation 						replaceFrom: 1						to: activeVariation size						with: (variations first)						startingAt: 1]].	^goodMove! !!ChessPlayerAI methodsFor: 'searching' stamp: 'asm 6/23/2003 22:02'!negaScout: theBoard depth: depth alpha: initialAlpha beta: initialBeta 	"Modified version to return the move rather than the score"	| move score alpha bestScore moveList newBoard beta goodMove a b notFirst |	self		assert: [initialAlpha < initialBeta].	ply < 10		ifTrue: [(variations at: ply + 1)				at: 1				put: 0].	ply _ 0.	alpha _ initialAlpha.	beta _ initialBeta.	bestScore _ AlphaBetaMinVal.	"Generate new moves"	moveList _ generator findPossibleMovesFor: theBoard activePlayer.	moveList		ifNil: [^ nil].	moveList size = 0		ifTrue: [generator recycleMoveList: moveList.			^ nil].	"Sort move list according to history heuristics"	moveList sortUsing: historyTable.	"And search"	a _ alpha.	b _ beta.	notFirst _ false.	[(move _ moveList next) isNil]		whileFalse: [newBoard _ (boardList at: ply + 1)						copyBoard: theBoard.			newBoard nextMove: move.			"Search recursively"			"Search recursively"			ply _ ply + 1.			score _ 0						- (self								ngSearch: newBoard								depth: depth - 1								alpha: 0 - b								beta: 0 - a).			(notFirst					and: [score > a							and: [score < beta									and: [depth > 1]]])				ifTrue: [score _ 0								- (self										ngSearch: newBoard										depth: depth - 1										alpha: 0 - beta										beta: 0 - score)].			notFirst _ true.			ply _ ply - 1.			stopThinking				ifTrue: [generator recycleMoveList: moveList.					^ move].			score = AlphaBetaIllegal				ifFalse: [score > bestScore						ifTrue: [ply < 10								ifTrue: [self copyVariation: move].							goodMove _ move copy.							goodMove value: score.							activeVariation								replaceFrom: 1								to: activeVariation size								with: variations first								startingAt: 1.							bestScore _ score].					"See if we can cut off the search"					score > a						ifTrue: [a _ score.							a >= beta								ifTrue: [transTable										storeBoard: theBoard										value: score										type: (ValueBoundary												bitOr: (ply bitAnd: 1))										depth: depth										stamp: stamp.									historyTable addMove: move.									alphaBetaCuts _ alphaBetaCuts + 1.									generator recycleMoveList: moveList.									^ goodMove]].					b _ a + 1]].	transTable		storeBoard: theBoard		value: bestScore		type: (ValueAccurate				bitOr: (ply bitAnd: 1))		depth: depth		stamp: stamp.	generator recycleMoveList: moveList.	^ goodMove! !!ChessPlayerAI methodsFor: 'searching' stamp: 'dgd 2/22/2003 14:45'!ngSearch: theBoard depth: depth alpha: initialAlpha beta: initialBeta 	"A basic alpha-beta algorithm; based on negaMax rather than from the text books"	| move score alpha entry bestScore moveList newBoard beta a b notFirst |	self assert: [initialAlpha < initialBeta].	ply < 10 ifTrue: [(variations at: ply + 1) at: 1 put: 0].	depth = 0 		ifTrue: 			[^self 				quiesce: theBoard				alpha: initialAlpha				beta: initialBeta].	nodesVisited := nodesVisited + 1.	"See if there's already something in the transposition table. If so, skip the entire search."	entry := transTable lookupBoard: theBoard.	alpha := initialAlpha.	beta := initialBeta.	(entry isNil or: [entry depth < depth]) 		ifFalse: 			[ttHits := ttHits + 1.			(entry valueType bitAnd: 1) = (ply bitAnd: 1) 				ifTrue: [beta := entry value max: initialBeta]				ifFalse: [alpha := 0 - entry value max: initialAlpha].			beta > initialBeta ifTrue: [^beta].			alpha >= initialBeta ifTrue: [^alpha]].	bestScore := AlphaBetaMinVal.	"Generate new moves"	moveList := generator findPossibleMovesFor: theBoard activePlayer.	moveList ifNil: [^0 - AlphaBetaIllegal].	moveList isEmpty 		ifTrue: 			[generator recycleMoveList: moveList.			^bestScore].	"Sort move list according to history heuristics"	moveList sortUsing: historyTable.	"And search"	a := alpha.	b := beta.	notFirst := false.	[(move := moveList next) isNil] whileFalse: 			[newBoard := (boardList at: ply + 1) copyBoard: theBoard.			newBoard nextMove: move.			"Search recursively"			ply := ply + 1.			score := 0 - (self 								ngSearch: newBoard								depth: depth - 1								alpha: 0 - b								beta: 0 - a).			(notFirst and: [score > a and: [score < beta and: [depth > 1]]]) 				ifTrue: 					[score := 0 - (self 										ngSearch: newBoard										depth: depth - 1										alpha: 0 - beta										beta: 0 - score)].			notFirst := true.			ply := ply - 1.			stopThinking 				ifTrue: 					[generator recycleMoveList: moveList.					^score].			score = AlphaBetaIllegal 				ifFalse: 					[score > bestScore 						ifTrue: 							[ply < 10 ifTrue: [self copyVariation: move].							bestScore := score].					score > a 						ifTrue: 							[a := score.							a >= beta 								ifTrue: 									[transTable 										storeBoard: theBoard										value: score										type: (ValueBoundary bitOr: (ply bitAnd: 1))										depth: depth										stamp: stamp.									historyTable addMove: move.									alphaBetaCuts := alphaBetaCuts + 1.									generator recycleMoveList: moveList.									^score]].					b := a + 1]].	transTable 		storeBoard: theBoard		value: bestScore		type: (ValueAccurate bitOr: (ply bitAnd: 1))		depth: depth		stamp: stamp.	generator recycleMoveList: moveList.	^bestScore! !!ChessPlayerAI methodsFor: 'searching' stamp: 'dgd 2/22/2003 14:46'!quiesce: theBoard alpha: initialAlpha beta: initialBeta 	"A variant of alpha-beta considering only captures and null moves to obtain a quiet position, e.g. one that is unlikely to change heavily in the very near future."	| move score alpha entry bestScore moveList newBoard beta |	self assert: [initialAlpha < initialBeta].	ply < 10 ifTrue: [(variations at: ply + 1) at: 1 put: 0].	nodesVisited := nodesVisited + 1.	"See if there's already something in the transposition table."	entry := transTable lookupBoard: theBoard.	alpha := initialAlpha.	beta := initialBeta.	entry isNil 		ifFalse: 			[ttHits := ttHits + 1.			(entry valueType bitAnd: 1) = (ply bitAnd: 1) 				ifTrue: [beta := entry value max: initialBeta]				ifFalse: [alpha := 0 - entry value max: initialAlpha].			beta > initialBeta ifTrue: [^beta].			alpha >= initialBeta ifTrue: [^alpha]].	ply < 2 		ifTrue: 			["Always generate moves if ply < 2 so that we don't miss a move that		would bring the king under attack (e.g., make an invalid move)."			moveList := generator findQuiescenceMovesFor: theBoard activePlayer.			moveList ifNil: [^0 - AlphaBetaIllegal]].	"Evaluate the current position, assuming that we have a non-capturing move."	bestScore := theBoard activePlayer evaluate.	"TODO: What follows is clearly not the Right Thing to do. The score we just evaluated doesn't take into account that we may be under attack at this point. I've seen it happening various times that the static evaluation triggered a cut-off which was plain wrong in the position at hand.	There seem to be three ways to deal with the problem. #1 is just deepen the search. If we go one ply deeper we will most likely find the problem (although that's not entirely certain). #2 is to improve the evaluator function and make it so that the current evaluator is only an estimate saying if it's 'likely' that a non-capturing move will do. The more sophisticated evaluator should then take into account which pieces are under attack. Unfortunately that could make the AI play very passive, e.g., avoiding situations where pieces are under attack even if these attacks are outweighed by other factors. #3 would be to insert a null move here to see *if* we are under attack or not (I've played with this) but for some reason the resulting search seemed to explode rapidly. I'm uncertain if that's due to the transposition table being too small (I don't *really* think so but it may be) or if I've just got something else wrong."	bestScore > alpha 		ifTrue: 			[alpha := bestScore.			bestScore >= beta 				ifTrue: 					[moveList ifNotNil: [generator recycleMoveList: moveList].					^bestScore]].	"Generate new moves"	moveList ifNil: 			[moveList := generator findQuiescenceMovesFor: theBoard activePlayer.			moveList ifNil: [^0 - AlphaBetaIllegal]].	moveList isEmpty 		ifTrue: 			[generator recycleMoveList: moveList.			^bestScore].	"Sort move list according to history heuristics"	moveList sortUsing: historyTable.	"And search"	[(move := moveList next) isNil] whileFalse: 			[newBoard := (boardList at: ply + 1) copyBoard: theBoard.			newBoard nextMove: move.			"Search recursively"			ply := ply + 1.			score := 0 - (self 								quiesce: newBoard								alpha: 0 - beta								beta: 0 - alpha).			stopThinking 				ifTrue: 					[generator recycleMoveList: moveList.					^score].			ply := ply - 1.			score = AlphaBetaIllegal 				ifFalse: 					[score > bestScore 						ifTrue: 							[ply < 10 ifTrue: [self copyVariation: move].							bestScore := score].					"See if we can cut off the search"					score > alpha 						ifTrue: 							[alpha := score.							score >= beta 								ifTrue: 									[transTable 										storeBoard: theBoard										value: score										type: (ValueBoundary bitOr: (ply bitAnd: 1))										depth: 0										stamp: stamp.									historyTable addMove: move.									alphaBetaCuts := alphaBetaCuts + 1.									generator recycleMoveList: moveList.									^bestScore]]]].	transTable 		storeBoard: theBoard		value: bestScore		type: (ValueAccurate bitOr: (ply bitAnd: 1))		depth: 0		stamp: stamp.	generator recycleMoveList: moveList.	^bestScore! !!ChessPlayerAI methodsFor: 'initialize' stamp: 'ar 10/18/2001 22:35'!reset	transTable ifNotNil:[transTable clear].	historyTable clear.! !!ChessPlayerAI methodsFor: 'initialize' stamp: 'ar 10/18/2001 20:52'!reset: aBoard	self reset.	boardList ifNil:[		boardList _ Array new: 100.		1 to: boardList size do:[:i| boardList at: i put: (aBoard copy userAgent: nil)].		boardListIndex _ 0].	board _ aBoard.! !!ChessPlayerAI methodsFor: 'searching' stamp: 'dgd 2/22/2003 14:46'!search: theBoard depth: depth alpha: initialAlpha beta: initialBeta 	"A basic alpha-beta algorithm; based on negaMax rather than from the text books"	| move score alpha entry bestScore moveList newBoard beta |	self assert: [initialAlpha < initialBeta].	ply < 10 ifTrue: [(variations at: ply + 1) at: 1 put: 0].	depth = 0 		ifTrue: 			[^self 				quiesce: theBoard				alpha: initialAlpha				beta: initialBeta].	nodesVisited := nodesVisited + 1.	"See if there's already something in the transposition table. If so, skip the entire search."	entry := transTable lookupBoard: theBoard.	alpha := initialAlpha.	beta := initialBeta.	(entry isNil or: [entry depth < depth]) 		ifFalse: 			[ttHits := ttHits + 1.			(entry valueType bitAnd: 1) = (ply bitAnd: 1) 				ifTrue: [beta := entry value max: initialBeta]				ifFalse: [alpha := 0 - entry value max: initialAlpha].			beta > initialBeta ifTrue: [^beta].			alpha >= initialBeta ifTrue: [^alpha]].	bestScore := AlphaBetaMinVal.	"Generate new moves"	moveList := generator findPossibleMovesFor: theBoard activePlayer.	moveList ifNil: [^0 - AlphaBetaIllegal].	moveList isEmpty 		ifTrue: 			[generator recycleMoveList: moveList.			^bestScore].	"Sort move list according to history heuristics"	moveList sortUsing: historyTable.	"And search"	[(move := moveList next) isNil] whileFalse: 			[newBoard := (boardList at: ply + 1) copyBoard: theBoard.			newBoard nextMove: move.			"Search recursively"			ply := ply + 1.			score := 0 - (self 								search: newBoard								depth: depth - 1								alpha: 0 - beta								beta: 0 - alpha).			stopThinking 				ifTrue: 					[generator recycleMoveList: moveList.					^score].			ply := ply - 1.			score = AlphaBetaIllegal 				ifFalse: 					[score > bestScore 						ifTrue: 							[ply < 10 ifTrue: [self copyVariation: move].							bestScore := score].					"See if we can cut off the search"					score > alpha 						ifTrue: 							[alpha := score.							score >= beta 								ifTrue: 									[transTable 										storeBoard: theBoard										value: score										type: (ValueBoundary bitOr: (ply bitAnd: 1))										depth: depth										stamp: stamp.									historyTable addMove: move.									alphaBetaCuts := alphaBetaCuts + 1.									generator recycleMoveList: moveList.									^bestScore]]]].	transTable 		storeBoard: theBoard		value: bestScore		type: (ValueAccurate bitOr: (ply bitAnd: 1))		depth: depth		stamp: stamp.	generator recycleMoveList: moveList.	^bestScore! !!ChessPlayerAI methodsFor: 'searching' stamp: 'dgd 2/22/2003 14:47'!searchMove: theBoard depth: depth alpha: initialAlpha beta: initialBeta 	"Modified version to return the move rather than the score"	| move score alpha bestScore moveList newBoard beta goodMove |	self assert: [initialAlpha < initialBeta].	ply < 10 ifTrue: [(variations at: ply + 1) at: 1 put: 0].	ply := 0.	alpha := initialAlpha.	beta := initialBeta.	bestScore := AlphaBetaMinVal.	"Generate new moves"	moveList := generator findPossibleMovesFor: theBoard activePlayer.	moveList ifNil: [^nil].	moveList isEmpty 		ifTrue: 			[generator recycleMoveList: moveList.			^nil].	"Sort move list according to history heuristics"	moveList sortUsing: historyTable.	"And search"	[(move := moveList next) isNil] whileFalse: 			[newBoard := (boardList at: ply + 1) copyBoard: theBoard.			newBoard nextMove: move.			"Search recursively"			ply := ply + 1.			score := 0 - (self 								search: newBoard								depth: depth - 1								alpha: 0 - beta								beta: 0 - alpha).			stopThinking 				ifTrue: 					[generator recycleMoveList: moveList.					^move].			ply := ply - 1.			score = AlphaBetaIllegal 				ifFalse: 					[score > bestScore 						ifTrue: 							[ply < 10 ifTrue: [self copyVariation: move].							goodMove := move copy.							goodMove value: score.							bestScore := score].					"See if we can cut off the search"					score > alpha 						ifTrue: 							[alpha := score.							score >= beta 								ifTrue: 									[transTable 										storeBoard: theBoard										value: score										type: (ValueBoundary bitOr: (ply bitAnd: 1))										depth: depth										stamp: stamp.									historyTable addMove: move.									alphaBetaCuts := alphaBetaCuts + 1.									generator recycleMoveList: moveList.									^goodMove]]]].	transTable 		storeBoard: theBoard		value: bestScore		type: (ValueAccurate bitOr: (ply bitAnd: 1))		depth: depth		stamp: stamp.	generator recycleMoveList: moveList.	^goodMove! !!ChessPlayerAI methodsFor: 'thinking' stamp: 'ar 10/18/2001 20:15'!startThinking	self isThinking ifTrue:[^self].	self activePlayer: board activePlayer.	self thinkStep.! !!ChessPlayerAI methodsFor: 'accessing' stamp: 'jdl 3/28/2003 08:12'!statusString	| av count |	^String streamContents: 			[:s | 			(myMove == #none or: [myMove isNil]) 				ifFalse: 					[s						print: myMove value * 0.01;						space].			av := bestVariation.			count := av first.			count > 0 				ifFalse: 					[av := activeVariation.					count := av first].			count > 0 				ifFalse: 					[s nextPutAll: '***'.					av := variations first.					count := av first.					count := count min: 3].			2 to: count + 1				do: 					[:index | 					s nextPutAll: (ChessMove decodeFrom: (av at: index)) moveString.					s space].			s nextPut: $[.			s print: nodesVisited.			"		s nextPut:$|.		s print: ttHits.		s nextPut: $|.		s print: alphaBetaCuts."			s nextPut: $]]! !!ChessPlayerAI methodsFor: 'thinking' stamp: 'dgd 2/22/2003 14:47'!think	| move |	self isThinking ifTrue: [^nil].	self startThinking.	[(move := self thinkStep) isNil] whileTrue.	^move! !!ChessPlayerAI methodsFor: 'thinking' stamp: 'aoy 2/15/2003 21:21'!thinkProcess	| score theMove depth |	stopThinking := false.	score := board activePlayer evaluate.	depth := 1.	stamp := stamp + 1.	ply := 0.	historyTable clear.	transTable clear.	startTime := Time millisecondClockValue.	nodesVisited := ttHits := alphaBetaCuts := 0.	bestVariation at: 1 put: 0.	activeVariation at: 1 put: 0.	[nodesVisited < 50000] whileTrue: 			["whats this ? (aoy)  false ifTrue:[] ????!!"			theMove := false 						ifTrue: 							[self 								mtdfSearch: board								score: score								depth: depth]						ifFalse: 							[self 								negaScout: board								depth: depth								alpha: AlphaBetaMinVal								beta: AlphaBetaMaxVal].			theMove ifNil: [^myProcess := nil].			stopThinking ifTrue: [^myProcess := nil].			myMove := theMove.			bestVariation 				replaceFrom: 1				to: bestVariation size				with: activeVariation				startingAt: 1.			score := theMove value.			depth := depth + 1].	myProcess := nil! !!ChessPlayerAI methodsFor: 'thinking' stamp: 'dgd 2/22/2003 14:48'!thinkStep	transTable ifNil: [self initializeTranspositionTable].	myProcess isNil 		ifTrue: 			[myMove := #none.			false 				ifTrue: 					[self thinkProcess.					^myMove].			myProcess := [self thinkProcess] forkAt: Processor userBackgroundPriority.			myProcess suspend.			^nil].	myProcess resume.	(Delay forMilliseconds: 50) wait.	myProcess ifNil: [^myMove == #none ifTrue: [nil] ifFalse: [myMove]].	myProcess suspend.	"Do we have a valid move?"	myMove == #none ifTrue: [^nil].	"no"	"Did we time out?"	Time millisecondClockValue - startTime > self timeToThink 		ifTrue: 			["Yes. Abort and return current move."			stopThinking := true.			myProcess resume.			[myProcess isNil] whileFalse: [(Delay forMilliseconds: 10) wait].			^myMove == #none ifTrue: [nil] ifFalse: [myMove]].	"Keep thinking"	^nil! !!ChessPlayerAI methodsFor: 'thinking' stamp: 'ar 10/21/2001 01:12'!timeToThink	"Return the number of milliseconds we're allowed to think"	^5000! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/10/2001 19:36'!clear	value _ valueType _ timeStamp _ depth _ -1.! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/10/2001 19:05'!depth	^depth! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 10/19/2001 00:04'!depth: aNumber	depth _ aNumber! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/8/2001 09:14'!hashLock	^hashLock! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/8/2001 09:14'!hashLock: aNumber	hashLock _ aNumber! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/8/2001 09:14'!timeStamp	^timeStamp! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/8/2001 09:14'!timeStamp: aNumber	timeStamp _ aNumber! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/10/2001 19:37'!value	^value! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/10/2001 19:37'!value: newValue	value _ newValue! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/10/2001 19:37'!valueType	^valueType! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/10/2001 19:37'!valueType: newType	valueType _ newType! !!ChessTranspositionTable class methodsFor: 'instance creation' stamp: 'ar 8/8/2001 09:15'!new: bits	^self basicNew initialize: bits! !!ChessTranspositionTable methodsFor: 'initialize' stamp: 'dgd 2/22/2003 13:24'!clear	"Set the following to true for printing information about the fill rate and number of collisions. The transposition table should have *plenty* of free space (it should rarely exceed 30% fill rate) and *very* few collisions (those require us to evaluate positions repeatedly that we've evaluated before -- bad idea!!)"	| entry |	false 		ifTrue: 			[used position > 0 				ifTrue: 					['entries used:	' , used position printString , ' (' 						, (used position * 100 // array size) printString , '%)	' 						displayAt: 0 @ 0].			collisions > 0 				ifTrue: 					['collisions:		' , collisions printString , ' (' 						, (collisions * 100 // array size) printString , '%)	' 						displayAt: 0 @ 15]].	used position: 0.	[(entry := used next) isNil] whileFalse: [entry clear].	used resetToStart.	collisions := 0! !!ChessTranspositionTable methodsFor: 'initialize' stamp: 'ar 10/18/2001 23:28'!initialize: nBits	"Initialize the receiver using 1<<nBits entries. See also ChessPlayerAI>>initializeTranspositionTable."	| entry |	array _ Array new: 1 << nBits.	used _ ReadWriteStream on: (Array new: 50000). "<- will grow if not sufficient!!"	entry _ ChessTTEntry new clear.	1 to: array size do:[:i| array at: i put: entry clone].	collisions _ 0.	Smalltalk garbageCollect. "We *really* want them old here"! !!ChessTranspositionTable methodsFor: 'lookup' stamp: 'ar 8/12/2001 14:06'!lookupBoard: aBoard	| key entry |	key _ aBoard hashKey bitAnd: array size - 1.	entry _ array at: key + 1.	entry ifNil:[^nil].	entry valueType = -1 ifTrue:[^nil].	entry hashLock = aBoard hashLock ifFalse:[^nil].	^entry! !!ChessTranspositionTable methodsFor: 'initialize' stamp: 'ar 10/18/2001 23:32'!storeBoard: aBoard value: value type: valueType depth: depth stamp: timeStamp	| key entry |	key _ aBoard hashKey bitAnd: array size - 1.	entry _ array at: key + 1.	entry valueType = -1 		ifTrue:[used nextPut: entry]		ifFalse:[entry hashLock = aBoard hashLock ifFalse:[collisions _ collisions + 1]].	(entry valueType = -1 		or:[entry depth <= depth		or:[entry timeStamp < timeStamp]]) ifFalse:[^self].	entry hashLock: aBoard hashLock.	entry value: value.	entry valueType: valueType.	entry depth: depth.	entry timeStamp: timeStamp.! !!FreeCellStatistics class methodsFor: 'instance creation' stamp: 'di 1/16/2000 10:39'!includeInNewMorphMenu	^false! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'ar 11/9/2000 21:17'!buildButton: aButton target: aTarget label: aLabel selector: aSelector	"wrap a button or switch in an alignmentMorph to provide some space around the button"	| a |	aButton 		target: aTarget;		label: aLabel;		actionSelector: aSelector;		borderColor: #raised;		borderWidth: 2;		color: Color gray.	a _ AlignmentMorph newColumn		wrapCentering: #center; cellPositioning: #topCenter;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: Color transparent;		layoutInset: 1.	a addMorph: aButton.	^ a! !!FreeCellStatistics methodsFor: 'updating' stamp: 'djp 10/24/1999 19:04'!changed	window ifNotNil: [		statsMorph ifNotNil: [statsMorph contents: self statsText]]! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 19:20'!close	window ifNotNil: [		window delete.		window _ nil].! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 16:42'!color	^Color green darker! !!FreeCellStatistics methodsFor: 'initialization' stamp: 'asm 11/24/2003 23:10'!defaultColor	"answer the default color/fill style for the receiver"	^ Color green! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'asm 11/24/2003 22:55'!display	| panel |	(window notNil and: [window owner notNil]) ifTrue: [window activate. ^nil].	panel _ AlignmentMorph newColumn.	panel		wrapCentering: #center; cellPositioning: #topCenter;		hResizing: #rigid;		vResizing: #rigid;		extent: 250@150;		color: self color;		addMorphBack: self makeStatistics;		addMorphBack: self makeControls.	window _ panel openInWindowLabeled: 'FreeCell Statistics' translated.! !!FreeCellStatistics methodsFor: 'actions' stamp: 'di 3/5/2000 14:30'!gameLost: gameNumber	"Don't count multiple losses of the same game"	gameNumber = lastGameLost ifTrue: [^ self].	lastGameLost _ gameNumber.	sessionLosses _ sessionLosses + 1.	totalLosses _ totalLosses + 1.	lossesWithReplay _ lossesWithReplay + 1.	currentType = #losses		ifTrue: [currentCount _ currentCount + 1]		ifFalse: 			[currentCount _ 1.			currentType _ #losses].	self updateStreak.	self changed! !!FreeCellStatistics methodsFor: 'actions' stamp: 'di 3/5/2000 16:48'!gameWon: gameNumber	sessionWins _ sessionWins + 1.	totalWins _ totalWins + 1.	gameNumber = lastGameWon ifFalse:		[gameNumber = lastGameLost ifTrue:			["Finally won a game by replaying"			lossesWithReplay _ lossesWithReplay - 1].		winsWithReplay _ winsWithReplay + 1].	lastGameWon _ gameNumber.	currentType = #wins		ifTrue: [currentCount _ currentCount + 1]		ifFalse: [currentCount _ 1.				currentType _ #wins].	self updateStreak.	self changed! !!FreeCellStatistics methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:56'!initialize	super initialize.	self reset! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'ar 11/9/2000 21:18'!makeControls	| row |	row _ AlignmentMorph newRow.	row		wrapCentering: #center; cellPositioning: #leftCenter;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: self color;		borderWidth: 2;		borderColor: #inset;		addMorphBack: self makeOkButton;		addMorphBack: self makeResetButton.	^row.! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 16:34'!makeOkButton	^self		buildButton: SimpleButtonMorph new		target: self		label: 'OK'		selector: #ok! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 17:07'!makeResetButton	^self		buildButton: SimpleButtonMorph new		target: self		label: 'Reset'		selector: #reset! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'ar 11/9/2000 21:26'!makeStatistics	| row |	row _ AlignmentMorph newRow.	row		wrapCentering: #center; cellPositioning: #leftCenter;		hResizing: #spaceFill;		vResizing: #spaceFill;		color: self color;		borderWidth: 2;		borderColor: #inset;		addMorphBack: (AlignmentMorph newColumn			wrapCentering: #center; cellPositioning: #topCenter;			color: self color;			addMorph: (statsMorph _ TextMorph new contents: self statsText)).	^row.! !!FreeCellStatistics methodsFor: 'actions' stamp: 'djp 10/24/1999 19:21'!newSession	sessionWins _ 0.	sessionLosses _ 0.	currentCount _ 0.	currentType _ nil.	self changed.! !!FreeCellStatistics methodsFor: 'actions' stamp: 'djp 10/24/1999 17:15'!ok	window delete.	window _ nil.! !!FreeCellStatistics methodsFor: 'printing' stamp: 'asm 11/24/2003 22:57'!print: aNumber type: type on: aStream 	"I moved the code from #printWins:on: and #printLosses:on: here because 	it is basically 	the same. I hope this increases the maintainability. - th 12/20/1999 20:37"	aStream print: aNumber.	type = #wins		ifTrue: [aNumber = 1				ifTrue: [aStream nextPutAll: ' win' translated]				ifFalse: [aStream nextPutAll: ' wins' translated]].	type = #losses		ifTrue: [aNumber = 1				ifTrue: [aStream nextPutAll: ' loss' translated]				ifFalse: [aStream nextPutAll: ' losses' translated]]! !!FreeCellStatistics methodsFor: 'printing' stamp: 'di 3/5/2000 15:22'!printOn: aStream	self printSessionOn: aStream.	aStream cr.	self printTotalOn: aStream.	aStream cr.	self printReplaysOn: aStream.	aStream cr.	self printStreaksOn: aStream.! !!FreeCellStatistics methodsFor: 'printing' stamp: 'asm 11/24/2003 23:02'!printReplaysOn: aStream 	| total |	aStream nextPutAll: 'With replays: ' translated;		 tab.	self		print: winsWithReplay		type: #wins		on: aStream.	aStream nextPutAll: ', '.	self		print: lossesWithReplay		type: #losses		on: aStream.	total := winsWithReplay + lossesWithReplay.	total ~~ 0		ifTrue: [aStream nextPutAll: ', ';				 print: (winsWithReplay / total * 100) asInteger;				 nextPut: $%]! !!FreeCellStatistics methodsFor: 'printing' stamp: 'asm 11/24/2003 23:02'!printSessionOn: aStream 	| total |	aStream nextPutAll: 'This session: ' translated, String tab.	self		print: sessionWins		type: #wins		on: aStream.	aStream nextPutAll: ', '.	self		print: sessionLosses		type: #losses		on: aStream.	total := sessionWins + sessionLosses.	total ~~ 0		ifTrue: [aStream nextPutAll: ', ';				 print: (sessionWins / total * 100) asInteger;				 nextPut: $%]! !!FreeCellStatistics methodsFor: 'printing' stamp: 'asm 11/24/2003 23:02'!printStreaksOn: aStream 	aStream nextPutAll: 'Streaks: ' translated;		 tab;		 tab.	self		print: streakWins		type: #wins		on: aStream.	aStream nextPutAll: ', '.	self		print: streakLosses		type: #losses		on: aStream.	aStream cr; tab; tab; tab; tab; nextPutAll: 'Current: '.	self		print: currentCount		type: currentType		on: aStream! !!FreeCellStatistics methodsFor: 'printing' stamp: 'asm 11/24/2003 23:03'!printTotalOn: aStream 	| total |	aStream nextPutAll: 'Total: ' translated;		 tab;		 tab;		 tab.	self		print: totalWins		type: #wins		on: aStream.	aStream nextPutAll: ', '.	self		print: totalLosses		type: #losses		on: aStream.	total := totalWins + totalLosses.	total ~~ 0		ifTrue: [aStream nextPutAll: ', ';				 print: (totalWins / total * 100) asInteger;				 nextPut: $%]! !!FreeCellStatistics methodsFor: 'actions' stamp: 'di 3/5/2000 14:30'!reset	sessionWins 		_ 0.	sessionLosses 	_ 0.	totalWins 		_ 0.	totalLosses 		_ 0.	streakWins		_ 0.	streakLosses 	_ 0. 	winsWithReplay _ 0.	lossesWithReplay _ 0.	lastGameWon	_ 0.	lastGameLost 	_ 0.	currentCount 	_ 0.	currentType		_ nil.	self changed.		! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 19:04'!statsText	^ String cr,self printString,String cr! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 15:56'!stringMorphFromPrintOn: aSelector		^StringMorph new 		contents: (String streamContents: [:s | self perform: aSelector with: s]);		yourself.! !!FreeCellStatistics methodsFor: 'actions' stamp: 'th 12/20/1999 20:42'!updateStreak	"I moved the code from #printWins:on: and #printLosses:on: here because 	 it is basically the same. I hope this increases the maintainability. 	th 12/20/1999 20:41"	currentType = #losses ifTrue: [streakLosses _ streakLosses max: currentCount].	currentType = #wins ifTrue: [streakWins _ streakWins max: currentCount]! !!PlayingCard class methodsFor: 'all' stamp: 'di 10/13/1999 17:26'!imageData ^ 'AgQALwAlAAAAAIDjaN4VEeFDEREREBIiIiIiIiIiIYiBiIGIgYiIiIgSIiIiEBIiIiIREiIiIhgRGBEYERiBiIEiIiIiEBIiIiERESIiIiFEREREREQRGBIiIiIiEBIiIhERERIiIiIRERERERFEQSIiIiISEBIiIhERERIiIiIRERERERERESIiIiEREBIiIhERERIiIiESIiIiISERESIiIhIUEBIiIiERESIiIhISIiIiISEhESIiIhIUEBIiERIREhESIhIRESERESEhISIiIhIUEBIhERERERERIhEREhESESEhISIiIhIUEBIREREREREREhISIhIiISEhISIiIhIUEBIREREREREREhISIhIiISEhISIiIhIUEBIREREREREREhISIhIiISEhISIiIhIUEBIhEREhIRERIhISIREiISEhISIiIhIUEBIiERIKISIREuIfIhEhISEhESIiEhQQEiIiIhESIiIhERIhESIhISEhIhIiEhQQEiIiIRERIiIiEhIiIiIhISISEhEiEhQQEiIiIiIiIiIREhISIhIRISERIRQREhQQEiIiIiIiIiEiEhISEhISESEhIUREEhQQEiIiIiIiIiEhIhISEhIRISIhFIREEhQQEiIiIiIiEREiISEhQSEiFBEUSIREEhQQEiIiIiERERERERQURBQRREQURESBEhQQEiIiERRBiBEhGBFERERERBFIREQSEhQQEiIhREREGIEREYERREREERSIRIEiEhQQEiEUJCQkIYgRIYGBEUQRGBRERBIhEhQQEhEURERERBiBERgYERERgUREgSIREhQQFBESQkJCQkGIERgYgREYgUhEQSEREhQQFBEUREREREEYQRGBGBGBFIhEEiEREhQQFBEUJCQkJCERhBGBiIiIFERIEhFBEhQQFBEUREQREUEUGBEYERQRFEREEhEREhQQEYgRQkEiIhEREYEYGIiIFISBIhFBEhQQGIiBRBIhEiEUQYEYERQRSIRBIREREhQQEYgRFBIUQSERERgRgYiBRESBIRERERQQERERERIUQSEURBgRgRQRRERBIREiEiEQEUQRERIhEiERERGBgYiBRISBIRIiIREQEREREREiIhERERERERERSIRBIRIRIiEQESISIREREUQSIiFEQRERFESBIRIiEREQBAAvACUAAAAAgONk3hURExERERAYiIiIiIQRQhISESEJIuNPIiIiEBGIiIiIhBFCESEhESIiIiIiIhESIiIiEBIYiIgRhBFCEiESESIiIiIiIRERIiIiEBIhiIgYRBFCEhIhISIiIiIiEREREiIiEBIhiIiEQRRCESIiERIiIiIiEREREiIiEBIiGIiEQRQiEiIiIRIiIiIiEREREiIiEBIiGBGEERQiERIREUEiIiIiIRERIiIiEBIiGBhEEUQhIRIhEUEiIiIREhESERIiEBIhiIRBEUIhIiEiIRQSIiEREREREREiEBIhiIRBFEISIiEiIRQSIhERERERERESEBIYEUQRRCISIiEiIRFBIhERERERERESEBGIFEERQiEiIhESIUFEEhERERERERESEBIRRBEUQiEiIiIiIUQUQSERESEhEREiEBIiERFEIhQSIhESERQRRBIREiEiERIiEBIiIRFCIhFBIiEiERFBFEEiIhESIiIiEBIiERRCIRgREiIhgREUEUQSIRERIiIiEBIhEUQhFISBgREYFIhBRBFBIiIiIiIiEBIRFEISIUhEgYGESIQSFEEUEiIRIiIiEBERQRERERSIRERIiEEREUQUEiFEESIiEBEUiIERESEUiIiIRBISGBQUEhQRRBIiEBGIGIgSISIRFBEUESIRgYFBIUREQSIiEBiIgYGBISERIURBIREYiBESIhEUEhESEBRERBiIEREhIUhBISGBgRGBIiIhIYiBEBREREGIGBEhIURBIRiIFBGBEhESGIESEBREREQRiIgRERQREYGBRBGBEYiBEREiEBgYGBREEYGIiBEYiIERhBGBGIgSEiISEBGBgYGBRBEYiIiIgRERhEEYERESIRESEBgYEREREUSBERERERgRhEERRBQRISISEBGBGIiIiBFEgREYEYEYREQUIkERERESEBgYiBERGIgUQRERgYEYREGBQkQUEiISEBGIERgYERiBSBERGBEYRBiBFERBEREiEBQRGBgYGBGIFBERgYEYRBgYgUIkFBIiEBRBGBEREYgYFIEYERgYQYgRERQkQREiEBQkEUREQREYgUGBEREYQYGIFEFERBQSEBQiQUIiRBiBgRERGIEREYERFCIUIkEREBFERBIRJBERgURBREQYgYGIFCEhQkQUEAQALwAlAAAAAIDjaN4VEeE/EREREBIiIiEUFEFEQUFEFBREFBIiIiIiIiIiEBEiIiIRQUQUQUFEFBRBQSIiIhESIiIiEBQSIiIhFBRBEUERFBEUEiIiIRERIiIiEBRBIiIiFERERERERERBEiIiEREREiIiEBREEiIiERERERERERERIiIiEREREiIiEBERESIiGBIiIiIhgYGBIiIiEREREiIiEBiIEiIiGBIiIiIhgYGBIiIiIRERIiIiEBGIEiIiGBERIREhgYGBIiIREhESERIiEBiIEiIiGBESERIRgYGBIiEREREREREiEBGIEiIiGBIiEiIhgYGBIhERERERERESEBiIEiIhGBIiEiIhgYGBIhERERERERESEBGIEiIYGBIiEiIhgYGBIhERERERERESEBiIEiIYGBIhESIhgYGBEiERESEhEREiEAoRGBIi4iMiIiGBgRiBIhESISIREiIQGIgSIYgYISERIiGBEYgRIiIiERIiIiIQERgSIYGIESIiIhGBiBERESIhEREiIiIQGIgSIYiBFBIiIUGBGBESEhIiIiIiIiIQGIgRIhEUFEERFEQYiBEhEkESIiIiIiEQEYEiEUFBFERBFEQREREYEkRBEiIiIhgQEhIiIRQUFIhBEUESIRIYEkSEIRIiIYgQERERIUFBFERBIREiESGIEkiIQhERGIgQEiESIRQUFIhBIhIhEhiIEohIghERGIgQERgSIUFBFERBEiIRIYgREkiIQhERGIgQEhgSIRQUFIhBESESQYiIEkSEQhERGIgQEYgSIUFBFERBIREkGIEREkREQhERGIgQEhgSFBQRFIhBEhIRiIiIEkSEQhERGIgQEYgREUERFERBQSFBgYEREkiIQhERGIgQGIgRERERSIQYFBQYiIiIEohIghERGIgQGIgRIREhREQRgUGBgREREkiIQRFEGIgQGIgSIhIhSIQYiBiIiIiIEkSEQUSIGIgQGIgSEiIRREQREYgYEREREhERREREGIgQGIgRISEhSIQYiIiIiIiIESIUSIREGIgQGIgSEhIRREQRhBgRGBSBIiFEREQRGIgQGIgRISEkiEGIgUEiIUESIiFIhEESGIgQGIgSEhIUREEYiBIREhIiIhRERBISGIgQGIgRISEUiEGBESFEQSEiIRSIQSEhGIgQBAAvACUAAAAAgONg3hUR4dsREREQEiIiIiIiIhiIgYiBiIiIiIiIgSIiIiIQEiIiIkIiIiGIERgRGIGIiIiIEiIREiEQEiIiJEQiIiIURERESBEYgYiBIiGBIhQQEiIiRERCIiIRERERFERIERgRIhiBIhQQEiIpRERJIiIhEREREREUREQSIhiBIhQQEiKUREREkiIhIiIiESERERESIYgSEREQEiKUREREkiIhIRIiEhIRERESIYEiQkIQEiRERERERCIhESEiEhISEhISIRIiQkIQEkREREREREImIiIiEhISEhISIYEiEhIQEiRERERERCISIiIiEhISEhISIYgSEREQEiKUREREkiEiIiIiEhISEhISIhiBIhQQEiKUREREkiEWIiIiISEhISEhIhiBIhQQEiIpRERJIiIhERISISEhISEhIiGBIhQQEiIiRERCIiIhIhESIhISEhISEiIREhQQEiIiJEQiIiIiESIiIiEhISEhISIiIhQQEiIiIkIiIiIhIiIiERIhISEhISIiIhQQEiERIiIiIiIhEiIhIiEhISEhISIiIhQQEhISERIiIhEhIiIhIRIhISEhISIiIhQQEhEhISEiISESIiIhEiISEhISEiIiIhQQERISEhISISIiIiIiCRFbIiIUEBEhISIiIRgSIiIRERERiBIiGIEiEREREBISEiIhERGBEREREREhGIEhEYgSIYgSEBIhIhERFEEYERRBERIRIYgREhiBIRiBEBIiEUEYFEERgUFEEQkR4ScRIYIQEhFEREGBEhGBRBQRiIiIiIiIiBEREREQEUREQRgYEUQRFEESEhISEhISIYEREREQFERBGIiBgUQYERIiIiIiIiIiGBRBEiEQFEEYiIERGBEYEiIRERERERIhgYFEESEQFBiIgRERGBIYEhGIiIiIiBIYEUgUQREQEYiBEREhGBEYEYgRERERgSGBiBSBRBEQGIgRESIhEYERGBERREQYEiGBGIFIFEEQGIFEERIiEYERgRFEREQYEhgREYEREREQGBQUQREiEYERgRERERGBIhgRERSBSBQQEYhBRBESERgRgUREREGBIYERGBSBSBQQEUiEFEERIRgRgRERERgSIYEUSBQREREQFEFIhBERERERGBIiIhgRERERERSIQUQQBAAvACUAAAAAgONo3hUR4bsREREQEhiIiIiIFEEiEhIRgSIiIiIiIiIiIiIQEiGIiIEYFEEhISEhiBIiIiIiIkIiIiIQEiGIiIiIFEEiIRIRGBIiIiIiJEQiIiIQEiIYiIEYFEEiEiEhEYEiIiIiRERCIiIQEiIYiIiBFBIRIiIRERgSIiIpRERJIiIQEiIYiBGBRBEiIiIhQRgSIiKUREREkiIQEiIYiIgRQSIREhERQRGBIiKUREREkiIQEiIYgRgUQSEhESERRBGBIiRERERERCIQEiIYiIEUESIiISIhRBEYEkREREREREIQEiGIEYFEEhIiISIhREEYEiRERERERCIQEiGIiBFBISEiISIhREEYEiKUREREkiIQEhiBgRRBIRIiERIhREEYEiKUREREkiIQEiGIEUQSISIiIiIhREQRgSIpRERJIiIQEiIRFEEiFBIiERIYFEQRgSIiRERCIiIQEiIhRBIiEUEiISIYEUQRgSIiJEQiIiIQEiIUQSIhiBESIiGIEhQRgSIiIkIiIiIQEiFEERESGIgRERGIEhERgSIiIiIiIiIQEhRBEhERIREYiIERIRERgSIiIhESIiIQEUQRIQohERIi4acREhGBIiIRiBEiIhAUQSESERERESIiIhESERgRIiIYEYgSEhAUGBIRESESEREREREhIRGBIiGIiIEiERAREYEhEREhIRESERESERIYEiIRGBIhgRARGBgSEREhISEhISERESGIESIiIRIYgRARgRGBIhESEREhIREREhiBERIiIhGBEhAYEUEYESERERESERESIYGBEhEiIRERIhARFBGBiBEYERERERIhGBGBIRESEiIREhARQRgUEYgRESIiIiEYgRGBIRERIhESEhAUEYERQhGIgRERERiBEUGBIREYEiEhEhARGBFBFCERGIiIiIEYEUGBEhGIESISEhARgRgUEUJBgRERERiIEUIYERiBERISEhAYERgRQSQhGBERGIEYEUIYgYgSEhEhIhASEhGBQUJCGBJBGIiIEUJBiIERERESIhARERGBQSQhGBJBGBEYEUEUGBESEhIRIhASEhIYEUJCGBJBGIiIERRBgRgREREREhAREREYFCQhGBERERERREhBgUGBEhISERASEhIRgUJCGBREREREiIQYESQYERERERAEAC8AJQAAAACA42neFRHjZxERERASIiIiIhQkRCRCRCRCRCQRIiIiIiIiIhASIiIiIiFCRCRCRCRCQkESIiIiQiIiIhASIiIiIiIUIiRCIiRCJBEiIiIkRCIiIhARIiIiIiIhRERERERERBIiIiJEREIiIhAREiIiIiIhERERERERERIiIilEREkiIhARgSIiIiIhERGBIiIiIhEiIpRERESSIhARgSIiIiIhEYGBIiIiIhEiIpRERESSIhARgSIiIiIhgYGBIREhERgSJEREREREIhARgSIiEiIhgYGBEhESERgSREREREREQhARgSIhEiIhgYGBIiISIhgSJEREREREIhARgSEYEiIhgYGBIiISIhgSIpRERESSIhARERiBIiIhgYGBIiISIhgSIpRERESSIhAUiIERIiIhgYGBIiERIhgSIilEREkiIhARgRESIiIhgYGBIiIiIhgREiJEREIiIhAUgRIiIiEYgYGBIiERISgYgSIkRCIiIhARgSIiIhiBgYGBEiIiIRiBgSIiQiIiIhAUgSIiIhgRgRgUISIiEkGIgSIiIiIiIRARgSIiIhiIGIFERBERREQRERIiIiIiFBAUgSIiIhERERFEREREREESGBESIiIhgRARgSIiEUERIRERREREQRERGBIREiIhhBAUgSIRGBQRESEREREREREhGBEYgRIhgRARgREREYFBEREhERERESERGBIYgUERhBAUgRERERgUERERISEhIRFBGBERgURBgRARgRFBERGBQREREREREUFBGIEhiBFBhBARESEUEREYFBFBQUFBQUFBIYERGIgRgRASISGBQRERgUEUhISEhISBIYgSERiBhBARESEYFBERGBQRQUFBQUFBIRiBEhERgRASIRGBgUEREYFBEUFBQUFBIRGIgREhhBAREUQYERgRERgUEUFBQUFBIRIRiIERgRASESQYGIFBERGBQRSEhISBIRISEYiBhBARgURBgRFIEREYFBFBQUFBIRIRgRERgRARgSJBgYFIQRERgUERQUFBIRIREYFBhBAUgURBgRFISBEhGBQRQUFBIRIYgYEhgRARgSJBgYFIQRERFIFBFISBERIRGBRBhBAUgURBgRFIESERhEgUEUFBERGIGBQhgRARgSJBgYFBEREUGESBQRQRIRERgURBhBAEAC8AJQAAAACA42neFRHjZxERERASIiIiIiIiIhgYiBiIGIgYiIiBIiIiIhASIkRJIilEQiERgRGBEYERgRgSIiIiIhASJEREkpRERCIYiIiIiIiBiBEiESIiIhASREREQkREREIhREREREiIiBIhiBIiIhASREREREREREIhERERERRERBIhiBESIhASREREREREREIhIiIiIhERERERgSIRIhASREREREREREIhIiIiIhISEhIhgSIYEhASlERERERERJIRERIRERISEhEYgREYEhASKURERERESSEhESERIRISEhEYgRIhIhASKURERERESSEhIiEiIhISEhIYgSIhIhASIpREREREQiEhIiEiIhISEhIhERERIhASIiREREREIiEhIiEiIhISEiEiFERBIhASIiJERERCIhISIhESIiEhISEhEREREhASIiIkREQiIhISIiIiIiEiEhIRQUFBQRASIiIiREIiIiESEhESIiISEhIUREREERASIiIiJCIhEREiEiIiISEhISIRRERBIhASIiIiIiERQRIhISIhISEhIiEiERQSRBASIiIiERERFBESISEhIREiIRISIhEUQRASIiIRFBIhFEEhEiEhIhIREiIiEUERERASIhEiFBIiEUQRIhEhEhiBIhIhQUGBERASERISFBISIRRBEYESEYiBISIUgUERgRARiEEhIUEhIhRBGBgRiIgSIiFIFBERGBAYREESIUEiIhFEEYEYiIgRIiGEFBgRERAUQRERIhQSEiFEQRGIiIgSIhhBQRSIERAUEREUEhRBISEUQRiIiIEiEhQUQREYgRARgRFEQSFEEiIURBiIiBEhIhFEERFEiBAYRIERRBIURBIRQYiIgUEiIRRBERRESBAUSIhBEREhFEESEYiIgRIhFEEREUSEGBAUiIFIgRESIREREREREREUQRERFEREiBAYiBQRGBEREiIiRERERERBERERRIQYgRAYiBSIiBgSIiQRERERERESEREURESIgRAYiBQRGBgSIiIiIhREQSIiERFEhBiIERAYiBSIiBgSIiIiERJEQSEhERSERIiBERARiIFIgRERERERIRERQRIREREUGIgRFBARGIiBERERESIhGIiIESIREUQYiIERQRAUEYEREYiIgSIhGBQYEiEhiIiIiBERRBAEAC8AJQAAAACA42neFRHjZxERERASIiIiIiIRISEiERSIiIEiIiIiIiIiIhASIiIiIiESEhISERSBiBIiREkiKURCIhASIiIiIhERIRIiERSIiBIkRESSlEREIhASIiIiIhgSEiEiIRSBgSJERERCREREQhASIiIiIRgRIiIRIRRIgSJEREREREREQhASIiIiIYQSIiIiERFIgSJEREREREREQhASIiIiEYQRESERIRFEiBJEREREREREQhASIiIiGEQREhESEREUSBKUREREREREkhASIiIhGEQSIhIiISERQSIpRERERERJIhASIiIhhEgSIhIiISEREiIpRERERERJIhASIiIhhEgSIhIiISIRESIiRERERESSIhASIiIhhEgSIREiIhIRERIiJEREREQiIhASIiIYRIgSIiIiIhIhEREiIkREREIiIhASIiIYRIERIREiIYEiERESIiRERCIiIhASIiIYRBGBIhIiGIEiIREREiJEQiIiIhASIiIYQYEYEiIhiBESIhERERIkIiIiIhASIiIYEoERgREYgRGBIiERERIiIiIiIhASIiIRghgRGIiBERgSEiIRESIiESESIhASIiEYGEKBEREREYQoERIiEiIhiBiBIhASIhiIgYIYgREYiBKBEREREiIhhEQSIhASIRGBGBhCGIiBJIgRESIiISIiGEiBIhASGIiIiIGIhCFIiBEhEiEhIRIREYgSEhARERgRGIERGIiBERgRISIiFEGIgRGBEhAYiIiIiBEiEREYERgRIiIRRBiIEiEYEhAREYERGBISERERgYESEhFEERERIiGIEhAYiIiIgRIRESIRgYESIURBiIEhERGBIhARgYERgREhEiEhGBEhIUQYREEhQSESIhAYiIiIgSEhQRIhGBEiFEGESEESESESIhARGBgRgREhhEEiGBISFEGERBESEhIhIhAYiIiIgRIRiEQSERIhRBhEhBEhEhIhIhARgREYESEYGIQRERIhRBhERBIREiERIhAYiIiIESEYEYQRiBERRBhIRBISEiIUEhARgRiBESEYQYhBEYiBFBhEERIREhFEQRAYiIgUERIYQYRBgREYgRERRBEhEURERBAREYFEEhIYEYhBgYiBGIFESBISFEREQRAYiBREESEYGIQYGERIERRIiBESFERBGBAEAC8AJQAAAACA42jeFRHiZxERERASIiIiIhRCREJCRCQkRCQSIiIiIiIiIhARIhESIiFEJEJCRCQkQkEiREkiKURCIhAUEiGBIiIUQiJCIiQiJBEkRESSlEREIhAUEiGIEiIUREREREREQRJERERCREREQhAUEiGIEiIRERERERERERJEREREREREQhARERIYgSIhgYGBgSIiISJEREREREREQhASQkIhgSIhgYGBgSIRISJEREREREREQhASQkIiESIYGBgYEhEhISKUREREREREkhASEhIhgSIYGBgYEiIiJiIpRERERERJIhARERIYgSIYGBgYEiIiIhIpRERERERJIhAUEiGIEiIYGBgYEiIiIiEiRERERESSIhAUEiGIEiIYGBgYEiIRJhEiJEREREQiIhAUEiGBIiIYGBgYEhESISIiIkREREIiIhAUEhESIhEYGBgYEiIiISIiIiRERCIiIhAUEiIiIYiBGBgYEiIhESIiIiJEQiISIhAUEiIiGIGBgYEYEiIiISIiIiIkIhFBEhAUEiIiGBiBgYGBREIiIREREiIiIhREEhAUEiIiGIEYgYEUREQRGIGIgSIiIiFBIhAUEiIiIYiIGBFEREREQYgRgSIiERFBIhAUEiIiIREREYgRREREQRiIgSIhIiFBIhAUEiIhFCQYiIiIERERiIGIESISIiIREhAUEiERERQhGIiIiIiIiIgRJBESIRISEhAUERIkQREUIRGIiIiIgREkRBERIhEREhAUFEIiJEERFCQRERERFCREERFEEiEiEhARERRCIiRBERQkJCQkJEQREUQiIREREhAYiBEUQiIkQQoRFBER4PtEIiJBESEiEBiBiIEUQiIkQRFBIiFBEUQiIkQRIhEiEBgYiBiBFEIiJEEUEhQRRCIiRBGBISESEBERgYhBERRCIiQRQUEUIiJEEYiBIiIREBIiGIQRiIEUQiJBFBFCIiQRiIiBISEREBEiIUEYiIiBRCIkERQiJEGIiIiBIiIREBIhIRGBEREREUIiQUIiQRERERGBISEREBEiIhiBIiIiIUQiERIkQSIiIiGBIiIREBESEhiBIRERIRRBIiFEESERESGBISEREBESIiGBIYgRESESERIRIREYgSGBIiIREBERISGBIYgRIhEhREEhEiEYgSGBISEREAQALwAlAAAAAIDjad4VEeNnEREREBIiIiIiIiIiGIiIiIiIiIiIiIEiIiIiEBIiIiIhIiIiIYiIiIGBgYGBgRIiIiIiEBIiIiIREiIiIhGBgYFBQUFBQSIiIiIiEBIiIiERESIiIkFBQUREREREEiIiIiIhEBIiIhERERIiIiFEREEREREREiIiIiIREBIiIREREREiIiEREREiIiIiESIiIiGBEBIiERERERESIiEhISEiIiIiEhIiIiGBEBIhERERERERIiEhISERESEREhIiIiGBEBIhERERERERIiEhISESERIRESIiIiGBEBIREREREREREiEhISEiIhIiEhIiIiGBEBIREREREREREiEhISEiIhIiEhIiIiGBEBIREREREREREiEhISEiIhIiEhIiIiGBEBIREREhIREREiEhISEiIREiEhIiIiGBEBIhERIhIhERIiEhISEhEiISEhIiIiGBEBIiIiIREiIiIREhISEhIREiESESIiGBEBIiIiERESIiEiEhISEiIiIiEhIhIiGBEBIiIiIiIiIhISEhISEiEiISEhIhIiGBEBIiIiIiIiERIRIhISESEhISEiEYESGBEBIiIiIiIRGBEiISISEiEhESIRGBEhGBEBIiIiIhGBSBEREhEhIhISGBQRgRIUGBEBIiIiERGBEYEYERERESEhGBEYESERGBEBIiIRgYEYEYFBGBgYERERgUGBEhREGBEBIhFEEREYFBgUQRERGBgRgRGBEhQRGBEBIUiBGBEYERgURIiIEREYFBgRIUREGBEBGEQRERgRgRgURIERiEQYERgRIUERGBEBSIQRgYGBgUGBRIiIiEQYEYESFEREGBEBRIEREYERgRGBERERERGBQYESFBEREREBhEEYGBiIGBGBEiISIhGBEYESFBiIgREBiEERGBgRGBGBIhIiEiGBGBEhQYERiIEBSIEYGBiIGBQYEhISEiGBGBEhQYgSGIEBRIERGBgRGBEYEiISIhgUGBERRBERIREBhEEYGBiIgYEYEhIiEhgRGBgRFEREEREBSEERGBgREYEYERERERgRgRERERERIiEBRIEYEYGIgYEYGIiIiIgRgRERERIiEREBEUEREYGBEYEYERERERgRgYgRGBEhIiEBIhIRgRgYgYFIERREERgRgRGIEREiEREAQALwAlAAAAAIDjWd4VEeMnEREREBIiIiIiIRIRISEkGBGIiBIiIiIiIiIiEBIhIiIiERESEhEkGIGIgSIiIiEiIiIiEBIhIiIiESEhEiEkGIiIgSIiIhESIiIiEBIhIiIiERISISIUGBGIEiIiIRERIiIiEBIYEiIiEhEiIhIUGIGIEiIiEREREiIiEBIYEiIhEhIiIiEUQYiIgSIhERERESIiEBIYEiIhQhERIREUQYEYgSIRERERERIiEBIYEiIhQhESERIURBgYEiEREREREREiEBGIgSIhQhIiEiISRBiBIiEREREREREiEBGBgSIhQhIiEiIhREGBIhERERERERESEBGIgSIUQhIiEiIhJEQRIhERERERERESEBIYEiIUIRIhESIiFEQRIhERERERERESEBIYEiIUIRIiIiIiEkRBIhERESEhERESEBERESISEREhESIhQSREEiEREiEiEREiEBGIgSFCEREiEiIUESREESIiIhESIiIiEBIREiFCERgSIiERgRJEQRIiIRERIiIiEBGIgSFCGBGBERgYGIEkRBEiIiIiIiIiEBGIgSERGIEYGBgRiBESIiESIiIiRCIiEBIREiERGIiBERGIgRERERQRIiJEEUQiEBIUEhESEYGIiIgYERIhFERBgiRBiBRCEBIYEYESEYgYGBiBEiERREIYESJEEUQhEBIYFIgRERiIiIgRIRFERCGBGBEiRCIUEBEYFEgRIRgYGIESERREIhgRGIgSEiGEEBEYFEgRERGIiBEhFERCIYFBEYiBEhEYEBEYFEiBEhGIgRIRREQkQYEREREYEREYEBEYEkSBESERgSEURCJEQYFEQRERIiIYEBEYEUSIERGIEhFEQkRBEYERERESIiIYEBEYEhRIERhEgRREJEEREYgUREEiIiIYEBEYESRIgRhEgURCQREiERgRERIhIhGEEBEYEhFEiBhEgUQkERIiIRGBRBIREREUEBEYESFESIGIFEIRFCIRIhEYEREYEREREBEYEhIURIgRFCERIhEREiERgUGIGBEYEBEYESEhRERERBESIiIiIiIRGBiIGIiBEBEYEhISERERCRETERERiIiBGBARGBEhIURERAlED0REQRERGIEQERgSEg4REhESCxESERiIgREQBAAvACUAAAAAgONM3hUR4dcREREQEiIRIiFBREFBRBQURBRBIiIiIiIiIiIQEiGIEiIUFEFBRBQUQUQSIiIiISIiIiIQEhgUgSIhQRFBERQRFEEiIiIiERIiIiIQEhgUgSIiFEREREREREEiIiIhEREiIiIQEhgUgSIiEREREREREREiIiIRERESIiIQEiGIEiIiEiIiGBgYGBIiIiERERERIiIQEiIRIiIiEhEiGBgYGBIiIhEREREREiIQEiGIEiIiEhIRIYGBgYEiIRERERERESIQEhgUgSIiYiIiIYGBgYEiIRERERERESIQEiGIEiIhIiIiIYGBgYEiERERERERERIQEiIRIiISIiIiIYGBgYEiERERERERERIQEiGIEiIRIhEmIYGBgYEiERERERERERIQEhgUgSIiEiEWIYGBgYEiERERISERERIQEhgUgSIiEiIiIYGBgYgRIRESISIRESIQEhgUgSIiERIiGIGBgYiIEiIiERIiIiIQEiGIEiIiEiIiGIGIGBgYgSIhEREiIiIQEhEREiIhEiIiQRgYGBiBgSIiIiIiIiIQEhIiESERFiJERBgRgYEYgSIiIiIiIiIQEiESIRERERRERBGIGBiIESIiIiIiIiIQEhIhERIREREJEeDrESIiIiIiIhASEhESEhEREREREREREREhIREiIiIiIhASERIRESGBgYGBgYGBgYEhESERIiIiIhARQREhISEREREREREREREhISEUESIiIhAUEUEhERIUREREREREREEhESFEQREiERARFBESEhIRSESESESESEEhISFBEUQRgRARQRgSEREhREgYSEgYREEhESERRBGIgRAUEYGBISEhFIGEiISBhEEhISFEEYgRERARGBgRIRERgUhEgYRIREEhESERGIiIERARgYGBEhGBERESERIREhEhISERiBERGBAYGBgRERgRgQkhKxERGIiIgRgQEYGBFBGBGIESERIREhERISERiBgREYEQGIgRJBgREYEJERMRGIiIiBGBEBgRFEGBGIiBCSITIhiBgREYFBARESQYEYERgQlEE0GIiIiBGEQQERRBgRiIiBEJESMRgYEREYFEEBGEGBERgRgRGBEhIiESESEYiIiIGEREEAQAJwAnAAAAAIDi8MMJIg8iISIiIiIiIiIiIiAJIg8iERIiIiIiIiIiIiAJIg8hEREiIiIiIiIiIiAJIuJ7EREREiIiIiIiIiIgIiIiIiIiIiEREhERIiIiIiIiIiAiIiIiIiIiEREhIRESIiIiIiIiICIiIiIiIiEREhESEREiIiIiIiIgIiIiIiIiEREhEREhERIiIiIiIiAiIiIiIiEREhERERIRESIiIiIiICIiIiIiEREhERIRESEREiIiIiIgIiIiIiEREhERISEREhERIiIiIiAiIiIiEREhERIREhERIRESIiIiICIiIiEREhERIRIRIRESEREiIiIgIiIiEREhERIRISESEREhERIiIiAiIiEREhERIRIREhEhERIRESIiICIiEREhERIREhESERIRESEREiIgIiEREhERIRERISERESEREhERIiAiEREhERESERESERESERERIRESICIREhEREREhESEhESERERESERIgIRESERIRERISERISERESERIRESAhESERESESESESESESESERESERICERIRERIRESEhESEhERIRERIREgERIRESIRESERISERIRESIRESERAREhESERESERESERESERESERIREBESERIRESEREREREREhERIREhEQERIREhESERESERIRERIREhESERAREhERIiERESEhISERESIhERIREBESERERERESERIREhEREREREhEQERIRERERESERERERIRERERESERARESERERESERERERESERERESERECERIhEREiEREhESEREiERESIREgIRERIiIhEREiERIhEREiIiERESAiEREREREREiIREiIRERERERESICIhEREREREiIRERIiERERERESIgIiIhERERIiIhEREiIiEREREiIiAJIg8RERESIiIiIiIiIiAJIjcRERESIiIiIiIiIiAiIiIiIiIiIREREREiIiIiIiIiICIiIiIiIiIRERERERIiIiIiIiIgAQALAAsAAAAAgB8LBw4AAAAOHwAAAAduwAAADv/gAAAHdcAAAAoOAAAAAQAJAAoAAAAAgB8KBxwAAAAKPgAAAAddAAAADv+AAAAHawAAAAocAAAAAQAPAA8AAAAAgDIPCwOAAAAHwAAADg/gAAAPB8AAADu4AAB//AAADv/+AAATfXwAADk4AAADgAAAB8AAAAEACwALAAAAAIAiCw8IAAAAHAAAAD4AAAAOfwAAAA8+AAAAHAAAAAgAAAAJAAEACQAKAAAAAIAkCg8IAAAAHAAAAD4AAAAOfwAAABM+AAAAHAAAAAgAAAAAAAAAAQAPAA8AAAAAgDoPEwEAAAADgAAAB8AAAA/gAAAKH/AAAA8/+AAAf/wAAD/4AAAKH/AAABMP4AAAB8AAAAOAAAABAAAAAQALAAsAAAAAgCYLBQALdwAAAPeAAAAO/4AAABd/AAAAPgAAABwAAAAIAAAAAAAAAAEACQAKAAAAAIAkCgt3AAAA94AAAA7/gAAAF38AAAA+AAAAHAAAAAgAAAAAAAAAAQAPAA8AAAAAgDEPDzx4AAB+/AAA/v4AABL//gAACn/8AAAbP/gAAB/wAAAP4AAAB8AAAAOAAAABAAAAAQALAAsAAAAAgCMLBQATCAAAABwAAAA+AAAAfwAAAA7/gAAAB2sAAAAKHAAAAAEACQAKAAAAAIAhChMIAAAAHAAAAD4AAAB/AAAADv+AAAAHawAAAAocAAAAAQAPAA8AAAAAgDUPGwEAAAADgAAAB8AAAA/gAAAf8AAAP/gAAAp//AAADv/+AAAT/X4AAHk8AAADgAAAB8AAAAEADAAMAAAAAIAmDAoCAAAACgcAAAAKDYAAABMYwAAAH8AAAD/gAAAwYAAACnjwAAABAAoADAAAAACALwwrHwAAAD+AAAAxgAAAAYAAAAOAAAAHAAAADgAAABwAAAA5gAAAMYAAAAo/gAAAAQAKAAwAAAAAgC0MCj+AAAAXMwAAAAYAAAAMAAAAHwAAAB+AAAAKAYAAAA8xgAAAP4AAAB8AAAABAAoADAAAAACAKQwbAwAAAAcAAAAPAAAAHwAAADsAAABzAAAACn/AAAAKAwAAAAoHgAAAAQAKAAwAAAAAgCcMCn8AAAAKYAAAAAt+AAAAfwAAAAoDAAAACmMAAAALfwAAAD4AAAABAAoADAAAAACAKAwbDwAAAB8AAAA4AAAAMAAAAD8AAAA/gAAAEjGAAAALP4AAAB8AAAABAAoADAAAAACAGgwKP4AAAAcxgAAACgMAAAAOBgAAABIMAAAAAQAKAAwAAAAAgCYMCx8AAAA/gAAADjGAAAALHwAAAD+AAAAOMYAAAAs/gAAAHwAAAAEACgAMAAAAAIAoDAsfAAAAP4AAABIxgAAAGz+AAAAfgAAAAYAAAAOAAAAfAAAAHgAAAAEACgAMAAAAAIAYDAtngAAAb8AAACJswAAAC2/AAABngAAAAQAKAAwAAAAAgBkMCg8AAAAaBgAAAApmAAAAC34AAAA8AAAAAQAKAA4AAAAAgCAOCz4AAAB/AAAAImMAAAATfwAAAD4AAAAHAAAAAwAAAAEACgAMAAAAAIAsDAr3gAAAI2YAAABsAAAAeAAAAHAAAAB4AAAAbAAAAGYAAABjAAAACveAAAA='! !!PlayingCard class methodsFor: 'all' stamp: 'di 1/16/2000 10:38'!includeInNewMorphMenu	^false! !!PlayingCard class methodsFor: 'class initialization' stamp: 'asm 11/25/2003 22:35'!initialize	"PlayingCard initialize"	"Read the stored forms from mime-encoded data in imageData."	| forms f |	f := Base64MimeConverter				mimeDecodeToBytes: (ReadStream on: self imageData).	forms := OrderedCollection new.	f next = 2		ifFalse: [self error: 'corrupted imageData' translated].	[f atEnd]		whileFalse: [forms				add: (Form new readFrom: f)].	"1/2 image of Kc, Qc, Jc, ... d, h, s, and center image of As"	FaceForms := forms copyFrom: 1 to: 13.	"Images of small club, smaller club (for face cards), large club (for 	2-10, A), 	followed by 3 more each for diamonds, heardt, spaces, all as 1-bit 	forms. "	SuitForms := forms copyFrom: 14 to: 25.	"Images of A, 2, 3 ... J, Q, K as 1-bit forms"	NumberForms := forms copyFrom: 26 to: 38.	CardSize := 71 @ 96.	FaceLoc := 12 @ 11.	NumberLoc := 2 @ 4.	SuitLoc := 3 @ 18.	FaceSuitLoc := 2 @ 18.	TopSpotLocs := {{}. {28 @ 10}. {28 @ 10}. {15 @ 10. 41 @ 10}. {15 @ 10. 41 @ 10}. {14 @ 10. 42 @ 10}. {14 @ 10. 42 @ 10}. {14 @ 10. 28 @ 26. 42 @ 10}. {14 @ 10. 14 @ 30. 42 @ 10. 42 @ 30}. {14 @ 10. 14 @ 30. 42 @ 10. 42 @ 30. 28 @ 21}}.	"A"	"2"	"3"	"4"	"5"	"6"	"7"	"8"	"9"	"10"	MidSpotLocs := {{28 @ 40}. {}. {28 @ 40}. {}. {28 @ 40}. {14 @ 40. 42 @ 40}. {14 @ 40. 42 @ 40. 28 @ 26}. {14 @ 40. 42 @ 40}. {28 @ 40}. {}}.	"A"	"2"	"3"	"4"	"5"	"6"	"7"	"8"	"9"	"10"	ASpadesLoc := 16 @ 27! !!PlayingCard class methodsFor: 'all' stamp: 'di 10/18/1999 23:36'!test    "Display all cards in the deck"	"MessageTally spyOn: [20 timesRepeat: [PlayingCard test]]"	1 to: 13 do: [:i | 1 to: 4 do: [:j |		(PlayingCard the: i of: (#(clubs diamonds hearts spades) at: j)) cardForm				displayAt: (i-1*CardSize x)@(j-1*CardSize y)]]! !!PlayingCard class methodsFor: 'all' stamp: 'di 10/18/1999 23:22'!the: cardNo of: suitOrNumber	^ self new setCardNo: cardNo		suitNo: (suitOrNumber isNumber				ifTrue: [suitOrNumber]				ifFalse: [#(clubs diamonds hearts spades) indexOf: suitOrNumber])		cardForm: (Form extent: CardSize depth: Display depth)! !!PlayingCard methodsFor: 'all' stamp: 'di 10/18/1999 23:38'!blankCard 	CachedDepth = Display depth ifFalse:		[CachedDepth _ Display depth.		CachedBlank _ Form extent: CardSize depth: CachedDepth.		CachedBlank fillWhite; border: CachedBlank boundingBox width: 1.		CachedBlank fill: (0@0 extent: 2@2) fillColor: Color transparent.  "Round the top corners"		CachedBlank fill: (1@1 extent: 1@1) fillColor: Color black.		CachedBlank fill: (CachedBlank width-2@0 extent: 2@2) fillColor: Color transparent.		CachedBlank fill: (CachedBlank width-2@1 extent: 1@1) fillColor: Color black].	^ CachedBlank! !!PlayingCard methodsFor: 'all' stamp: 'ar 5/14/2001 23:39'!buildImage     "(PlayingCard the: 12 of: #hearts) cardForm display"	"World addMorph: (ImageMorph new image: (PlayingCard the: 12 of: #hearts) cardForm)"	"PlayingCard test"	| blt numForm suitForm spot face ace sloc colorMap fillColor |		"Set up blt to copy in color for 1-bit forms"	blt _ BitBlt current toForm: cardForm.	fillColor _ self color.	colorMap _ (((Array with: Color white with: fillColor)				collect: [:c | cardForm pixelWordFor: c])					 as: Bitmap).	blt copy: cardForm boundingBox from: 0@0 in: self blankCard.  "Start with a blank card image"	numForm _ NumberForms at: cardNo.  "Put number in topLeft"	blt copyForm: numForm to: NumberLoc rule: Form over colorMap: colorMap.	suitForm _ SuitForms at: suitNo*3-2.   "Put small suit just below number"	sloc _ SuitLoc.	cardNo > 10 ifTrue:		[suitForm _ SuitForms at: suitNo*3-1.   "Smaller for face cards"		sloc _ SuitLoc - (1@0)].	blt copyForm: suitForm to: sloc rule: Form over colorMap: colorMap.	cardNo <= 10	ifTrue:		["Copy top-half spots to the number cards"		spot _ SuitForms at: suitNo*3.   "Large suit spots"		(TopSpotLocs at: cardNo) do:			[:loc | blt copyForm: spot to: loc rule: Form over colorMap: colorMap]]	ifFalse:		["Copy top half of face cards"		face _ FaceForms at: suitNo-1*3 + 14-cardNo.		blt colorMap: self faceColorMap;			copy: (FaceLoc extent: face extent) from: 0@0 in: face].	"Now copy top half to bottom"	self copyTopToBottomHalf.	cardNo <= 10 ifTrue:		["Copy middle spots to the number cards"		(MidSpotLocs at: cardNo) do:			[:loc | blt copyForm: spot to: loc rule: Form over colorMap: colorMap]].	(cardNo = 1 and: [suitNo = 4]) ifTrue:		["Special treatment for the ace of spades"		ace _ FaceForms at: 13.		blt colorMap: self faceColorMap;			copy: (ASpadesLoc extent: ace extent) from: 0@0 in: ace]	! !!PlayingCard methodsFor: 'all' stamp: 'di 10/18/1999 23:31'!cardForm	^ cardForm! !!PlayingCard methodsFor: 'all' stamp: 'di 10/15/1999 09:12'!color	CachedDepth = 1 ifTrue: [^ Color black].	CachedDepth = 2 ifTrue: [^ Color perform: (#(black gray gray black) at: suitNo)].	^ Color perform: (#(black red red black) at: suitNo)! !!PlayingCard methodsFor: 'all' stamp: 'ar 5/28/2000 12:13'!copyTopToBottomHalf	"The bottom half is a 180-degree rotation of the top half (except for 7)"	| topHalf corners |	topHalf _ 0@0 corner: cardForm width@(cardForm height+1//2).	corners _ topHalf corners.	(WarpBlt current toForm: cardForm)		sourceForm: cardForm;		combinationRule: 3;		copyQuad: ((3 to: 6) collect: [:i | corners atWrap: i])		toRect: (CardSize - topHalf extent corner: CardSize).	! !!PlayingCard methodsFor: 'all' stamp: 'di 10/14/1999 20:17'!faceColorMap	| map |	map _ Color colorMapIfNeededFrom: 4 to: Display depth.	^ map! !!PlayingCard methodsFor: 'all' stamp: 'di 10/18/1999 23:23'!setCardNo: c suitNo: s cardForm: f	cardNo _ c.	suitNo _ s.	cardForm _ f.	self buildImage! !!MinesTile class methodsFor: 'new-morph participation' stamp: 'das 7/24/2001 00:11'!includeInNewMorphMenu	^false! !!MinesTile methodsFor: 'accessing' stamp: 'dgd 2/14/2003 21:59'!color: aColor 	super color: aColor.	onColor _ aColor.	offColor _ aColor.	self changed! !!MinesTile methodsFor: 'accessing' stamp: 'DAS 7/9/2001 13:14'!disabled	^ disabled! !!MinesTile methodsFor: 'accessing' stamp: 'DAS 7/9/2001 13:14'!disabled: aBoolean	disabled _ aBoolean.	disabled		ifTrue:			[self color: owner color.			self borderColor: owner color]		ifFalse:			[self setSwitchState: self switchState]! !!MinesTile methodsFor: 'accessing' stamp: 'dgd 2/22/2003 19:09'!doButtonAction: modifier 	"Perform the action of this button. The first argument of the message sent to the target is the current state of this switch, 	the second argument is the modifier button state."	(target notNil and: [actionSelector notNil]) 		ifTrue: 			[^target perform: actionSelector				withArguments: ((arguments copyWith: switchState) copyWith: modifier)]! !!MinesTile methodsFor: 'drawing' stamp: 'ar 12/31/2001 02:38'!drawOn: aCanvas 	"Draw a rectangle with a solid, inset, or raised border.	Note: the raised border color *and* the inset border color are generated	from the receiver's own color, instead of having the inset border color	generated from the owner's color, as in BorderedMorph."	| font rct |	borderWidth = 0 ifTrue: [  "no border"		aCanvas fillRectangle: bounds color: color.		^ self.].	borderColor == #raised ifTrue: [		^ aCanvas frameAndFillRectangle: bounds			fillColor: color			borderWidth: borderWidth			topLeftColor: color lighter lighter			bottomRightColor: color darker darker darker].	borderColor == #inset ifTrue: [		aCanvas frameAndFillRectangle: bounds			fillColor: color			borderWidth: 1 " borderWidth"			topLeftColor: (color darker darker darker)			bottomRightColor: color lighter.		self isMine ifTrue: [  			font  _ StrikeFont familyName: 'Atlanta' size: 22 emphasized: 1.			rct _ bounds insetBy: ((bounds width) - (font widthOfString: '*'))/2@0.			rct _ rct top: rct top + 1.			aCanvas drawString: '*' in: (rct translateBy: 1@1) font: font color: Color black.			^ aCanvas drawString: '*' in: rct font: font color: Color red .].		self nearMines > 0 ifTrue: [ 			font _ StrikeFont familyName: 'ComicBold' size: 22 emphasized: 1.			rct _ bounds insetBy: ((bounds width) - (font widthOfString: nearMines asString))/2@0.			rct _ rct top: rct top + 1.			aCanvas drawString: nearMines asString in: (rct translateBy: 1@1) font: font color: Color black.			^ aCanvas drawString: nearMines asString in: rct font: font color: ((palette at: nearMines) ) .].		^self. ].	"solid color border"	aCanvas frameAndFillRectangle: bounds		fillColor: color		borderWidth: borderWidth		borderColor: borderColor.! !!MinesTile methodsFor: 'initialization' stamp: 'ar 11/25/2001 14:56'!initialize	super initialize.	self label: ''.	self borderWidth: 3.	bounds _ 0@0 corner: 20@20.	offColor _ self preferredColor.	onColor _ self preferredColor.	switchState _ false.	oldSwitchState _ false.	disabled _ false.	isMine _ false.	nearMines _ 0.	self useSquareCorners.	palette _ (Color wheel: 8) asOrderedCollection reverse."	flashColor _ palette removeLast."! !!MinesTile methodsFor: 'accessing' stamp: 'DAS 7/9/2001 15:47'!isMine	^ isMine! !!MinesTile methodsFor: 'accessing' stamp: 'das 7/22/2001 19:49'!isMine: aBoolean	isMine _ aBoolean.! !!MinesTile methodsFor: 'accessing' stamp: 'das 7/22/2001 19:44'!mineFlag	^ mineFlag.! !!MinesTile methodsFor: 'accessing' stamp: 'das 7/22/2001 19:47'!mineFlag: boolean	mineFlag _ boolean.	mineFlag ifTrue: [		self color: Color red lighter lighter lighter lighter.]		ifFalse: [		self color: self preferredColor.].	^ mineFlag.! !!MinesTile methodsFor: 'event handling' stamp: 'das 7/21/2001 16:08'!mouseDown: evt 	"The only real alternative mouse clicks are the yellow button or the shift key. I will treat them as the same thing, and ignore two button presses for now. I am keeping this code around, because it is the only documentation I have of MouseButtonEvent."	| mod |"	Transcript show: 'anyModifierKeyPressed - '; show: evt anyModifierKeyPressed printString ; cr;			 show: 'commandKeyPressed - '; show: evt commandKeyPressed printString ;  cr;			 show: 'controlKeyPressed - '; show:evt controlKeyPressed printString ; cr;			 show: 'shiftPressed - '; show: evt shiftPressed printString ; cr;			 show: 'buttons - '; show: evt buttons printString ; cr;			 show: 'handler - '; show: evt handler printString ;  cr;			 show: 'position - '; show: evt position printString ; cr;			 show: 'type - '; show: evt type printString ; cr;			 show: 'anyButtonPressed - '; show: evt anyButtonPressed printString ; cr;			 show: 'blueButtonPressed - '; show: evt blueButtonPressed printString ; cr;			 show: 'redButtonPressed - '; show: evt redButtonPressed printString ; cr;			 show: 'yellowButtonPressed - '; show: evt yellowButtonPressed printString ; cr; cr; cr."					mod _  (evt yellowButtonPressed) | (evt shiftPressed). 	switchState ifFalse:[		(self doButtonAction: mod) ifTrue:			[mod ifFalse: [ self setSwitchState: true. ].].	] ifTrue: [			self doButtonAction: mod.].! !!MinesTile methodsFor: 'event handling' stamp: 'DAS 7/9/2001 13:16'!mouseMove: evt	"don't do anything, here"! !!MinesTile methodsFor: 'event handling' stamp: 'DAS 7/9/2001 13:16'!mouseUp: evt	"don't do anything, here"! !!MinesTile methodsFor: 'accessing' stamp: 'DAS 7/10/2001 14:27'!nearMines	^ nearMines.! !!MinesTile methodsFor: 'accessing' stamp: 'das 7/22/2001 19:48'!nearMines: nMines	nearMines _ nMines.! !!MinesTile methodsFor: 'initialization' stamp: 'di 11/26/2001 21:27'!preferredColor		"PreferredColor _ nil  <-- to reset cache"	PreferredColor ifNil:		["This actually takes a while to compute..."		PreferredColor _ Color gray lighter lighter lighter].	^ PreferredColor! !!MinesTile methodsFor: 'accessing' stamp: 'DAS 7/9/2001 13:15'!switchState	^ switchState! !!MinesTile methodsFor: 'accessing' stamp: 'das 7/22/2001 19:32'!switchState: aBoolean	switchState _ aBoolean.	disabled ifFalse:		[switchState			ifTrue:[				"flag ifTrue: [self setFlag]." "if this is a flagged tile, unflag it."				self borderColor: #inset.				self color: onColor]			ifFalse:[				self borderColor: #raised.				self color: offColor]]! !!SameGameTile class methodsFor: 'new-morph participation' stamp: 'di 1/16/2000 10:37'!includeInNewMorphMenu	^false! !!SameGameTile methodsFor: 'accessing' stamp: 'dgd 2/14/2003 21:59'!color: aColor 	super color: aColor.	onColor _ aColor.	offColor _ aColor.	self changed! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 08:46'!disabled	^ disabled! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:21'!disabled: aBoolean	disabled _ aBoolean.	disabled		ifTrue:			[self color: owner color.			self borderColor: owner color]		ifFalse:			[self setSwitchState: self switchState]! !!SameGameTile methodsFor: 'button' stamp: 'dgd 2/22/2003 19:00'!doButtonAction	"Perform the action of this button. The last argument of the message sent to the target is the new state of this switch."	(target notNil and: [actionSelector notNil]) 		ifTrue: 			[target perform: actionSelector				withArguments: (arguments copyWith: switchState)]! !!SameGameTile methodsFor: 'initialization' stamp: 'sw 11/30/1999 08:21'!initialize	super initialize.	self label: ''.	self borderWidth: 2.	bounds _ 0@0 corner: 16@16.	offColor _ Color gray.	onColor _ Color gray.	switchState _ false.	oldSwitchState _ false.	disabled _ false.	self useSquareCorners	! !!SameGameTile methodsFor: 'accessing' stamp: 'ar 8/26/2001 17:14'!insetColor	"Use my own color for insets"	^color! !!SameGameTile methodsFor: 'event handling' stamp: 'tao 5/18/1998 17:43'!mouseDown: evt	disabled ifFalse:		[oldSwitchState _ switchState.		self setSwitchState: (oldSwitchState = false).		self doButtonAction].! !!SameGameTile methodsFor: 'event handling' stamp: 'njb 9/29/2005 22:24'!mouseEnter: evt! !!SameGameTile methodsFor: 'event handling' stamp: 'njb 9/29/2005 22:15'!mouseLeave: evt! !!SameGameTile methodsFor: 'event handling' stamp: 'tao 5/18/1998 17:43'!mouseMove: evt	"don't do anything, here"! !!SameGameTile methodsFor: 'event handling' stamp: 'tao 5/18/1998 17:42'!mouseUp: evt	"don't do anything, here"! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:21'!setSwitchState: aBoolean	switchState _ aBoolean.	disabled ifFalse:		[switchState			ifTrue:				[self borderColor: #inset.				self color: onColor]			ifFalse:				[self borderColor: #raised.				self color: offColor]]! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:19'!switchState	^ switchState! !!AtomicAtom methodsFor: 'visual properties' stamp: 'GP 4/15/2003 23:38'!drawAtom: aCanvas bound: aBound 	"Draw the shadow and the body"	| newBound |	mapStyle isSmallScreen		ifTrue: [newBound _ aBound insetBy: 2]		ifFalse: [newBound _ aBound insetBy: 4.			"shadow"			aCanvas				fillOval: (newBound translateBy: 2)				color: Color veryVeryLightGray].	"draws the links"	self drawLinks: aCanvas.	"real color..."	aCanvas fillOval: newBound color: self defaultColor.	^ newBound! !!AtomicAtom methodsFor: 'visual properties' stamp: 'grp 8/21/2002 21:48'!drawBright: aCanvas bound: aBound 	"Circles representing light"	| selectedColor newBound |	selectedColor _ self defaultColor.	newBound _ aBound insetBy: 2.	1		to: 4		do: [:index | 			selectedColor _ selectedColor alphaMixed: 0.77 with: Color white.			aCanvas fillOval: newBound color: selectedColor.			newBound _ (newBound insetBy: 2)						translateBy: -1].	^ aBound! !!AtomicAtom methodsFor: 'visual properties' stamp: 'grp 8/21/2002 20:53'!drawLinks: aCanvas 	"Draw the list of arrows"	| lineWidth maxSize startPos linksCount endPos |	maxSize _ self bounds extent // 2.	startPos _ self bounds center.links ifNotNil: [	links		do: [:link | 			"for every link"			linksCount _ (links						select: [:item | item = link]) size.			lineWidth _ linksCount * 2.			endPos _ maxSize - lineWidth + linksCount * link + startPos.			"draw the line"			aCanvas				line: startPos				to: endPos				width: lineWidth				color: Color darkGray]]! !!AtomicAtom methodsFor: 'visual properties' stamp: 'GP 4/14/2003 22:46'!drawOn: aCanvas 	| newBound |	newBound _ self bounds.	"draws a basic shape of the atom"	newBound _ self drawAtom: aCanvas bound: newBound.	"Special behavior for small devices"	mapStyle		isSmallScreen ifFalse: [newBound _ self drawBright: aCanvas bound: newBound.			mapStyle isPreview				ifTrue: [self drawTitle: aCanvas]].	"draw the seleccion mark"	self drawActivation: aCanvas! !!AtomicAtom methodsFor: 'visual properties' stamp: 'GP 4/14/2003 23:17'!drawTitle: aCanvas 	"Draw the text inside"	| newBound text |	newBound _ Rectangle center: self bounds center + (3 @ 0) extent: 12 @ 12.	text _ self getText.	aCanvas		text: text		bounds: newBound		font: nil		color: Color white.aCanvas		text: text		bounds: (newBound translateBy: -1)		font: nil		color: (self defaultColor alphaMixed: 0.7 with: Color black)! !!AtomicAtom methodsFor: 'access properties' stamp: 'grp 5/1/2002 13:26'!forcedLinks: aLinks 	forcedLinks _ aLinks.	! !!AtomicAtom methodsFor: 'access properties' stamp: 'grp 8/21/2002 20:54'!fullyLinkedlinks		ifNotNil: [	"Verifies if all the links are ok"	(links			allSatisfy: [:link | self owner isAtom: self linkedTo: link])		ifFalse: [^ false].	"If has required links, verify them"	forcedLinks		allSatisfy: [:forced | links				anySatisfy: [:link | self owner						isAtomKind: forced						fromAtom: self						linkedTo: link]].].	"no more checks"	^ true! !!AtomicAtom methodsFor: 'access properties' stamp: 'grp 1/4/2002 09:23'!getTextself subclassResponsibility! !!AtomicAtom methodsFor: 'access properties' stamp: 'grp 2/2/2002 10:30'!isAtom	^ true! !!AtomicAtom methodsFor: 'access properties' stamp: 'grp 9/24/2001 00:54'!links: aLinks links _ aLinks! !!AtomicAtom methodsFor: 'access properties' stamp: 'grp 7/19/2002 18:00'!previewPosition^	previewPosition! !!AtomicAtom methodsFor: 'access properties' stamp: 'grp 8/21/2002 20:43'!previewPosition: aPosition 	previewPosition _ aPosition! !!AtomicCarbon methodsFor: 'access properties' stamp: 'grp 6/1/2002 23:34'!defaultColor	^ Color		r: 0		g: 0		b: 0.6! !!AtomicCarbon methodsFor: 'access properties' stamp: 'grp 1/3/2002 01:50'!getText	^ 'C'! !!AtomicFluor methodsFor: 'access properties' stamp: 'grp 7/27/2002 19:01'!defaultColor	^ Color		r: 1		g: 0		b: 0.4! !!AtomicFluor methodsFor: 'access properties' stamp: 'grp 1/12/2002 11:38'!getText	^ 'F'! !!AtomicHydrogen methodsFor: 'access properties' stamp: 'grp 6/1/2002 23:34'!defaultColor	^ Color		r: 0		g: 0.6		b: 0.0! !!AtomicHydrogen methodsFor: 'access properties' stamp: 'grp 12/29/2001 12:28'!getText	^ 'H'! !!AtomicLink methodsFor: 'visual properties' stamp: 'grp 2/2/2002 11:40'!drawOn: aCanvas 	| |	self drawLinks: aCanvas.	self drawActivation: aCanvas! !!AtomicNitrogen methodsFor: 'access properties' stamp: 'grp 6/1/2002 23:48'!defaultColor	^ Color		r: 0.6		g: 0.6		b: 0! !!AtomicNitrogen methodsFor: 'access properties' stamp: 'grp 1/26/2002 01:59'!getText	^ 'N'! !!AtomicOxygen methodsFor: 'access properties' stamp: 'grp 6/1/2002 23:34'!defaultColor	^ Color		r: 0.6		g: 0		b: 0.0! !!AtomicOxygen methodsFor: 'access properties' stamp: 'grp 9/4/2001 19:07'!getText	^ 'O'! !!AtomicBrick methodsFor: 'visual properties' stamp: 'grp 7/20/2002 02:37'!defaultColor	^ Color darkGray! !!AtomicBrick methodsFor: 'visual properties' stamp: 'GP 4/15/2003 23:45'!drawOn: aCanvas 	| rectBound rectColor |	rectBound _ self bounds.	rectColor _ self defaultColor.	aCanvas fillRectangle: rectBound fillStyle: rectColor.	rectBound _ rectBound insetBy: 1.	1		to: (mapStyle isSmallScreen				ifTrue: [2]				ifFalse: [4])		do: [:value | 			rectColor _ rectColor alphaMixed: 0.75 with: Color white.			aCanvas fillRectangle: rectBound fillStyle: rectColor.			rectBound _ rectBound insetBy: 2]! !!AtomicComponent class methodsFor: 'instance creation' stamp: 'grp 8/1/2002 22:16'!includeInNewMorphMenu	^ false! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 1/31/2002 22:56'!activate	isActive _ true.self changed.! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 2/2/2002 11:06'!canBeProgramed	^ isMoving not! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 1/31/2002 22:56'!deactivate	isActive _ false .self changed! !!AtomicComponent methodsFor: 'stepping and presenter' stamp: 'grp 8/22/2002 20:33'!doMovement	| distances direction |	self		position: (owner fastMoves				ifTrue: [futurePosition]				ifFalse: [distances _ futurePosition - self position.					direction _ distances x sign @ distances y sign.					self position + (direction + (distances // 6))])! !!AtomicComponent methodsFor: 'visual properties' stamp: 'grp 5/1/2002 16:31'!drawActivation: aCanvas 	"When is active has a border"	isActive		ifTrue: [aCanvas frameRectangle: self bounds color: Color black.			aCanvas				frameRectangle: (self bounds insetBy: 1)				color: self defaultColor]! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 12/25/2001 20:41'!fullyLinked^ false! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 4/15/2002 23:21'!initialize	super initialize.	isActive _ false.	isMoving _ false! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 2/2/2002 10:29'!isAtom	^ false! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 8/21/2002 20:41'!isMovable	^ mapStyle isPreview not! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 8/21/2002 20:39'!isPreview	^ mapStyle isPreview! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 8/21/2002 20:30'!mapStyle^ mapStyle! !!AtomicComponent methodsFor: 'access properties' stamp: 'grp 8/21/2002 20:02'!mapStyle: aMapStylemapStyle _ aMapStyle! !!AtomicComponent methodsFor: 'stepping and presenter' stamp: 'grp 8/22/2002 20:30'!startMovement: aNewPosition 	futurePosition _ aNewPosition.	isMoving _ true.	self startStepping! !!AtomicComponent methodsFor: 'stepping and presenter' stamp: 'grp 1/30/2002 22:31'!step	futurePosition = self position		ifTrue: [self stopMovement]		ifFalse: [self doMovement]! !!AtomicComponent methodsFor: 'stepping and presenter' stamp: 'grp 1/30/2002 22:32'!stepTime	^ 15! !!AtomicComponent methodsFor: 'stepping and presenter' stamp: 'grp 8/22/2002 20:31'!stopMovement	self stopStepping.	isMoving _ false.	futurePosition _ nil.	self owner checkIsCompleted! !!AtomicComponent methodsFor: 'stepping and presenter' stamp: 'grp 1/30/2002 22:32'!wantsSteps^isMoving! !!AtomicGame class methodsFor: 'parts bin' stamp: 'asm 4/20/2004 22:00'!descriptionForPartsBin	^ self		partName: 'Atomic'		categories: #('Games' )		documentation: 'A game where you have to build chemical molecules using given atoms.'! !!AtomicGame class methodsFor: 'instance creation' stamp: 'grp 8/1/2002 21:58'!includeInNewMorphMenu	^ true! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 8/5/2002 13:29'!availableMaps	| maps |	maps _ OrderedCollection new.	maps add: AtomicMap01;		 add: AtomicMap02;		 add: AtomicMap03;		 add: AtomicMap04;		 add: AtomicMap05;		 add: AtomicMap06;		 add: AtomicMap07;		 add: AtomicMap08;		 add: AtomicMap09;		 add: AtomicMap10.	maps add: AtomicMap11;		 add: AtomicMap12;		 add: AtomicMap13;		 add: AtomicMap14;		 add: AtomicMap15;		 add: AtomicMap16;		 add: AtomicMap17;		 add: AtomicMap18;		 add: AtomicMap19;		 add: AtomicMap20.	maps add: AtomicMap21;		 add: AtomicMap22;		 add: AtomicMap23;		 add: AtomicMap24;		 add: AtomicMap25;		 add: AtomicMap26;		 add: AtomicMap27;		 add: AtomicMap28;		 add: AtomicMap29; add: AtomicMap30.	^ maps! !!AtomicGame methodsFor: 'access properties' stamp: 'asm 4/20/2004 20:55'!checkIsCompleted	"Checks if the level is completed"	| map result |	result _ ((self submorphs				select: [:each | each isKindOf: AtomicAtom])				select: [:each | each isPreview not])				allSatisfy: [:each | each fullyLinked].	result		ifTrue: ["how many movements"			gameMoves _ gameMoves + mapMoves.			"Has next map?"			map _ self createNextMap.			map				ifNil: ["No selection"					self select: nil.					"show a final message"					infoMorph contents: 'YOU WON !!!!!!!!!!!!' translated]				ifNotNil: ["Go to the next level"					self goLevel: map]]! !!AtomicGame methodsFor: 'structure' stamp: 'GP 4/14/2003 22:44'!createButtonFor: anAction shortText: aShortText longText: aLongText hint: aHint 	| text |	text _ currentMap mapStyle				isSmallScreen ifTrue: [aShortText]				ifFalse: [aLongText].	^ (SimpleButtonMorph newWithLabel: text) target: self;		 actionSelector: anAction;		 useSquareCorners;		 borderWidth: 0;		 color: Color yellow twiceLighter;		 setBalloonText: aHint! !!AtomicGame methodsFor: 'structure' stamp: 'asm 4/20/2004 20:57'!createButtonsBar	| controlPosition moveStyleButton helpButton prevButton sameButton nextButton quitButton |	controlPosition _ currentMap borderSpace + (bounds origin x @ bounds corner y).	"Instructions"	helpButton _ self				createButtonFor: #showHelpWindow				shortText: '?'				longText: '? Help' translated				hint: 'Shows instructions' translated.	helpButton position: controlPosition.	self addMorph: helpButton.	"Go to previous map"	controlPosition _ controlPosition + (helpButton bounds width * 1.5 @ 0).	prevButton _ self				createButtonFor: #goPrevLevel				shortText: '<<'				longText: '< Prev' translated				hint: 'Jumps to the previous level' translated.	prevButton position: controlPosition.	self addMorph: prevButton.	"Restart this map"	controlPosition _ controlPosition + (prevButton bounds width * 1.2 @ 0).	sameButton _ self				createButtonFor: #goSameLevel				shortText: 'Rst' translated				longText: 'Reset' translated				hint: 'Restarts this level' translated.	sameButton position: controlPosition.	self addMorph: sameButton.	"Go to next map"	controlPosition _ controlPosition + (sameButton bounds width * 1.2 @ 0).	nextButton _ self				createButtonFor: #goNextLevel				shortText: '>>'				longText: 'Next >' translated				hint: 'Jumps to the next level' translated.	nextButton position: controlPosition.	self addMorph: nextButton.	"Moves style"	controlPosition _ controlPosition + (nextButton bounds width * 1.5 @ 0).	moveStyleButton _ self				createSwitchButtonFor: #moveStyleState:				shortText: 'F'				longText: 'Fast'				state: fastMoves				hint: 'Animation on/off' translated.	moveStyleButton position: controlPosition.	self addMorph: moveStyleButton.	"Close the game"	controlPosition _ controlPosition + (nextButton bounds width * 1.5 @ 0).	quitButton _ self				createButtonFor: #delete				shortText: '[X]'				longText: 'Quit' translated				hint: 'Closes the game' translated.	quitButton position: controlPosition.	self addMorph: quitButton.	"Extends the morph bound"	bounds _ bounds extendBy: 0 @ prevButton bounds height.	bounds _ bounds extendBy: currentMap borderSpace! !!AtomicGame methodsFor: 'structure' stamp: 'grp 7/19/2002 01:12'!createFirstMap	| maps |	maps _ self availableMaps.	^ (maps at: 1) new	! !!AtomicGame methodsFor: 'structure' stamp: 'grp 7/20/2002 01:04'!createMaze	| dx dy |	currentMap buildLayout: self.	dx _ currentMap neededSize x - bounds width.	dx > 0		ifTrue: [bounds _ bounds extendBy: dx @ 0].	dy _ currentMap neededSize y.	bounds _ bounds extendBy: 0 @ dy.	self changed! !!AtomicGame methodsFor: 'structure' stamp: 'grp 1/9/2002 00:24'!createNextMap	| maps mapName index |	maps _ self availableMaps.	mapName _ currentMap class.	index _ maps indexOf: mapName.	index < maps size		ifTrue: [^ (maps at: index + 1) new]		ifFalse: [^ nil]! !!AtomicGame methodsFor: 'structure' stamp: 'grp 1/9/2002 00:24'!createPrevMap	| maps mapName index |	maps _ self availableMaps.	mapName _ currentMap class.	index _ maps indexOf: mapName.	index > 1		ifTrue: [^ (maps at: index - 1) new]		ifFalse: [^ nil]! !!AtomicGame methodsFor: 'structure' stamp: 'grp 7/20/2002 02:05'!createPreview	| extra |	currentMap buildLayoutForPreview: self.	extra _ currentMap previewNeededSize x.	bounds _ bounds extendBy: extra @ 0.	self changed! !!AtomicGame methodsFor: 'structure' stamp: 'grp 1/5/2002 12:42'!createSameMap	| mapName |	mapName _ currentMap class.	^ mapName new! !!AtomicGame methodsFor: 'structure' stamp: 'GP 4/14/2003 22:45'!createSwitchButtonFor: anAction shortText: aShortText longText: aLongText state: aBoolean hint: aHint 	| text |	text _ currentMap mapStyle				isSmallScreen ifTrue: [aShortText]ifFalse: [aLongText].	^ (SimpleSwitchMorph newWithLabel: text) target: self;		 actionSelector: anAction;		 useSquareCorners;		 borderWidth: 0;		 offColor: Color yellow twiceLighter;		 onColor: Color orange;		 setSwitchState: aBoolean;		 setBalloonText: aHint! !!AtomicGame methodsFor: 'structure' stamp: 'GP 4/15/2003 22:40'!createTextBars	"title"	titleMorph _ StringMorph new contents: ' ATOMIC 1.2 ';				 font: Preferences windowTitleFont emphasis: 3.	titleMorph position: bounds origin x @ bounds corner y + currentMap borderSpace.	titleMorph color: Color blue twiceDarker.	self addMorph: titleMorph.	bounds _ bounds extendBy: 0 @ titleMorph bounds height + currentMap borderSpace.	"information"	infoMorph _ StringMorph new contents: self levelMessage.	infoMorph position: bounds origin x @ bounds corner y + currentMap borderSpace.	infoMorph color: Color gray twiceDarker.	self addMorph: infoMorph.	bounds _ bounds extendBy: 0 @ infoMorph bounds height + currentMap borderSpace.	"points"	pointsMorph _ StringMorph new contents: ''.	pointsMorph position: bounds origin x @ bounds corner y + currentMap borderSpace.	pointsMorph color: Color gray twiceDarker.	self addMorph: pointsMorph.	bounds _ bounds extendBy: 0 @ pointsMorph bounds height + currentMap borderSpace! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 8/1/2002 18:22'!defaultColor	^ Color yellow veryMuchLighter! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 8/22/2002 20:32'!fastMoves^fastMoves! !!AtomicGame methodsFor: 'structure' stamp: 'grp 8/1/2002 21:31'!getNextPosition: aDirection 	| currentPosition delta morph |	currentPosition _ selected position.	delta _ currentMap atomSize  * aDirection.	[morph _ self somethingAt: currentPosition + delta.	morph isNil]		whileTrue: [currentPosition _ currentPosition + delta].	^ currentPosition! !!AtomicGame methodsFor: 'structure' stamp: 'grp 7/19/2002 01:13'!goFirstLevel	| map |	map _ (self createFirstMap).	map		ifNotNil: [self goLevel: map]! !!AtomicGame methodsFor: 'structure' stamp: 'GP 4/14/2003 22:39'!goLevel: aMap 	"Initialization"	self select: nil.	self removeAllMorphs.	mapMoves _ 0.	currentMap _ aMap.	fastMoves		ifNil: [fastMoves _ currentMap mapStyle isSmallScreen].	bounds _ self position corner: self position.	"creates new controls"	self createTextBars.	self createButtonsBar.	self createMaze.	self createPreview.	"information"	self showPointsInfo.	"select the first atom"	self select: self nextMolecule! !!AtomicGame methodsFor: 'structure' stamp: 'grp 1/5/2002 12:14'!goNextLevel	| map |	map _ self createNextMap.	map		ifNotNil: [self goLevel: map]! !!AtomicGame methodsFor: 'structure' stamp: 'grp 1/5/2002 12:16'!goPrevLevel	| map |	map _ self createPrevMap.	map		ifNotNil: [self goLevel: map]! !!AtomicGame methodsFor: 'structure' stamp: 'grp 1/5/2002 12:41'!goSameLevel	| map |	map _ self createSameMap.	map		ifNotNil: [self goLevel: map]! !!AtomicGame methodsFor: 'event handling' stamp: 'grp 9/6/2001 22:21'!handlesKeyboard: evt 	^ true! !!AtomicGame methodsFor: 'event handling' stamp: 'grp 2/2/2002 12:03'!handlesMouseDown: evt 	| morph movable |	morph _ self somethingAt: evt position.	movable _ morph notNil				and: [morph isMovable].	movable		ifFalse: [self select: nil].^ movable! !!AtomicGame methodsFor: 'initialization' stamp: 'grp 8/22/2002 20:36'!initialize	super initialize.	gameMoves _ 0.	self position: 50 @ 50.	self goFirstLevel! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 8/1/2002 21:31'!isAtom: aAtom linkedTo: aLink 	| currentPosition delta |	currentPosition _ aAtom position.	delta _ currentMap atomSize  * aLink.	^ self isAtomAt: currentPosition + delta! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 2/2/2002 10:37'!isAtomAt: aPosition 	| morph |	morph _ self somethingAt: aPosition.^ morph notNil and:[ morph isAtom]! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 7/30/2002 16:34'!isAtomKind: aKind at: aPosition 	| morph |	morph _ self somethingAt: aPosition.		^ morph isKindOf: aKind! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 8/1/2002 21:31'!isAtomKind: aKind fromAtom: aAtom linkedTo: aLink 	| currentPosition delta |	currentPosition _ aAtom position.	delta _ currentMap atomSize  * aLink.	^ self isAtomKind: aKind at: currentPosition + delta! !!AtomicGame methodsFor: 'event handling' stamp: 'grp 8/23/2002 15:33'!keyStroke: evt 	| charValue |	charValue _ evt keyCharacter asciiValue.	"Tab pressed"	(charValue = 9			or: [charValue = 32])		ifTrue: [self select: self nextMolecule].	"This keys requires something selected"	selected		ifNotNil: ["Left pressed"			charValue = 28				ifTrue: [self makeMovement: -1 @ 0].			"Right pressed"			charValue = 29				ifTrue: [self makeMovement: 1 @ 0].			"Up pressed"			charValue = 30				ifTrue: [self makeMovement: 0 @ -1].			"Down pressed"			charValue = 31				ifTrue: [self makeMovement: 0 @ 1]].! !!AtomicGame methodsFor: 'access properties' stamp: 'asm 4/20/2004 20:56'!levelMessage	| number message |	number _ self availableMaps indexOf: currentMap class.	message _ 'Level ' translated, number asString.	currentMap mapStyle		isSmallScreen ifFalse: [message _ message , ': ' , currentMap levelName].	^ message! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 8/2/2002 16:36'!makeMovement: aDirection 	selected canBeProgramed		ifTrue: ["Increase the movements counter"			mapMoves _ mapMoves + 1.			self showPointsInfo.			"Moves the piece"			selected				startMovement: (self getNextPosition: aDirection)]! !!AtomicGame methodsFor: 'event handling' stamp: 'grp 2/2/2002 12:01'!mouseDown: evt 		self		select: (self somethingAt: evt position)! !!AtomicGame methodsFor: 'structure' stamp: 'grp 8/22/2002 20:34'!moveStyleState: aState 	fastMoves _ aState! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 7/23/2002 17:04'!nextMolecule	| current morph |	selected		ifNil: [current _ 0]		ifNotNil: [current _ submorphs indexOf: selected].	"get the next molecule since the current"	current + 1		to: submorphs size		do: [:index | 			morph _ submorphs at: index.(			(morph isKindOf: AtomicAtom) and: [morph isMovable])						ifTrue: [^ morph]].	"nothing"	^ nil! !!AtomicGame methodsFor: 'structure' stamp: 'GP 4/14/2003 22:46'!pointsMessage	| message |	message _ 'Record: ' , currentMap record asString.	message _ message , '   Moves: ' , mapMoves asString.	currentMap mapStyle		isSmallScreen ifFalse: [message _ message , '   Total: ' , gameMoves asString].	^ message! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 9/8/2001 19:19'!select: aMolecule 	selected == aMolecule		ifFalse: ["Replace the selected for the new one" selected				ifNotNil: [selected deactivate].			selected _ aMolecule.			selected				ifNotNil: [selected activate]]! !!AtomicGame methodsFor: 'structure' stamp: 'asm 4/20/2004 20:59'!showHelpWindow	((StringHolder new contents: 'Instructions:  The aim of ATOMIC is to build chemical molecules using given atoms. The goal is to solve a level with as few moves as possible.  The level is solved when the new molecule has the same structure as shown by the preview molecule (on the top right). In the higher levels, some tactical skill will be neccessary for solving the puzzle.  Clicking on an atom will cause to be selected (like with [Tab] key). The selected atom will move in any direction until it reaches a border or another atom. Direction is specified with cursor keys ([Up][Down][Left][Right]). If all the atoms touch each other with the corresponding connectors, they form a molecule. The atoms can only be moved one at a time. Controls:   ''Record'' shows the lowest number of moves used for this level.   ''Moves'' shows the current number of moves.   ''Total'' shows the number of moves in all the levels.    [Prev][Next] buttons on the top left changes the game level.    [Restart] button restarts to the current level.    [Quit] closes the game.Dedicated to:  - Smalltalk & Linux Comunities.Thanks to:  - Diego Gomez Deck.  - Alejandro Reimondo.  - Andreas Wüst.Implemented By:  Gustavo Rafael Pistoia.  ' translated)		embeddedInMorphicWindowLabeled: 'ATOMIC')		setWindowColor: (Color				r: 0.032				g: 0.968				b: 1.0);		 openInWorld: self world extent: 400 @ 320! !!AtomicGame methodsFor: 'structure' stamp: 'grp 8/2/2002 16:39'!showPointsInfo	pointsMorph contents: self pointsMessage.	mapMoves = currentMap record		ifTrue: [pointsMorph color: Color blue]		ifFalse: [mapMoves - 1 = currentMap record				ifTrue: [pointsMorph color: Color red]]! !!AtomicGame methodsFor: 'access properties' stamp: 'grp 7/19/2002 18:20'!somethingAt: aPosition 	| morphs morph |	morphs _ self rootMorphsAt: aPosition.	morphs notEmpty		ifTrue: [morph _ morphs at: 1.			(morph isKindOf: AtomicComponent)				ifTrue: [^ morph]].	^ nil! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:18'!blackBishopImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 21053440 0 0 21053440 0 0 4538368 0 0 88489984 0 0 357978112 0 0 357994496 0 0 1431675904 0 1 1452647424 0 1 1452631040 0 5 1789487360 0 5 1789483264 0 5 1452628224 0 21 1452627200 0 21 1452626944 0 21 1431655424 0 21 1431655424 0 21 1431655424 0 21 1431654400 0 21 1431654400 0 5 1431654400 0 5 1431650304 0 1 1431650304 0 1 2863284224 0 1 2863284224 0 0 1431633920 0 0 445644800 0 1 1431650304 0 1 1789476864 0 1 1789476864 0 1 1431650304 0 0 20971520 0 0 89128960 0 0 357826560 0 21840 1414858069 0 349525 1410684245 1342177280 344085 1074091009 1342177280 262144 0 268435456 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:18'!blackKingImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 0 0 0 4194304 0 0 22020096 0 0 4194304 0 0 89391104 0 0 111411200 0 1398016 107216981 1426063360 22369600 107218261 1430257664 22456660 107222362 2772434944 89740885 111416741 1498415104 90527125 1162892885 1448083456 93672805 1095850325 1448083456 362108249 1431656790 2522087424 362190169 1435854230 2522087424 362190422 1452643686 2522087424 362112598 1431672169 1448345600 362112597 2505463146 2522087424 93760085 2505463145 1448083456 93678165 2526434665 1448083456 93673045 1704351141 1498415104 90527317 1700353429 1498415104 23418261 1700353429 1497366528 22631829 1499027029 1497366528 22631829 1503221333 1698693120 5657957 1503222101 1694498816 1463653 1499026773 2483027968 1414485 1499026774 1409286144 354986 2841291433 1342177280 87381 1431655765 1073741824 21845 1431655765 0 5802 2863311508 0 6485 1431655780 0 6485 1521046884 0 6485 1431655780 0 6826 2863311524 0 5461 1431655764 0 0 0 0 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!blackKnightImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 268435456 0 1 335544320 0 1 335544320 0 1 1430257664 0 0 1431568384 0 1 1431650304 0 21 1432704000 0 342 2774160704 0 1370 1767216464 0 5461 2505402708 0 21845 1431656021 0 87381 1431655829 0 349525 1431655781 1073741824 1398101 1431672149 1342177280 1398101 1431672153 1342177280 5592405 1431983446 1409286144 5592405 1343576406 1409286144 22369600 1402197 2483027968 26543360 5920085 2768240640 22287360 5593685 1694498816 22040576 23766357 1694498816 81920 89478485 1698693120 0 89478485 1698693120 0 357913941 1765801984 0 1431655765 1765801984 0 1431655765 1766850560 1 1431655765 1498415104 5 1431655765 1498415104 21 1431655765 1498415104 21 1431655765 1498415104 21 1431655765 1498415104 85 1431655765 1498415104 341 1431655765 1498415104 341 1431655765 1498415104 1365 1431655765 1498415104 1365 1431655765 1431306240 1365 1431655765 1431306240 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!blackPawnImage	^((ColorForm	extent: 40@40	depth: 1	fromArray: #( 0 0 15360 0 32256 0 32256 0 32256 0 32256 0 32256 0 15360 0 65280 0 262080 0 65280 0 32256 0 32256 0 65280 0 65280 0 65280 0 130944 0 262080 0 262080 0 524256 0 524256 0 524256 0 524256 0 524256 0 524256 0 524256 0 262080 0 262080 0 262080 0 130944 0 65280 0 65280 0 524256 0 4194300 0 8388606 0 16777215 0 33554431 2147483648 33554431 2147483648 33554431 2147483648 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032)  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!blackQueenImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 0 0 0 5242880 0 0 5242880 0 0 1048576 0 320 4194324 0 320 5242900 0 64 5242896 0 64 5242896 0 64 5242896 0 80 5242960 0 83886160 5242960 0 83886160 5242960 1310720 16777300 5243216 1310720 4194388 22282576 1048576 4194388 22282576 4194304 5242964 22282576 4194304 5505109 22283600 20971520 1310805 22283600 88080384 1376341 22283600 88080384 1392725 1096029520 356515840 1392725 1096029520 356515840 1396821 1096029520 1430257664 1397845 1431655761 1426063360 349269 1431655761 1426063360 349525 1431655765 1426063360 349525 1431655765 1426063360 349525 1431655765 1426063360 349525 1521112405 1426063360 88746 2773854890 1409286144 91477 1453938005 2483027968 27285 1436898666 2415919104 23125 1521112410 1342177280 6826 2773854890 1073741824 5461 1431655765 1073741824 21845 1431655765 1342177280 21845 1431655765 1342177280 0 0 0 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!blackRookImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 357826560 0 349184 357826645 1073741824 349184 357826645 1073741824 349184 357826645 1073741824 349525 1431655765 1073741824 436906 2863311530 1073741824 349526 1431721301 1073741824 1366 1431721296 0 1366 1431721296 0 1366 1431721296 0 1366 1431721296 0 1366 1431721296 0 1706 2863311504 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1706 2863311504 0 1366 1431721296 0 1366 1431721296 0 1366 1431721296 0 1366 1431721296 0 1366 1431721296 0 1706 2863311504 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1706 2863311504 0 23210 2863311525 0 27306 2863311529 0 87381 1431655765 1073741824 436906 2863311530 2415919104 436906 2863311530 2415919104 349525 1431655765 1342177280 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'parts bin' stamp: 'ar 8/13/2001 22:33'!descriptionForPartsBin	^ self partName: 	'Chess'		categories:		#('Games')		documentation:	'A fine game of chess'! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!whiteBishopImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 16842752 0 0 88424448 0 0 88424448 0 0 89473024 0 0 378966016 0 0 1520865280 0 1 1789240320 0 1 2842256384 0 5 2842321920 0 6 2505462784 0 22 2505479168 0 26 2842338304 0 26 2842338304 0 26 2842338304 0 26 2863309824 0 26 2863309824 0 26 2863309824 0 26 2863309824 0 26 2863305728 0 22 2863304704 0 6 2863288320 0 5 2863284224 0 1 1431650304 0 1 1431650304 0 1 1768505344 0 1 1768505344 0 1 1768505344 0 1 1431650304 0 5 2863284224 0 5 1431654400 0 0 104857600 0 0 374341632 0 0 1498677248 0 87381 1701139797 1073741824 1419946 2488969898 1409286144 349525 1343575381 1342177280 1310720 0 335544320 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!whiteKingImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 22020096 0 0 93585408 0 0 111411200 0 0 93585408 0 0 362020864 0 1397760 447021077 1409286144 5940480 425263450 2768240640 23767376 429458858 2839543808 94721684 425268885 1448083456 110536037 426072410 2794455040 379234921 1499818410 2777939968 442149466 1431676586 2846097408 443198102 2526451305 1772355584 443116133 2842319449 1772355584 443111785 2841270937 2846097408 443193769 1785293465 2577661952 442866090 1789504149 1503920128 443110826 1785309845 2846097408 376083882 1499048598 2845048832 106603946 2573838938 2777677824 110799274 2594548330 2794455040 110799210 2594613610 2794455040 93760106 2523310506 2521825280 27699802 2774968746 2587885568 23440026 2795939242 1497366528 6908570 2795939497 1694498816 5925546 2795940521 2751463424 1463637 1453675861 2483027968 371301 2506447274 1342177280 87641 2590415189 1073741824 26261 1431655845 0 21850 2774182229 0 21930 2505484885 0 21866 2842339669 0 22165 1431655829 0 21850 2863311189 0 21845 1431655765 0 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!whiteKnightImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 1073741824 0 16 1342177280 0 20 1342177280 0 5 1430257664 0 6 2857713664 0 6 2862956544 0 22 2863223808 0 346 2863306048 0 1445 1789569360 0 22166 1521134164 0 91813 1789569685 0 367274 2863245989 1073741824 1469098 2862983845 1342177280 1682090 2863049385 1342177280 5679786 2863048362 1409286144 22718890 2861996714 1409286144 27961706 2775210410 2499805184 95070809 1432708522 2499805184 111503701 22455978 2503999488 378889472 27957930 2773483520 374969344 94988970 2773483520 88428544 106343082 2773483520 84295680 359312042 2840592384 344064 1521134250 2840592384 1 1789569706 2840592384 1 2863311530 2840854528 5 2863311530 2857631744 22 2863311530 2857631744 26 2863311530 2857631744 90 2863311530 2857631744 106 2863311530 2857631744 362 2863311530 2857631744 1450 2863311530 2857631744 1706 2863311530 2857631744 5802 2863311530 2857631744 6826 2863311530 2857631744 23210 2863311530 2857631744 21845 1431655765 1431568384 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!whitePawnImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 357826560 0 0 446955520 0 0 1520762880 0 0 1789460480 0 0 1520762880 0 0 378798080 0 0 1431633920 0 1 1789476864 0 21 2863289344 0 85 1431655680 0 0 446955520 0 0 1520762880 0 0 1789460480 0 0 1789460480 0 1 1789476864 0 5 2863288320 0 6 2863304704 0 22 2863305728 0 26 2863309824 0 90 2863310080 0 106 2863311104 0 106 2863311104 0 106 2863311104 0 90 2863310080 0 26 2863309824 0 26 2863309824 0 22 2863305728 0 6 2863304704 0 5 2863288320 0 1 1789476864 0 0 1789460480 0 341 1520784704 0 1450 2505484880 0 22186 2863311509 0 92842 2863311529 1073741824 109226 2863311530 1073741824 109226 2863311530 1073741824 87381 1431655765 1073741824 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!whiteQueenImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 5242880 0 0 22282240 0 0 5242880 0 64 5242896 0 336 5242964 0 336 5242964 0 64 5242896 0 64 5242896 0 80 5242960 0 80 22282320 0 83886160 27525200 1310720 352321620 27525456 1376256 88080484 27525520 1376256 20971620 27525520 5242880 5242981 27526544 5242880 5505129 27526800 22020096 6553705 27526800 93323264 6619241 1101272720 105906176 6881386 1168448144 373293056 5849194 1185487504 440401920 1724522 1453939344 1514143744 1740906 2527685265 1782579200 1741930 2527685265 2856321024 1746282 2863311509 2856321024 1747306 2863311510 2856321024 1485482 2863311530 2839543808 436906 2863311530 2835349504 436906 2505403050 2835349504 365909 1515869525 1694498816 87466 2773854885 1409286144 21850 2841029205 1342177280 21866 2505403029 1342177280 21845 1521112405 1342177280 27306 2863311530 2415919104 27306 2863311530 2415919104 92842 2863311530 2483027968 87381 1431655765 1409286144 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!whiteRookImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 357892096 0 87360 447283221 1409286144 109120 447283226 2751463424 109120 447283226 2751463424 109141 1521046874 2751463424 109226 2863311530 2751463424 87381 1431655765 1409286144 426 1789553316 0 426 1789553316 0 426 1789553316 0 426 1789553316 0 426 1789553316 0 341 1431655764 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 341 1431655764 0 426 1789553316 0 426 1789553316 0 426 1789553316 0 426 1789553316 0 426 1789553316 0 341 1431655764 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 5461 1431655765 0 23210 2863311529 1073741824 27306 2863311530 1073741824 87381 1431655765 1342177280 371370 2863311530 2483027968 436906 2863311530 2751463424 349525 1431655765 1409286144 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph methodsFor: 'layout' stamp: 'ar 8/10/2001 11:50'!acceptDroppingMorph: aMorph event: anEvent	| destSquare sourceSquare |	sourceSquare _ aMorph valueOfProperty: #chessBoardSourceSquare.	aMorph removeProperty: #chessBoardSourceSquare.	destSquare _ self asSquare: aMorph center.	"!!!!!! ACTUAL MOVE HAPPENS INDIRECTLY !!!!!!"	(self atSquare: sourceSquare) addMorphCentered: aMorph.	destSquare ifNil:[^self].	self movePieceFrom: sourceSquare to: destSquare.	self showMovesAt: destSquare.! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 10/18/2001 21:01'!addButtonRow	| r m |	r _ AlignmentMorph newRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; color: Color transparent.	r addMorphBack: (self buttonName: '  New  ' action: #newGame).	r addMorphBack: (self buttonName: '  Help  ' action: #findBestMove).	r addMorphBack: (self buttonName: '  Play  ' action: #thinkAndMove).	r addMorphBack: (self buttonName: '  Auto  ' action: #autoPlay).	r addMorphBack: (self buttonName: '  Undo  ' action: #undoMove).	r addMorphBack: (self buttonName: '  Redo  ' action: #redoMove).	r addMorphBack: (self buttonName: '  Quit  ' action: #delete).	r disableTableLayout: true.	r align: r bounds topLeft with: self layoutBounds topLeft.	self addMorphFront: r.	m _ UpdatingStringMorph on: self selector: #statusString.	m useStringFormat.	m disableTableLayout: true.	m align: m bounds topLeft with: r fullBounds bottomLeft.	self addMorphFront: m.! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:34'!addSquares	| white black square index |	white _ Color white.	black _ Color lightGray.	index _ 0.	#(		(	' '	'a'	'b'	'c'	'd'	'e'	'f'	'g'	'h'	' ')		(	'1'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	' ')		(	'2'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	' ')		(	'3'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	' ')		(	'4'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	' ')		(	'5'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	' ')		(	'6'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	' ')		(	'7'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	' ')		(	'8'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	' ')		(	' '	' '	' '	' '	' '	' '	' '	' '	' '	' ')	) do:[:file|		file do:[:sq|		square _ self newSquare.		square borderWidth: 0.		(sq = 'W' or:[sq = 'B']) ifTrue:[			square color: (sq = 'W' ifTrue:[white] ifFalse:[black]).			square borderColor: Color red.			square setProperty: #squarePosition toValue: (index _ index + 1).			square setNameTo: 				(String with: ($a asInteger + (index - 1 bitAnd: 7)) asCharacter with: ($1 asInteger + (index -1 bitShift: -3)) asCharacter).			square on: #mouseEnter send: #showMoves:from: to: self.			square on: #mouseEnterDragging send: #dragSquareEnter:from: to: self.			square on: #mouseLeaveDragging send: #dragSquareLeave:from: to: self.		] ifFalse:["decoration"			square color: Color transparent.			sq = ' ' ifFalse:[				square addMorphCentered: (StringMorph contents: sq asUppercase font: Preferences windowTitleFont emphasis: 1).			].		].		square extent: 40@40.		self addMorphBack: square.	]].! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 8/10/2001 11:35'!addedPiece: piece at: square white: isWhite	| m |	m _ self newPiece: piece white: isWhite.	m on: #mouseDown send: #dragPiece:from: to: self.	m setProperty: #chessBoard toValue: self.	(self atSquare: square) removeAllMorphs; addMorphCentered: m.! !!ChessMorph methodsFor: 'drawing' stamp: 'ar 8/8/2001 23:59'!areasRemainingToFill: x	^x areasOutside: self bounds! !!ChessMorph methodsFor: 'geometry' stamp: 'ar 8/10/2001 11:46'!asSquare: aPoint	self squaresDo:[:sq| (sq bounds containsPoint: aPoint) ifTrue:[^sq valueOfProperty: #squarePosition]].	^nil! !!ChessMorph methodsFor: 'geometry' stamp: 'ar 8/10/2001 11:34'!atSquare: square	^submorphs detect:[:any| (any valueOfProperty: #squarePosition) = square] ifNone:[nil]! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 21:02'!autoPlay	autoPlay _ autoPlay not.	autoPlay ifTrue:[self thinkAndMove].! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 8/10/2001 12:25'!buttonFillStyle	| fill |	fill _ GradientFillStyle ramp: {		0.0 -> (Color r: 0.05 g: 0.5 b: 1.0). 		1.0 -> (Color r: 0.85 g: 0.95 b: 1.0)}.	fill origin: (0@0).	fill direction: 40@10.	fill radial: false.	^ fill! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 8/10/2001 12:18'!buttonName: aString action: aSymbol	^ SimpleButtonMorph new		target: self;		label: aString;		actionSelector: aSymbol;		color: (Color gray: 0.8);  "old color"		fillStyle: self buttonFillStyle;		borderWidth: 0;		borderColor: #raised.! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 10/18/2001 20:11'!completedMove: aMove white: aBool	board ifNil:[^self].	history addLast: aMove.	self validateGamePosition.! !!ChessMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:17'!defaultBorderColor"answer the default border color/fill style for the receiver"	^ #raised! !!ChessMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:17'!defaultBorderWidth"answer the default border width for the receiver"	^ 5! !!ChessMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:26'!defaultBounds	"answer the default bounds for the receiver"	^ 0 @ 0 corner: 410 @ 410! !!ChessMorph methodsFor: 'initialization' stamp: 'jam 3/9/2003 16:47'!defaultColor	"answer the receiver's default color"	| result |	result _ GradientFillStyle ramp: {0.0					-> (Color							r: 0.05							g: 0.5							b: 1.0). 1.0					-> (Color							r: 0.85							g: 0.95							b: 1.0)}.	result origin: self bounds origin;		 direction: self extent.	result radial: false.	^ result! !!ChessMorph methodsFor: 'drag and drop' stamp: 'ar 10/18/2001 20:11'!dragPiece: evt from: aMorph	board searchAgent isThinking ifTrue:[^self].	self submorphsDo:[:m| m borderWidth: 0].	aMorph setProperty: #chessBoardSourceSquare toValue: (aMorph owner valueOfProperty: #squarePosition).	evt hand grabMorph: aMorph.! !!ChessMorph methodsFor: 'drag and drop' stamp: 'ar 10/18/2001 20:11'!dragSquareEnter: evt from: aMorph	"Note: #wantsDroppedMorph: will validate move"	board ifNil:[^self].	evt hand hasSubmorphs ifFalse:[^self].	(self wantsDroppedMorph: evt hand firstSubmorph event: evt) ifFalse:[^self].	aMorph borderWidth: 1.! !!ChessMorph methodsFor: 'drag and drop' stamp: 'ar 10/18/2001 20:10'!dragSquareLeave: evt from: aMorph	board ifNil:[^self].	evt hand hasSubmorphs ifFalse:[^self].	aMorph borderWidth: 0.! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 20:18'!findBestMove	| move |	board searchAgent isThinking ifTrue:[^self].	Cursor wait showWhile:[move _ board searchAgent think].	self inform: 'I suggest: ', move printString.	^move! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 10/18/2001 20:13'!finishedGame: result	"		0 - white lost		0.5 - draw		1 - white won	"	board _ nil.! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 8/10/2001 11:33'!gameReset	self squaresDo:[:m| m removeAllMorphs; borderWidth: 0]! !!ChessMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:26'!initialize	"initialize the state of the receiver"	super initialize.	""	animateMove _ false.	autoPlay _ false.	self cornerStyle: #rounded.	self layoutPolicy: TableLayout new.	self listDirection: #leftToRight;		 wrapDirection: #bottomToTop.	self addSquares.	self addButtonRow.	self newGame! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 20:19'!movePieceFrom: sourceSquare to: destSquare	board ifNil:[^self].	board searchAgent isThinking ifTrue:[^self].	board movePieceFrom: sourceSquare to: destSquare.	board searchAgent startThinking.! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 10/18/2001 20:43'!movedPiece: piece from: sourceSquare to: destSquare	| sourceMorph destMorph sourcePos destPos w startTime nowTime deltaTime |	sourceMorph _ (self atSquare: sourceSquare) firstSubmorph.	destMorph _ self atSquare: destSquare.	animateMove ifTrue:[		sourcePos _ sourceMorph boundsInWorld center.		destPos _ destMorph boundsInWorld center.		(w _ self world) ifNotNil:[			w addMorphFront: sourceMorph.			sourceMorph addDropShadow.			sourceMorph shadowColor: (Color black alpha: 0.5).			deltaTime _ (sourcePos dist: destPos) * 10 asInteger.			startTime _ Time millisecondClockValue.			[nowTime _ Time millisecondClockValue.			nowTime - startTime < deltaTime] whileTrue:[				sourceMorph center: sourcePos + (destPos - sourcePos * (nowTime - startTime) // deltaTime) asIntegerPoint.				w displayWorldSafely].			sourceMorph removeDropShadow.		].	].	destMorph removeAllMorphs.	destMorph addMorphCentered: sourceMorph.	animateMove _ false.! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 22:38'!newGame	board ifNil:[board _ ChessBoard new].	board initialize.	board userAgent: self.	board initializeNewBoard.	history _ OrderedCollection new.	redoList _ OrderedCollection new.! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 8/10/2001 10:22'!newPiece: piece white: isWhite	| index selector m |	index _ piece.	isWhite ifFalse:[index _ index + 6].	selector _ #(			whitePawnImage		whiteKnightImage		whiteBishopImage		whiteRookImage		whiteQueenImage		whiteKingImage		blackPawnImage		blackKnightImage		blackBishopImage		blackRookImage		blackQueenImage		blackKingImage) at: index.	m _ ChessPieceMorph new image: (self class perform: selector).	m setProperty: #isWhite toValue: isWhite.	m setProperty: #piece toValue: piece.	^m! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 8/8/2001 22:53'!newSquare	^BorderedMorph new "or anyone alike"! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 20:13'!redoMove	"Redo the last undone move"	redoList isEmpty ifTrue:[^self].	board nextMove: redoList removeLast.! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 10/18/2001 20:47'!removedPiece: piece at: square	animateMove ifFalse:[		(self atSquare: square) removeAllMorphs.	].! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 8/9/2001 03:40'!replacedPiece: oldPiece with: newPiece at: square white: isWhite	self removedPiece: oldPiece at: square.	self addedPiece: newPiece at: square white: isWhite! !!ChessMorph methodsFor: 'other stuff' stamp: 'ar 8/10/2001 11:34'!rotateBoard	self listDirection = #leftToRight		ifTrue:[^self listDirection: #topToBottom; wrapDirection: #leftToRight].	self listDirection = #topToBottom		ifTrue:[^self listDirection: #rightToLeft; wrapDirection: #topToBottom].	self listDirection = #rightToLeft		ifTrue:[^self listDirection: #bottomToTop; wrapDirection: #rightToLeft].	self listDirection = #bottomToTop		ifTrue:[^self listDirection: #leftToRight; wrapDirection: #bottomToTop].! !!ChessMorph methodsFor: 'events' stamp: 'ar 10/18/2001 20:21'!showMoves: evt from: aMorph	| square |	square _ aMorph valueOfProperty: #squarePosition.	square ifNotNil:[^self showMovesAt: square].! !!ChessMorph methodsFor: 'events' stamp: 'ar 10/18/2001 20:13'!showMovesAt: square	| list |	board ifNil:[^self].	board searchAgent isThinking ifTrue:[^self].	self squaresDo:[:m| m borderWidth: 0].	list _ board activePlayer findValidMovesAt: square.	list isEmpty ifTrue:[^self].	(self atSquare: square) borderWidth: 1.	list do:[:move|		(self atSquare: move destinationSquare) borderWidth: 1.	].! !!ChessMorph methodsFor: 'geometry' stamp: 'ar 8/10/2001 11:34'!squaresDo: aBlock	^submorphs do:[:m| (m hasProperty: #squarePosition) ifTrue:[aBlock value: m]].! !!ChessMorph methodsFor: 'other stuff' stamp: 'ar 10/18/2001 20:10'!statusString	board ifNil:[^''].	^board statusString! !!ChessMorph methodsFor: 'stepping and presenter' stamp: 'ar 10/18/2001 21:02'!step	| move |	board searchAgent isThinking ifTrue:[		move _ board searchAgent thinkStep.		move ifNotNil:[			animateMove _ true.			board movePieceFrom: move sourceSquare 					to: move destinationSquare].	] ifFalse:[		autoPlay ifTrue:[board searchAgent startThinking].	].! !!ChessMorph methodsFor: 'testing' stamp: 'ar 8/12/2001 21:10'!stepTime	^0! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 20:19'!thinkAndMove	board searchAgent isThinking ifTrue:[^self].	board searchAgent startThinking.! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 20:11'!undoMove	"Undo the last move"	board ifNil:[^self].	history isEmpty ifTrue:[^self].	board undoMove: history removeLast.! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 10/18/2001 20:13'!undoMove: aMove white: aBool	board ifNil:[^self].	redoList addLast: aMove.	self validateGamePosition.! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 10/18/2001 20:23'!validateGamePosition	"This method does nothing but validating what you see (on screen) is what you get (from the board)."	| square piece isWhite p |	1 to: 64 do:[:idx|		square _ self atSquare: idx.		square hasSubmorphs 			ifTrue:[piece _ square firstSubmorph valueOfProperty: #piece.					isWhite _ square firstSubmorph valueOfProperty: #isWhite]			ifFalse:[piece _ 0. isWhite _ nil].		p _ board whitePlayer pieceAt: idx.		idx = board whitePlayer castlingRookSquare ifTrue:[p _ ChessPlayer rook].		isWhite == true ifTrue:[			p = piece ifFalse:[self error:'White broken'].		] ifFalse:[p = 0 ifFalse:[self error:'White broken']].		p _ board blackPlayer pieceAt: idx.		idx = board blackPlayer castlingRookSquare ifTrue:[p _ ChessPlayer rook].		isWhite == false ifTrue:[			p = piece ifFalse:[self error:'White broken'].		] ifFalse:[p = 0 ifFalse:[self error:'White broken']].	].! !!ChessMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/18/2001 20:11'!wantsDroppedMorph: aMorph event: anEvent	| sourceSquare destSquare |	(aMorph valueOfProperty: #chessBoard) == self ifFalse:[^false].	board ifNil:[^true].	sourceSquare _ aMorph valueOfProperty: #chessBoardSourceSquare.	destSquare _ self asSquare: aMorph bounds center.	destSquare ifNil:[^false].	^board activePlayer isValidMoveFrom: sourceSquare to: destSquare! !!ChineseCheckers class methodsFor: 'parts bin' stamp: 'sw 8/2/2001 01:21'!descriptionForPartsBin	^ self partName:	'ChineseCheckers'		categories:		#('Games')		documentation:	'Halma - the classic board game of Chinese Checkers, written by Dan Ingalls'! !!ChineseCheckers methodsFor: 'layout' stamp: 'ajh 2/15/2001 21:11'!acceptDroppingMorph: aPiece event: evt	| dropLoc |	dropLoc _ self boardLocAt: evt cursorPoint.	dropLoc = aPiece boardLoc ifTrue:  "Null move"		[^ aPiece rejectDropMorphEvent: evt].	(plannedMove _ (self allMovesFrom: aPiece boardLoc)				detect: [:move | move last = dropLoc]				ifNone: [nil])		ifNil: [^ aPiece rejectDropMorphEvent: evt.   "Not a valid move"].	super acceptDroppingMorph: aPiece event: evt.	movePhase _ 1.  "Start the animation if any."! !!ChineseCheckers methodsFor: 'menus' stamp: 'di 4/13/2000 13:23'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Include our modest command set in the ctrl-menu"	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	self addMenuItemsTo: aCustomMenu hand: aHandMorph! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 14:01'!addMenuItemsTo: aMenu hand: aHandMorph	aMenu add: 'new game' target: self action: #newGame.	aMenu add: 'reset...' target: self action: #reset.	animateMoves		ifTrue: [aMenu add: 'don''t animate moves' target: self action: #dontAnimateMoves]		ifFalse: [aMenu add: 'animate moves' target: self action: #animateMoves]! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/13/2000 14:18'!allMovesFrom: boardLoc  "boardLoc must be occupied"	| team stepMoves jumpDict |	team := self at: boardLoc.	stepMoves := (sixDeltas collect: [:d | boardLoc + d])		select: [:p | (self at: p) notNil and: [(self at: p) = 0]].	jumpDict := Dictionary new.	jumpDict at: boardLoc put: (Array with: boardLoc).	self jumpFor: team from: boardLoc havingVisited: jumpDict.	jumpDict removeKey: boardLoc.	^ (stepMoves collect: [:p | {boardLoc. p}]) , jumpDict values		reject:		[:move |  "Don't include any moves that land in other homes."		(self distFrom: move last to: self boardCenter) >= 5  "In a home..."			and: [(self distFrom: move last to: (homes atWrap: team+3)) > 3  "...not my goal..."			and: [(self distFrom: move last to: (homes at: team)) > 3  "...nor my home"]]]! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 13:36'!animateMoves	animateMoves _ true! !!ChineseCheckers methodsFor: 'accessing'!at: p	^ (board at: p x) at: p y! !!ChineseCheckers methodsFor: 'accessing'!at: p put: x	^ (board at: p x) at: p y put: x! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/12/2000 23:23'!bestMove: ply forTeam: team	| score bestScore bestMove |	bestScore := -999.	(teams at: team) do:		[:boardLoc |		(self allMovesFrom: boardLoc) do:			[:move |			score := self score: move for: team.			(score > -99 and: [ply > 0]) ifTrue: 				[score := score  "Add 0.7 * score of next move (my guess)"					+ (0 max: ((self score: ((self copyBoard makeMove: move)							bestMove: ply - 1 forTeam: team) for: team) * 0.7))].			score > bestScore ifTrue:				[bestScore := score.  bestMove := move]]].	^ bestMove! !!ChineseCheckers methodsFor: 'initialization'!board: b teams: t	board := b.	teams := t! !!ChineseCheckers methodsFor: 'board geometry'!boardCenter	^ 10@10! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 4/9/2000 10:00'!boardLocAt: cellPoint	| dx dy row col |	dx _ self width/15.0.  dy _ dx * 0.8660254037844385 "(Float pi / 3) sin".	row _ (cellPoint y - self position y) // dy + 1.	col _ (cellPoint x - self position x) / (dx/2.0) + 16 - row // 2.	^ row @ col! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 4/11/2000 17:18'!cellPointAt: boardLoc	| dx dy row col |	dx _ self width/15.0.  dy _ dx * 0.8660254037844385 "(Float pi / 3) sin".	row _ boardLoc x.	col _ boardLoc y.	^ self position + ((col*2+row-16*dx//2)@(row-1*dy)) asIntegerPoint! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/10/2000 08:27'!checkDoneAfter: move	| team locsAfterMove |	(team := self at: move first) = 0 ifTrue: [^ false].	(locsAfterMove _ (teams at: team) copy) replaceAll: move first with: move last.	^ self testDone: locsAfterMove for: team! !!ChineseCheckers methodsFor: 'initialization' stamp: 'di 4/9/2000 20:55'!copyBoard	"Return a copy of the board for the purpose of looking ahead one or more moves."	^ self copy		board: (board collect: [:row | row copy])		teams: (teams collect: [:team | team copy])! !!ChineseCheckers methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:18'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 0.6		g: 0.4		b: 0.0! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 3/13/2000 19:50'!distFrom: a to: b	"The six possible moves are: 1@0, 1@-1, 0@1, 0@-1, -1@0, -1@1."	| dx dy |	dx _ b x - a x.	dy _ b y - a y.	dx abs >= dy abs	ifTrue: ["Major change is in x-coord..."			dx >= 0			ifTrue: [(dy between: (0-dx) and: 0)						ifTrue: [^ dx  "no lateral motion"].					^ dx + ((0-dx) - dy max: dy - 0)  "added lateral dist"]			ifFalse: ["Reverse sign and rerun same code"					^ self distFrom: b to: a]]	ifFalse: ["Transpose and re-run same code"			^ self distFrom: a transposed to: b transposed]! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 13:36'!dontAnimateMoves	animateMoves _ false! !!ChineseCheckers methodsFor: 'drawing' stamp: 'di 8/10/2000 09:40'!drawOn: aCanvas 	| row1 row2 offset dotExtent |	super drawOn: aCanvas.   "Draw square board"	"Only draw rows in the clipping region"	dotExtent _ (self width//25) asPoint.	offset _ self pieceSize - dotExtent + 1 // 2.  "Offset of smaller dots rel to larger"	row1 _ (self boardLocAt: aCanvas clipRect topLeft) x max: 1.	row2 _ (self boardLocAt: aCanvas clipRect bottomRight) x min: board size.	row1 to: row2 do:		[:row | (board at: row) doWithIndex:			[:cell :i | cell ifNotNil:				[aCanvas fillOval: ((self cellPointAt: (row@i)) + offset extent: dotExtent)					color: (colors at: cell+1)]]]! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/12/2000 23:40'!endGameFor: team	"Return true if we are in the end game (all players within 1 of home triangle)."	| goalLoc |	goalLoc _ homes atWrap: team+3.  "Farthest cell across the board"	(teams at: team)		do: [:boardLoc | (self distFrom: boardLoc to: goalLoc) > 4 ifTrue: [^ false]].	^ true! !!ChineseCheckers methodsFor: 'geometry' stamp: 'di 4/11/2000 09:21'!extent: newExtent	| extraY |	extraY _ (newExtent x / 15.0 * 1.25) asInteger.	super extent: (newExtent x) @ (newExtent x + extraY).	self submorphsDo:		[:m | (m isKindOf: ChineseCheckerPiece) ifTrue:				[m position: (self cellPointAt: m boardLoc); extent: self pieceSize]]! !!ChineseCheckers methodsFor: 'event handling' stamp: 'sma 4/30/2000 09:23'!handlesMouseDown: evt	"Prevent stray clicks from picking up the whole game in MVC."	^ Smalltalk isMorphic not or: [evt yellowButtonPressed]! !!ChineseCheckers methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:19'!initialize	"Default creation is for one person against Squeak."	super initialize.	""	self extent: 382 @ 413.	animateMoves _ true.	self teams: #(2 5 ) autoPlay: {false. true}! !!ChineseCheckers methodsFor: 'parts bin' stamp: 'sw 6/28/2001 11:32'!initializeToStandAlone 	"Default creation is for one person against Squeak."	super initializeToStandAlone.	self extent: 382@413.	self color: (Color r: 0.6 g: 0.4 b: 0.0).	self borderWidth: 2.	animateMoves _ true.	self teams: #(2 5) autoPlay: {false. true}.! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/12/2000 20:36'!jumpFor: team from: loc havingVisited: dict	"Recursively explore all jumps from loc, leaving in dict	the prior position from which we got there"	"Fasten seatbelts..."	((((sixDeltas		collect: [:d | loc + d])		select: [:p | (self at: p) notNil and: [(self at: p) > 0]])		collect: [:p | p + (p - loc)])		select: [:p | (self at: p) notNil and: [(self at: p) = 0]])		do: [:p | (dict includesKey: p) ifFalse:			[dict at: p put: ((dict at: loc) copyWith: p).			self jumpFor: team from: p havingVisited: dict]]! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/10/2000 08:17'!makeMove: move	| team |	team := self at: move first.	self at: move last put: team.	self at: move first put: 0.	(teams at: team) replaceAll: move first with: move last! !!ChineseCheckers methodsFor: 'event handling' stamp: 'RAA 6/12/2000 08:57'!mouseDown: evt	| menu |	evt yellowButtonPressed ifFalse: [^ self].	menu _ MenuMorph new defaultTarget: self.	self addMenuItemsTo: menu hand: evt hand.	menu popUpEvent: evt in: self world.! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 13:32'!newGame	"Reset the board, with same teams."	| teamNumbers |	teamNumbers _ (1 to: 6) reject: [:i | (teams at: i) isEmpty].	self teams: teamNumbers		 autoPlay: (teamNumbers collect: [:i | autoPlay at: i]).! !!ChineseCheckers methodsFor: 'game sequence' stamp: 'di 4/13/2000 14:25'!nextTurn	(self testDone: (teams at: whoseMove) for: whoseMove) ifTrue:		[(self pieceAt: self turnIndicatorLoc) extent: self width asPoint//6; borderWidth: 2.		^ whoseMove _ 0.  "Game over."].		[whoseMove _ whoseMove\\6 + 1.	(teams at: whoseMove) isEmpty]  "Turn passes to the next player"		whileTrue: [].	(self pieceAt: self turnIndicatorLoc) color: (colors at: whoseMove+1)! !!ChineseCheckers methodsFor: 'drag and drop' stamp: 'di 4/8/2000 23:45'!okToPickUpPieceAt: boardLoc	^ (self at: boardLoc) = whoseMove and: [(autoPlay at: whoseMove) not]! !!ChineseCheckers methodsFor: 'drag and drop' stamp: 'di 4/9/2000 08:30'!pieceAt: boardLoc	self submorphsDo:		[:m | ((m isMemberOf: ChineseCheckerPiece) and: [m boardLoc = boardLoc])				ifTrue: [^ m]].	^ nil! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 4/11/2000 09:20'!pieceSize	^ self width asPoint // 20! !!ChineseCheckers methodsFor: 'printing' stamp: 'dgd 2/21/2003 23:14'!printOn: s 	"For testing only"	1 to: board size		do: 			[:row | 			s				cr;				next: row put: $ .			(board at: row) do: 					[:cell | 					s						space;						nextPut: (cell isNil ifTrue: [$-] ifFalse: [cell printString last])]]! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 13:31'!reset	"Reset the board, choosing anew how many teams."	| nPlayers nHumans |	nPlayers _ (SelectionMenu selections: (1 to: 6)) startUpWithCaption: 'How many players?'.	nPlayers ifNil: [nPlayers _ 2].	nHumans _ (SelectionMenu selections: (0 to: nPlayers)) startUpWithCaption: 'How many humans?'.	nHumans ifNil: [nHumans _ 1].	self teams: (#((1) (2 5) (2 4 6) (1 2 4 5) (1 2 3 4 6) (1 2 3 4 5 6)) at: nPlayers)		 autoPlay: ((1 to: nPlayers) collect: [:i | i > nHumans]).! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/13/2000 14:21'!score: move for: team	"Return the decrease in distance toward this team's goal"	| goal closerToGoal wasBack nowBack |	goal _ homes atWrap: team+3.	wasBack _ self distFrom: move first to: goal.	nowBack _ self distFrom: move last to: goal.	closerToGoal _ wasBack - nowBack.	closerToGoal < -1 ifTrue: [^ -99].  "Quick rejection if move backward more than 1"	(nowBack <= 3 and: [self checkDoneAfter: move]) ifTrue: [^ 999].	"Reward closerToGoal, but add bias to move those left far behind."	^ (closerToGoal*5) + wasBack! !!ChineseCheckers methodsFor: 'game sequence' stamp: 'di 4/11/2000 08:35'!showNextMoveSegment	"Display the current move in progress.  Starts with movePhase = 1.	Increments movePhase at each tick.  Ends by setting movePhase to 0."	| dot p1 p2 delta secondPhase line |	delta _ self width//40.	movePhase <= plannedMove size	ifTrue:		["First we trace the move with dots and lines..."		movePhase = 1 ifTrue: [pathMorphs _ OrderedCollection new].		p1 _ self cellPointAt: (plannedMove at: movePhase).		dot _ (ImageMorph new image: (Form dotOfSize: 7)) position: p1 + delta - (7//2).		self addMorph: dot.  pathMorphs addLast: dot.		movePhase > 1 ifTrue:			[p2 _ self cellPointAt: (plannedMove at: movePhase-1).			line _ PolygonMorph vertices: {p2 + delta. p1 + delta} color: Color black					borderWidth: 3 borderColor: Color black.			self addMorph: line.  pathMorphs addLast: line]]	ifFalse:		["...then we erase the path while moving the piece."		secondPhase _ movePhase - plannedMove size.		pathMorphs removeFirst delete.		secondPhase > 1 ifTrue:			[pathMorphs removeFirst delete.			self makeMove: {plannedMove at: secondPhase - 1. plannedMove at: secondPhase}.			(self pieceAt: (plannedMove at: secondPhase - 1))				position: (self cellPointAt: (plannedMove at: secondPhase));				setBoard: self loc: (plannedMove at: secondPhase).			self changed]].	(movePhase _ movePhase + 1) > (plannedMove size * 2)		ifTrue: [movePhase _ 0  "End of animated move"].! !!ChineseCheckers methodsFor: 'game sequence' stamp: 'dgd 2/21/2003 23:14'!step	whoseMove = 0 ifTrue: [^self].	"Game over."	plannedMove isNil 		ifTrue: 			[(autoPlay at: whoseMove) ifFalse: [^self].	"Waiting for a human."			plannedMove := (self endGameFor: whoseMove) 						ifTrue: 							["Look deeper at the end."							self bestMove: 2 forTeam: whoseMove]						ifFalse: [self bestMove: 1 forTeam: whoseMove].			movePhase := 1	"Start the animated move"].	animateMoves 		ifTrue: 			["Display the move in phases..."			movePhase > 0 ifTrue: [^self showNextMoveSegment]]		ifFalse: 			["... or skip the entire animated move if requested."			self makeMove: plannedMove.			(self pieceAt: plannedMove first)				position: (self cellPointAt: plannedMove last);				setBoard: self loc: plannedMove last.			self changed.			movePhase := 0].	plannedMove := nil.	"End the animated move"	self nextTurn! !!ChineseCheckers methodsFor: 'testing' stamp: 'di 4/12/2000 23:43'!stepTime	^ 200! !!ChineseCheckers methodsFor: 'initialization' stamp: 'di 4/12/2000 23:44'!teams: teamsPlaying autoPlay: ifAuto	"Initialize board, teams, steps, jumps"	| p q teamInPlay |	colors _ (#(gray) , #(red green blue cyan magenta yellow white) shuffled)				collect: [:c | Color perform: c].  "New set of colors each time."	self removeAllMorphs.  "eg, from previous game."	board := (1 to: 19) collect: [:i | Array new: 19].	sixDeltas := {0@1. -1@1. -1@0. 0@-1. 1@-1. 1@0}.	homes := {14@2. 18@6. 14@14. 6@18. 2@14. 6@6}.	teams := (1 to: 6) collect: [:i | OrderedCollection new].	autoPlay := (1 to: 6) collect: [:i | false].	1 to: 6 do:		[:team | p:= homes at: team.		(teamInPlay := teamsPlaying includes: team) ifTrue:			[autoPlay at: team put: (ifAuto at: (teamsPlaying indexOf: team))].		"Place empty cells in rhombus extending out from each		home, and occupied cells in active home triangles."		1 to: 5 do: [:i | q := p.			1 to: 5 do: [:j |				(teamInPlay and: [j <= (5 - i)])					ifTrue: [self at: q put: team.							(teams at: team) add: q.							self addMorph:								((ChineseCheckerPiece									newBounds: ((self cellPointAt: q) extent: self pieceSize)									color: (colors at: team+1))										setBoard: self loc: q)]					ifFalse: [self at: q put: 0].				q := q + (sixDeltas at: team).  "right,forward"].			p := p + (sixDeltas atWrap: team+1).  "left,forward"].		teams at: team put: (teams at: team) asArray].	whoseMove _ teamsPlaying first.	self addMorph:		((ChineseCheckerPiece			newBounds: ((self cellPointAt: self turnIndicatorLoc) extent: self pieceSize)			color: (colors at: whoseMove+1))				setBoard: self loc: self turnIndicatorLoc).	plannedMove _ nil.	self changed! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/12/2000 23:40'!testDone: teamLocs for: team	"Return true if we are done (all players in home triangle)."	| goalLoc |	goalLoc _ homes atWrap: team+3.	teamLocs		do: [:boardLoc | (self distFrom: boardLoc to: goalLoc) > 3 ifTrue: [^ false]].	^ true! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 4/9/2000 09:44'!turnIndicatorLoc	^ 16@11! !!ChineseCheckers methodsFor: 'dropping/grabbing' stamp: 'di 4/9/2000 10:44'!wantsDroppedMorph: aPiece event: evt	^ aPiece isKindOf: ChineseCheckerPiece! !!WordGameLetterMorph class methodsFor: 'new-morph participation' stamp: 'di 5/10/2000 07:42'!includeInNewMorphMenu	^ false! !!WordGameLetterMorph class methodsFor: 'class initialization' stamp: 'di 5/11/2000 07:15'!initialize  "WordGameLetterMorph initialize"	IDFont _ StrikeFont familyName: 'ComicPlain' size: 13.	IDHeight _ IDFont height.	LetterFont _ StrikeFont familyName: 'ComicBold' size: 19.	LetterHeight _ LetterFont height.! !!WordGameLetterMorph methodsFor: 'style inits' stamp: 'di 5/7/2000 17:00'!boxed	style _ #boxed! !!WordGameLetterMorph methodsFor: 'event handling' stamp: 'di 10/14/2000 22:36'!handlesKeyboard: evt	^ true! !!WordGameLetterMorph methodsFor: 'initialization' stamp: 'di 5/11/2000 07:33'!id2: idString	"Add further clue id for acrostic puzzles."	| idMorph |	idString ifNotNil:		[idMorph _ StringMorph contents: idString font: IDFont.		idMorph align: idMorph bounds topRight with: self bounds topRight + (-1@-1).		self addMorph: idMorph].! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'di 5/7/2000 13:42'!indexInQuote	^ indexInQuote! !!WordGameLetterMorph methodsFor: 'initialization' stamp: 'dgd 2/21/2003 23:15'!indexInQuote: qi id1: aString 	"Initialize me with the given index and an optional aString"	| idMorph y |	style = #boxed		ifTrue: [aString isNil				ifTrue: [self extent: 18 @ 16;						 borderWidth: 1]				ifFalse: [self extent: 26 @ 24;						 borderWidth: 1]]		ifFalse: [aString isNil				ifTrue: [self extent: 18 @ 16;						 borderWidth: 0]				ifFalse: [self extent: 18 @ 26;						 borderWidth: 0]].	qi		ifNil: [^ self color: Color gray].	"blank"	self color: self normalColor.	indexInQuote _ qi.	style == #underlined		ifTrue: [y _ self bottom - 2.			aString				ifNotNil: [y _ y - IDFont ascent + 2].			lineMorph _ PolygonMorph						vertices: {self left + 2 @ y. self right - 3 @ y}						color: Color gray						borderWidth: 1						borderColor: Color gray.			self addMorph: lineMorph.			aString				ifNil: [^ self].			idMorph _ StringMorph contents: aString font: IDFont.			idMorph align: idMorph bounds bottomCenter with: self bounds bottomCenter + (0 @ (IDFont descent - 1)).			self addMorphBack: idMorph]		ifFalse: [aString				ifNil: [^ self].			idMorph _ StringMorph contents: aString font: IDFont.			idMorph align: idMorph bounds topLeft with: self bounds topLeft + (2 @ -1).			self addMorph: idMorph			" 			World addMorph: (WordGameLetterMorph new boxed  			indexInQuote: 123 id1: '123';  			id2: 'H'; setLetter: $W).  			World addMorph: (WordGameLetterMorph new underlined  			indexInQuote: 123 id1: '123';  			setLetter: $W).  			World addMorph: (WordGameLetterMorph new underlined  			indexInQuote: 123 id1: nil;  			setLetter: $W). 			"]! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'dgd 2/21/2003 23:15'!isBlank	^indexInQuote isNil! !!WordGameLetterMorph methodsFor: 'event handling' stamp: 'di 5/9/2000 16:20'!keyboardFocusChange: boolean	| panel |	boolean ifFalse:		[panel _ self nearestOwnerThat: [:m | m respondsTo: #checkForLostFocus].		panel ifNotNil: [panel checkForLostFocus]]! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'di 5/7/2000 23:31'!letter	^ letter! !!WordGameLetterMorph methodsFor: 'linking' stamp: 'dgd 2/21/2003 23:15'!morphsInWordDo: aBlock 	aBlock value: self.	(successor isNil or: [successor isBlank]) ifTrue: [^self].	successor morphsInWordDo: aBlock! !!WordGameLetterMorph methodsFor: 'linking' stamp: 'di 5/7/2000 14:06'!nextTypeableLetter	successor ifNil: [^ self].	successor isBlank ifTrue: [^ successor nextTypeableLetter].	^ successor! !!WordGameLetterMorph methodsFor: 'initialization' stamp: 'di 5/8/2000 11:22'!normalColor	^ Color r: 1.0 g: 0.8 b: 0.2! !!WordGameLetterMorph methodsFor: 'style inits' stamp: 'di 5/7/2000 17:00'!plain	style _ #plain! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'di 5/7/2000 13:43'!predecessor	^ predecessor! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'di 5/7/2000 13:25'!predecessor: pred	predecessor _ pred! !!WordGameLetterMorph methodsFor: 'linking' stamp: 'di 5/7/2000 14:19'!previousTypeableLetter	predecessor ifNil: [^ self].	predecessor isBlank ifTrue: [^ predecessor previousTypeableLetter].	^ predecessor! !!WordGameLetterMorph methodsFor: 'initialization' stamp: 'di 5/7/2000 23:58'!setLetter: aLetter	^ self setLetter: aLetter color: Color black! !!WordGameLetterMorph methodsFor: 'initialization' stamp: 'dgd 2/21/2003 23:15'!setLetter: aLetter color: aColor 	letterMorph ifNotNil: [letterMorph delete].	letter := aLetter.	letter ifNil: [^letterMorph := nil].	letterMorph := StringMorph contents: aLetter asString font: LetterFont.	letterMorph color: aColor.	style == #boxed 		ifTrue: 			[letterMorph align: letterMorph bounds bottomCenter				with: self bounds bottomCenter + (0 @ (LetterFont descent - 2))]		ifFalse: 			[lineMorph isNil 				ifTrue: 					[letterMorph align: letterMorph bounds bottomCenter						with: self bounds bottomCenter + (0 @ (LetterFont descent - 4))]				ifFalse: 					[letterMorph align: letterMorph bounds bottomCenter						with: self center x @ (lineMorph top + LetterFont descent)]].	self addMorphBack: letterMorph! !!WordGameLetterMorph methodsFor: 'linking' stamp: 'dgd 2/21/2003 23:15'!startOfWord	(predecessor isNil or: [predecessor isBlank]) ifTrue: [^self].	^predecessor startOfWord! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'di 5/7/2000 13:43'!successor	^ successor! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'di 5/7/2000 13:25'!successor: succ	successor _ succ! !!WordGameLetterMorph methodsFor: 'style inits' stamp: 'di 5/7/2000 17:01'!underlined	style _ #underlined! !!WordGameLetterMorph methodsFor: 'typing' stamp: 'di 5/8/2000 11:21'!unhighlight	(self isBlank or: [self color = self normalColor])		ifFalse: [self color: self normalColor]! !!CipherPanel class methodsFor: 'parts bin' stamp: 'sw 8/2/2001 01:21'!descriptionForPartsBin	^ self partName:	'Cipher'		categories:		#('Games')		documentation:	'The Cipher Panel: A playground for cryptograms, by Dan Ingalls'! !!CipherPanel class methodsFor: 'as yet unclassified' stamp: 'di 10/4/2000 10:42'!encode: aString	"CipherPanel encode: 'Now is the time for all good men to come to the aid of their country.'"	| dict repeat |	dict _ Dictionary new.	repeat _ true.	[repeat] whileTrue:		[repeat _ false.		($A to: $Z) with: ($A to: $Z) shuffled do:			[:a :b | a = b ifTrue: [repeat _ true].			dict at: a put: b]].	^ aString asUppercase collect: [:a | dict at: a ifAbsent: [a]]! !!CipherPanel class methodsFor: 'new-morph participation' stamp: 'di 5/10/2000 09:52'!includeInNewMorphMenu	^ true! !!CipherPanel class methodsFor: 'instance creation' stamp: 'di 5/10/2000 10:08'!new	"NOTE: Use newFromQuote: rather than new to create new CipherPanels"	^ self newFromQuote: self sampleString" Here are some other examples...World addMorph: (CipherPanel newFromQuote: 'BPFFXY LZY PK ROY RPBY PG XPAY HOYG EJCM SXJROYK FJG''R APR QCR PR''K EJC HOJ GYYF ROY LXRYMLRPJGK.  KJCMSY CGNGJHG')World addMorph: (CipherPanel newFromQuote: 'Y FRV TRK HJRH QVL QS HJL BPLRHLTH WZLRTXPLT YV ZYSL YT OQYVB MJRH WLQWZL TRK KQX FRVVQH OQ.')World addMorph: (CipherPanel newFromQuote: 'XI''H SAZRG: SDCIZCIZT EZDEAZ TD CDI SGZRIZ EGDPGZHH.')World addMorph: (CipherPanel newFromQuote: 'PY MOJ WPMMWJ MZGYR ZL MOJ GZSWH PM''R YZ RZZYJS HZYJ MOBY RBPH.')World addMorph: (CipherPanel newFromQuote: 'PYSLHYA DJP VBHHLXYAA BPY BGNBMA PLUVQ LX AQMGY; QVY HPLXSLHBG LXUPYCLYXQA BPY NBPK BXC DPLYXCGM AKLGYA.')World addMorph: (CipherPanel newFromQuote: 'U HWVS RJ AHOST RLO FOOQOST TJUSM AJIO LOVNC WUXRUSM VST HWVCUSM LVSTZVWW. -- TVNUT WORROEIVS VXROE LUA KGUSRGHWO-ZCHVAA LOVER JHOEVRUJS')"! !!CipherPanel class methodsFor: 'as yet unclassified' stamp: 'di 5/10/2000 10:06'!newFromQuote: encodedString	"Use this to creat new panels instead of new."	^ super new encodedQuote: encodedString! !!CipherPanel class methodsFor: 'as yet unclassified' stamp: 'asm 11/25/2003 22:20'!randomComment	"CipherPanel randomComment"	"Generate cryptic puzzles from method comments in the system"	| c s |	s := 'none'.	[s = 'none']		whileTrue: [s := ((c := SystemNavigation new allClasses atRandom) selectors						collect: [:sel | (c firstCommentAt: sel) asString])						detect: [:str | str size between: 100 and: 200]						ifNone: ['none' translated]].	^ s! !!CipherPanel class methodsFor: 'as yet unclassified' stamp: 'di 5/8/2000 11:58'!sampleString	^'E SGJC OSCVC LICGNV, ENGRCV, JEVEMAV. E SGJC OSEV QGVVEMA XMI [SMWWDHMML] ... EO''V HMALCIXKW OM SGJC VMNCOSEAR OSGO EAVQEICV GAL LIEJCV DMK. -- ZGIZIG VOICEVGAL'! !!CipherPanel class methodsFor: 'as yet unclassified' stamp: 'di 10/4/2000 10:45'!tedsHack  	"Generate cryptic puzzles from method comments in the system"	(self newFromQuote: (self encode: (self randomComment))) openInWorld"CipherPanel tedsHack"! !!CipherPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:21'!addMenuItemsTo: aMenu hand: aHandMorph 	aMenu		add: 'show cipher help' translated		target: self		action: #showHelpWindow.	aMenu		add: 'show cipher hints' translated		target: self		action: #showHintsWindow.	aMenu		add: 'clear cipher typing' translated		target: self		action: #clearTyping.	aMenu		add: 'enter a new cipher' translated		target: self		action: #enterANewCipher.	aMenu		add: 'quote from Squeak' translated		target: self		action: #squeakCipher! !!CipherPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:23'!buttonRow	| row aButton |	row := AlignmentMorph newRow color: self color;				 hResizing: #shrinkWrap;				 vResizing: #shrinkWrap.	#('show help' 'show hints' 'clear typing' 'enter a new cipher' 'quote from Squeak' )		with: #(#showHelpWindow #showHintsWindow #clearTyping #enterANewCipher #squeakCipher )		do: [:label :selector | 			aButton := SimpleButtonMorph new target: self.			aButton color: Color transparent;				 borderWidth: 1;				 borderColor: Color black.			aButton actionSelector: selector.			aButton label: label translated.			row addMorphBack: aButton.			row addTransparentSpacerOfSize: 3 @ 0].	^ row! !!CipherPanel methodsFor: 'menu' stamp: 'di 5/8/2000 10:46'!cipherStats	| letterCounts digraphs d digraphCounts |	letterCounts _ (quote copyWithout: Character space) asBag sortedCounts.	digraphs _ Bag new.	quote withIndexDo:		[:c :i |		i < quote size ifTrue:			[d _ quote at: i+1.			(c ~= Character space and: [d ~= Character space]) ifTrue:				[digraphs add: (String with: c with: d)]]].	digraphCounts _ digraphs sortedCounts.	^ String streamContents:		[:strm |		1 to: 10 do:			[:i |			strm cr; tab; nextPut: (letterCounts at: i) value.			strm tab; print: (letterCounts at: i) key.			(digraphCounts at: i) key > 1 ifTrue:				[strm tab; tab; tab; nextPutAll: (digraphCounts at: i) value.				strm tab; print: (digraphCounts at: i) key]]]! !!CipherPanel methodsFor: 'defaults' stamp: 'asm 11/25/2003 22:22'!clearTyping	self isClean		ifTrue: [^ self].	(self confirm: 'Are you sure you want to discard all typing?' translated)		ifFalse: [^ self].	super clearTyping! !!CipherPanel methodsFor: 'initialization' stamp: 'asm 11/25/2003 22:21'!encodedQuote: aString 	"World addMorph: CipherPanel new"	| morph prev |	aString isEmpty		ifTrue: [^ self].	(letterMorphs isNil			or: [self isClean])		ifFalse: [(self confirm: 'Are you sure you want to discard all typing?' translated)				ifFalse: [^ self]].	haveTypedHere := false.	quote := aString asUppercase.	prev := nil.	originalMorphs := quote asArray				collectWithIndex: [:c :i | WordGameLetterMorph new plain indexInQuote: i id1: nil;												setLetter: (quote at: i)].	letterMorphs := OrderedCollection new.	decodingMorphs := quote asArray				collectWithIndex: [:c :i | (quote at: i) isLetter						ifTrue: [morph := WordGameLetterMorph new underlined indexInQuote: i id1: nil.							morph								on: #mouseDown								send: #mouseDownEvent:letterMorph:								to: self.							morph								on: #keyStroke								send: #keyStrokeEvent:letterMorph:								to: self.							letterMorphs addLast: morph.							morph predecessor: prev.							prev								ifNotNil: [prev successor: morph].							prev := morph]						ifFalse: [WordGameLetterMorph new plain indexInQuote: i id1: nil;																setLetter: (quote at: i)]].	self color: originalMorphs first color.	self extent: 500 @ 500! !!CipherPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:23'!enterANewCipher	self clearTyping;		encodedQuote: (FillInTheBlank request: 'Type a cipher text to work on here below...' translated)! !!CipherPanel methodsFor: 'geometry' stamp: 'di 2/14/2001 13:50'!extent: newExtent 	"Lay out with word wrap, alternating bewteen decoded and encoded lines."	"Currently not tolerant of narrow (less than a word) margins"	| w h relLoc topLeft thisWord i m corner row firstWord |	self removeAllMorphs.	w _ originalMorphs first width - 1.  h _ originalMorphs first height * 2 + 10.	topLeft _ self position + self borderWidth + (0@10).	thisWord _ OrderedCollection new.	i _ 1.  firstWord _ true.  relLoc _ 0@0.  corner _ topLeft.	[i <= originalMorphs size] whileTrue:		[m _ originalMorphs at: i.		thisWord addLast: ((decodingMorphs at: i) position: topLeft + relLoc).		thisWord addLast: (m position: topLeft + relLoc + (0@m height)).		(m letter = Character space or: [i = originalMorphs size])			ifTrue: [self addAllMorphs: thisWord.					corner _ corner max: thisWord last bounds bottomRight.					thisWord reset.  firstWord _ false].		relLoc _ relLoc + (w@0).		(relLoc x + w) > newExtent x			ifTrue: [firstWord						ifTrue: ["No spaces -- force a line break"								thisWord removeLast; removeLast.								self addAllMorphs: thisWord.								corner _ corner max: thisWord last bounds bottomRight]						ifFalse: [i _ i - (thisWord size//2) + 1].					thisWord reset.  firstWord _ true.					relLoc _ 0@(relLoc y + h)]			ifFalse: [i _ i + 1]].	row _ self buttonRow. row fullBounds.	self addMorph: row.	super extent: (corner - topLeft) + (self borderWidth * 2) + (0@row height+10).	row align: row bounds bottomCenter with: self bounds bottomCenter - (0@2).! !!CipherPanel methodsFor: 'parts bin' stamp: 'sw 6/28/2001 17:58'!initializeToStandAlone 	super initializeToStandAlone.	self encodedQuote: self class sampleString! !!CipherPanel methodsFor: 'defaults' stamp: 'di 5/12/2000 00:52'!keyCharacter: aLetter atIndex: indexInQuote nextFocus: nextFocus	| encodedLetter |	encodedLetter _ quote at: indexInQuote.	originalMorphs with: decodingMorphs do:		[:e :d | e letter = encodedLetter ifTrue: [d setLetter: aLetter color: Color red]].! !!CipherPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:23'!showHelpWindow	((StringHolder new contents: 'The Cipher Panel displays an encrypted message.  The encryption is a simple substitution code;  each letter of the alphabet has been changed to a different one.You can solve the cipher by clicking above any letter in the message, and typing the letter you think it should be.  The Cipher Panel automatically makes the same substitution anywhere else that letter occurs in the encoded message.If you are having trouble, you can use the command menu to ''show cipher hints''.  That will display how many of each letter occurs, which is often a help in solving ciphers.' translated)		embeddedInMorphicWindowLabeled: 'About the Cipher Panel' translated)		setWindowColor: (Color				r: 1.0				g: 0.6				b: 0.0);		 openInWorld: self world extent: 389 @ 209! !!CipherPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:22'!showHintsWindow	((StringHolder new contents: 'Most bodies of english text follow a general pattern of letter usage.  The following are the most common letters, in approximate order of frequency:	E  T  A  O  N  I  R  S  HThe following are the most common digraphs:	EN  ER  RE  NT  TH  ON  INThe message you are trying to decode has the following specific statistics:' translated , self cipherStats , 'Good luck!!' translated)		embeddedInMorphicWindowLabeled: 'Some Useful Statistics' translated)		setWindowColor: (Color				r: 1.0				g: 0.6				b: 0.0);		 openInWorld: self world extent: 318 @ 326! !!CipherPanel methodsFor: 'menu' stamp: 'di 10/4/2000 10:48'!squeakCipher	self encodedQuote: (CipherPanel encode: (CipherPanel randomComment))! !!CrosticPanel class methodsFor: 'parts bin' stamp: 'sw 8/2/2001 12:46'!descriptionForPartsBin	^ self partName:	'Crostic'		categories:		#('Games')		documentation:	'The Crostic Panel: A classic word diagram game, by Dan Ingalls'! !!CrosticPanel class methodsFor: 'new-morph participation' stamp: 'di 5/11/2000 20:37'!includeInNewMorphMenu	^ true! !!CrosticPanel class methodsFor: 'instance creation' stamp: 'di 5/11/2000 20:37'!new	"NOTE: Use newFromFile: rather than new to create new CrosticPanels"	^ self newFromFile: (ReadStream on: self sampleFile)! !!CrosticPanel class methodsFor: 'instance creation' stamp: 'asm 11/25/2003 22:28'!newFromFile: aStream 	"World addMorph: CrosticPanel new"	"World addMorph: (CrosticPanel newFromFile: (FileStream 	readOnlyFileNamed: 'first.crostic'))"	| quoteWithBlanks citation clue numberLine numbers clues answers indexableQuote quotePanel crosticPanel buttonRow quoteWidth |	aStream next asciiValue = 31 & (aStream next asciiValue = 139)		ifTrue: ["It's gzipped..."			aStream skip: -2.			^ self newFromFile: aStream asUnZippedStream ascii].	aStream skip: -2.	quoteWithBlanks := aStream nextLine.	quoteWithBlanks := quoteWithBlanks asUppercase				select: [:c | c isLetter						or: [' -' includes: c]].	indexableQuote := quoteWithBlanks				select: [:c | c isLetter].	citation := aStream nextLine.	aStream nextLine.	clues := OrderedCollection new.	answers := OrderedCollection new.	[aStream atEnd]		whileFalse: [clue := aStream nextLine.			"Transcript cr; show: clue."			clues addLast: clue.			numberLine := aStream nextLine.			numbers := Scanner new scanTokens: numberLine.			answers addLast: numbers].	aStream close.	"Consistency check:"	(citation asUppercase			select: [:c | c isLetter])			= (String					withAll: (answers							collect: [:a | indexableQuote at: a first]))		ifFalse: [self error: 'mal-formed crostic file' translated].	crosticPanel := super new.	quotePanel := CrosticQuotePanel new				quote: quoteWithBlanks				answers: answers				cluesPanel: crosticPanel.	crosticPanel color: quotePanel firstSubmorph color;				quote: indexableQuote		clues: clues		answers: answers		quotePanel: quotePanel.	buttonRow := crosticPanel buttonRow.	quoteWidth := crosticPanel width + quotePanel firstSubmorph width max: buttonRow width.	quotePanel extent: quoteWidth @ 9999.	crosticPanel addMorph: quotePanel.	^ crosticPanel breakColumnAndResizeWithButtons: buttonRow! !!CrosticPanel class methodsFor: 'as yet unclassified' stamp: 'di 5/12/2000 15:12'!oldStyle	"return true if we should cross-index all the cells (takes more space)."	^ false! !!CrosticPanel class methodsFor: 'as yet unclassified' stamp: 'di 11/30/2000 10:15'!sampleFile 	"If you want to enter a new acrostic, follow this format exactly with regard to CRs and the like, and store it in a file.  Do not double the string quotes as here -- that is only because they are embedded in a string.  Finally, compress the file in the fileList (so it will be easy to transport and hard to read), and name it 'yourName.crostic' so that the 'open' button on the panel will recognize it."	^'Men and women do not feel the same way about dirt.  Women for some hormonal reason can see individual dirt molecules, whereas men tend not to notice them until they join together into clumps large enough to support commercial agriculture.Dave Barry''s Guide to MarriageBoccaccio''s collection of tales74 19 175 156 9 122 84 113 104Wooden instrument of Swiss herders67 184 153 103 14 142 148 54 3Evening service76 99 154 171 89 194 69Russian-born American anarchist (2 wds)159 102 177 25 186 134 128 82 50 62 11Apple-polish (2 wds)32 190 129 126 179 157 79 170Visual-gesture means of communication4 178 27 168 150 185 114Postponed contest173 58 77 65 8 124 85Groundbreaking invention98 15 116 162 112 37 92 155 70 187Material used to make English longbows132 195 28Gracile48 191 145 152Have the effrontery; experience a high (2 wds)164 61 137 33 17 45Florentine painter who experimented with perspective91 181 189 2 20 81 167Sondheim opus (3 wds)72 109 147 13 192 165 93 40 115 138 6 63Spanish rake108 56 44 133 193 29 125Emergence  as of an adult butterfly106 149 59 41 24 135 87 68Type of rifle (hyph)111 7 143 73 39 30 105 95 53Free of charge (3 wds)176 107 120 130 160 22 46 34 94 71Pie filling86 75 136 118 43Master filmmaker31 151 174 51 163 144Longtime sportswriter for the NY Herald tribune (2 wds)60 140 12 101 55 188 166 121Birthplace of Erasmus47 64 141 21 10 180 36 80 1Mae West classic (3 wds)127 123 161 110 183 5 139 97 88Element that glows blue in the dark100 90 35 182 146 117 169 26Sturm und Drang writer158 172 119 16 52 23Starfish or sea cucumber18 66 96 83 57 49 78 131 38 42'! !!CrosticPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:27'!addMenuItemsTo: aMenu hand: aHandMorph 	aMenu		add: 'show crostic help' translated		target: self		action: #showHelpWindow.	aMenu		add: 'show crostic hints' translated		target: self		action: #showHintsWindow.	aMenu		add: 'show crostic errors' translated		target: self		action: #showErrors.	aMenu		add: 'clear crostic typing' translated		target: self		action: #clearTyping.	aMenu		add: 'open crostic file...' translated		target: self		action: #openFile! !!CrosticPanel methodsFor: 'initialization' stamp: 'di 11/25/2000 19:17'!breakColumnAndResizeWithButtons: buttonRow	| indexToSplit yToSplit |	"The column of clues has been laid out, and the crostic panel has been resized to that width and embedded as a submorph.  This method breaks the clues in two, placing the long part to the left of the crostic and the short one below it."	yToSplit _ cluesPanel height + quotePanel height // 2 + self top.	indexToSplit _ cluesPanel submorphs findFirst: [:m | m bottom > yToSplit].	cluesCol2 _ AlignmentMorph newColumn color: self color;		hResizing: #shrinkWrap; vResizing: #shrinkWrap; layoutInset: 0;		cellPositioning: #topLeft.	cluesCol2 addAllMorphs: (cluesPanel submorphs copyFrom: indexToSplit + 1							to: cluesPanel submorphs size).	cluesPanel position: self position + self borderWidth + (0 @ 4).	quotePanel position: self position + (quotePanel width @ 0).	cluesCol2 position: self position + quotePanel extent + (0 @ 4).	self addMorph: cluesCol2.	self addMorph: buttonRow.	buttonRow align: buttonRow topLeft with: cluesCol2 bottomLeft.	self extent: 100@100; bounds: ((self fullBounds topLeft - self borderWidth asPoint)							corner: (self fullBounds bottomRight - (2@0))).! !!CrosticPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:27'!buttonRow	| row aButton |	row := AlignmentMorph newRow color: self color;				 hResizing: #shrinkWrap;				 vResizing: #shrinkWrap.	#('show help' 'show errors' 'show hints' 'clear' 'open...' )		with: #(#showHelpWindow #showErrors #showHintsWindow #clearTyping #openFile )		do: [:label :selector | 			aButton := SimpleButtonMorph new target: self.			aButton color: Color transparent;				 borderWidth: 1;				 borderColor: Color black.			aButton actionSelector: selector.			aButton label: label translated.			row addMorphBack: aButton.			row addTransparentSpacerOfSize: 3 @ 0].	^ row! !!CrosticPanel methodsFor: 'defaults' stamp: 'asm 11/25/2003 22:24'!clearTyping	self isClean		ifTrue: [^ self].	(self confirm: 'Are you sure you want to discard all typing?' translated)		ifFalse: [^ self].	super clearTyping.	quotePanel clearTyping! !!CrosticPanel methodsFor: 'defaults' stamp: 'di 5/11/2000 20:44'!highlight: morph	self unhighlight.	quotePanel unhighlight.	morph startOfWord morphsInWordDo:		[:m | m color: Color lightGreen.		(quotePanel letterMorphs at: m indexInQuote) color: Color lightMagenta].	morph color: Color green.	(quotePanel letterMorphs at: morph indexInQuote) color: Color magenta.! !!CrosticPanel methodsFor: 'parts bin' stamp: 'asm 11/25/2003 22:24'!initializeToStandAlone	| aStream quoteWithBlanks indexableQuote citation clue numberLine numbers buttonRow quoteWidth |	super initializeToStandAlone.	aStream := ReadStream on: self class sampleFile.	quoteWithBlanks := aStream nextLine.	quoteWithBlanks := quoteWithBlanks asUppercase				select: [:c | c isLetter						or: [' -' includes: c]].	indexableQuote := quoteWithBlanks				select: [:c | c isLetter].	citation := aStream nextLine.	aStream nextLine.	clues := OrderedCollection new.	answers := OrderedCollection new.	[aStream atEnd]		whileFalse: [clue := aStream nextLine.			"Transcript cr; show: clue."			clues addLast: clue.			numberLine := aStream nextLine.			numbers := Scanner new scanTokens: numberLine.			answers addLast: numbers].	aStream close.	"Consistency check:"	(citation asUppercase			select: [:c | c isLetter])			= (String					withAll: (answers							collect: [:a | indexableQuote at: a first]))		ifFalse: [self error: 'mal-formed crostic file' translated].	quotePanel := CrosticQuotePanel new				quote: quoteWithBlanks				answers: answers				cluesPanel: self.	self color: quotePanel firstSubmorph color;				quote: indexableQuote		clues: clues		answers: answers		quotePanel: quotePanel.	buttonRow := self buttonRow.	quoteWidth := self width + quotePanel firstSubmorph width max: buttonRow width.	quotePanel extent: quoteWidth @ 9999.	self addMorph: quotePanel.	self breakColumnAndResizeWithButtons: buttonRow! !!CrosticPanel methodsFor: 'defaults' stamp: 'di 5/11/2000 20:44'!keyCharacter: aLetter atIndex: indexInQuote nextFocus: nextFocus	(self letterMorphs at: indexInQuote) setLetter: aLetter.	(quotePanel letterMorphs at: indexInQuote) setLetter: aLetter.	self highlight: nextFocus! !!CrosticPanel methodsFor: 'defaults' stamp: 'di 5/11/2000 20:44'!lostFocus	self unhighlight.	quotePanel unhighlight! !!CrosticPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:26'!openFile	| stdFileMenuResult crostic file |	stdFileMenuResult := (StandardFileMenu new pattern: '*.crostic';				 oldFileFrom: FileDirectory default) startUpWithCaption: 'Select a Crostic File...' translated.	stdFileMenuResult		ifNil: [^ nil].	file := stdFileMenuResult directory readOnlyFileNamed: stdFileMenuResult name.	crostic := CrosticPanel newFromFile: file.	file close.	(self isClean			or: [self confirm: 'Is it OK to discard this crostic?' translated])		ifTrue: [self world				addMorphFront: (crostic position: self position).			self delete]		ifFalse: [self world addMorphFront: crostic]! !!CrosticPanel methodsFor: 'initialization' stamp: 'di 11/28/2000 10:40'!quote: indexableQuote clues: clueStrings answers: answerIndices quotePanel: panel	| row clue answer answerMorph letterMorph prev clueText clueStyle |	quote _ indexableQuote.	quotePanel _ panel.	clues _ clueStrings.	answers _ answerIndices.	cluesPanel _ AlignmentMorph newColumn color: self color;		hResizing: #shrinkWrap; vResizing: #shrinkWrap;		cellPositioning: #topLeft; layoutInset: 1.	letterMorphs _ Array new: quotePanel letterMorphs size.	clueStyle _ nil.	1 to: clues size do:		[:i |  clue _ clues at: i.  answer _ answers at: i.		row _ AlignmentMorph newRow cellPositioning: #bottomLeft.		clueText _ (TextMorph newBounds: (0@0 extent: 120@20) color: Color black)				string: (CrosticPanel oldStyle							ifTrue: [(($A to: $Z) at: i) asString , '.  ' , clue]							ifFalse: [clue])				fontName: 'ComicPlain' size: 13.		clueStyle ifNil: ["Make up a special style with decreased leading"						clueStyle _ clueText textStyle copy.						clueStyle gridForFont: 1 withLead: -2].		clueText text: clueText asText textStyle: clueStyle.  "All clues share same style"		clueText composeToBounds.		row addMorphBack: clueText.		answerMorph _ AlignmentMorph newRow layoutInset: 0.		prev _ nil.		answer do:			[:n | letterMorph _ WordGameLetterMorph new underlined						indexInQuote: n						id1: (CrosticPanel oldStyle ifTrue: [n printString] ifFalse: [nil]);						setLetter: Character space.			letterMorph on: #mouseDown send: #mouseDownEvent:letterMorph: to: self.			letterMorph on: #keyStroke send: #keyStrokeEvent:letterMorph: to: self.			letterMorph predecessor: prev.			prev ifNotNil: [prev successor: letterMorph].			prev _ letterMorph.			letterMorphs at: n put: letterMorph.			answerMorph addMorphBack: letterMorph].		answerMorph color: answerMorph firstSubmorph color.		row addMorphBack: answerMorph.row fullBounds.		row color: answerMorph firstSubmorph color.		cluesPanel addMorphBack: row].	self addMorph: cluesPanel.	self bounds: cluesPanel fullBounds.! !!CrosticPanel methodsFor: 'menu' stamp: 'di 5/12/2000 15:09'!showErrors	letterMorphs do:		[:m | (m letter ~= Character space and: [m letter ~= (quote at: m indexInQuote)])			ifTrue: [m color: Color red.					(quotePanel letterMorphs at: m indexInQuote) color: Color red]]! !!CrosticPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:26'!showHelpWindow	((StringHolder new contents: 'The Crostic Panel presents an acrostic puzzle for solution.  As you type in answers for the clues, the letters also get entered in the text of the hidden quote.  Conversely, as you guess words in the quote, those letters will fill in missing places in your answers.  In addition, the first letters of all the answers together form the author''s name and title of the work from which the quote is taken.If you wish to make up other acrostic puzzles, follow the obvious file format in the sampleFile method.  If you wish to print an acrostic to work it on paper, then change the oldStyle method to return true, and it will properly cross-index all the cells.Have fun.' translated)		embeddedInMorphicWindowLabeled: 'About the Crostic Panel' translated)		setWindowColor: (Color				r: 1.0				g: 0.6				b: 0.0);		 openInWorld: self world extent: 409 @ 207! !!CrosticPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:25'!showHintsWindow	| hints |	(self confirm: 'As hints, you will be given the five longest answers.Do you really want to do this?' translated)		ifFalse: [^ self].	hints := (answers				asSortedCollection: [:x :y | x size > y size]) asArray copyFrom: 1 to: 5.	((StringHolder new contents: 'The five longest answers are...' translated			, (String					streamContents: [:strm | 						hints							do: [:hint | strm cr;									nextPutAll: (hint											collect: [:i | quote at: i])].						strm cr; cr]) , 'Good luck!!' translated)		embeddedInMorphicWindowLabeled: 'Crostic Hints' translated)		setWindowColor: (Color				r: 1.0				g: 0.6				b: 0.0);		 openInWorld: self world extent: 198 @ 154! !!CrosticQuotePanel methodsFor: 'geometry' stamp: 'di 5/7/2000 11:59'!extent: newExtent	| w h nAcross relLoc topLeft |	w _ self firstSubmorph width - 1.  h _ self firstSubmorph height - 1.	nAcross _ newExtent x - (self borderWidth-1*2)-1 // w.	topLeft _ self position + self borderWidth - 1.	submorphs withIndexDo:		[:m :i | 		relLoc _ (i-1 \\ nAcross * w) @ (i-1 // nAcross * h).		m position: topLeft + relLoc].	super extent: ((w * nAcross + 1) @ (submorphs size - 1 // nAcross + 1 * h+1))					+ (self borderWidth - 1 * 2).! !!CrosticQuotePanel methodsFor: 'defaults' stamp: 'di 5/11/2000 09:37'!highlight: morph	self unhighlight.	cluesPanel unhighlight.	morph startOfWord morphsInWordDo:		[:m | m color: Color lightGreen.		(cluesPanel letterMorphs at: m indexInQuote) color: Color lightMagenta].	morph color: Color green.	(cluesPanel letterMorphs at: morph indexInQuote) color: Color magenta.! !!CrosticQuotePanel methodsFor: 'defaults' stamp: 'di 5/10/2000 09:25'!keyCharacter: aLetter atIndex: indexInQuote nextFocus: nextFocus	(self letterMorphs at: indexInQuote) setLetter: aLetter.	(cluesPanel letterMorphs at: indexInQuote) setLetter: aLetter.	self highlight: nextFocus! !!CrosticQuotePanel methodsFor: 'defaults' stamp: 'di 5/10/2000 08:49'!lostFocus	self unhighlight.	cluesPanel unhighlight! !!CrosticQuotePanel methodsFor: 'initialization' stamp: 'di 5/12/2000 00:07'!quote: quoteWithBlanks answers: theAnswers cluesPanel: panel	| n morph prev clueIxs |	cluesPanel _ panel.	self color: Color gray.	clueIxs _ Array new: quoteWithBlanks size.	theAnswers withIndexDo: [:a :i | a do: [:j | clueIxs at: j put: i]].	letterMorphs _ OrderedCollection new.	prev _ nil.	self addAllMorphs: (quoteWithBlanks asArray collect:		[:c |		c isLetter			ifTrue: [n _ letterMorphs size + 1.					morph _ WordGameLetterMorph new boxed.					CrosticPanel oldStyle						ifTrue: [morph indexInQuote: n id1: n printString.								morph id2: (($A to: $Z) at: (clueIxs at: n)) asString]						ifFalse: [morph indexInQuote: n id1: nil].					morph setLetter: Character space.					morph on: #mouseDown send: #mouseDownEvent:letterMorph: to: self.					morph on: #keyStroke send: #keyStrokeEvent:letterMorph: to: self.					letterMorphs addLast: morph]			ifFalse: [morph _ WordGameLetterMorph new boxed indexInQuote: nil id1: nil.					CrosticPanel oldStyle ifTrue: [morph extent: 26@24  "Oops"]].		morph predecessor: prev.		prev ifNotNil: [prev successor: morph].		prev _ morph]).! !!WordGamePanelMorph class methodsFor: 'new-morph participation' stamp: 'di 5/10/2000 07:41'!includeInNewMorphMenu	^ false! !!WordGamePanelMorph methodsFor: 'menus' stamp: 'di 5/9/2000 21:53'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Include our modest command set in the ctrl-menu"	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	self addMenuItemsTo: aCustomMenu hand: aHandMorph! !!WordGamePanelMorph methodsFor: 'menu' stamp: 'di 5/9/2000 22:07'!addMenuItemsTo: aCustomMenu hand: aHandMorph	"override with actual menu items"! !!WordGamePanelMorph methodsFor: 'events' stamp: 'di 5/10/2000 08:45'!checkForLostFocus	"Determine if the user has clicked outside this panel"	self activeHand ifNil: [^ self].	(self containsPoint: self activeHand position) ifFalse: [self lostFocus]! !!WordGamePanelMorph methodsFor: 'defaults' stamp: 'di 5/12/2000 00:28'!clearTyping	"Clear out all letters entered as a solution."	letterMorphs do: [:m | (m letter notNil and: [m letter isLetter])							ifTrue: [m setLetter: Character space]].	self unhighlight.! !!WordGamePanelMorph methodsFor: 'event handling' stamp: 'di 5/11/2000 22:38'!handlesMouseDown: event	"Absorb mouseDown so stray clicks will not pick up the panel"	^ true! !!WordGamePanelMorph methodsFor: 'defaults' stamp: 'di 5/10/2000 09:31'!highlight: morph	self unhighlight.	morph color: Color green! !!WordGamePanelMorph methodsFor: 'defaults' stamp: 'di 5/12/2000 00:53'!isClean	"Return true only if all cells are blank."	letterMorphs do:		[:m | (m letter notNil and: [m letter ~= $ ]) ifTrue: [^ false]].	^ true! !!WordGamePanelMorph methodsFor: 'defaults' stamp: 'di 5/10/2000 08:37'!keyCharacter: keyCharacter atIndex: indexOfAffectedMorph nextFocus: nextFocus	"Override with actual response"! !!WordGamePanelMorph methodsFor: 'events' stamp: 'aoy 2/15/2003 21:25'!keyStrokeEvent: evt letterMorph: morph 	"Handle typing.  Calls keyCharacter:atIndex:nextFocus: for further behavior."	| affectedMorph keyCharacter nextFocus |	evt keyCharacter = Character backspace 		ifTrue: 			["<delete> zaps the current selection if there has been no typing,				but it zaps the previous selection if there has been prior typing."			affectedMorph := haveTypedHere 						ifTrue: [morph previousTypeableLetter]						ifFalse: [morph]. 			keyCharacter := Character space.			nextFocus := morph previousTypeableLetter]		ifFalse: 			[affectedMorph := morph.			keyCharacter := evt keyCharacter asUppercase.			(keyCharacter isLetter or: [keyCharacter = Character space]) 				ifFalse: [^self].			haveTypedHere := true.			nextFocus := morph nextTypeableLetter.			nextFocus == morph 				ifTrue: 					["If hit end of a word, change backspace mode"					haveTypedHere := false]].	evt hand newKeyboardFocus: nextFocus.	self unhighlight.	nextFocus color: Color green.	self 		keyCharacter: keyCharacter		atIndex: affectedMorph indexInQuote		nextFocus: nextFocus! !!WordGamePanelMorph methodsFor: 'access' stamp: 'di 5/9/2000 22:27'!letterMorphs	^ letterMorphs! !!WordGamePanelMorph methodsFor: 'defaults' stamp: 'di 5/10/2000 08:44'!lostFocus	self unhighlight! !!WordGamePanelMorph methodsFor: 'events' stamp: 'di 5/10/2000 09:30'!mouseDownEvent: evt letterMorph: morph	haveTypedHere _ false.	evt hand newKeyboardFocus: morph.	self highlight: morph! !!WordGamePanelMorph methodsFor: 'defaults' stamp: 'di 5/12/2000 09:54'!unhighlight	letterMorphs do: [:m | m ifNotNil: [m unhighlight]]! !!MorphicGamesInfo methodsFor: 'introspection' stamp: 'asm 10/14/2005 14:41'!changesText	^'verison 7:  - added Andreas''s fix for http://bugs.impara.de/view.php?id=1591              - adeed njb''s fic for http://bugs.impara.de/view.php?id=1813version 6: included Rick McGeer''s Chess Castling Fixversion 5: included Atomic (some changes were needed to make it work in 3.7) and some Babel stuffversion 4: includes Andreas Raab''s rewrite of ChessConstants as declarative pool (update 5325)version 3: 	-added one change by the KCP team			-Chess its playing againversion 2: applied changes by the MCP team'! !!MorphicGamesInfo methodsFor: 'introspection' stamp: 'asm 6/25/2003 22:10'!postscriptText	"Executed after load"	^ 'Utilities informUser: ''Generating Games thumbnails in PartsBin, please wait...'' during: [	PartsBin clearThumbnailCache.	PartsBin cacheAllThumbnails.]."End ', self packageName, '"'! !!MorphicGamesInfo methodsFor: 'introspection' stamp: 'asm 4/20/2004 22:14'!readmeText	^'Morphic-Games has the games that were in the image before 3.6:Chess, Chinese Checkers, Cipher, Crostic, FreeCell, Mines, Same and Tetris.plus Atomic'! !!ChessMoveList methodsFor: 'accessing' stamp: 'ar 8/24/2001 16:32'!contents	^collection copyFrom: startIndex to: readLimit! !!ChessMoveList methodsFor: 'private' stamp: 'ar 8/24/2001 16:10'!on: aCollection from: firstIndex to: lastIndex	startIndex _ firstIndex.	^super on: aCollection from: firstIndex to: lastIndex.! !!ChessMoveList methodsFor: 'sorting' stamp: 'ar 8/24/2001 16:16'!sort: i to: j using: sorter	"Sort elements i through j of self to be nondescending according to sorter."	| di dij dj tt ij k l n |	"The prefix d means the data at that index."	(n _ j + 1  - i) <= 1 ifTrue: [^self].	"Nothing to sort." 	 "Sort di,dj."	di _ collection at: i.	dj _ collection at: j.	(sorter sorts: di before: dj) ifFalse:["i.e., should di precede dj?"		collection swap: i with: j.		tt _ di. di _ dj. dj _ tt].	n > 2 ifTrue:["More than two elements."		ij _ (i + j) // 2.  "ij is the midpoint of i and j."		 dij _ collection at: ij.  "Sort di,dij,dj.  Make dij be their median."		 (sorter sorts: di before: dij) ifTrue:["i.e. should di precede dij?"			(sorter sorts: dij before: dj) "i.e., should dij precede dj?"				ifFalse:[collection swap: j with: ij.					 	dij _ dj].		] ifFalse:[  "i.e. di should come after dij"			collection swap: i with: ij.			 dij _ di		].		n > 3 ifTrue:["More than three elements."			"Find k>i and l<j such that dk,dij,dl are in reverse order.			Swap k and l.  Repeat this procedure until k and l pass each other."			 k _ i.  l _ j.			[				[l _ l - 1.  k <= l and: [sorter sorts: dij before: (collection at: l)]]					whileTrue.  "i.e. while dl succeeds dij"				[k _ k + 1.  k <= l and: [sorter sorts: (collection at: k) before: dij]]					whileTrue.  "i.e. while dij succeeds dk"				k <= l			] whileTrue:[collection swap: k with: l]. 			"Now l<k (either 1 or 2 less), and di through dl are all less than 			or equal to dk through dj.  Sort those two segments."			self sort: i to: l using: sorter.			self sort: k to: j using: sorter]].! !!ChessMoveList methodsFor: 'sorting' stamp: 'ar 8/24/2001 16:32'!sortUsing: historyTable	^self sort: startIndex to: readLimit using: historyTable! !!ChessMoveList methodsFor: 'accessing' stamp: 'ar 8/24/2001 16:11'!startIndex	^startIndex! !!TetrisBoard class methodsFor: 'new-morph participation' stamp: 'RAA 1/7/2000 22:56'!includeInNewMorphMenu	^false! !!TetrisBoard methodsFor: 'as yet unclassified' stamp: 'RAA 1/7/2000 23:12'!cellSize	^12@12! !!TetrisBoard methodsFor: 'other' stamp: 'RAA 1/8/2000 13:20'!checkForFullRows	| targetY morphsInRow bonus |	self numRows to: 2 by: -1 do: [ :row |		targetY _ (self originForCell: 1@row) y.		[			morphsInRow _ self submorphsSatisfying: [ :each | each top = targetY].			morphsInRow size = self numColumns		] whileTrue: [			bonus _ (morphsInRow collect: [:each | each color]) asSet size = 1 				ifTrue: [1000] 				ifFalse: [100].			self score: score + bonus.			submorphs copy do: [ :each |				each top = targetY ifTrue: [					each delete				].				each top < targetY ifTrue: [					each position: each position + (0@self cellSize y)				].			].		].	].! !!TetrisBoard methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:07'!defaultBounds"answer the default bounds for the receiver"	^ 0 @ 0 extent: self numColumns @ self numRows * self cellSize + (1 @ 1)! !!TetrisBoard methodsFor: 'initialization' stamp: 'dgd 2/17/2003 19:38'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		  lightBlue! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 14:03'!dropAllTheWay	self running ifFalse: [^ self].	[currentBlock dropByOne] whileTrue: [		self score: score + 1	].! !!TetrisBoard methodsFor: 'data' stamp: 'RAA 1/8/2000 13:16'!emptyAt: aPoint	| cellOrigin |	(aPoint x between: 1 and: self numColumns) ifFalse: [^ false].	(aPoint y < 1) ifTrue: [^ true].	"handle early phases"	(aPoint y <= self numRows) ifFalse: [^ false].	cellOrigin _ self originForCell: aPoint.	^(self submorphsSatisfying: [ :each | each topLeft = cellOrigin]) isEmpty! !!TetrisBoard methodsFor: 'accessing' stamp: 'RAA 1/7/2000 22:34'!game: aTetris	game _ aTetris! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:17'!moveLeft	self running ifFalse: [^ self].	currentBlock moveDeltaX: -1 deltaY: 0 deltaAngle: 0.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:17'!moveRight	self running ifFalse: [^ self].	currentBlock moveDeltaX: 1 deltaY: 0 deltaAngle: 0.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 13:20'!newGame	self removeAllMorphs.	gameOver _ paused _ false.	delay _ 500.	currentBlock _ nil.	self score: 0.! !!TetrisBoard methodsFor: 'data' stamp: 'RAA 8/28/1999 23:29'!numColumns	^10	! !!TetrisBoard methodsFor: 'data' stamp: 'RAA 8/28/1999 23:30'!numRows	^27	! !!TetrisBoard methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 13:11'!originForCell: aPoint	^aPoint - (1@1) * self cellSize + self position! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:16'!pause	gameOver ifTrue: [^ self].	paused _ paused not.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:17'!rotateAntiClockWise	self running ifFalse: [^ self].	currentBlock moveDeltaX: 0 deltaY: 0 deltaAngle: -1.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:17'!rotateClockWise	self running ifFalse: [^ self].	currentBlock moveDeltaX: 0 deltaY: 0 deltaAngle: 1.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 8/28/1999 22:31'!running	^currentBlock notNil and: [paused not]! !!TetrisBoard methodsFor: 'accessing' stamp: 'RAA 1/7/2000 22:38'!score: aNumber	score _ aNumber.	game score: score.! !!TetrisBoard methodsFor: 'stepping and presenter' stamp: 'RAA 1/8/2000 15:59'!step	(self ownerThatIsA: HandMorph) ifNotNil: [^self].	paused ifTrue: [^ self]. 	currentBlock ifNil: [		currentBlock _ TetrisBlock new.		self addMorphFront: currentBlock.		currentBlock board: self.	] ifNotNil: [		currentBlock dropByOne ifFalse: [self storePieceOnBoard]	].! !!TetrisBoard methodsFor: 'testing' stamp: 'AM 7/26/1999 16:07'!stepTime	^ delay! !!TetrisBoard methodsFor: 'other' stamp: 'RAA 1/8/2000 13:59'!storePieceOnBoard	currentBlock submorphs do: [ :each |		self addMorph: each.		((each top - self top) // self cellSize y) < 3 ifTrue: [			paused _ gameOver _ true.		].	].	currentBlock delete.	currentBlock _ nil.	self checkForFullRows.	self score: score + 10.	delay _ delay - 2 max: 80.! !"Morphic-Games"!!NsGame commentStamp: 'sbw 11/8/2003 09:28' prior: 0!This is the main game morph for playing the game NsGame.To open the morph do	NsGame new openInWorldA game board will be presented.  There is an Instructions button which provides a number of details on how the game operates.The instructions are created using a GeeMailMorph.  To update the instructions, open them via the instructions button, extract the GeeMailMorph from the opened window and then edit the GeeMailMorph in the usual manner.  Once you have completed your changes to the GeeMailMorph, use the debug menu and save the morph in a file.  There were some issues with saving stand-alone GeeMailMorphs in Squeak 3.6 at the time this game was created so the change set includes 2 patches to support that operation.  After the morph is saved in a file, use the FileList and compress the morph file.  Once you have the file compressed, use the FileList and select the file and then choose to copy the name of the file to the Clipboard.  Perform the following line of Squeak code in a workspace with that full file name path.  The file path shown here is an example of course.	NsGame convertSavedMorphFile: 'Meine Welt:Users:steve:Develop:squeak:3.6:my GeeMailMorph.morph.gz'.A workspace window will be opened showing the hex converted ascii for binary contained in the compressed morph.  Copy the contents of that text window into the	NsGame class>>compressedEncodedInstructionsmethod.  You can test your new instructions after completing this step.!!NsGameTile commentStamp: 'sbw 11/8/2003 08:24' prior: 0!This is the top of the NsGame tiles hierarchy.The hierarchy is divided into the kinds of tiles, those having no connections, one connection, two connections, three connections or four.The game uses Forms for drawing the game pieces.  There are 2 states for each game piece (active or idle).  Each game piece also has forms to represent the tile in each of the 4 possible positions.  Note that for some (blank and cross) there is only one rotation position.Forms for each rotated position were used to account for possible errors in drawing symmetry.All forms are actually stored on class instance variables in the hierarchy.  Note that a class instance variable exists for each instance of a class and is not the same object as a class variable.The subclasses of this hierarchy contain an elegant model for defining only what is different between the game tile pieces.!!NsFourConnectionsGameTile commentStamp: 'sbw 11/8/2003 08:25' prior: 0!This tile piece abstract class is the super class of all game pieces that have 4 connections.  Pieces in this hierarchy do not rotate.!!NsCrossGameTile commentStamp: 'sbw 11/8/2003 08:25' prior: 0!The Cross game tile piece.!!NsNoConnectionsGameTile commentStamp: 'sbw 11/8/2003 08:25' prior: 0!This tile piece abstract class is the super class of all game pieces that have no connections.  Pieces in this hierarchy do not rotate.!!NsBlankGameTile commentStamp: 'sbw 11/8/2003 08:26' prior: 0!The Blank tile game piece.!!NsOneConnectionGameTile commentStamp: 'sbw 11/8/2003 08:26' prior: 0!This hierarchy includes only the game pieces having one connection.  Each piece can have 4 rotated positions.!!NsDestinationGameTile commentStamp: 'sbw 11/8/2003 08:27' prior: 0!An instance of this game piece is an end point for the power grid.  There may be more than one destination piece on a game board, depending on the size of the board.!!NsSourceGameTile commentStamp: 'sbw 11/8/2003 08:27' prior: 0!This is the power source for the game board or grid.  There is only one on any game board.!!NsThreeConnectionsGameTile commentStamp: 'sbw 11/8/2003 08:28' prior: 0!This hierarchy includes only the game pieces having three connections.  Each piece can have 4 rotated positions.!!NsTeeGameTile commentStamp: 'sbw 11/8/2003 08:28' prior: 0!The Tee shaped game piece.!!NsTwoConnectionsGameTile commentStamp: 'sbw 11/8/2003 08:29' prior: 0!This hierarchy includes only the game pieces having two connections.  Each piece can have 4 rotated positions because of possible errors in piece drawing symmetry.!!NsCornerGameTile commentStamp: 'sbw 11/8/2003 08:29' prior: 0!The corner piece.!!NsLineGameTile commentStamp: 'sbw 11/8/2003 08:29' prior: 0!The horizontal or vertical game tile.!!NsModel commentStamp: 'sbw 11/8/2003 08:30' prior: 0!The model contains the logic to the game.  It also contains each game piece and the state of all the counters.!!NsGameHelpWindow commentStamp: '<historical>' prior: 0!Provides help window for NS Game.!!TextStream methodsFor: '*nsTileGame' stamp: 'sbw 10/28/2003 14:02' prior: 58758820!nextPutAll: aCollection 	"Optimized access to get around Text at:Put: overhead"	| n |	n _ aCollection size.	position + n > writeLimit ifTrue: [		super nextPutAll: aCollection.		self skip: 0 - aCollection size.		^self nextPutAll: aCollection].	(aCollection isMemberOf: String) ifFalse: [^super nextPutAll: aCollection].	collection string		replaceFrom: position + 1		to: position + n		with: aCollection		startingAt: 1.	position _ position + n! !!NsGame class methodsFor: 'parts bin' stamp: 'sbw 11/10/2003 22:00'!descriptionForPartsBin	^ self		partName: 'NsGame'		categories: #('Games' )		documentation: 'A power-circuit tile game.'! !!NsGame class methodsFor: 'as yet unclassified' stamp: 'sbw 10/19/2003 17:04'!helpFor: aKey 	^ self rules at: aKey ifAbsent: ['?']! !!NsGame class methodsFor: 'instructions' stamp: 'sbw 6/13/2004 18:07'!helpWindow	NsGameHelpWindow openHelpWindow! !!NsGame class methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 18:29'!initializeNsGame postLoadOperation! !!NsGame class methodsFor: 'as yet unclassified' stamp: 'sbw 12/7/2003 15:23'!initializeHelp	"NsGame initializeHelp"	| dict |	dict _ Dictionary new.	dict at: 'EndGame' put: 'Ends game and closes window.';		 at: 'ConnectedCounter' put: 'Shows how many powered cells you have.  Counter turns yellow when all destination cells are powered.';		 at: 'MaxCounter' put: 'Shows the highest number of connected cells for this game.';		 at: 'TurnsCounter' put: 'Shows how many turns you have taken.';		 at: 'Help' put: 'Opens up help window';		 at: 'NewGame' put: 'Start a new game using the same size board.';		 at: 'NewSize' put: 'Starts a new game where you choose the grid size.';		 at: 'Restart' put: 'Start the existing game over again.  The Max counter is not reset when a game is restarted.';		 at: 'Colors' put: 'Edit the colors used by the game.  This button toggles the display between the game board and the colors control panel.';		at: 'LoadSave' put: 'Load a previously saved game or save the current game.  This button toggles the display between the game board and the load/save control panel,'.	self rules: dict! !!NsGame class methodsFor: 'as yet unclassified' stamp: 'sbw 12/14/2003 12:42'!postLoadOperation	"NsGame postLoadOperation"	NsGame initializeHelp.	NsGameTile initializeForms.	NsGameTile initializeColors.	Smalltalk addToStartUpList: NsModel.! !!NsGame class methodsFor: 'as yet unclassified' stamp: 'sbw 10/19/2003 16:51'!rules	Rules == nil ifTrue: [self initializeHelp].	^Rules! !!NsGame class methodsFor: 'as yet unclassified' stamp: 'sbw 10/19/2003 15:04'!rules: aDictionary	Rules _ aDictionary! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 11/28/2003 16:27'!addButtonToColumn: column buttonHeight: buttonHeight vOffset: vOffset selector: selector top: top 	| bottom |	bottom _ top + buttonHeight.	selector = #NONE		ifFalse: [self				addControl: (self perform: selector)				to: column				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (self windowPadding x @ top corner: self windowPadding x negated @ bottom)].	^ bottom + vOffset! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 12/7/2003 15:26'!addButtonsToColumn: column buttonHeight: buttonHeight offset: offset 	| vOffset top selectors |	top _ offset copy.	vOffset _ 5.	selectors _ #(#makeRestartButton #makeNewGameButton #makeNewSizeButton #makeEditColorsButton #makeHelpButton #makeLoadSaveButton #makeCloseGameButton ).	selectors		do: [:selector | top _ self						addButtonToColumn: column						buttonHeight: buttonHeight						vOffset: vOffset						selector: selector						top: top].	^ top! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/25/2003 06:54'!addControl: aMorph to: column fractions: fractions offsets: offsets	aMorph isNil		ifFalse: [column addMorph: aMorph		fullFrame: (LayoutFrame				fractions: (fractions)				offsets: (offsets))]! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/29/2003 20:05'!addMorphs	self		addMorph: self makeControls		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 0 @ 1)				offsets: (0 @ 0 corner: self controlPanelWidth @ 0)).	self		addMorph: self makeGameBoardMorph		fullFrame: (self boardMorphLayoutFrame)! !!NsGame methodsFor: 'widgets - counters' stamp: 'sbw 11/27/2003 10:52'!addPanelsToColumn: column panelHeight: countPanelHeight offset: offset	| vOffset top bottom |	vOffset _ 5.	top _ offset copy.	bottom _ top + countPanelHeight.	self		addControl: self makeMovesMorph		to: column		fractions: (0 @ 0 corner: 1 @ 0)		offsets: (self windowPadding x @ top corner: self windowPadding x negated @ bottom).	top _ bottom + vOffset.	bottom _ top + countPanelHeight.	self		addControl: self makeCountMorph		to: column		fractions: (0 @ 0 corner: 1 @ 0)		offsets: (self windowPadding x @ top corner: self windowPadding x negated @ bottom).	top _ bottom + vOffset.	bottom _ top + countPanelHeight.	self		addControl: self makeMaxMorph		to: column		fractions: (0 @ 0 corner: 1 @ 0)		offsets: (self windowPadding x @ top corner: self windowPadding x negated @ bottom).	^ bottom + vOffset! !!NsGame methodsFor: 'widgets' stamp: 'sbw 12/7/2003 17:20'!boardMorph	^ board! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/29/2003 20:04'!boardMorphLayoutFrame	^LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (self controlPanelWidth @ self windowPadding y corner: self windowPadding negated)! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 11/29/2003 20:10'!buildColorsMorph	| colorsMorph buttonMorph colorsTableMorph |	colorsTableMorph _ self editColorsControlMorph.	buttonMorph _ self resetColorsButtonMorph.	colorsMorph _ AlignmentMorph newColumn beTransparent.	colorsMorph addMorphBack: colorsTableMorph;		 addMorphBack: buttonMorph.	buttonMorph color: Color transparent.	^ colorsMorph! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 22:24'!buildLoadSaveMorph	| theMorph saveButton loadButton deleteButton |	saveButton _ self saveGameButtonMorph.	loadButton _ self loadGameButtonMorph.	deleteButton _ self deleteGamesButtonMorph.	theMorph _ AlignmentMorph newColumn beTransparent.	theMorph addTransparentSpacerOfSize: 10 @ 10;		 addMorphBack: loadButton;		 addTransparentSpacerOfSize: 10 @ 10;		 addMorphBack: saveButton;		 addTransparentSpacerOfSize: 10 @ 10;		addMorphBack: deleteButton;		addTransparentSpacerOfSize: 10 @ 10.	saveButton color: Color transparent.	loadButton color: Color transparent.	deleteButton color: Color transparent.	^ theMorph! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/25/2003 06:26'!calculatedExtent	| pt |	pt _ self gameModel renderFormSize + self windowExtra.	^ pt x		@ (pt y max: 380)! !!NsGame methodsFor: 'events' stamp: 'sbw 11/27/2003 10:09'!click: evt forMorph: aSketchMorph 	| selectedCell |	selectedCell _ self selectedCellClicked: evt forMorph: aSketchMorph.	selectedCell isNil		ifFalse: [Sensor shiftPressed				ifTrue: [self gameModel rotateCellRight: selectedCell forMorph: aSketchMorph]				ifFalse: [self gameModel rotateCellLeft: selectedCell forMorph: aSketchMorph].			self gameModel updateMoves.			self gameModel update.			self gameModel renderCellsOn: aSketchMorph form.			aSketchMorph layoutChanged]! !!NsGame methodsFor: 'events' stamp: 'sbw 12/7/2003 22:04'!closeGame	"Use the following preferences check to decide if we are a Squeak image 	running the game morph."	Preferences cmdDotEnabled		ifTrue: [self delete]		ifFalse: [(self confirm: 'Really quit?')				ifTrue: [Smalltalk quitPrimitive]]! !!NsGame methodsFor: 'widgets' stamp: 'sbw 12/7/2003 17:38'!colorsMorph	^self submorphNamed: 'colors'! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/26/2003 17:42'!controlPanelWidth	^ 100! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 11/25/2003 06:26'!currentColor: key 	^ NsGameTile colors at: key! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 11/25/2003 06:26'!currentColor: key new: newColor 	NsGameTile colors at: key put: newColor.	self updateColors! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/25/2003 06:26'!defaultBounds	"answer the default bounds for the receiver"	^ 0 @ 0 corner: self calculatedExtent! !!NsGame methodsFor: 'accessing' stamp: 'sbw 11/28/2003 13:40'!defaultGameSize	^7 @ 11 ! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 22:29'!deleteGames	| list choice deleteList |	self hideLoadSaveButtons.	deleteList _ OrderedCollection new.	list _ (FileDirectory default fileNamesMatching: '*.ns') asOrderedCollection.	list size = 0		ifTrue: [self inform: 'No files found to delete.']		ifFalse: [list size = 1				ifTrue: [deleteList add: list first]				ifFalse: [list addFirst: 'All saved games'.					list addLast: 'Cancel'.					choice _ PopUpMenu withCaption: 'Delete a saved game file.' chooseFrom: list.					(choice = 0							or: [choice = list size])						ifFalse: [choice = 1								ifTrue: [2										to: list size - 1										do: [:index | deleteList												add: (list at: index)]]								ifFalse: [deleteList										add: (list at: choice)]]].			deleteList				do: [:fn | FileDirectory default deleteFileNamed: fn].			deleteList size > 0 ifTrue: [self inform: 'Deleted files = ', deleteList size printString]].	self showLoadSaveButtons! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 22:20'!deleteGamesButtonMorph	| btn labelMorph am |	btn _ PluggableButtonMorph				on: self				getState: nil				action: #deleteGames.	btn name: 'deleteGames'.	labelMorph _ StringMorph contents: '  Delete Saved Game(s)  '.	btn label: labelMorph;		 setBalloonText: 'Delete saved game files.'.	self setButtonAttributes: btn.	am _ AlignmentMorph newRow wrapCentering: #topLeft;				 cellPositioning: #topLeft;				 hResizing: #shrinkWrap;				 vResizing: #spaceFill;				 borderWidth: 0;				 layoutInset: 5;				 color: Color white.	am addMorphBack: btn.	^ am! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 12/7/2003 17:46'!editColors	self boardMorph visible		ifTrue: [self hideBoard.			self showColors]		ifFalse: [self isLoadSaveMorphVisible ifFalse: [self hideColors.			self showBoard]]! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 12/7/2003 17:32'!editColorsControlMorph	| tags tag tableMorph row swatch stringMorph |	tags _ NsGameTile colorTags.	tableMorph _ AlignmentMorph newColumn beTransparent.	NsGameTile editableColorKeys		do: [:key | 			tag _ tags at: key.			row _ AlignmentMorph newRow beTransparent.			swatch _ ColorSwatch new target: self;						 getSelector: #currentColor:;						 putSelector: #currentColor:new:;						 argument: key;						 extent: 40 @ 20;						 setBalloonText: 'click here to change the color';						 yourself.			swatch useRoundedCorners; borderStyle: (BorderStyle complexAltInset width: 2).			row addTransparentSpacerOfSize: 4 @ 0.			row addMorphBack: swatch.			row addTransparentSpacerOfSize: 6 @ 0.			stringMorph _ StringMorph contents: tag.			stringMorph color: self stringColor.			row addMorphBack: stringMorph.			row addTransparentSpacerOfSize: 4 @ 0.			tableMorph addMorphBack: row].	^ tableMorph! !!NsGame methodsFor: 'accessing' stamp: 'sbw 11/25/2003 06:24'!gameModel	^ gameModel! !!NsGame methodsFor: 'accessing' stamp: 'sbw 11/25/2003 06:24'!gameModel: anNsModel 	gameModel _ anNsModel! !!NsGame methodsFor: 'events' stamp: 'sbw 11/25/2003 06:27'!help	^ NsGame helpWindow! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 12/7/2003 17:20'!hideBoard	(self boardMorph) hide! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 12/7/2003 17:39'!hideColors	| m |	m _ self colorsMorph.	m isNil		ifFalse: [m hide]! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 17:49'!hideLoadSave	| m |	m _ self loadSaveMorph.	m isNil		ifFalse: [m hide]! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 22:21'!hideLoadSaveButtons	| m loadBtn saveBtn delBtn |	m _ self loadSaveMorph.	loadBtn _ m submorphNamed: 'loadGame'.	saveBtn _ m submorphNamed: 'saveGame'.	delBtn _ m submorphNamed: 'deleteGames'.	((loadBtn isNil			or: [saveBtn isNil]) or: [delBtn isNil])		ifFalse: [loadBtn hide.			saveBtn hide.			delBtn hide]! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 11/25/2003 06:27'!initialExtent	"Extent used for colors window."	^ 250 @ 200! !!NsGame methodsFor: 'initialization' stamp: 'sbw 11/28/2003 13:40'!initialize	self		gameModel: (NsModel new: (self defaultGameSize) gameMorph: self).	super initialize.	self layoutPolicy: ProportionalLayout new.	self setWindowColors.	self addMorphs! !!NsGame methodsFor: 'widgets' stamp: 'sbw 12/7/2003 17:44'!isColorsMorphVisible	| m |	m _ self colorsMorph.	m isNil ifTrue: [^false].	^m visible! !!NsGame methodsFor: 'widgets' stamp: 'sbw 12/7/2003 17:45'!isLoadSaveMorphVisible	| m |	m _ self loadSaveMorph.	m isNil		ifTrue: [^ false].	^ m visible! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 22:34'!loadGame	| fileName fStream assoc list choice didIt |	self hideLoadSaveButtons.	didIt _ false.	list _ FileDirectory default fileNamesMatching: '*.ns'.	list size = 0		ifTrue: [self inform: 'No files found to load']		ifFalse: [list size = 1				ifTrue: [fileName _ list first]				ifFalse: [choice _ PopUpMenu withCaption: 'Select a saved game file.' chooseFrom: list.					choice = 0						ifTrue: [fileName _ nil]						ifFalse: [fileName _ list at: choice]].					fileName isNil						ifFalse: [fStream _ FileDirectory default readOnlyFileNamed: fileName.							assoc _ self gameModel loadPiecesFrom: fStream.							fStream close.							self gameModel restartWith: self boardMorph usingPositions: assoc value.							self gameModel initialPositions: assoc value.							didIt _ true]].	self showLoadSaveButtons.	didIt		ifTrue: [self loadSave]! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 21:27'!loadGameButtonMorph	| btn labelMorph am |	btn _ PluggableButtonMorph				on: self				getState: nil				action: #loadGame.	btn name: 'loadGame'.	labelMorph _ StringMorph contents: '  Load Previously Saved Game  '.	btn label: labelMorph;		 setBalloonText: 'Load a previously saved game.  This will destroy the current game.'.	self setButtonAttributes: btn.	am _ AlignmentMorph newRow wrapCentering: #topLeft;				 cellPositioning: #topLeft;				 hResizing: #shrinkWrap;				 vResizing: #spaceFill;				 borderWidth: 0;				 layoutInset: 5;				 color: Color white.	am addMorphBack: btn.	^ am! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 17:48'!loadSave	self boardMorph visible		ifTrue: [self hideBoard.  self showLoadSave]		ifFalse: [self isColorsMorphVisible				ifFalse: [self hideLoadSave. self showBoard]]! !!NsGame methodsFor: 'widgets' stamp: 'sbw 12/7/2003 17:40'!loadSaveMorph	^ self submorphNamed: 'loadSave'! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 11/28/2003 16:20'!makeButtonNamed: label action: actionSymbol helpKey: helpKey	| btn labelMorph |	btn _ PluggableButtonMorph				on: self				getState: nil				action: actionSymbol.	labelMorph _ StringMorph contents: label.	btn label: labelMorph;				setBalloonText: (NsGame helpFor: helpKey).	self setButtonAttributes: btn.	^ btn! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 12/4/2003 02:19'!makeCloseGameButton	^ self		makeButtonNamed: 'End Game'		action: #closeGame		helpKey: 'EndGame'! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/27/2003 11:03'!makeControls	| column countPanelHeight buttonHeight top |	column _ RectangleMorph new borderWidth: 0;				 color: Color transparent;				 layoutPolicy: ProportionalLayout new.	column name: 'controls'.	countPanelHeight _ 40.	buttonHeight _ 24.	top _ self				addPanelsToColumn: column				panelHeight: countPanelHeight				offset: self windowPadding y.	top _ self				addButtonsToColumn: column				buttonHeight: buttonHeight				offset: top.	^ column! !!NsGame methodsFor: 'widgets - counters' stamp: 'sbw 11/25/2003 06:32'!makeCountMorph	count _ LedMorph new digits: 3;				 extent: 3 * 10 @ 15;								setBalloonText: (NsGame helpFor: 'ConnectedCounter').	count color: NsGameTile ledColor.	^ self wrapPanel: count label: 'Connected:'! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 11/28/2003 16:21'!makeEditColorsButton	^ self		makeButtonNamed: 'Colors'		action: #editColors		helpKey: 'Colors'! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/25/2003 06:28'!makeGameBoardMorph	board _ SketchMorph withForm: self gameModel renderCells.	board name: 'board'.	self registerSelectedBoardEvents.	^ board! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 11/28/2003 16:22'!makeHelpButton	^ self		makeButtonNamed: 'Instructions'		action: #help		helpKey: 'Help'! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 12/7/2003 15:22'!makeLoadSaveButton	^ self		makeButtonNamed: 'Load/Save'		action: #loadSave		helpKey: 'LoadSave'! !!NsGame methodsFor: 'widgets - counters' stamp: 'sbw 11/25/2003 06:32'!makeMaxMorph	max _ LedMorph new digits: 3;				 extent: 3 * 10 @ 15;								setBalloonText: (NsGame helpFor: 'MaxCounter').	max color: NsGameTile ledColor.	^ self wrapPanel: max label: 'Max:'! !!NsGame methodsFor: 'widgets - counters' stamp: 'sbw 11/25/2003 06:32'!makeMovesMorph	moves _ LedMorph new digits: 3;				 extent: 3 * 10 @ 15;								setBalloonText: (NsGame helpFor: 'TurnsCounter').	moves color: NsGameTile ledColor.	^ self wrapPanel: moves label: 'Turns:'! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 11/28/2003 16:22'!makeNewGameButton	^ self		makeButtonNamed: 'New Game'		action: #newGame		helpKey: 'NewGame'! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 11/28/2003 16:23'!makeNewSizeButton	^ self		makeButtonNamed: 'New Size'		action: #newSize		helpKey: 'NewSize'! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 11/28/2003 16:23'!makeRestartButton	^ self		makeButtonNamed: 'Restart'		action: #restart		helpKey: 'Restart'! !!NsGame methodsFor: 'events' stamp: 'sbw 12/7/2003 20:46'!newGame	self boardMorph visible ifFalse: [^self].	self newGameOfSize: self gameModel extent! !!NsGame methodsFor: 'events' stamp: 'sbw 12/7/2003 17:21'!newGameOfSize: aPoint 	self		gameModel: (NsModel new: aPoint gameMorph: self).	self boardMorph newForm: self gameModel renderCells.	self registerSelectedBoardEvents! !!NsGame methodsFor: 'events' stamp: 'sbw 4/26/2004 22:26'!newSize	| choices index point initial choiceStrings reply menu |	self boardMorph visible		ifFalse: [^ self].	initial := {7. 8. 9. 10. 11. 12. 13}.	choices := OrderedCollection new.	choices add: 'enter value'.	initial		do: [:x | 			choices add: x @ x.			x < 9				ifTrue: [choices add: x @ (x + 1);						 add: x @ (x + 2);						 add: x @ (x + 3);						 add: x @ (x + 4)]].	choiceStrings := choices				collect: [:x | x isPoint						ifTrue: [x = self defaultGameSize								ifTrue: [x printString , ' DEFAULT']								ifFalse: [x printString]]						ifFalse: [x]].	menu _ EmphasizedMenu selections: choiceStrings.	menu				emphases: (choices						collect: [:it | it = self gameModel extent								ifTrue: [#bold]								ifFalse: [#normal]]).	reply _ menu startUpWithCaption: 'Choose new game size'.	reply isNil		ifFalse: [index := choiceStrings indexOf: reply.			index = 1				ifTrue: [point := self promptForNewSize.					point isNil						ifTrue: [^ self]]				ifFalse: [point := choices at: index].			self newGameOfSize: point.			self extent: self calculatedExtent]! !!NsGame methodsFor: 'events' stamp: 'sbw 11/25/2003 06:29'!promptForNewSize	| prompt array x y |	prompt _ FillInTheBlank request: 'Enter x@y dimensions'.	prompt isEmpty		ifTrue: [^ nil].	array _ prompt findTokens: $@.	x _ array first asNumber.	y _ array second asNumber.	^ x @ y! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 21:52'!promptForSaveFileName: initial	| continue default reply trialName choice |	continue _ true.	default _ initial.	[continue] whileTrue: [	reply _ FillInTheBlank request: 'File name (.ns will be appended)?' initialAnswer: default.	reply isEmpty		ifTrue: [^ nil].	trialName _ reply, '.ns'.	continue _ FileDirectory default fileExists: trialName.	continue ifTrue: [		choice _ PopUpMenu withCaption: 'File "', reply, '" already exists' chooseFrom:			{'Overwrite it'. 'Try a new name'. 'Cancel'}.		choice = 0 ifTrue: [^nil].		choice = 3 ifTrue: [^nil].		choice = 1 ifTrue: [^trialName].		choice = 2 ifTrue: [default _ reply]		]	].	^trialName! !!NsGame methodsFor: 'events' stamp: 'sbw 12/7/2003 17:21'!registerSelectedBoardEvents	self boardMorph		on: #mouseUp		send: #click:forMorph:		to: self! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 11/25/2003 06:29'!resetColors	NsGameTile initializeColors.	self updateColors! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 12/7/2003 18:19'!resetColorsButtonMorph	| btn labelMorph am |	btn _ PluggableButtonMorph				on: self				getState: nil				action: #resetColors.	labelMorph _ StringMorph contents: '  Reset to defaults  '.	btn label: labelMorph;		 setBalloonText: 'Reset to using default colors'.	self setButtonAttributes: btn.	am _ AlignmentMorph newRow wrapCentering: #topLeft;				 cellPositioning: #topLeft;				 hResizing: #shrinkWrap;				 vResizing: #spaceFill;				 borderWidth: 0;				 layoutInset: 5;				 color: Color white.	am addMorphBack: btn.	^ am! !!NsGame methodsFor: 'events' stamp: 'sbw 12/7/2003 20:46'!restart	self boardMorph visible ifFalse: [^self].	self gameModel restartWith: self boardMorph! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 22:27'!saveGame	| fileName fStream |	fileName _ self promptForSaveFileName: self saveGameFileName.	fileName isNil		ifTrue: [^ self].	fStream _ FileDirectory default forceNewFileNamed: fileName.	self gameModel savePiecesOn: fStream.	fStream close.! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 20:37'!saveGameButtonMorph	| btn labelMorph am |	btn _ PluggableButtonMorph				on: self				getState: nil				action: #saveGame.	btn name: 'saveGame'.	labelMorph _ StringMorph contents: '  Save Current Game  '.	btn label: labelMorph;		 setBalloonText: 'Save the current game to a file.'.	self setButtonAttributes: btn.	am _ AlignmentMorph newRow wrapCentering: #topLeft;				 cellPositioning: #topLeft;				 hResizing: #shrinkWrap;				 vResizing: #spaceFill;				 borderWidth: 0;				 layoutInset: 5;				 color: Color white.	am addMorphBack: btn.	^ am! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 21:40'!saveGameFileName	^ 'saved'! !!NsGame methodsFor: 'events' stamp: 'sbw 11/27/2003 10:27'!selectedCellClicked: evt forMorph: aSketchMorph 	| clickPosn cellSize selectedCell guess1 guess2 guess3 tolerance |	clickPosn _ evt cursorPoint - aSketchMorph position.	cellSize _ aSketchMorph extent // self gameModel extent.	tolerance _ 1.	guess1 _ clickPosn // cellSize.	guess1 _ guess1 + 1.	guess2 _ clickPosn - tolerance // cellSize.	guess2 _ guess2 + 1.	guess3 _ clickPosn + tolerance // cellSize.	guess3 _ guess3 + 1.	selectedCell _ nil.	(guess1 = guess2			and: [guess1 = guess3])		ifTrue: [((guess1 x > 0 and: [guess1 x <= self gameModel extent x]) and: [guess1 y > 0 and: [guess1 y <= self gameModel extent y]]) ifTrue: [			selectedCell _ guess1]].	^ selectedCell! !!NsGame methodsFor: 'widgets - buttons' stamp: 'sbw 11/25/2003 06:29'!setButtonAttributes: btn 	btn useRoundedCorners; hResizing: #spaceFill; onColor: Color transparent offColor: Color transparent; borderWidth: 2; borderColor: #raised; fillWithRamp: self windowColorRamp oriented: 0.1 @ 0.8.	btn label color: Color white! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/28/2003 17:09'!setWindowColors	self setWindowColorsOn: self! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/28/2003 17:09'!setWindowColorsOn: target	target borderWidth: 4;				borderColor: (Color				r: 0.369				g: 0.369				b: 0.505);		 useRoundedCorners.	target fillWithRamp: self windowColorRamp oriented: 0.4 @ 0.35! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 12/7/2003 17:19'!showBoard	self boardMorph show! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 12/7/2003 17:40'!showColors	| m |	m _ self colorsMorph.	m isNil		ifTrue: [m _ self wrapPanel: self buildColorsMorph label: 'Colors'.			m name: 'colors'.			self addMorph: m fullFrame: self boardMorphLayoutFrame].	m show! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 12/7/2003 17:40'!showControls	(self colorsMorph) show! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 17:52'!showLoadSave	| m |	m _ self loadSaveMorph.	m isNil		ifTrue: [m _ self wrapPanel: self buildLoadSaveMorph label: 'Load/Save'.			m name: 'loadSave'.			self addMorph: m fullFrame: self boardMorphLayoutFrame].	m show! !!NsGame methodsFor: 'load-save' stamp: 'sbw 12/7/2003 22:22'!showLoadSaveButtons	| m loadBtn saveBtn delBtn |	m _ self loadSaveMorph.	loadBtn _ m submorphNamed: 'loadGame'.	saveBtn _ m submorphNamed: 'saveGame'.	delBtn _ m submorphNamed: 'deleteGames'.	((loadBtn isNil				or: [saveBtn isNil])			or: [delBtn isNil])		ifFalse: [loadBtn show.			saveBtn show.			delBtn show]! !!NsGame methodsFor: 'widgets' stamp: 'sbw 12/7/2003 17:09'!stringColor	^Color				r: 0.84				g: 1.0				b: 0.8! !!NsGame methodsFor: 'colors mods' stamp: 'sbw 12/7/2003 17:19'!updateColors	NsGameTile updateColors.	(self boardMorph)		newForm: gameModel renderCells! !!NsGame methodsFor: 'events' stamp: 'sbw 11/25/2003 06:30'!updateCounters	count isNil		ifFalse: [count value: self gameModel currentCount.			count highlighted: self gameModel circuitComplete].	max isNil		ifFalse: [max value: self gameModel maxConnected.			max highlighted: self gameModel allTilesActive].	moves isNil		ifFalse: [moves value: self gameModel moves].	^ self gameModel circuitComplete! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/25/2003 06:25'!windowColorRamp	^ {0.0		-> (Color				r: 0.7				g: 0.7				b: 1.0). 1.0		-> (Color				r: 0.3				g: 0.3				b: 0.4)}! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/26/2003 17:23'!windowExtra	^ self controlPanelWidth @ 0 + ((self windowPadding) * 2)! !!NsGame methodsFor: 'widgets' stamp: 'sbw 11/26/2003 17:22'!windowPadding	^ 10 @ 10! !!NsGame methodsFor: 'widgets - counters' stamp: 'sbw 12/7/2003 17:09'!wrapPanel: anLedPanel label: aLabel 	"wrap an LED panel in an alignmentMorph with a label above it"	| a strM |	a _ AlignmentMorph newColumn wrapCentering: #topLeft;				 cellPositioning: #topLeft;				 hResizing: #spaceFill;				 vResizing: #shrinkWrap;				 borderWidth: 2;				 layoutInset: 5;				 color: Color transparent;				 useRoundedCorners;								borderStyle: (BorderStyle complexAltInset width: 2).	a addMorph: anLedPanel.	strM _ StringMorph contents: aLabel.	strM color: self stringColor.	a addMorph: strM.	^ a! !!NsCrossGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:09'!hasForms	^ true! !!NsCrossGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:35'!initializeActiveForms	| orientationForm line |	self activeCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self fullHorizontalMiddleLine: true.	line displayOn: orientationForm.	line _ self fullVerticalMiddleLine: true.	line displayOn: orientationForm.	self activeCachedForms at: 1 put: orientationForm! !!NsCrossGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:33'!initializeIdleForms	| orientationForm line |	self idleCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self fullHorizontalMiddleLine: false.	line displayOn: orientationForm.	line _ self fullVerticalMiddleLine: false.	line displayOn: orientationForm.	self idleCachedForms at: 1 put: orientationForm! !!NsCrossGameTile class methodsFor: 'constants' stamp: 'sbw 12/7/2003 14:30'!partCode	^1! !!NsCrossGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:39'!tileName	^'Cross'! !!NsFourConnectionsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:18'!maxConnections	^ 4! !!NsFourConnectionsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:19'!maxOrientations	^ 1! !!NsFourConnectionsGameTile methodsFor: 'neighbors' stamp: 'sbw 10/17/2003 14:15'!neighborDeltas	^OrderedCollection		with: -1@0		with: 0@-1		with: 1@0		with: 0@1! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 4/27/2004 22:46'!activeCachedForms	ActiveCachedForms isNil ifTrue: [self initializeActiveForms].	^ ActiveCachedForms! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:05'!activeCachedForms: aDictionary 	ActiveCachedForms _ aDictionary! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 04:54'!activeLineColor	^self colors at: 'activeLineColor'! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 21:49'!activeLineColorString	^ 'Active Line Color'! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 04:55'!backgroundColor	^ self colors at: 'backgroundColor'! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 21:49'!backgroundColorString	^ 'Background Color'! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 04:56'!borderColor	^ self colors at: 'borderColor'! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 21:50'!borderColorString	^ 'Border Color'! !!NsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:15'!borderWidth	^ 2! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 04:57'!boxColor	^ self colors at: 'boxColor'! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 21:50'!boxColorString	^'Box Color'! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/15/2003 06:40'!colorTags	| dict selector value |	dict _ Dictionary new.	self editableColorKeys		do: [:key | 			selector _ (key , 'String') asSymbol.			value _ self perform: selector.			dict at: key put: value].	^ dict! !!NsGameTile class methodsFor: 'accessing' stamp: 'sbw 11/13/2003 04:52'!colors	Colors == nil ifTrue: [self initializeColors].	^ Colors! !!NsGameTile class methodsFor: 'accessing' stamp: 'sbw 11/13/2003 04:51'!colors: dict	Colors _ dict! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:50'!displayForms	"NsGameTile displayForms"	| xPos yPos form maxPos |	yPos _ 10.	maxPos _ 0.	(self allSubclasses		select: [:cls | cls hasForms])		do: [:subclass | 			xPos _ 10.			1				to: subclass maxOrientations				do: [:index | 					form _ subclass activeCachedForms at: index.					form displayAt: xPos @ yPos.					xPos + form extent x > maxPos						ifTrue: [maxPos _ xPos + form extent x].					xPos _ xPos + 10 + self extent x].			yPos _ yPos + 10 + self extent y].	yPos _ 10.	(self allSubclasses		select: [:cls | cls hasForms])		do: [:subclass | 			xPos _ maxPos  + 10.			1				to: subclass maxOrientations				do: [:index | 					form _ subclass idleCachedForms at: index.					form displayAt: xPos @ yPos.					xPos _ xPos + 10 + self extent x].			yPos _ yPos + 10 + self extent y]! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:53'!eastLineSegment: beActive 	| line lineFillForm x1 y1 p1 x2 y2 p2 |	line _ Line new.	lineFillForm _ Form extent: self lineWidth @ self lineWidth depth: self formDepth.	lineFillForm		fillColor: (beActive				ifTrue: [self activeLineColor]				ifFalse: [self idleLineColor]).	line form: lineFillForm.	x1 _ self extent x // 2.	y1 _ self extent y // 2 - (self lineWidth // 2).	p1 _ x1 @ y1.	line beginPoint: p1.	x2 _ self extent x.	y2 _ y1.	p2 _ x2 @ y2.	line endPoint: p2.	^ line! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/15/2003 06:40'!editableColorKeys	^(OrderedCollection new)		add: 'activeLineColor';		add: 'backgroundColor';		add: 'borderColor';		add: 'boxColor';		add: 'idleLineColor';		yourself! !!NsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:16'!extent	^ 30 @ 30! !!NsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:16'!formDepth	^ 16! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:16'!fullHorizontalMiddleLine: beActive 	| line lineFillForm x1 y1 p1 x2 y2 p2 |	line _ Line new.	lineFillForm _ Form extent: self lineWidth @ self lineWidth depth: self formDepth.	lineFillForm		fillColor: (beActive				ifTrue: [self activeLineColor]				ifFalse: [self idleLineColor]).	line form: lineFillForm.	x1 _ 0.	y1 _ self extent y // 2 - (self lineWidth // 2).	p1 _ x1 @ y1.	line beginPoint: p1.	x2 _ self extent x.	y2 _ y1.	p2 _ x2 @ y2.	line endPoint: p2.	^ line! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:17'!fullVerticalMiddleLine: beActive 	| line lineFillForm x1 y1 p1 x2 y2 p2 |	line _ Line new.	lineFillForm _ Form extent: self lineWidth @ self lineWidth depth: self formDepth.	lineFillForm		fillColor: (beActive				ifTrue: [self activeLineColor]				ifFalse: [self idleLineColor]).	line form: lineFillForm.	x1 _ self extent x // 2 - (self lineWidth // 2).	y1 _ 0.	p1 _ x1 @ y1.	line beginPoint: p1.	x2 _ x1.	y2 _ self extent y.	p2 _ x2 @ y2.	line endPoint: p2.	^ line! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:08'!hasForms	^false! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 4/27/2004 22:47'!idleCachedForms	IdleCachedForms isNil ifTrue: [self initializeIdleForms].	^ IdleCachedForms! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:05'!idleCachedForms: aDictionary 	IdleCachedForms _ aDictionary! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 04:57'!idleLineColor	^ self colors at: 'idleLineColor'! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 21:50'!idleLineColorString	^'Idle Line Color'! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:17'!initializeActiveForms	^ self subclassResponsibility! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 12/7/2003 17:35'!initializeColors	"NsGameTile initializeColors"	| dict |	dict _ Dictionary new.	dict		at: 'activeLineColor'		put: (Color				r: 0.972				g: 0.595				b: 0.349);				at: 'backgroundColor'		put: (Color				r: 0.8				g: 0.8				b: 0.8);		 at: 'borderColor' put: Color white;		 at: 'boxColor' put: Color blue;				at: 'idleLineColor'		put: (Color r: 0.376 g: 0.376 b: 0.513);				at: 'ledColor'		put: (Color				r: 0.674				g: 0.674				b: 0.96).	self colors: dict! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:49'!initializeForms	"NsGameTile initializeForms"	(self allSubclasses		select: [:cls | cls hasForms])		do: [:subclass | 			subclass initializeActiveForms.			subclass initializeIdleForms]! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:17'!initializeIdleForms	^ self subclassResponsibility! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 04:58'!ledColor	^self colors at: 'ledColor'! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 21:51'!ledColorString	^'LED Color'! !!NsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:18'!lineWidth	^ 2! !!NsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:18'!maxConnections	^ self subclassResponsibility! !!NsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:18'!maxOrientations	^ self subclassResponsibility! !!NsGameTile class methodsFor: 'accessing' stamp: 'sbw 12/7/2003 15:10'!newTileMatchingPartCode: anInteger 	| clsToUse |	clsToUse _ NsGameTile allSubclasses		detect: [:cls | cls partCode = anInteger]		ifNone: [^nil].	^clsToUse new! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:56'!northLineSegment: beActive 	| line lineFillForm x1 y1 p1 x2 y2 p2 |	line _ Line new.	lineFillForm _ Form extent: self lineWidth @ self lineWidth depth: self formDepth.	lineFillForm		fillColor: (beActive				ifTrue: [self activeLineColor]				ifFalse: [self idleLineColor]).	line form: lineFillForm.	x1 _ self extent x // 2 - (self lineWidth // 2).	y1 _ 0.	p1 _ x1 @ y1.	line beginPoint: p1.	x2 _ x1.	y2 _ self extent y // 2.	p2 _ x2 @ y2.	line endPoint: p2.	^ line! !!NsGameTile class methodsFor: 'constants' stamp: 'sbw 12/7/2003 15:07'!partCode	^0! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:57'!southLineSegment: beActive 	| line lineFillForm x1 y1 p1 x2 y2 p2 |	line _ Line new.	lineFillForm _ Form extent: self lineWidth @ self lineWidth depth: self formDepth.	lineFillForm		fillColor: (beActive				ifTrue: [self activeLineColor]				ifFalse: [self idleLineColor]).	line form: lineFillForm.	x1 _ self extent x // 2 - (self lineWidth // 2).	y1 _ self extent y // 2.	p1 _ x1 @ y1.	line beginPoint: p1.	x2 _ x1.	y2 _ self extent y.	p2 _ x2 @ y2.	line endPoint: p2.	^ line! !!NsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:38'!tileName	^ self subclassResponsibility! !!NsGameTile class methodsFor: 'colors' stamp: 'sbw 11/13/2003 05:01'!updateColors	self initializeForms! !!NsGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:54'!westLineSegment: beActive 	| line lineFillForm x1 y1 p1 x2 y2 p2 |	line _ Line new.	lineFillForm _ Form extent: self lineWidth @ self lineWidth depth: self formDepth.	lineFillForm		fillColor: (beActive				ifTrue: [self activeLineColor]				ifFalse: [self idleLineColor]).	line form: lineFillForm.	x1 _ 0.	y1 _ self extent y // 2 - (self lineWidth // 2).	p1 _ x1 @ y1.	line beginPoint: p1.	x2 _ self extent x // 2.	y2 _ y1.	p2 _ x2 @ y2.	line endPoint: p2.	^ line! !!NsGameTile methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:23'!active	active isNil ifTrue: [self active: false].	^active! !!NsGameTile methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:23'!active: aBoolean	active _ aBoolean! !!NsGameTile methodsFor: 'testing' stamp: 'sbw 10/26/2003 08:04'!canBeActive	^true! !!NsGameTile methodsFor: 'accessing' stamp: 'sbw 10/16/2003 15:03'!form	^self active		ifTrue: [self class activeCachedForms at: self orientation]		ifFalse: [self class idleCachedForms at: self orientation]! !!NsGameTile methodsFor: 'accessing' stamp: 'sbw 10/16/2003 09:18'!form: aForm	form _ aForm! !!NsGameTile methodsFor: 'testing' stamp: 'sbw 10/17/2003 14:05'!isSource	^false! !!NsGameTile methodsFor: 'neighbors' stamp: 'sbw 10/17/2003 15:20'!neighborDeltas	^  OrderedCollection new! !!NsGameTile methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:22'!orientation	orientation isNil ifTrue: [self orientation: 1].	^orientation! !!NsGameTile methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:22'!orientation: int	orientation _ int! !!NsGameTile methodsFor: 'printing' stamp: 'sbw 10/18/2003 13:20'!printOn: aStream 	super printOn: aStream.	aStream 		cr; nextPutAll: '  ' , self class tileName;		cr; nextPutAll: '  Active: ', self active printString;		cr; nextPutAll: '  Orientation: ', self orientation printString! !!NsGameTile methodsFor: 'events' stamp: 'sbw 10/17/2003 13:56'!rotateLeft	| value |	value _ self orientation.	value _ value + 1.	value > self class maxOrientations		ifTrue: [value _ 1].	self orientation: value! !!NsGameTile methodsFor: 'events' stamp: 'sbw 10/17/2003 13:56'!rotateRight	| value |	value _ self orientation.	value _ value - 1.	value < 1		ifTrue: [value _ self class maxOrientations].	self orientation: value! !!NsBlankGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:09'!hasForms	^ true! !!NsBlankGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:35'!initializeActiveForms	| orientationForm |	self activeCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	self activeCachedForms at: 1 put: orientationForm! !!NsBlankGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:34'!initializeIdleForms	| orientationForm |	self idleCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	self idleCachedForms at: 1 put: orientationForm! !!NsBlankGameTile class methodsFor: 'constants' stamp: 'sbw 12/7/2003 14:30'!partCode	^2! !!NsBlankGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:40'!tileName	^ 'Empty'! !!NsBlankGameTile methodsFor: 'testing' stamp: 'sbw 10/26/2003 08:04'!canBeActive	^ false! !!NsNoConnectionsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:19'!maxConnections	^ 0! !!NsNoConnectionsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:20'!maxOrientations	^ 1! !!NsDestinationGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:10'!hasForms	^ true! !!NsDestinationGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:35'!initializeActiveForms	| orientationForm line |	self activeCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self eastLineSegment: true.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self boxColor		innerColor: self activeLineColor.	self activeCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self northLineSegment: true.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self boxColor		innerColor: self activeLineColor.	self activeCachedForms at: 2 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self westLineSegment: true.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self boxColor		innerColor: self activeLineColor.	self activeCachedForms at: 3 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self southLineSegment: true.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self boxColor		innerColor: self activeLineColor.	self activeCachedForms at: 4 put: orientationForm! !!NsDestinationGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:34'!initializeIdleForms	| orientationForm line |	self idleCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self eastLineSegment: false.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self boxColor		innerColor: self idleLineColor.	self idleCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self northLineSegment: false.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self boxColor		innerColor: self idleLineColor.	self idleCachedForms at: 2 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self westLineSegment: false.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self boxColor		innerColor: self idleLineColor.	self idleCachedForms at: 3 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self southLineSegment: false.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self boxColor		innerColor: self idleLineColor.	self idleCachedForms at: 4 put: orientationForm! !!NsDestinationGameTile class methodsFor: 'constants' stamp: 'sbw 12/7/2003 14:30'!partCode	^3! !!NsDestinationGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:40'!tileName	^ 'Destination'! !!NsOneConnectionGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 21:07'!fillBoxesOn: aForm outerColor: outerColor innerColor: innerColor 	| rect |	rect _ (0 @ 0 extent: aForm extent)				insetBy: 7.	aForm fill: rect fillColor: outerColor.	rect _ (0 @ 0 extent: aForm extent)				insetBy: 11.	aForm fill: rect fillColor: innerColor! !!NsOneConnectionGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:21'!maxConnections	^ 1! !!NsOneConnectionGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:21'!maxOrientations	^ 4! !!NsOneConnectionGameTile methodsFor: 'neighbors' stamp: 'sbw 10/17/2003 14:33'!neighborDeltas	| delta |	delta _ 1 @ 0.	self orientation = 2		ifTrue: [delta _ 0 @ -1].	self orientation = 3		ifTrue: [delta _ -1 @ 0].	self orientation = 4		ifTrue: [delta _ 0 @ 1].	^ OrderedCollection with: delta! !!NsSourceGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:09'!hasForms	^ true! !!NsSourceGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:35'!initializeActiveForms	| orientationForm line |	self activeCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self eastLineSegment: true.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self activeLineColor		innerColor: self boxColor.	self activeCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self northLineSegment: true.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self activeLineColor		innerColor: self boxColor.	self activeCachedForms at: 2 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self westLineSegment: true.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self activeLineColor		innerColor: self boxColor.	self activeCachedForms at: 3 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self southLineSegment: true.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self activeLineColor		innerColor: self boxColor.	self activeCachedForms at: 4 put: orientationForm! !!NsSourceGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:34'!initializeIdleForms	| orientationForm line |	self idleCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self eastLineSegment: false.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self idleLineColor		innerColor: self boxColor.	self idleCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self northLineSegment: false.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self idleLineColor		innerColor: self boxColor.	self idleCachedForms at: 2 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self westLineSegment: false.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self idleLineColor		innerColor: self boxColor.	self idleCachedForms at: 3 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self southLineSegment: false.	line displayOn: orientationForm.	self		fillBoxesOn: orientationForm		outerColor: self idleLineColor		innerColor: self boxColor.	self idleCachedForms at: 4 put: orientationForm! !!NsSourceGameTile class methodsFor: 'constants' stamp: 'sbw 12/7/2003 14:31'!partCode	^4! !!NsSourceGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:41'!tileName	^ 'Source'! !!NsSourceGameTile methodsFor: 'accessing' stamp: 'sbw 10/16/2003 21:06'!active	^true! !!NsSourceGameTile methodsFor: 'accessing' stamp: 'sbw 10/17/2003 14:12'!active: aBoolean 	"ignored"	active _ true! !!NsSourceGameTile methodsFor: 'testing' stamp: 'sbw 10/17/2003 14:04'!isSource	^true! !!NsTeeGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:10'!hasForms	^ true! !!NsTeeGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:36'!initializeActiveForms	| orientationForm line |	self activeCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self eastLineSegment: true.	line displayOn: orientationForm.	line _ self northLineSegment: true.	line displayOn: orientationForm.	line _ self southLineSegment: true.	line displayOn: orientationForm.	self activeCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self northLineSegment: true.	line displayOn: orientationForm.	line _ self westLineSegment: true.	line displayOn: orientationForm.	line _ self eastLineSegment: true.	line displayOn: orientationForm.	self activeCachedForms at: 2 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self westLineSegment: true.	line displayOn: orientationForm.	line _ self southLineSegment: true.	line displayOn: orientationForm.	line _ self northLineSegment: true.	line displayOn: orientationForm.	self activeCachedForms at: 3 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self southLineSegment: true.	line displayOn: orientationForm.	line _ self eastLineSegment: true.	line displayOn: orientationForm.	line _ self westLineSegment: true.	line displayOn: orientationForm.	self activeCachedForms at: 4 put: orientationForm! !!NsTeeGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:34'!initializeIdleForms	| orientationForm line |	self idleCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self eastLineSegment: false.	line displayOn: orientationForm.	line _ self northLineSegment: false.	line displayOn: orientationForm.	line _ self southLineSegment: false.	line displayOn: orientationForm.	self idleCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self northLineSegment: false.	line displayOn: orientationForm.	line _ self westLineSegment: false.	line displayOn: orientationForm.	line _ self eastLineSegment: false.	line displayOn: orientationForm.	self idleCachedForms at: 2 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self westLineSegment: false.	line displayOn: orientationForm.	line _ self southLineSegment: false.	line displayOn: orientationForm.	line _ self northLineSegment: false.	line displayOn: orientationForm.	self idleCachedForms at: 3 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self southLineSegment: false.	line displayOn: orientationForm.	line _ self eastLineSegment: false.	line displayOn: orientationForm.	line _ self westLineSegment: false.	line displayOn: orientationForm.	self idleCachedForms at: 4 put: orientationForm! !!NsTeeGameTile class methodsFor: 'constants' stamp: 'sbw 12/7/2003 14:31'!partCode	^5! !!NsTeeGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:41'!tileName	^ 'Tee'! !!NsTeeGameTile methodsFor: 'neighbors' stamp: 'sbw 10/17/2003 14:35'!neighborDeltas	| delta1 delta2 delta3 |	delta1 _ 0 @ 1.	delta2 _ 1 @ 0.	delta3 _ 0 @ -1.	self orientation = 2		ifTrue: [delta1 _ 1 @ 0.			delta2 _ 0 @ -1.			delta3 _ -1 @ 0].	self orientation = 3		ifTrue: [delta1 _ 0 @ -1.			delta2 _ -1 @ 0.			delta3 _ 0 @ 1].	self orientation = 4		ifTrue: [delta1 _ 0 @ 1.			delta2 _ 1 @ 0.			delta3 _ -1@ 0].	^ OrderedCollection		with: delta1		with: delta2		with: delta3! !!NsThreeConnectionsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:21'!maxConnections	^ 3! !!NsThreeConnectionsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:22'!maxOrientations	^ 4! !!NsCornerGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:10'!hasForms	^ true! !!NsCornerGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:36'!initializeActiveForms	| orientationForm line |	self activeCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self eastLineSegment: true.	line displayOn: orientationForm.	line _ self northLineSegment: true.	line displayOn: orientationForm.	self activeCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self northLineSegment: true.	line displayOn: orientationForm.	line _ self westLineSegment: true.	line displayOn: orientationForm.	self activeCachedForms at: 2 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self westLineSegment: true.	line displayOn: orientationForm.	line _ self southLineSegment: true.	line displayOn: orientationForm.	self activeCachedForms at: 3 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self southLineSegment: true.	line displayOn: orientationForm.	line _ self eastLineSegment: true.	line displayOn: orientationForm.	self activeCachedForms at: 4 put: orientationForm! !!NsCornerGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:35'!initializeIdleForms	| orientationForm line |	self idleCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self eastLineSegment: false.	line displayOn: orientationForm.	line _ self northLineSegment: false.	line displayOn: orientationForm.	self idleCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self northLineSegment: false.	line displayOn: orientationForm.	line _ self westLineSegment: false.	line displayOn: orientationForm.	self idleCachedForms at: 2 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self westLineSegment: false.	line displayOn: orientationForm.	line _ self southLineSegment: false.	line displayOn: orientationForm.	self idleCachedForms at: 3 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self southLineSegment: false.	line displayOn: orientationForm.	line _ self eastLineSegment: false.	line displayOn: orientationForm.	self idleCachedForms at: 4 put: orientationForm! !!NsCornerGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 11:46'!maxOrientations	^ 4! !!NsCornerGameTile class methodsFor: 'constants' stamp: 'sbw 12/7/2003 14:31'!partCode	^6! !!NsCornerGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:41'!tileName	^ 'Corner'! !!NsCornerGameTile methodsFor: 'neighbors' stamp: 'sbw 10/17/2003 15:11'!neighborDeltas	| delta1 delta2 |	delta1 _ 1 @ 0.	delta2 _ 0 @ -1.	self orientation = 2		ifTrue: [delta1 _ -1 @ 0.			delta2 _ 0 @ -1].	self orientation = 3		ifTrue: [delta1 _ 0 @ 1.			delta2 _ -1 @ 0].	self orientation = 4		ifTrue: [delta1 _ 0 @ 1.			delta2 _ 1 @ 0].	^ OrderedCollection with: delta1 with: delta2! !!NsLineGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 10:10'!hasForms	^ true! !!NsLineGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:36'!initializeActiveForms	| orientationForm line |	self activeCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self fullHorizontalMiddleLine: true.	line displayOn: orientationForm.	self activeCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self fullVerticalMiddleLine: true.	line displayOn: orientationForm.	self activeCachedForms at: 2 put: orientationForm! !!NsLineGameTile class methodsFor: 'cached forms' stamp: 'sbw 10/16/2003 11:35'!initializeIdleForms	| orientationForm line |	self idleCachedForms: Dictionary new.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self fullHorizontalMiddleLine: false.	line displayOn: orientationForm.	self idleCachedForms at: 1 put: orientationForm.	orientationForm _ Form extent: self extent depth: self formDepth.	orientationForm fillColor: self backgroundColor.	line _ self fullVerticalMiddleLine: false.	line displayOn: orientationForm.	self idleCachedForms at: 2 put: orientationForm! !!NsLineGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 11:46'!maxOrientations	^ 2! !!NsLineGameTile class methodsFor: 'constants' stamp: 'sbw 12/7/2003 14:31'!partCode	^7! !!NsLineGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:41'!tileName	^ 'Line'! !!NsLineGameTile methodsFor: 'neighbors' stamp: 'sbw 10/17/2003 14:33'!neighborDeltas	| delta1 delta2 |	delta1 _ 1 @ 0.	delta2 _ -1 @ 0.	self orientation = 2		ifTrue: [delta1 _ 0 @ -1.			delta2 _ 0 @ 1].	^ OrderedCollection with: delta1 with: delta2! !!NsTwoConnectionsGameTile class methodsFor: 'constants' stamp: 'sbw 10/16/2003 10:22'!maxConnections	^ 2! !!NsModel class methodsFor: 'example' stamp: 'sbw 10/16/2003 21:55'!example: aPoint	"NsModel example: 5@6"	| model |	model _ self new: aPoint.	model renderCells displayAt: 10 @ 10! !!NsModel class methodsFor: 'instance creation' stamp: 'sbw 10/18/2003 10:33'!new: anExtent 	"NsModel new: 5@5"	| model |	model _ self new.	model initialize: anExtent.	^ model! !!NsModel class methodsFor: 'instance creation' stamp: 'sbw 10/18/2003 10:31'!new: anExtent gameMorph: aMorph	"NsModel new: 5@5"	| model |	model _ self new.	model initialize: anExtent gameMorph: aMorph.	^ model! !!NsModel class methodsFor: 'randomization' stamp: 'sbw 10/16/2003 14:32'!randomNumberGenerator	RandomNumberGenerator isNil ifTrue: [		RandomNumberGenerator _ Random new.		RandomNumberGenerator seed: Time totalSeconds].	^RandomNumberGenerator! !!NsModel class methodsFor: 'randomization' stamp: 'sbw 12/14/2003 12:37'!reSeed	self randomNumberGenerator seed: Time totalSeconds! !!NsModel class methodsFor: 'randomization' stamp: 'sbw 12/14/2003 12:41'!startUp	self reSeed! !!NsModel methodsFor: 'testing' stamp: 'sbw 10/26/2003 08:05'!allTilesActive	^ (self pieces		select: [:each | each active]) size = (self pieces select: [:each | each canBeActive]) size! !!NsModel methodsFor: 'testing' stamp: 'sbw 10/18/2003 10:17'!circuitComplete	^(self destinationAddresses reject: [:addr | (self pieces at: addr) active]) isEmpty! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:08'!currentCount	^currentCount! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:08'!currentCount: int	currentCount _ int! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:12'!destinationAddresses	^destinationAddresses! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:12'!destinationAddresses: aColl	destinationAddresses _ aColl! !!NsModel methodsFor: 'testing' stamp: 'sbw 10/17/2003 15:02'!doesNextAddress: nextAddress pointBackTo: currentAddress 	| piece deltas goodDeltas calculatedAddress |	piece _ self pieces at: nextAddress.	deltas _ piece neighborDeltas.	goodDeltas _ deltas				select: [:delta | 					calculatedAddress _ nextAddress + delta.					(self isAddressValid: calculatedAddress)						and: [calculatedAddress = currentAddress]].	^ goodDeltas notEmpty! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:12'!extent	^extent! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:12'!extent: aPoint	extent _ aPoint! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:29'!gameMorph	^gameMorph! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:29'!gameMorph: aMorph	gameMorph _ aMorph! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 13:10'!initialPositions	^initialPositions! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 13:10'!initialPositions: aCollection 	initialPositions _ aCollection! !!NsModel methodsFor: 'initialize' stamp: 'sbw 11/15/2003 06:27'!initialize: anExtent gameMorph: aMorph 	self gameMorph: aMorph.	self extent: anExtent.	self pieces: nil.	self maxConnected: 0.	self currentCount: 0.	self moves: 0.	self destinationAddresses: OrderedCollection new.	self populateWithRandomCells! !!NsModel methodsFor: 'initialize' stamp: 'sbw 10/16/2003 14:20'!initializePieces	self pieces: Dictionary new! !!NsModel methodsFor: 'testing' stamp: 'sbw 10/17/2003 14:39'!isAddressValid: aPoint	aPoint x = 0 ifTrue: [^false].	aPoint y = 0 ifTrue: [^false].	aPoint x > self extent x ifTrue: [^false].	aPoint y > self extent y ifTrue: [^false].	^true! !!NsModel methodsFor: 'persist' stamp: 'sbw 12/7/2003 20:12'!loadPiecesFrom: aStream 	| coll newSize dict lc pc or tile string pair |	aStream reset.	coll _ aStream contents findTokens: self tokenChar.	string _ coll removeFirst.	pair _ string findTokens: $@.	newSize _ Point x: pair first asInteger y: pair last asInteger.	dict _ Dictionary new.	[coll isEmpty]		whileFalse: [string _ coll removeFirst.			pair _ string findTokens: $@.			lc _ Point x: pair first asInteger y: pair last asInteger.			pc _ coll removeFirst asInteger.			or _ coll removeFirst asInteger.			tile _ NsGameTile newTileMatchingPartCode: pc.			tile orientation: or.			dict at: lc put: tile].	^ newSize -> dict! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:08'!maxConnected	^maxConnected! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:06'!maxConnected: int	maxConnected _ int! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:22'!moves	^moves! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/18/2003 10:22'!moves: int	moves _ int! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:20'!pieces	pieces isNil		ifTrue: [self initializePieces].	^ pieces! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:00'!pieces: aCollection	pieces _ aCollection! !!NsModel methodsFor: 'logic' stamp: 'sbw 10/19/2003 10:37'!populateWithRandomCells	| count |	count _ self size // 50.	count < 1		ifTrue: [count _ 1].	^ self populateWithRandomCells: count! !!NsModel methodsFor: 'logic' stamp: 'sbw 10/19/2003 09:51'!populateWithRandomCells: numberOfDestinations 	| howMany address cell |	howMany _ self size.	sourceAddress _ self randomCellAddress.	self pieces at: sourceAddress put: NsSourceGameTile new.	numberOfDestinations		timesRepeat: [address _ self randomUnusedCellAddress.			self destinationAddresses add: address.			self pieces at: address put: NsDestinationGameTile new].	howMany _ howMany - 1 - numberOfDestinations.	howMany		timesRepeat: [address _ self randomUnusedCellAddress.			cell _ self randomCell.			self pieces at: address put: cell].	self initialPositions: Dictionary new.	self pieces		keysDo: [:addr | self initialPositions at: addr put: (self pieces at: addr) deepCopy]! !!NsModel methodsFor: 'logic' stamp: 'sbw 12/7/2003 17:03'!randomCell	| random percentLine percentCorner percentTee percentCross |	percentLine _ 60.	percentCorner _ 40.	percentTee _ 79.	percentCross _ 20.	random _ self class randomNumberGenerator nextInt: 200.	random < percentLine		ifTrue: [^ NsLineGameTile new].	random < (percentLine + percentCorner)		ifTrue: [^ NsCornerGameTile new].	random < (percentLine + percentCorner + percentTee)		ifTrue: [^ NsTeeGameTile new].	random < (percentLine + percentCorner + percentTee + percentCross)		ifTrue: [^ NsCrossGameTile new].	^ NsBlankGameTile new! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:32'!randomCellAddress	| xPos yPos |	xPos _ self class randomNumberGenerator nextInt: self extent x.	yPos _ self class randomNumberGenerator nextInt: self extent y.	^ xPos @ yPos! !!NsModel methodsFor: 'accessing' stamp: 'sbw 10/16/2003 14:45'!randomUnusedCellAddress	| random |	[random _ self randomCellAddress.	self pieces includesKey: random] whileTrue.	^ random! !!NsModel methodsFor: 'drawing' stamp: 'sbw 10/16/2003 15:08'!renderBordersOn: aForm	! !!NsModel methodsFor: 'drawing' stamp: 'sbw 10/16/2003 21:03'!renderCells	| renderForm |	renderForm _ Form extent: self renderFormSize depth: NsGameTile formDepth.	renderForm fillColor: NsGameTile borderColor.	self renderCellsOn: renderForm.	^ renderForm! !!NsModel methodsFor: 'drawing' stamp: 'sbw 10/18/2003 10:07'!renderCellsOn: aForm 	| standardExtent offset location piece |	self update.	standardExtent _ NsGameTile extent.	self pieces		keysDo: [:address | 			offset _ address - 1.			location _ offset * standardExtent.			location _ location + (address * NsGameTile borderWidth).			piece _ self pieces at: address.			piece form displayOn: aForm at: location]! !!NsModel methodsFor: 'drawing' stamp: 'sbw 10/16/2003 15:11'!renderFormSize	| basic addX addY |	basic _ self extent * NsGameTile extent.	addX _ (self extent x + 1) * (NsGameTile borderWidth).	addY _ (self extent y + 1) * (NsGameTile borderWidth).	^basic + (addX@addY)! !!NsModel methodsFor: 'events' stamp: 'sbw 12/7/2003 15:16'!restartWith: aMorph 	self restartWith: aMorph usingPositions: self initialPositions! !!NsModel methodsFor: 'events' stamp: 'sbw 12/7/2003 15:15'!restartWith: aMorph usingPositions: dict	dict		keysDo: [:addr | self pieces at: addr put: (dict at: addr) deepCopy].	self currentCount: 0.	self moves: -1.	self updateMoves.	self update.	self renderCellsOn: aMorph form.	aMorph layoutChanged! !!NsModel methodsFor: 'events' stamp: 'sbw 10/17/2003 14:00'!rotateCellLeft: aPoint forMorph: aSketchMorph 	(self pieces at: aPoint) rotateLeft.! !!NsModel methodsFor: 'events' stamp: 'sbw 10/17/2003 14:00'!rotateCellRight: aPoint forMorph: aSketchMorph 	(self pieces at: aPoint) rotateRight.! !!NsModel methodsFor: 'persist' stamp: 'sbw 12/7/2003 14:41'!saveInitialPositionsOn: aStream 	self savePieces: self initialPositions on: aStream! !!NsModel methodsFor: 'persist' stamp: 'sbw 12/7/2003 20:08'!savePiece: pc at: loc on: strm 	strm nextPutAll: loc printString;		 nextPut: self tokenChar;		 nextPutAll: pc class partCode printString;		 nextPut: self tokenChar;		 nextPutAll: pc orientation printString! !!NsModel methodsFor: 'persist' stamp: 'sbw 12/7/2003 19:50'!savePieces: dict on: aStream 	aStream nextPutAll: self extent printString.	dict		keysAndValuesDo: [:k :v | 			aStream nextPut: self tokenChar.			self				savePiece: v				at: k				on: aStream]! !!NsModel methodsFor: 'persist' stamp: 'sbw 12/7/2003 14:50'!savePiecesOn: aStream 	self savePieces: self pieces on: aStream! !!NsModel methodsFor: 'logic' stamp: 'sbw 10/19/2003 09:51'!size	^self extent x * self extent y! !!NsModel methodsFor: 'persist' stamp: 'sbw 12/7/2003 19:48'!tokenChar	^$.! !!NsModel methodsFor: 'events' stamp: 'sbw 11/15/2003 06:26'!update	self updateActiveStates.	self currentCount: (self pieces			select: [:each | each active]) size - 1.	self currentCount > self maxConnected		ifTrue: [self maxConnected: self currentCount].	self updateCounters! !!NsModel methodsFor: 'events' stamp: 'sbw 10/17/2003 15:05'!updateActiveStates	| sourcePieceAddress eachPiece |	sourcePieceAddress _ self pieces keys				detect: [:address | (self pieces at: address) isSource]				ifNone: [].	self pieces keys		do: [:address | 			eachPiece _ self pieces at: address.			eachPiece active: false].	"The source will always answer true to active."	self updateActiveStatesForNeighborsAt: sourcePieceAddress! !!NsModel methodsFor: 'events' stamp: 'sbw 10/17/2003 14:57'!updateActiveStatesForNeighborsAt: address	| rootPiece deltas nextAddress nextPiece |	rootPiece _ self pieces at: address.	rootPiece active		ifFalse: [^ self].	deltas _ rootPiece neighborDeltas.	deltas		do: [:delta | 			nextAddress _ address + delta.			(self isAddressValid: nextAddress)				ifTrue: [nextPiece _ self pieces at: nextAddress.					nextPiece active						ifFalse: [(self doesNextAddress: nextAddress pointBackTo: address)								ifTrue: [nextPiece active: true.									self updateActiveStatesForNeighborsAt: nextAddress]]]]! !!NsModel methodsFor: 'events' stamp: 'sbw 11/15/2003 06:23'!updateCounters	self gameMorph isNil		ifFalse: [self gameMorph updateCounters]! !!NsModel methodsFor: 'events' stamp: 'sbw 11/15/2003 06:23'!updateMoves	self moves: self moves + 1.	self updateCounters! !!HandMorph methodsFor: '*nsTileGame-objects from disk' stamp: 'sbw 11/8/2003 07:06' prior: 51333524!objectForDataStream: refStrm 	"I am about to be written on an object file. Write a path to me in the 	other system instead."	| dp |	refStrm project isNil ifFalse: [(refStrm project world hands includes: self)		ifTrue: [^ self]].	"owned by the project"	dp _ DiskProxy				global: #World				selector: #primaryHand				args: #().	refStrm replace: self with: dp.	^ dp"Note, when this file is loaded in an MVC project, this will return nil. 	The MenuItemMorph that has this in a field will have that item not 	work. Maybe warn the user at load time?"! !!NsGameHelpWindow class methodsFor: 'instructions' stamp: 'sbw 1/4/2005 22:25'!compressedEncodedInstructions	^ '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w8FRWy6CU1BItFTpCohqlFqq7KXlpXh3HuXpKggoolJ2FZNot81iLaK3FVBZkB5Yy+JzdMqOMih3em1a4aN1BcfiSJkjx/ZDJNqHhroMjwklBIef8wo1/rqF/4K8DloUDlunhbXXwh7lrH68DWqDbz2Fw0VlMwL1Vr99AYXpty+gp3Toc0dACi3sujNFiv5a2umt5Df9X8jvdCv5nQ7ID0ug39Y68QJle4XgqJk/6vYK83i7RnV7BUq4tolLHaku1J6nhOu3iw3WSIEXaif5L+32pfBtF2vUNlUI0jZBaC2Fb7vYB7UDv6O2rRS+7WJ5r4O4tjYZ8KXwbRc7HIepWoqwtlL4tovlvXTXaCny20rh2y62STtcvR6fadvFrtUOV0/h2y6W++ITWqk+bSOFb7vYoCdxeEtL8WBbKbTtYoOYFL/XUtzeVgptu9igf+Dqdi3FkLZS+LaLjcVhkJbilbZS+LaLHawero6VbrtYFCN4VFtbavhS+LaL5Y0Wpra1XawvhW+7WLe6Z6xM0b2tFBx5Bg7bcPC1R++2UnDkpSprCP5GS7HEf7OEeWqHDf6aN8XVb5bg1+VlwpXKXgPEXegQs4wOsZmtbpbQH/u/flGNQ5PfHgSc66L/7fshBMf05rrxIdifC5+XfPunLwT99IWgf10IAi0dw7BuxOFmHO7BIR6HHBycOMzGYQMOL+KwF4d3cfgWB6Hbd0B+t+wbdd+B4KgudLi7myTk/5X7DrQLNAdXmIcUbfUzB79nHlKtutAH373vx9sy8O++LQO/20apk/abRW3NE0ZRU/14hKiueswkqiofFRXl24zC69kSKcq9WzmkquZR4fZu6iamlm8wiqneTUbhnLoeh40RorSMwpxl60yi1LVWOJxNRlFS2hAhih31BlFcurKbsDtWGEWhfaVJFBStELbC5UaRX7DMKKy2pb4rk8jLXyIs1sVGkZu3yCzy8xZRuGWhWeTlLqCw7HkDRU7WXJE9ZY7IypwtpmTMEpmTZ9JvBj2cI3KyZ4r0tCo+W3Jniwmp5SI7a7qYkllrFJMnVUbyB//T08r5o/RpaW6jmDhxqhEAmAGAGQAYtNu7RU3Vk1z5cs8jYqp7MwBA/UUZaYlcnnXC5d4gUSgtW2dAqJGCNhkAilGC4nCtN4nikiaCotEo7CUN3UVR8Wr6rQIa9FtBSK02AikTQBJFJQRNYfEyA54ZEZFxMwI3I4Az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'! !!NsGameHelpWindow class methodsFor: 'instructions' stamp: 'sbw 1/4/2005 22:20'!convertSavedMorphFile: fileName 	"Save the BookMorph, compress it in FileList and then copy the file  	name (path) for this method. Copy the ASCII text into the  	#compressedEncodedInstructions method."	| fileStream encoded |	fileStream _ FileStream oldFileNamed: fileName.	encoded _ Base64MimeConverter mimeEncode: fileStream.	fileStream close.	encoded contents openInWorkspaceWithTitle: 'Copy this to #compressedEncodedInstructions'! !!NsGameHelpWindow class methodsFor: 'as yet unclassified' stamp: 'sbw 6/13/2004 17:42'!includeInNewMorphMenu	^false! !!NsGameHelpWindow class methodsFor: 'instructions' stamp: 'sbw 6/13/2004 18:06'!instructions	| encodedTutorial zippedString data rwStream |	encodedTutorial _ self compressedEncodedInstructions.	zippedString _ Base64MimeConverter mimeDecode: encodedTutorial as: String.	data _ zippedString unzipped.	rwStream _ RWBinaryOrTextStream with: data.	rwStream reset; fileInAnnouncing: 'Building instructions...'.	^ SmartRefStream scannedObject! !!NsGameHelpWindow class methodsFor: 'instructions' stamp: 'sbw 1/4/2005 22:45'!modifyHelpBookMorph: aBookMorph	aBookMorph configureForKids.	aBookMorph showPageControls: {		#spacer.		#variableSpacer.		{'previous page'. 		#previousPage.			'Previous page' translated}.		#variableSpacer.		{'next page'.		#nextPage.				'Next page' translated}.		#spacer.		#variableSpacer.		}! !!NsGameHelpWindow class methodsFor: 'instructions' stamp: 'sbw 1/4/2005 22:33'!openHelpWindow	"NsGameHelpWindow openHelpWindow"	| topView morph |	topView _ self labelled: 'NsGame Instructions'.	morph _ self instructions.	topView		addMorph: morph		frame: (0 @ 0 corner: 1 @ 1).	topView customizeForHelp.	morph borderColor: Color transparent;		 borderWidth: 0.	topView openInWorld.	topView extent: 505@475.	self modifyHelpBookMorph: morph! !!NsGameHelpWindow methodsFor: 'as yet unclassified' stamp: 'sbw 1/4/2005 22:30'!customizeForHelp	self		setWindowColor: (Color				r: 0.603				g: 0.603				b: 0.85).	self removeMenuBox; removeExpandBox; removeCollapseBox.! !!NsGameHelpWindow methodsFor: 'as yet unclassified' stamp: 'sbw 4/24/2004 20:49'!removeCollapseBox	collapseBox		ifNotNil: [collapseBox delete.			collapseBox := nil]! !!NsGameHelpWindow methodsFor: 'as yet unclassified' stamp: 'sbw 4/24/2004 20:49'!removeExpandBox	expandBox		ifNotNil: [expandBox delete.			expandBox := nil]! !"NsTileGame"!self fileInMonticelloZipVersionNamed: 'Games-Sokoban-sbw.9.mcz'.self fileInMonticelloZipVersionNamed: 'Morphic-Games-asm.1.mcz'.self fileInMonticelloZipVersionNamed: 'NsTileGame-sbw.17.mcz'.!----End fileIn of a stream----!----SNAPSHOT----{17 March 2011 . 3:08:34 pm} Squeak4.1.image priorSource: 684365!Billete removeSelector: #mouseUp:!Billete removeSelector: #mouseStillDown:!Billete removeSelector: #mouseMoveWhileButtonUp:!Billete removeSelector: #mouseMoveWhileButtonDown:!Billete removeSelector: #mouseLeaveDragging:!Billete removeSelector: #mouseDown:!Billete removeSelector: #initialize!Billete removeSelector: #handlesMouseOverDragging:!Billete removeSelector: #handlesMouseDown:!Billete removeSelector: #firstClickTimedOut:!Billete removeSelector: #doubleClick:!Billete removeSelector: #click:!!Billete methodsFor: 'nil' stamp: 'agb 3/17/2011 15:09'!handlesMouseDown: evt	^ true! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:10'!mouseDown: evt	evt hand waitForClicksOrDrag: self event: evt selectors: { #click:. #doubleClick:. #firstClickTimedOut:. nil} threshold: 5! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:11'!firstClickTimedOut: evt evt hand grabMorph: self.! !----SNAPSHOT----{17 March 2011 . 3:11:03 pm} Squeak4.1.image priorSource: 1265446!billete _ Billete new.!!Billete methodsFor: 'iniciales' stamp: 'agb 3/17/2011 15:11'!initializesuper initialize.self extent:180@76.self openInWorld.! !billete _ Billete new.!a := EllipseMorph new openInWorld.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:13'!justDroppedInto: newOwner event: evt	(newOwner isKindOf: EllipseMorph)		ifFalse: ["Can't drop a card anywhere but on a deck"				self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:13' prior: 34821296!justDroppedInto: newOwner event: evt	^(newOwner isKindOf: EllipseMorph)		"ifFalse: [self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt·"! !billete _ Billete new.!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:14' prior: 34821598!justDroppedInto: newOwner event: evt	^(newOwner isKindOf: EllipseMorph)	Transcript show:'dentro'.		"ifFalse: [self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt·"! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:14' prior: 34821883!justDroppedInto: newOwner event: evtTranscript show:'dentro'.	^(newOwner isKindOf: EllipseMorph).			"ifFalse: [self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt·"! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:15' prior: 34822170!justDroppedInto: newOwner event: evtTranscript show:(newOwner isKindOf: EllipseMorph)..	^(newOwner isKindOf: EllipseMorph).			"ifFalse: [self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt·"! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:18' prior: 34822458!justDroppedInto: newOwner event: evtTranscript show:(newOwner isKindOf: EllipseMorph).Transcript show:(newOwner asString).	^(newOwner isKindOf: EllipseMorph).			"ifFalse: [self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt·"! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:18' prior: 34822772!justDroppedInto: newOwner event: evtTranscript show:(newOwner isKindOf: EllipseMorph).Transcript show:(newOwner).	^(newOwner isKindOf: EllipseMorph).			"ifFalse: [self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt·"! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:18' prior: 34823122!justDroppedInto: newOwner event: evtTranscript show:(newOwner isKindOf: EllipseMorph).Transcript show:(newOwner).Transcript show: self position.	^(newOwner isKindOf: EllipseMorph).			"ifFalse: [self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt·"! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:20'!doubleClick: evt evt hand grabMorph: self.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:21'!wantsToBeDroppedInto: newOwnerTranscript show:(newOwner isKindOf: EllipseMorph).Transcript show:(newOwner).Transcript show: self position.	^(newOwner isKindOf: EllipseMorph).			"ifFalse: [self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt·"! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:21' prior: 34823463!justDroppedInto: newOwner event: evt	^(newOwner isKindOf: EllipseMorph).			"ifFalse: [self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt·"! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:22' prior: 34823940!wantsToBeDroppedInto: newOwnerTranscript show:(newOwner isKindOf: PasteUpMorph).Transcript show:(newOwner).Transcript show: self position.	^(newOwner isKindOf: EllipseMorph).			"ifFalse: [self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt·"! !a addMorph:billete.!atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:25' prior: 33613681!initialize|b inicial alto ancho|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:ancho@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.self addMorph:pdeposito.self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:28' prior: 34824971!initialize|b inicial alto ancho|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:ancho@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:29' prior: 34826275!initialize|b inicial alto ancho|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self color:(Color r: 0.878 g: 0.878 b: 0.882)."superior"superior:= RectangleMorph new.superior extent:ancho@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:29' prior: 34827664!initialize|b inicial alto ancho|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self openInWorld.! !billete _ Billete new.!atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:29' prior: 34829105!initialize|b inicial alto ancho|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:30' prior: 34830588!initialize|b inicial alto ancho|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 15:30' prior: 34832053!initialize|b inicial alto ancho|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self openInWorld.! !atm_  ATM new.!Smalltalk removeClassNamed: #ATMServiceProvider!lapuesta:= StringMorph new openInWorld.!lapuesta:= StringMorph new openInWorld.!lapuesta extent:100@100.!lapuesta:= StringMorph new openInWorld.!lapuesta font!font_StrikeFont new.!----SNAPSHOT----{17 March 2011 . 3:42:40 pm} Squeak4.1.image priorSource: 1266486!lapuesta:= StringMorph new openInWorld.!lapuesta setWidth:100.!lapuesta fontName:'Sans' size:14.!lapuesta fontName:'Sans' size:18.!lapuesta:= StringMorph new openInWorld.!lapuesta fontName:'Sans' size:36.!lapuesta fontName:'Sans' size:100.!lapuesta fontName:'Sans' size:100.!lapuesta:= StringMorph new openInWorld.!lapuesta fontName:'Sans' size:100.!atm_  ATM new.!lapuesta fontToUse!lapuesta fontName:'Sans' size:8!lapuesta fontName:'Sans' size:10!lapuesta fontName:'Sans' size:8!lapuesta fontName:'Sans' size:20!lapuesta fontName:'Sans' size:220!lapuesta fontName:'Sans' size:22!lapuesta fontName:'Sans' size:20!lapuesta fontName:'Sans' size:16!lapuesta fontName:'Sans' size:18!lapuesta fontName:'Sans' size:18!lapuesta fontName:'Sans' size:20!lapuesta fontName:'Sans' size:22!lapuesta fontName:'Sans' size:20!lapuesta fontName:'Sans' size:18!lapuesta fontName:'Sans' size:20!lapuesta contents:'Bienvenido'.!lapuesta fontName:'Sans' size:20.!!ATM methodsFor: 'nil' stamp: 'agb 3/17/2011 16:00'!print:aString position:aPoint|text|text:= StringMorph new openInWorld.text fontName:'Sans' size:20.text contents:aString.text position:(pantalla position) + aPoint.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:01' prior: 34833585!initialize|b inicial alto ancho|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self print: 'Bienvenidos' position:10@10.self addMorph:pdeposito.self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:02' prior: 34836433!print:aString position:aPoint|text|text:= StringMorph new.text fontName:'Sans' size:20.text contents:aString.text position:(pantalla position) + aPoint.pantalla addMorph:text.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:03' prior: 34836691!initialize|b inicial alto ancho|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self print: 'Bienvenidos' position:10@10.self print: 'Por favor ingrese su numero de cuenta:' position:10@30.self addMorph:pdeposito.self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:04' prior: 34838572!initialize|b inicial alto ancho|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self print: 'Bienvenidos' position:10@10.self print: 'Por favor ingrese su numero de cuenta:' position:10@40.self addMorph:pdeposito.self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:04' prior: 34838285!print:aString position:aPoint|text|text:= StringMorph new.text fontName:'Sans' size:18.text contents:aString.text position:(pantalla position) + aPoint.pantalla addMorph:text.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:15'!read:aPoint|text|text:= StringMorph new.text fontName:'Sans' size:18.text position:(pantalla position) + aPoint.! !RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter estado pdeposito pretiro puedeingresar temp'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:22' prior: 34842169!read:aPoint|text|puedeingresar:=true.text:= StringMorph new.text fontName:'Sans' size:18.text position:(pantalla position) + aPoint.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:23' prior: 34842582!read:aPointpuedeingresar:=true.temp:= StringMorph new.temp fontName:'Sans' size:18.temp position:(pantalla position) + aPoint.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:24' prior: 33581346!keyStroke: anEvent  Transcript show: (anEvent keyValue)-48.temp contents:temp contents + ((anEvent keyValue) asString)! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:24' prior: 34843029!keyStroke: anEvent  Transcript show: (anEvent keyValue)-48.temp contents:temp contents + ((anEvent keyValue) asString).! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:26' prior: 34840235!initialize|b inicial alto ancho|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self print: 'Bienvenidos' position:10@10.self print: 'Por favor ingrese su numero de cuenta:' position:10@40.self read:10@50.self addMorph:pdeposito.self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:27' prior: 34842809!read:aPointpuedeingresar:=true.temp:= StringMorph new.temp contents:'hola'.temp fontName:'Sans' size:18.temp position:(pantalla position) + aPoint.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:27' prior: 34843238!keyStroke: anEvent  Transcript show: (anEvent keyValue)-48.temp contents:temp contents, ((anEvent keyValue) asString).! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:28' prior: 34845128!read:aPointpuedeingresar:=true.temp:= StringMorph new.temp contents:'hola'.temp fontName:'Sans' size:18.temp position:(pantalla position) + aPoint.pantalla addMorph:temp.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:29' prior: 34845370!keyStroke: anEvent  Transcript show: (anEvent keyValue)-48.temp contents:temp contents, ((anEvent keyValue) asString).! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:30' prior: 34845879!keyStroke: anEvent puedeingresar ifFalse:[^nil]. Transcript show: (anEvent keyValue)-48.temp contents:temp contents, ((anEvent keyValue) asString).! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:30' prior: 34846089!keyStroke: anEvent puedeingresar ifFalse:[^nil].Transcript show: (anEvent keyValue)-48.temp contents:temp contents, ((anEvent keyValue)-48) asString.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:32' prior: 34846328!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor>9) | (valor<0) ifTrue:[^nil].Transcript show:valor.temp contents:temp contents, ((anEvent keyValue)-48) asString.! !atm_  ATM new.!atm_  ATM new.!!ATM methodsFor: 'nil' stamp: 'agb 3/17/2011 16:45'!pruebaRectangleMorph new openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:45' prior: 34843448!initialize|b inicial alto ancho p|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self print: 'Bienvenidos' position:10@10.self print: 'Por favor ingrese su numero de cuenta:' position:10@40.self read:10@50.self addMorph:pdeposito.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:45' prior: 34847014!initialize|b inicial alto ancho p|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self print: 'Bienvenidos' position:10@10.self print: 'Por favor ingrese su numero de cuenta:' position:10@40.self read:10@50.self addMorph:pdeposito.p:= self prueba.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:45' prior: 34848679!initialize|b inicial alto ancho p|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self print: 'Bienvenidos' position:10@10.self print: 'Por favor ingrese su numero de cuenta:' position:10@40.self read:10@50.self addMorph:pdeposito.p:= self prueba.p.self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 16:45' prior: 34850361!initialize|b inicial alto ancho p|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self print: 'Bienvenidos' position:10@10.self print: 'Por favor ingrese su numero de cuenta:' position:10@40.self read:10@50.self addMorph:pdeposito.p:= self prueba.self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 17:08' prior: 34852063!initialize|b inicial alto ancho p|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self print: 'Bienvenidos' position:10@10.self print: 'Por favor ingrese su numero de cuenta:' position:10@40.self read:10@50.self addMorph:pdeposito.p:= 'prueba'.self p.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 17:11' prior: 34853762!initialize|b inicial alto ancho p|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self print: 'Bienvenidos' position:10@10.self print: 'Por favor ingrese su numero de cuenta:' position:10@40.self read:10@50.self addMorph:pdeposito.self openInWorld.! !atm_  ATM new.!atm_  ATM new.!----QUIT----{17 March 2011 . 5:33:06 pm} Squeak4.1.image priorSource: 1280861!----STARTUP----{17 March 2011 . 11:24:08 pm} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 23:25' prior: 34846586!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.Transcript show:valor.temp contents:temp contents, ((anEvent keyValue)-48) asString.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 23:29' prior: 34857348!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor=- 35)ifTrue:[		puedeingresar:=false.	].(valor>9) | (valor<0) ifTrue:[^nil].Transcript show:valor.temp contents:temp contents, ((anEvent keyValue)-48) asString.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 23:29' prior: 34857628!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= 35)ifTrue:[		puedeingresar:=false.	].(valor>9) | (valor<0) ifTrue:[^nil].Transcript show:valor.temp contents:temp contents, ((anEvent keyValue)-48) asString.! !4-8!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 23:30' prior: 34857993!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		puedeingresar:=false.	].(valor>9) | (valor<0) ifTrue:[^nil].Transcript show:valor.temp contents:temp contents, ((anEvent keyValue)-48) asString.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 23:30' prior: 34858346!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[				puedeingresar:=false.	].(valor>9) | (valor<0) ifTrue:[^nil].Transcript show:valor.temp contents:temp contents, ((anEvent keyValue)-48) asString.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 23:31' prior: 34858711!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[				puedeingresar:=false.	].(valor>9) | (valor<0) ifTrue:[^nil].Transcript show:valor.temp contents:temp contents, ((anEvent keyValue)-48) asString.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 23:33' prior: 34859062!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		1=accion ifTrue:[].		puedeingresar:=false.	].(valor>9) | (valor<0) ifTrue:[^nil].Transcript show:valor.temp contents:temp contents, ((anEvent keyValue)-48) asString.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 23:33' prior: 34859413!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		1=accion ifTrue:[self pedirPin].		puedeingresar:=false.	].(valor>9) | (valor<0) ifTrue:[^nil].Transcript show:valor.temp contents:temp contents, ((anEvent keyValue)-48) asString.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 23:34'!pedirPin! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 23:34'!pedirNumeroCuenta! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 23:34' prior: 34855449!initialize|b inicial alto ancho p|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 23:36' prior: 34860231!pedirNumeroCuentaself print: 'Bienvenidos' position:10@10.self print: 'Por favor ingrese su numero de cuenta:' position:10@40.self read:10@50.self addMorph:pdeposito.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 23:36' prior: 34861873!pedirNumeroCuentaself print: 'Bienvenidos' position:10@10.self print: 'Por favor ingrese su numero de cuenta:' position:10@40.self read:10@50.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 23:36' prior: 34860337!initialize|b inicial alto ancho p|estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 23:37' prior: 34862132!pedirNumeroCuentaself print: 'Bienvenidos' position:10@10.self print: 'Por favor ingrese su numero de cuenta:' position:10@40.self read:10@50.accion:=1.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 23:38' prior: 34860150!pedirPinself print: 'Ingrese su PIN:' position:10@60.self read:10@70.accion:=1.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/17/2011 23:38' prior: 34864190!pedirPinself print: 'Ingrese su PIN:' position:10@60.self read:10@70.accion:=2.! !atm_  ATM new.!atm_  ATM new.!atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 00:48' prior: 34859783!keyStroke: anEvent |valor|Transcript show:puedeingresar.puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		1=accion ifTrue:[self pedirPin].		puedeingresar:=false.	].(valor>9) | (valor<0) ifTrue:[^nil].Transcript show:valor.temp contents:temp contents, ((anEvent keyValue)-48) asString.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 00:50'!limpiarPantallapantalla removeAllMorphs.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 00:58' prior: 34845596!read:aPointpuedeingresar:=true.temp:= StringMorph new.temp contents:puedeingresar.temp fontName:'Sans' size:18.temp position:(pantalla position) + aPoint.pantalla addMorph:temp.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 00:58' prior: 34865145!read:aPointpuedeingresar:=true.temp:= StringMorph new.temp contents:puedeingresar asString.temp fontName:'Sans' size:18.temp position:(pantalla position) + aPoint.pantalla addMorph:temp.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 00:59' prior: 34864361!pedirPinself print: 'Ingrese su PIN:' position:10@60.self read:10@70.! !atm_  ATM new.!atm_  ATM new.!atm_  ATM new.!atm hasFocus.!atm hasFocus.!atm hasFocus.!atm_  ATM new.!ATM removeSelector: #keyUp:!ATM removeSelector: #keyDown:!atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:13' prior: 34864583!keyStroke: anEvent |valor|Transcript show:puedeingresar.valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		1=accion ifTrue:[self pedirPin].		puedeingresar:=false.	].(valor>9) | (valor<0) ifTrue:[^nil].Transcript show:valor.temp contents:temp contents, ((anEvent keyValue)-48) asString.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:14' prior: 34866072!keyStroke: anEvent |valor|Transcript show:puedeingresar.valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		1=accion ifTrue:[self pedirPin].		puedeingresar:=false.	].(valor>9) | (valor<0) ifTrue:[^nil].Transcript show:valor.temp contents:temp contents, ((anEvent keyValue)-48) asString.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:15' prior: 34866474!keyStroke: anEvent |valor|Transcript show:puedeingresar.valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		puedeingresar:=false.		1=accion ifTrue:[self pedirPin].	].(valor>9) | (valor<0) ifTrue:[^nil].Transcript show:valor.temp contents:temp contents, ((anEvent keyValue)-48) asString.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:15' prior: 34866859!keyStroke: anEvent |valor|Transcript show:puedeingresar.puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		puedeingresar:=false.		1=accion ifTrue:[self pedirPin].	].(valor>9) | (valor<0) ifTrue:[^nil].Transcript show:valor.temp contents:temp contents, ((anEvent keyValue)-48) asString.! !atm_  ATM new.!Object subclass: #Usuario	instanceVariableNames: 'codigo pin nombre monto'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!atm_  ATM new.!Object subclass: #Usuario	instanceVariableNames: 'cuenta pin nombre monto'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!Usuario methodsFor: 'nil' stamp: 'agb 3/18/2011 01:24'!cuenta:aNumbercuenta:=aNumber! !!Usuario methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:24'!monto:aNumbermonto:=aNumber! !!Usuario methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:25'!pin:aNumberpin:=aNumber! !!Usuario methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:25'!nombre:aStringnombre:=aString! !!Usuario methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:25'!cuenta^cuenta! !!Usuario methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:25'!monto^monto! !!Usuario methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:25'!nombre^nombre! !!Usuario methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:25'!pin^pin! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:26' prior: 33578464!keyboardFocusChange: aBoolean 	aBoolean 		ifTrue: [ Transcript show: 'Got Focus' ]		ifFalse: [ Transcript show: 'Lost Focus']! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:26' prior: 34867244!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		puedeingresar:=false.		1=accion ifTrue:[self pedirPin].	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.! !atm_  ATM new.!RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter estado pdeposito pretiro puedeingresar temp accion usuario'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:28' prior: 34862367!initialize|b inicial alto ancho p|usuario:=Usuario new.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:28' prior: 34869550!initialize|b inicial alto ancho|usuario:=Usuario new.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:28' prior: 34865717!pedirPinself print: 'Ingrese su PIN:' position:10@60.self read:10@70.accion:=2.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:29' prior: 34868951!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		puedeingresar:=false.		1=accion ifTrue:[self pedirPin].		2=accion ifTrue:[self validarUsuario].	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:29'!validarUsuario! !ATM removeSelector: #prueba!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 01:31' prior: 34872731!pedirPinself print: 'Ingrese su PIN:' position:10@60.self read:10@70.accion:=2.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 01:32' prior: 34873412!pedirPinself print: 'Ingrese su PIN:' position:10@60.self read:10@70.accion:=2.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 01:32' prior: 34873575!pedirPinTranscript show: temp contents.self print: 'Ingrese su PIN:' position:10@60.self read:10@70.accion:=2.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 01:33' prior: 34873738!pedirPinself usuario cuenta: temp contents.self print: 'Ingrese su PIN:' position:10@60.self read:10@70.accion:=2.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 01:33' prior: 34873950!pedirPinusuario cuenta: temp contents.self print: 'Ingrese su PIN:' position:10@60.self read:10@70.accion:=2.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 01:34' prior: 34865418!read:aPointpuedeingresar:=true.temp:= StringMorph new.temp fontName:'Sans' size:18.temp position:(pantalla position) + aPoint.pantalla addMorph:temp.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 01:34' prior: 34874360!read:aPointpuedeingresar:=true.temp:= StringMorph new.temp contents:''.temp fontName:'Sans' size:18.temp position:(pantalla position) + aPoint.pantalla addMorph:temp.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:35' prior: 34873287!validarUsuariousuario pin: temp contents.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 01:36' prior: 34874892!validarUsuariousuario pin: temp contents.! !RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter estado pdeposito pretiro puedeingresar temp accion usuario usuarios'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!atm_  ATM new.!!ATM methodsFor: 'datos' stamp: 'agb 3/18/2011 01:40'!cargarDatos|file line|file := FileStream fileNamed: 'usuarios.txt'.[file atEnd] whileFalse:	[		line := file nextLine.		Transcript show:line.	].file close. ! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:41' prior: 34871133!initialize|b inicial alto ancho|self cargarDatos.usuario:=Usuario new.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'datos' stamp: 'agb 3/18/2011 01:41' prior: 34875365!cargarDatos|file line|file := FileStream fileNamed: 'atm\usuarios.txt'.[file atEnd] whileFalse:	[		line := file nextLine.		Transcript show:line.	].file close. ! !atm_  ATM new.!'hola;como;estas' findBetweenSubStrs:';'!----SNAPSHOT----{18 March 2011 . 1:48:07 am} Squeak4.1.image priorSource: 1302630!!ATM methodsFor: 'datos' stamp: 'agb 3/18/2011 01:48' prior: 34877202!cargarDatos|file line datos usuarios usuario|file := FileStream fileNamed: 'atm\usuarios.txt'.usuarios:= OrderedCollection new.[file atEnd] whileFalse:	[		line := file nextLine.		datos:=line findBetweenSubStrs:';'.		usuarios 	].file close. ! !!ATM methodsFor: 'datos' stamp: 'agb 3/18/2011 01:49' prior: 34877588!cargarDatos|file line datos usuarios usuario|file := FileStream fileNamed: 'atm\usuarios.txt'.usuarios:= OrderedCollection new.[file atEnd] whileFalse:	[		line := file nextLine.		datos:=line findBetweenSubStrs:';'.		usuario:= Usuario new.		usuario cuenta:(datos at:1).		usuario pin:(datos at:2).		usuario nombre:(datos at:3).		usuario monto:(datos at:4).		usuarios add:usuario.	].file close. ! !!ATM methodsFor: 'datos' stamp: 'agb 3/18/2011 01:50' prior: 34877913!cargarDatos|file line datos usuarios usuario|file := FileStream fileNamed: 'atm\usuarios.txt'.usuarios:= OrderedCollection new.[file atEnd] whileFalse:	[		line := file nextLine.		datos:=line findBetweenSubStrs:';'.		usuario:= Usuario new.		usuario cuenta:(datos at:1).		usuario pin:(datos at:2).		usuario nombre:(datos at:3).		usuario monto:(datos at:4).		usuarios add:usuario.	].file close. ^usuarios.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:50' prior: 34875617!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:51'!usuarios^usuarios.! !atm_  ATM new.!atm usuarios.!(atm usuarios) at:1.!(atm usuarios) at:2.!(atm usuarios) at:3.!----QUIT----{18 March 2011 . 1:54:55 am} Squeak4.1.image priorSource: 1323000!----STARTUP----{18 March 2011 . 1:55:05 am} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!!ATM methodsFor: 'datos' stamp: 'agb 3/18/2011 01:55'! guardarDatos| dir filename text file|text := 'This is the text file I wanted to write'.filename := 'sample.txt'.dir := FileDirectory default.(dir fileExists: filename) ifTrue:[ dir deleteFileNamed: filename ].filename isEmpty ifTrue:[^self].file := dir newFileNamed: filename.file nextPutAll: text.file close.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 01:56' prior: 34878902!initialize|b inicial alto ancho|usuarios:=self cargarDatos.self guardarDatos.usuario:=Usuario new.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'datos' stamp: 'agb 3/18/2011 01:59' prior: 34880874!guardarDatos| dir filename text file n usuario|n := usuarios size.text := ''.1to: n do:[:i|		usuario:= usuarios at:i.		text:= text, usuario cuenta,';',usuario pin,';',usuario nombre,';',usuario monto,'\n'.	].filename := 'sample.txt'.dir := FileDirectory default.(dir fileExists: filename) ifTrue:[ dir deleteFileNamed: filename ].filename isEmpty ifTrue:[^self].file := dir newFileNamed: filename.file nextPutAll: text.file close.! !atm_  ATM new.!Character enter.!!ATM methodsFor: 'datos' stamp: 'agb 3/18/2011 02:01' prior: 34882913!guardarDatos| dir filename text file n usuario|n := usuarios size.text := ''.1to: n do:[:i|		usuario:= usuarios at:i.		text:= text, usuario cuenta,';',usuario pin,';',usuario nombre,';',usuario monto,(Character enter) asString.	].filename := 'sample.txt'.dir := FileDirectory default.(dir fileExists: filename) ifTrue:[ dir deleteFileNamed: filename ].filename isEmpty ifTrue:[^self].file := dir newFileNamed: filename.file nextPutAll: text.file close.! !atm_  ATM new.!atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 02:03' prior: 34881282!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:06' prior: 34875015!validarUsuario|n|usuario pin: temp contents.n:=usuarios size.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:09' prior: 34885658!validarUsuario|n user|usuario pin: temp contents.n:=usuarios size.1to:n do:[:i|		user:=usuarios at:i.		((user cuenta) = (usuario cuenta))&((user pin) = (usuario pin))		ifTrue:[Transcript show:'Usuario valido.']	].! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:10' prior: 34885804!validarUsuario|n user|usuario pin: temp contents.n:=usuarios size.1to:n do:[:i|		user:=usuarios at:i.		((user cuenta) = (usuario cuenta))&((user pin) = (usuario pin))		ifTrue:[Transcript show:'Usuario valido.']		ifFalse:[Transcript show:'Usuario invalido.']	].! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:11' prior: 34886106!validarUsuario|n user|Transcript show:'hoola'.usuario pin: temp contents.n:=usuarios size.1to:n do:[:i|		user:=usuarios at:i.		((user cuenta) = (usuario cuenta))&((user pin) = (usuario pin))		ifTrue:[Transcript show:'Usuario valido.']		ifFalse:[Transcript show:'Usuario invalido.']	].! !atm_  ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 02:13' prior: 34872902!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		puedeingresar:=false.		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.! !atm_  ATM new.!atm_  ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 02:13' prior: 34886861!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		puedeingresar:=false.		1=accion ifTrue:[self pedirPin].		2=accion ifTrue:[self validarUsuario].	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.! !atm_  ATM new.!atm_  ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 02:14' prior: 34887286!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		puedeingresar:=false.		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:15' prior: 34886473!validarUsuario|n user|usuario pin: temp contents.n:=usuarios size.Transcript show:n.1to:n do:[:i|		user:=usuarios at:i.		((user cuenta) = (usuario cuenta))&((user pin) = (usuario pin))		ifTrue:[Transcript show:'Usuario valido.']		ifFalse:[Transcript show:'Usuario invalido.']	].! !atm_  ATM new.!atm_  ATM new.!atm usuarios!atm_  ATM new.!atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:18'!menuPrincipal! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:18' prior: 34888121!validarUsuario|n user|usuario pin: temp contents.n:=usuarios size.Transcript show:n.1to:n do:[:i|		user:=usuarios at:i.		((user cuenta) = (usuario cuenta))&((user pin) = (usuario pin))		ifTrue:[^self menuPrincipal.].	].! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:19' prior: 34888557!menuPrincipalself limpiarPantalla.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:20' prior: 34863945!pedirNumeroCuentaself limpiarPantalla.self print: 'Bienvenidos' position:10@10.self print: 'Por favor ingrese su numero de cuenta:' position:10@40.self read:10@50.accion:=1.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:20' prior: 34888651!validarUsuario|n user|usuario pin: temp contents.n:=usuarios size.Transcript show:n.1to:n do:[:i|		user:=usuarios at:i.		((user cuenta) = (usuario cuenta))&((user pin) = (usuario pin))		ifTrue:[^self menuPrincipal.].	].^self pedirNumeroCuenta.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:23' prior: 34888960!menuPrincipalself limpiarPantalla.! !----SNAPSHOT----{18 March 2011 . 2:23:56 am} Squeak4.1.image priorSource: 1326187!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:25' prior: 34889720!menuPrincipalself limpiarPantalla.self print:'Menu Principal' position:10@10.self print:'1 - Ver Saldo' position:20@30.self print:'2 - Retirar dinero' position:20@40.self print:'3 - Depositar dinero' position:20@50.self print:'4 - Salir' position:20@60.self print:'Elija una opcion:' position:10@70.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:26' prior: 34889921!menuPrincipalself limpiarPantalla.self print:'Menu Principal' position:10@10.self print:'1 - Ver Saldo' position:30@30.self print:'2 - Retirar dinero' position:30@50.self print:'3 - Depositar dinero' position:30@70.self print:'4 - Salir' position:30@90.self print:'Elija una opcion:' position:10@110.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:26' prior: 34890325!menuPrincipalself limpiarPantalla.self print:'Menu Principal' position:10@10.self print:'1 - Ver Saldo' position:50@30.self print:'2 - Retirar dinero' position:50@50.self print:'3 - Depositar dinero' position:50@70.self print:'4 - Salir' position:50@90.self print:'Elija una opcion:' position:10@110.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 02:27' prior: 34884057!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self menuPrincipal.self openInWorld.! !atm_  ATM new.!atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:27' prior: 34890730!menuPrincipalself limpiarPantalla.self print:'Menu Principal' position:10@30.self print:'1 - Ver Saldo' position:50@50.self print:'2 - Retirar dinero' position:50@70.self print:'3 - Depositar dinero' position:50@90.self print:'4 - Salir' position:50@110.self print:'Elija una opcion:' position:10@130.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:28' prior: 34892757!menuPrincipalself limpiarPantalla.self print:'Menu Principal' position:10@20.self print:'1 - Ver Saldo' position:50@40.self print:'2 - Retirar dinero' position:50@60.self print:'3 - Depositar dinero' position:50@80.self print:'4 - Salir' position:50@100.self print:'Elija una opcion:' position:10@120.! !atm_  ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 02:28' prior: 34891126!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:31' prior: 34893163!menuPrincipalself limpiarPantalla.self print:'Menu Principal' position:10@20.self print:'1 - Ver Saldo' position:50@40.self print:'2 - Retirar dinero' position:50@60.self print:'3 - Depositar dinero' position:50@80.self print:'4 - Salir' position:50@100.self print:'Elija una opcion:' position:10@120.self read:120@120.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:32' prior: 34895195!menuPrincipalself limpiarPantalla.self print:'Menu Principal' position:10@20.self print:'1 - Ver Saldo' position:50@40.self print:'2 - Retirar dinero' position:50@60.self print:'3 - Depositar dinero' position:50@80.self print:'4 - Salir' position:50@100.self print:'Elija una opcion:' position:10@120.self read:110@120.! !atm_  ATM new.!atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:33' prior: 34895620!menuPrincipalself limpiarPantalla.self print:'Menu Principal' position:10@20.self print:'1 - Ver Saldo' position:50@40.self print:'2 - Retirar dinero' position:50@60.self print:'3 - Depositar dinero' position:50@80.self print:'4 - Salir' position:50@100.self print:'Elija una opcion:' position:10@120.self read:110@120.accion:=3.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 02:34' prior: 34887709!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		puedeingresar:=false.		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[^self mostrarSaldo].	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 02:35'!mostrarSaldoself limpiarPantalla.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 02:36' prior: 34896892!mostrarSaldoself limpiarPantalla.self print:'El saldo de su cuenta es: $', (usuario monto) position:30@30.self print:'Presione'! !!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 02:37' prior: 34896477!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		puedeingresar:=false.		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=(temp contents)ifTrue:[^self mostrarSaldo].			].	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.! !atm_  ATM new.!'23' asInteger!!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 02:39' prior: 34897211!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		puedeingresar:=false.		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=((temp contents) asInteger)ifTrue:[^self mostrarSaldo].			].	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.! !atm_  ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 02:39' prior: 34897004!mostrarSaldoself limpiarPantalla.self print:'El saldo de su cuenta es: $', (usuario monto) position:30@30.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 02:39' prior: 34898206!mostrarSaldoself limpiarPantalla.self print:'El saldo de su cuenta es: $', ((usuario monto) asString) position:30@30.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:40' prior: 34889369!validarUsuario|n user|usuario pin: temp contents.n:=usuarios size.Transcript show:n.1to:n do:[:i|		user:=usuarios at:i.		((user cuenta) = (usuario cuenta))&((user pin) = (usuario pin))		ifTrue:[				usuario:=user.				^self menuPrincipal.			].	].^self pedirNumeroCuenta.! !atm_  ATM new.!atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:42' prior: 34898391!mostrarSaldoself limpiarPantalla.self print:'El saldo de su cuenta es: $', ((usuario monto) asString) position:60@30.self print:'Presione enter para regresar.' position:60@60.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:43' prior: 34899004!mostrarSaldoself limpiarPantalla.self print:'El saldo de su cuenta es: $', ((usuario monto) asString) position:120@40.self print:'Presione enter para regresar.' position:120@60.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:44' prior: 34899280!mostrarSaldoself limpiarPantalla.self print:'El saldo de su cuenta es: $', ((usuario monto) asString) position:120@40.self print:'Presione enter para regresar.' position:120@60.enter:=1.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:45' prior: 34899558!mostrarSaldoself limpiarPantalla.self print:'El saldo de su cuenta es: $', ((usuario monto) asString) position:120@40.self print:'Presione enter para regresar.' position:120@60.accion:=0.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 02:45' prior: 34897711!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		puedeingresar:=false.		0=accion ifTrue:[^self menuPrincipal].		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=((temp contents) asInteger)ifTrue:[^self mostrarSaldo].			].	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 02:46' prior: 34899829!mostrarSaldoself limpiarPantalla.self print:'El saldo de su cuenta es: $', ((usuario monto) asString) position:120@40.self print:'Presione enter para regresar.' position:120@60.puedeingresar:=true.accion:=0.! !atm_  ATM new.!atm_  ATM new.!----QUIT----{18 March 2011 . 2:53:08 am} Squeak4.1.image priorSource: 1335327!----STARTUP----{18 March 2011 . 11:10:31 am} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 11:11' prior: 34900097!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		puedeingresar:=false.		0=accion ifTrue:[^self menuPrincipal].		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=((temp contents) asInteger)ifTrue:[^self mostrarSaldo].			2=((temp contents) asInteger)ifTrue:[^self pantallaRetiro].			3=((temp contents) asInteger)ifTrue:[^self pantalladeposito].			4=((temp contents) asInteger)ifTrue:[^self salir].			].	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.! !!ATM methodsFor: 'datos' stamp: 'agb 3/18/2011 11:17'!pantallaRetiro! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 11:17'!pantallaDeposito! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 11:17'!salir! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 11:17' prior: 34901843!pantallaRetiroself limpiarPantalla.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 11:27' prior: 34902089!pantallaRetiroself limpiarPantalla.self print:'Menu Retiro' position:10@20.self print:'1 - 20' position:50@40.self print:'2 - 40' position:50@60.self print:'3 - 60' position:50@80.self print:'4 - 100' position:50@100.self print:'5 - 200' position:50@100.self print:'6 - Cancelar Transaccion' position:50@100.self print:'Elija una opcion:' position:10@120.self read:110@120.accion:=3.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 11:27' prior: 34893577!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pantallaRetiro.self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 11:28' prior: 34902224!pantallaRetiroself limpiarPantalla.self print:'Menu Retiro' position:10@20.self print:'1 - 20' position:50@40.self print:'2 - 40' position:50@60.self print:'3 - 60' position:150@80.self print:'4 - 100' position:150@100.self print:'5 - 200' position:150@100.self print:'6 - Cancelar Transaccion' position:50@100.self print:'Elija una opcion:' position:10@120.self read:110@120.accion:=3.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 11:28' prior: 34904322!pantallaRetiroself limpiarPantalla.self print:'Menu Retiro' position:10@20.self print:'1 - 20' position:50@40.self print:'2 - 40' position:50@60.self print:'3 - 60' position:150@80.self print:'4 - 100' position:150@100.self print:'5 - 200' position:150@120.self print:'6 - Cancelar Transaccion' position:50@100.self print:'Elija una opcion:' position:10@120.self read:110@120.accion:=3.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 11:28' prior: 34904800!pantallaRetiroself limpiarPantalla.self print:'Menu Retiro' position:10@20.self print:'1 - 20' position:50@40.self print:'2 - 40' position:50@60.self print:'3 - 60' position:50@80.self print:'4 - 100' position:150@40.self print:'5 - 200' position:150@60.self print:'6 - Cancelar Transaccion' position:150@80.self print:'Elija una opcion:' position:10@120.self read:110@120.accion:=3.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 11:31' prior: 34905295!pantallaRetiroself limpiarPantalla.self print:'Menu Retiro' position:10@20.self print:'1 - 20' position:50@50.self print:'2 - 40' position:50@70.self print:'3 - 60' position:50@90.self print:'4 - 100' position:150@50.self print:'5 - 200' position:150@70.self print:'6 - Cancelar Transaccion' position:150@90.self print:'Elija una opcion:' position:10@120.self read:110@120.accion:=3.! !atm_  ATM new.!----SNAPSHOT----{18 March 2011 . 11:31:38 am} Squeak4.1.image priorSource: 1346454!atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 11:36' prior: 34905787!pantallaRetiroself limpiarPantalla.self print:'Menu Retiro' position:10@20.self print:'1 - $20' position:50@50.self print:'2 - $40' position:50@70.self print:'3 - $60' position:50@90.self print:'4 - $100' position:150@50.self print:'5 - $200' position:150@70.self print:'6 - Cancelar Transaccion' position:150@90.self print:'Elija una opcion:' position:10@120.self read:110@120.accion:=3.! !atm_  ATM new.!atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 11:39' prior: 34906381!pantallaRetiroself limpiarPantalla.self print:'Menu Retiro' position:10@20.self print:'1 - $20' position:50@50.self print:'2 - $40' position:50@70.self print:'3 - $60' position:50@90.self print:'4 - $100' position:150@50.self print:'5 - $200' position:150@70.self print:'6 - Cancelar Transaccion' position:150@90.self print:'Elija una opcion:' position:10@120.self read:110@120.accion:=4.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 11:40' prior: 34901160!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		puedeingresar:=false.		0=accion ifTrue:[^self menuPrincipal].		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=((temp contents) asInteger)ifTrue:[^self mostrarSaldo].			2=((temp contents) asInteger)ifTrue:[^self pantallaRetiro].			3=((temp contents) asInteger)ifTrue:[^self pantalladeposito].			4=((temp contents) asInteger)ifTrue:[^self salir].			].		4=accion ifTrue:[^self validarRetiro].	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 11:40'!validarRetiro! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 11:40' prior: 34908101!validarRetiro! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 11:48' prior: 34908195!validarRetiro|opcion cantidad|opcion:=(temp contents)asInteger.(opcion=6)ifTrue:[^self menuPrincipal].(opcion<4)ifTrue:[cantidad:=opcion*20].(opcion=4)ifTrue:[cantidad:=100].(opcion=5)ifTrue:[cantidad:=200].! !----SNAPSHOT----{18 March 2011 . 11:48:49 am} Squeak4.1.image priorSource: 1351769!!ATM methodsFor: 'mensajes' stamp: 'agb 3/18/2011 11:49'!notieneDinero! !!ATM methodsFor: 'mensajes' stamp: 'agb 3/18/2011 11:49'!notieneDineroCajero! !(20<=20)!(20<=19)!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 11:54' prior: 34908290!validarRetiro|opcion cantidad|opcion:=(temp contents)asInteger.(opcion=6)ifTrue:[^self menuPrincipal].(opcion<4)ifTrue:[cantidad:=opcion*20].(opcion=4)ifTrue:[cantidad:=100].(opcion=5)ifTrue:[cantidad:=200].(cantidad<=usuario monto)ifFalse:[^self notieneDinero]! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 11:55' prior: 34908850!validarRetiro|opcion cantidad|opcion:=(temp contents)asInteger.(opcion=6)ifTrue:[^self menuPrincipal].(opcion<4)ifTrue:[cantidad:=opcion*20].(opcion=4)ifTrue:[cantidad:=100].(opcion=5)ifTrue:[cantidad:=200].(cantidad<=usuario monto)ifFalse:[^self notieneDinero].(cantidad<=dinerocajero)ifFalse:[^self notieneDineroCajero].! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 11:56' prior: 34909199!validarRetiro|opcion cantidad|opcion:=(temp contents)asInteger.(opcion=6)ifTrue:[^self menuPrincipal].(opcion<4)ifTrue:[cantidad:=opcion*20].(opcion=4)ifTrue:[cantidad:=100].(opcion=5)ifTrue:[cantidad:=200].(cantidad<=usuario monto)ifFalse:[^self notieneDinero].(cantidad<=dinerocajero)ifFalse:[^self notieneDineroCajero].! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 11:56' prior: 34902707!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=2000.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pantallaRetiro.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 11:59' prior: 34910030!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pantallaRetiro.self openInWorld.! !atm_  ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 12:17' prior: 34909610!validarRetiro|opcion cantidad|opcion:=(temp contents)asInteger.(opcion=6)ifTrue:[^self menuPrincipal].(opcion<4)ifTrue:[cantidad:=opcion*20].(opcion=4)ifTrue:[cantidad:=100].(opcion=5)ifTrue:[cantidad:=200].(cantidad<=usuario monto)ifFalse:[^self notieneDinero].(cantidad<=dinerocajero)ifFalse:[^self notieneDineroCajero].self retirarDinero:cantidad.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 12:17'!retirarDinero:cantidad! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 12:18' prior: 34913715!retirarDinero:cantidadusuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'TOME SU DINERO'position:50@50.! !ImageMorph subclass: #Billete	instanceVariableNames: 'imagen valor'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!ImageMorph subclass: #Billete	instanceVariableNames: 'valor'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!ImageMorph subclass: #Billete	instanceVariableNames: 'valor todo'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!Billete methodsFor: 'iniciales' stamp: 'agb 3/18/2011 12:25' prior: 34821091!initializesuper initialize.self image: (ImageReadWriter formFromFileNamed: 'atm\20Dollar.jpg').self extent:180@76.self openInWorld.! !billete _ Billete new.!Billete removeSelector: #wantsToBeDroppedInto:!billete _ Billete new.!!Billete methodsFor: 'iniciales' stamp: 'agb 3/18/2011 12:25' prior: 34914459!initializesuper initialize.self image: (ImageReadWriter formFromFileNamed: 'atm\20Dollar.jpg').self extent:180@50.self openInWorld.! !billete _ Billete new.!!Billete methodsFor: 'iniciales' stamp: 'agb 3/18/2011 12:26' prior: 34914776!initializesuper initialize.self image: (ImageReadWriter formFromFileNamed: 'atm\20Dollar.jpg').self extent:180@20.self openInWorld.! !billete _ Billete new.!cont:= RectangleMorph new openInWorld.!imagen:= ImageMorph new.imagen image: (ImageReadWriter formFromFileNamed: 'atm\20Dollar.jpg').!cont addMorph:imagen.!cont extent:100@100.!cont extent:100@100.!atm _ ATM new.!ImageMorph subclass: #Billete	instanceVariableNames: 'valor todo fajo'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!ImageMorph subclass: #Billete	instanceVariableNames: 'valor todo fajo'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!Billete methodsFor: 'nil' stamp: 'agb 3/18/2011 12:40'!fajo^fajo! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 12:40'!fajo:aFajofajo:=aFajo! !Object subclass: #Fajo	instanceVariableNames: 'grupo'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 12:43' prior: 34913819!retirarDinero:cantidadusuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'TOME SU DINERO'position:50@50.! !----SNAPSHOT----{18 March 2011 . 12:43:44 pm} Squeak4.2.image priorSource: 1354075!----SNAPSHOT----{18 March 2011 . 12:43:52 pm} Squeak4.2.image priorSource: 1361787!!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 12:48'!todo:aBooleantodo:=aBoolean! !!Billete methodsFor: 'iniciales' stamp: 'agb 3/18/2011 12:48' prior: 34915019!initializesuper initialize.self image: (ImageReadWriter formFromFileNamed: 'atm\20Dollar1.jpg').self extent:180@20.self openInWorld.! !!Billete methodsFor: 'iniciales' stamp: 'agb 3/18/2011 12:48' prior: 34916574!initializesuper initialize.self image: (ImageReadWriter formFromFileNamed: 'atm\20Dollar1.jpg').self openInWorld.! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 12:49'!click: evt todo ifFalse:[].! !!Billete methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 12:49' prior: 34916986!click: evt todo ifFalse:[].todo:=true.! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 12:50' prior: 34917107!click: evt todo ifFalse:[self image: (ImageReadWriter formFromFileNamed: 'atm\20Dollar.jpg').].todo:=true.! !!Billete methodsFor: 'iniciales' stamp: 'agb 3/18/2011 12:51' prior: 34916463!todo:aBooleantodo:=aBoolean.todo ifTrue:[].todo ifFalse:[].! !!Billete methodsFor: 'iniciales' stamp: 'agb 3/18/2011 12:51' prior: 34917419!todo:aBooleantodo:=aBoolean.todo ifTrue:[self image: (ImageReadWriter formFromFileNamed: 'atm\20Dollar1.jpg').].todo ifFalse:[].! !!Billete methodsFor: 'iniciales' stamp: 'agb 3/18/2011 12:51' prior: 34917564!todo:aBooleantodo:=aBoolean.todo ifTrue:[self image: (ImageReadWriter formFromFileNamed: 'atm\20Dollar.jpg').].todo ifFalse:[self image: (ImageReadWriter formFromFileNamed: 'atm\20Dollar1.jpg').].! !!Billete methodsFor: 'iniciales' stamp: 'agb 3/18/2011 12:51' prior: 34916793!initializesuper initialize.self image: (ImageReadWriter formFromFileNamed: 'atm\20Dollar1.jpg').todo:=false.self openInWorld.! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 12:52' prior: 34917228!click: evt todo:=false.! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 12:52' prior: 34918270!click: evt todo ifFalse:[self todo:true.].! !----SNAPSHOT----{18 March 2011 . 12:53:21 pm} Squeak4.2.image priorSource: 1361872!billete _ Billete new.!billete _ Billete new.!billete _ Billete new.!----SNAPSHOT----{18 March 2011 . 1:01:02 pm} Squeak4.2.image priorSource: 1363989!cont:= RectangleMorph new openInWorld.!r1:= RectangleMorph new openInWorld.!cont addMorph:r1.!World.!World addMorph:r1.!Morph subclass: #Fajo	instanceVariableNames: 'billetes grupo'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!Fajo methodsFor: 'nil' stamp: 'agb 3/18/2011 13:07'!initializesuper initialize.billetes:=OrderedCollection new.! !!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:08'!de:aNumber.aNumber=20 ifTrue:[		[billetes size >0] whileTrue:[billetes removeFirst].	]! !!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:08' prior: 34919113!de:aNumber.[billetes size >0] whileTrue:[billetes removeFirst].aNumber=20 ifTrue:[					]! !!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:09' prior: 34919292!de:aNumber.[billetes size >0] whileTrue:[billetes removeFirst].aNumber=40 ifTrue:[		1to:2 do:[:i|							]	]! !!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:10' prior: 34919475!de:aNumber|billete|[billetes size >0] whileTrue:[billetes removeFirst].aNumber=40 ifTrue:[		1to:2 do:[:i|				billete:=Billete new.				billetes add:billete.				self addMorph:billete.			]	]! !fajo:=Fajo new.!fajo de:40.!fajo de:40.!!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:11' prior: 34919678!de:aNumber|billete|[billetes size >0] whileTrue:[billetes removeFirst].aNumber=40 ifTrue:[		1to:2 do:[:i|				billete:=Billete new.				billetes add:billete.				self addMorph:billete.			]	]! !!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:11' prior: 34920010!de:aNumber|billete|[billetes size >0] whileTrue:[billetes removeFirst].aNumber=40 ifTrue:[		1to:2 do:[:i|				billete:=Billete new.				billetes add:billete.				self addMorph:billete.			]	]! !!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:11' prior: 34920297!de:aNumber|billete|[billetes size >0] whileTrue:[billetes removeFirst].aNumber=40 ifTrue:[		1to:2 do:[:i|				billete:=Billete new.				billetes add:billete.				self addMorph:billete.			]	].self openInWorld.! !fajo de:40.!fajo de:40.!fajo:=Fajo new.!fajo de:40.!!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:13' prior: 34920585!de:aNumber|billete|[billetes size >0] whileTrue:[billetes removeFirst].aNumber=40 ifTrue:[		1to:2 do:[:i|				billete:=Billete new.				billetes add:billete.				self addMorph:billete.			]	].self extent:0@0.self openInWorld.! !fajo:=Fajo new.!fajo de:40.!!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:14' prior: 34920951!de:aNumber|billete pinicial|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=10@10.aNumber=40 ifTrue:[		1to:2 do:[:i|				billete:=Billete new.				billetes add:billete.				billete position:pinicial.				self addMorph:billete.				pinicial:=pinicial+(0@20).			]	].self extent:0@0.self openInWorld.! !fajo:=Fajo new.!fajo de:40.!!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:14' prior: 34921305!de:aNumber|billete pinicial|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=10@10.aNumber=40 ifTrue:[		1to:2 do:[:i|				billete:=Billete new.				billetes add:billete.				billete position:pinicial.				self addMorph:billete.				pinicial:=pinicial+(0@30).			]	].self extent:0@0.self openInWorld.! !fajo de:40.!!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:15' prior: 34921747!de:aNumber|billete pinicial|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=10@10.aNumber=40 ifTrue:[		1to:2 do:[:i|				billete:=Billete new.				billetes add:billete.				billete position:pinicial.				self addMorph:billete.				pinicial:=pinicial+(0@ -30).			]	].self extent:0@0.self openInWorld.! !fajo de:40.!!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:15' prior: 34922171!de:aNumber|billete pinicial|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=10@10.aNumber=40 ifTrue:[		1to:2 do:[:i|				billete:=Billete new.				billetes add:billete.				billete position:pinicial.				self addMorph:billete.				pinicial:=pinicial+(0@ -20).			]	].self extent:0@0.self openInWorld.! !!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:15' prior: 34922597!de:aNumber|billete pinicial|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=10@10.aNumber=40 ifTrue:[		1to:2 do:[:i|				billete:=Billete new.				billetes add:billete.				billete position:pinicial.				self addMorph:billete.				pinicial:=pinicial+(0@ 20).			]	].self extent:0@0.self openInWorld.! !!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:15' prior: 34923009!de:aNumber|billete pinicial|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=10@10.aNumber=40 ifTrue:[		1to:2 do:[:i|				billete:=Billete new.				billetes add:billete.				billete position:pinicial.				self addMorph:billete.				pinicial:=pinicial+(0@20).			]	].self extent:0@0.self openInWorld.! !!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:16' prior: 34923420!de:aNumber|billete pinicial|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=10@10.aNumber=40 ifTrue:[		1to:2 do:[:i|				billete:=Billete new.				billetes add:billete.				billete position:pinicial.				self addMorphBack:billete.				pinicial:=pinicial+(0@20).			]	].self extent:0@0.self openInWorld.! !fajo de:40.!fajo de:40.!!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:16' prior: 34923830!de:aNumber|billete pinicial|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=100@100.aNumber=40 ifTrue:[		1to:2 do:[:i|				billete:=Billete new.				billetes add:billete.				billete position:pinicial.				self addMorphBack:billete.				pinicial:=pinicial+(0@20).			]	].self extent:0@0.self openInWorld.! !!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:16' prior: 34924272!de:aNumber|billete pinicial|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=100@100.aNumber=40 ifTrue:[		1to:2 do:[:i|				billete:=Billete new.				billetes add:billete.				billete position:pinicial.				self addMorphBack:billete.				pinicial:=pinicial+(0@10).			]	].self extent:0@0.self openInWorld.! !fajo de:40.!fajo de:40.!!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 13:18' prior: 34820544!handlesMouseDown: evt	^ false! !billete _ Billete new.!fajo:=Fajo new.!fajo de:40.!!Fajo methodsFor: 'eventos' stamp: 'agb 3/18/2011 13:20'!handlesMouseDown:evt^true! !!Fajo methodsFor: 'eventos' stamp: 'agb 3/18/2011 13:21'!firstClickTimedOut: evt evt hand grabMorph: self.! !!Fajo methodsFor: 'eventos' stamp: 'agb 3/18/2011 13:21'!mouseDown: evt	evt hand waitForClicksOrDrag: self event: evt selectors: { #click:. #doubleClick:. #firstClickTimedOut:. nil} threshold: 5! !fajo de:40.!fajo:=Fajo new.!fajo de:40.!fajo:=Fajo new.!fajo de:40.!!Fajo methodsFor: 'eventos' stamp: 'agb 3/18/2011 13:23'!click: evt|n|n:=billetes size.1to:n do:[:i|		(billetes at:i) todo:true.	]! !fajo de:40.!fajo:=Fajo new.!fajo de:40.!!Fajo methodsFor: 'eventos' stamp: 'agb 3/18/2011 13:24'!justDroppedInto: newOwner event: evt! !!Fajo methodsFor: 'eventos' stamp: 'agb 3/18/2011 13:24' prior: 34925936!justDroppedInto: newOwner event: evt! !!Fajo methodsFor: 'eventos' stamp: 'agb 3/18/2011 13:25' prior: 34926050!justDroppedInto: newOwner event: evt|n|n:=billetes size.1to:n do:[:i|		World addMorph:(billetes at:i).	]! !fajo:=Fajo new.!fajo de:40.!!Fajo methodsFor: 'eventos' stamp: 'agb 3/18/2011 13:26' prior: 34926165!justDroppedInto: newOwner event: evtWorld addAllMorphs:billetes.! !fajo:=Fajo new.!fajo de:40.!fajo de:40.!Morph subclass: #Fajo	instanceVariableNames: 'billetes'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:27'!de:aNumber position:aPoint|billete pinicial|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=aPoint.aNumber=40 ifTrue:[		1to:2 do:[:i|				billete:=Billete new.				billetes add:billete.				billete position:pinicial.				self addMorphBack:billete.				pinicial:=pinicial+(0@10).			]	].self extent:0@0.self openInWorld.! !!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:29' prior: 34926692!de:aNumber position:aPoint|billete pinicial n|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=aPoint.n:=(aNumber/20).1to:n do:[:i|		billete:=Billete new.		billetes add:billete.		billete position:pinicial.		self addMorphBack:billete.		pinicial:=pinicial+(0@10).].self extent:0@0.self openInWorld.! !fajo:=Fajo new.!fajo de:60 position:100@100.!fajo de:60 position:100@100.!fajo de:200 position:100@100.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 13:32' prior: 34916050!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'TOME SU DINERO'position:50@50.cantidad=20 ifTrue:[		dinero:=Billete new.	]! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 13:34' prior: 34927638!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'TOME SU DINERO'position:50@50.cantidad=20 ifTrue:[		dinero:=Billete new.		dinero position:pretiro position+(50@50).	]! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 13:36' prior: 34927942!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'TOME SU DINERO'position:50@50.cantidad=20 ifTrue:[		dinero:=Billete new.		dinero position:pretiro position+(50@50).	]ifFalse:[		dinero:=Fajo new.		dinero de:cantidad position:pretiro position+(50@50).	]! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 13:36' prior: 34928289!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'TOME SU DINERO'position:50@50.cantidad=20 ifTrue:[		dinero:=Billete new.		dinero position:pretiro position+(50@50).	]ifFalse:[		dinero:=Fajo new.		dinero de:(cantidad) position:pretiro position+(50@50).	]! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:38' prior: 34911656!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pantallaRetiro.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 13:38' prior: 34929171!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!atm _ ATM new.!!Fajo methodsFor: 'nil' stamp: 'agb 3/18/2011 13:40'!atm:aATMatm:=aATM.! !!Fajo methodsFor: 'eventos' stamp: 'agb 3/18/2011 13:41' prior: 34925750!click: evt|n|n:=billetes size.1to:n do:[:i|		(billetes at:i) todo:true.	]atm menuPrincipal.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 13:42' prior: 34928725!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'TOME SU DINERO'position:50@50.cantidad=20 ifTrue:[		dinero:=Billete new.		dinero position:pretiro position+(50@50).	]ifFalse:[		dinero:=Fajo new.		dinero atm:self.		dinero de:(cantidad) position:pretiro position+(50@50).	]! !atm _ ATM new.!!Fajo methodsFor: 'eventos' stamp: 'agb 3/18/2011 13:43' prior: 34932524!click: evt|n|n:=billetes size.1to:n do:[:i|		(billetes at:i) todo:true.	]atm menuPrincipal.! !ATM new.!!Fajo methodsFor: 'eventos' stamp: 'agb 3/18/2011 13:45' prior: 34933173!click: evt|n|atm menuPrincipal.n:=billetes size.1to:n do:[:i|		(billetes at:i) todo:true.	].! !ATM new.!ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 13:47' prior: 34932702!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'TOME SU DINERO'position:50@50.dinero:=Fajo new.dinero atm:self.dinero de:(cantidad) position:pretiro position+(50@50).! !ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 13:49' prior: 34933560!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'Por favor retire su dinero!!.'position:50@50.dinero:=Fajo new.dinero atm:self.dinero de:(cantidad) position:pretiro position+(50@50).! !ATM new.!ATM new.!!ATM methodsFor: 'mensajes' stamp: 'agb 3/18/2011 14:36' prior: 34908651!notieneDineroself limpiarPantalla.self print:'No posee fondos suficientes!!' position:100@100.! !!ATM methodsFor: 'mensajes' stamp: 'agb 3/18/2011 14:36' prior: 34934299!notieneDineroself limpiarPantalla.self print:'No posee fondos suficientes!!' position:120@40.self print:'Presione enter para regresar.' position:120@60.! !!ATM methodsFor: 'mensajes' stamp: 'agb 3/18/2011 14:37' prior: 34934473!notieneDineroself limpiarPantalla.self print:'No posee fondos suficientes!!' position:120@40.self print:'Presione enter para regresar.' position:120@60.puedeingresar:=true.accion:=10.! !!ATM methodsFor: 'mensajes' stamp: 'agb 3/18/2011 14:37' prior: 34908727!notieneDineroCajeroself limpiarPantalla.self print:'Este equipo no posee fondos suficientes!!' position:120@40.self print:'Presione enter para regresar.' position:120@60.puedeingresar:=true.accion:=10.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 14:38' prior: 34907371!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		puedeingresar:=false.		0=accion ifTrue:[^self menuPrincipal].		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=((temp contents) asInteger)ifTrue:[^self mostrarSaldo].			2=((temp contents) asInteger)ifTrue:[^self pantallaRetiro].			3=((temp contents) asInteger)ifTrue:[^self pantalladeposito].			4=((temp contents) asInteger)ifTrue:[^self salir].			].		4=accion ifTrue:[^self validarRetiro].		"mensajes"		10=accion ifTrue:[^self pantallaRetiro].	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 14:39' prior: 34935255!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		puedeingresar:=false.		0=accion ifTrue:[^self menuPrincipal].		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=((temp contents) asInteger)ifTrue:[^self mostrarSaldo].			2=((temp contents) asInteger)ifTrue:[^self pantallaRetiro].			3=((temp contents) asInteger)ifTrue:[^self pantalladeposito].			4=((temp contents) asInteger)ifTrue:[^self salir].			^self menuPrincipal.			].		4=accion ifTrue:[^self validarRetiro].		"mensajes"		10=accion ifTrue:[^self pantallaRetiro].	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.! !ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 14:42' prior: 34901922!pantallaDepositoself limpiarPantalla. ! !ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 14:46' prior: 34936901!pantallaDepositoself limpiarPantalla.self print:'Ingrese Monto de Deposito (o cero para salir): ' position:10@20.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 14:47' prior: 34936064!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		puedeingresar:=false.		0=accion ifTrue:[^self menuPrincipal].		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=((temp contents) asInteger)ifTrue:[^self mostrarSaldo].			2=((temp contents) asInteger)ifTrue:[^self pantallaRetiro].			3=((temp contents) asInteger)ifTrue:[^self pantallaDeposito].			4=((temp contents) asInteger)ifTrue:[^self salir].			^self menuPrincipal.			].		4=accion ifTrue:[^self validarRetiro].		"mensajes"		10=accion ifTrue:[^self pantallaRetiro].	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.! !ATM new.!!Fajo methodsFor: 'eventos' stamp: 'agb 3/18/2011 14:48' prior: 34926384!justDroppedInto: newOwner event: evt|n billete|atm menuPrincipal.n:=billetes size.1to:n do:[:i|	World addMorph:billete.		(billetes at:i) todo:true.				].! !!Fajo methodsFor: 'eventos' stamp: 'agb 3/18/2011 14:50' prior: 34938070!justDroppedInto: newOwner event: evt|n billete|atm menuPrincipal.n:=billetes size.1to:n do:[:i|	billete:=billetes removeFirst.	World addMorph:billete.	billete handlesMouseDown:true.	].! !ATM new.!!Fajo methodsFor: 'eventos' stamp: 'agb 3/18/2011 14:52' prior: 34938309!justDroppedInto: newOwner event: evt|n billete|atm menuPrincipal.n:=billetes size.1to:n do:[:i|	billete:=billetes removeFirst.	World addMorphBack:billete.	billete handlesMouseDown:true.	].! !ATM new.!!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 14:52' prior: 34824307!justDroppedInto: newOwner event: evt! !Billete removeSelector: #doubleClick:!!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 14:54'!doubleClick: evt evt hand grabMorph: self.! !r1:=RectangleMorph new openInWorld.!r1 position:0@0.!r1 extent:100@100.!r1 position:0@0.r1 extent:100@100.!r1 extent:100@100.!r1 position:0@0.!ImageMorph subclass: #Billete	instanceVariableNames: 'valor contenedor'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!ImageMorph subclass: #Billete	instanceVariableNames: 'valor contenedor todo'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!ImageMorph subclass: #Billete	instanceVariableNames: 'valor contenedor todo fajo'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!Billete removeSelector: #fajo:!Billete removeSelector: #fajo!ImageMorph subclass: #Billete	instanceVariableNames: 'valor contenedor todo'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!----SNAPSHOT----{18 March 2011 . 2:57:23 pm} Squeak4.2.image priorSource: 1364149!(10@10)/2!(10@10)x!!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 15:06' prior: 34938878!justDroppedInto: newOwner event: evt|punto|punto:=(self position)+((self extent)/2).(contenedor x)<=(punto x) & (punto x)<=((contenedor x)+ (contenedor width)) & (contenedor y)<=(punto y) & (punto y)<=((contenedor y)+ (contenedor height))ifTrue:[Transcript show:'esta dentro'.].! !Morph subclass: #Fajo	instanceVariableNames: 'billetes atm contenedor'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!Fajo removeSelector: #de:!!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 15:07'!de:aNumber position:aPoint contenedor:aMorph|billete pinicial n|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=aPoint.n:=(aNumber/20).1to:n do:[:i|		billete:=Billete new.		billetes add:billete.		billete position:pinicial.		self addMorphBack:billete.		pinicial:=pinicial+(0@10).].self extent:0@0.self openInWorld.! !!Billete methodsFor: 'iniciales' stamp: 'agb 3/18/2011 15:08'!contenedor:aMorphcontenedor:=aMorph.! !!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 15:08' prior: 34940565!de:aNumber position:aPoint contenedor:aMorph|billete pinicial n|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=aPoint.n:=(aNumber/20).1to:n do:[:i|		billete:=Billete new.		billetes add:billete.		billete position:pinicial.		billete contenedor:aMorph.		self addMorphBack:billete.		pinicial:=pinicial+(0@10).].self extent:0@0.self openInWorld.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 15:10' prior: 34933918!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'Por favor retire su dinero!!.'position:50@50.dinero:=Fajo new.dinero atm:self.dinero de:(cantidad) position:pretiro position+(50@50) contenedor:pdeposito.! !ATM new.!!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 15:51' prior: 34940044!justDroppedInto: newOwner event: evt|punto|punto:=(self position)+((self extent)/2).((contenedor x)<=(punto x)) & ((punto x)<=((contenedor x)+ (contenedor width))) & ((contenedor y)<=(punto y)) & ((punto y)<=((contenedor y)+ (contenedor height)))ifTrue:[Transcript show:'esta dentro'.].! !ATM new.!ATM new.!!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 15:53' prior: 34941943!justDroppedInto: newOwner event: evt|punto|Transcript show:'hola'.punto:=(self position)+((self extent)/2).((contenedor x)<=(punto x)) & ((punto x)<=((contenedor x)+ (contenedor width))) & ((contenedor y)<=(punto y)) & ((punto y)<=((contenedor y)+ (contenedor height)))ifTrue:[Transcript show:'esta dentro'.].! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 15:56' prior: 34942336!justDroppedInto: newOwner event: evt|punto|Transcript show:contenedor.punto:=(self position)+((self extent)/2).((contenedor x)<=(punto x)) & ((punto x)<=((contenedor x)+ (contenedor width))) & ((contenedor y)<=(punto y)) & ((punto y)<=((contenedor y)+ (contenedor height)))ifTrue:[Transcript show:'esta dentro'.].! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 15:56' prior: 34942731!justDroppedInto: newOwner event: evt|punto|Transcript show:contenedor position.punto:=(self position)+((self extent)/2).((contenedor x)<=(punto x)) & ((punto x)<=((contenedor x)+ (contenedor width))) & ((contenedor y)<=(punto y)) & ((punto y)<=((contenedor y)+ (contenedor height)))ifTrue:[Transcript show:'esta dentro'.].! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 15:57' prior: 34943130!justDroppedInto: newOwner event: evt|punto|Transcript show:contenedor position.punto:=(self position)+((self extent)/2).Transcript show:punto.((contenedor x)<=(punto x)) & ((punto x)<=((contenedor x)+ (contenedor width))) & ((contenedor y)<=(punto y)) & ((punto y)<=((contenedor y)+ (contenedor height)))ifTrue:[Transcript show:'esta dentro'.].! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 15:57' prior: 34943538!justDroppedInto: newOwner event: evt|punto|Transcript show:contenedor position asString,' '.punto:=(self position)+((self extent)/2).Transcript show:punto.((contenedor x)<=(punto x)) & ((punto x)<=((contenedor x)+ (contenedor width))) & ((contenedor y)<=(punto y)) & ((punto y)<=((contenedor y)+ (contenedor height)))ifTrue:[Transcript show:'esta dentro'.].! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 15:57' prior: 34943969!justDroppedInto: newOwner event: evt|punto|Transcript show:contenedor position asString,' '.punto:=(self position)+((self extent)/2).Transcript show:punto asString,' '.((contenedor x)<=(punto x)) & ((punto x)<=((contenedor x)+ (contenedor width))) & ((contenedor y)<=(punto y)) & ((punto y)<=((contenedor y)+ (contenedor height)))ifTrue:[Transcript show:'esta dentro'.].! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 15:58' prior: 34944413!justDroppedInto: newOwner event: evt|punto|Transcript show:contenedor position asString,' '.punto:=(self position)+((self extent)/2).Transcript show:punto asString,' '.((contenedor x)<=(punto x)) & ((punto x)<=((contenedor x)+ (contenedor width))) & ((contenedor y)<=(punto y)) & ((punto y)<=((contenedor y)+ (contenedor height)))ifTrue:[Transcript show:' esta dentro '.].! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 16:06' prior: 34944870!justDroppedInto: newOwner event: evt|punto|Transcript show:'limites '.Transcript show:contenedor x asString,' '.Transcript show:((contenedor x)+(contenedor width)) asString,' '.punto:=(self position)+((self extent)/2).Transcript show:punto asString,' '.((contenedor x)<=(punto x)) & ((punto x)<=((contenedor x)+ (contenedor width))) & ((contenedor y)<=(punto y)) & ((punto y)<=((contenedor y)+ (contenedor height)))ifTrue:[Transcript show:' esta dentro '.].! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 16:07' prior: 34945329!justDroppedInto: newOwner event: evt|punto|Transcript show:'limites '.Transcript show:contenedor x asString,' '.Transcript show:((contenedor x)+(contenedor width)) asString,' '.Transcript show:contenedor y asString,' '.Transcript show:((contenedor y)+(contenedor height)) asString,' '.punto:=(self position)+((self extent)/2).Transcript show:punto asString,' '.((contenedor x)<=(punto x)) & ((punto x)<=((contenedor x)+ (contenedor width))) & ((contenedor y)<=(punto y)) & ((punto y)<=((contenedor y)+ (contenedor height)))ifTrue:[Transcript show:' esta dentro '.].! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 16:08' prior: 34945875!justDroppedInto: newOwner event: evt|punto|Transcript show:'posicion: ', contenedor position.Transcript show:' limites '.Transcript show:contenedor x asString,' '.Transcript show:((contenedor x)+(contenedor width)) asString,' '.Transcript show:contenedor y asString,' '.Transcript show:((contenedor y)+(contenedor height)) asString,' '.punto:=(self position)+((self extent)/2).Transcript show:punto asString,' '.((contenedor x)<=(punto x)) & ((punto x)<=((contenedor x)+ (contenedor width))) & ((contenedor y)<=(punto y)) & ((punto y)<=((contenedor y)+ (contenedor height)))ifTrue:[Transcript show:' esta dentro '.].! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 16:09' prior: 34946531!justDroppedInto: newOwner event: evt|punto|Transcript show:'posicion: ', contenedor position.Transcript show:' x: ', contenedor x.Transcript show:' limites '.Transcript show:contenedor x asString,' '.Transcript show:((contenedor x)+(contenedor width)) asString,' '.Transcript show:contenedor y asString,' '.Transcript show:((contenedor y)+(contenedor height)) asString,' '.punto:=(self position)+((self extent)/2).Transcript show:punto asString,' '.((contenedor x)<=(punto x)) & ((punto x)<=((contenedor x)+ (contenedor width))) & ((contenedor y)<=(punto y)) & ((punto y)<=((contenedor y)+ (contenedor height)))ifTrue:[Transcript show:' esta dentro '.].! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 16:11' prior: 34947239!justDroppedInto: newOwner event: evt|punto posicion|posicion:=contenedor position.Transcript show:'posicion: ', contenedor position.Transcript show:' x: ', contenedor x.Transcript show:' limites '.Transcript show:contenedor x asString,' '.Transcript show:((contenedor x)+(contenedor width)) asString,' '.Transcript show:contenedor y asString,' '.Transcript show:((contenedor y)+(contenedor height)) asString,' '.punto:=(self position)+((self extent)/2).Transcript show:punto asString,' '.((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (posicion width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (posicion height)))ifTrue:[Transcript show:' esta dentro '.].! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 16:11' prior: 34947985!justDroppedInto: newOwner event: evt|punto posicion|posicion:=contenedor position.Transcript show:'posicion: ', contenedor position.Transcript show:' x: ', contenedor x.Transcript show:' limites '.Transcript show:contenedor x asString,' '.Transcript show:((contenedor x)+(contenedor width)) asString,' '.Transcript show:contenedor y asString,' '.Transcript show:((contenedor y)+(contenedor height)) asString,' '.punto:=(self position)+((self extent)/2).Transcript show:punto asString,' '.((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (contenedor width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (contenedor height)))ifTrue:[Transcript show:' esta dentro '.].! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 16:12' prior: 34948759!justDroppedInto: newOwner event: evt|punto posicion|posicion:=contenedor position.punto:=(self position)+((self extent)/2).Transcript show:punto asString,' '.((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (contenedor width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (contenedor height)))ifTrue:[Transcript show:' esta dentro '.].! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 16:12' prior: 34949537!justDroppedInto: newOwner event: evt|punto posicion|posicion:=contenedor position.punto:=(self position)+((self extent)/2).((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (contenedor width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (contenedor height)))ifTrue:[Transcript show:' esta dentro '.].! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 16:16' prior: 34949978!justDroppedInto: newOwner event: evt|punto posicion|posicion:=contenedor position.punto:=(self position)+((self extent)/2).((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (contenedor width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (contenedor height)))ifTrue:[Transcript show:' esta dentro '. self delete.].! !!Fajo methodsFor: 'eventos' stamp: 'agb 3/18/2011 16:17' prior: 34938590!justDroppedInto: newOwner event: evt|n billete|atm menuPrincipal.n:=billetes size.1to:n do:[:i|	billete:=billetes removeFirst.	World addMorphBack:billete.	billete handlesMouseDown:true.	].self delete.! !ATM new.!!Fajo methodsFor: 'eventos' stamp: 'agb 3/18/2011 16:22'!de:aNumber position:aPoint atm:aATM|billete pinicial n|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=aPoint.n:=(aNumber/20).1to:n do:[:i|		billete:=Billete new.		billetes add:billete.		billete position:pinicial.		billete atm:aATM.		billete contenedor:(aATM pdeposito).		self addMorphBack:billete.		pinicial:=pinicial+(0@10).].self extent:0@0.self openInWorld.! !!Billete methodsFor: 'nil' stamp: 'agb 3/18/2011 16:23'!atm:aATMatm:=aATM.! !!ATM methodsFor: 'nil' stamp: 'agb 3/18/2011 16:24'!pdeposito^pdeposito! !!Fajo methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 16:25' prior: 34941099!de:aNumber position:aPoint contenedor:aMorph|billete pinicial n|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=aPoint.n:=(aNumber/20).1to:n do:[:i|		billete:=Billete new.		billetes add:billete.		billete position:pinicial.		billete contenedor:aMorph.		billete atm:atm.		self addMorphBack:billete.		pinicial:=pinicial+(0@10).].self extent:0@0.self openInWorld.! !Fajo removeSelector: #de:position:atm:!Fajo removeSelector: #de:position:!----SNAPSHOT----{18 March 2011 . 4:25:58 pm} Squeak4.2.image priorSource: 1385427!RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter estado pdeposito pretiro puedeingresar temp accion usuario usuarios dinerocajero aceptaingreso'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 16:26'!aceptaIngresos:aBooleanaceptaingresos:=aBoolean.! !RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter estado pdeposito pretiro puedeingresar temp accion usuario usuarios dinerocajero aceptaingresos'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 16:27'!aceptaIngresos^aceptaingresos! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 16:28' prior: 34950383!justDroppedInto: newOwner event: evt|punto posicion|atm aceptaIngresos ifFalse:[^nil].posicion:=contenedor position.punto:=(self position)+((self extent)/2).((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (contenedor width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (contenedor height)))ifTrue:[Transcript show:' esta dentro '. self delete.].! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 16:29' prior: 34930796!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 16:30' prior: 34937033!pantallaDepositoself limpiarPantalla.self print:'Ingrese Monto de Deposito (o cero para salir): ' position:10@20.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 16:30' prior: 34955205!pantallaDepositoself limpiarPantalla.self print:'Ingrese Monto de Deposito (o cero para salir): ' position:10@20.self read:110@120.accion:=5.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 16:30' prior: 34937236!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		puedeingresar:=false.		0=accion ifTrue:[^self menuPrincipal].		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=((temp contents) asInteger)ifTrue:[^self mostrarSaldo].			2=((temp contents) asInteger)ifTrue:[^self pantallaRetiro].			3=((temp contents) asInteger)ifTrue:[^self pantallaDeposito].			4=((temp contents) asInteger)ifTrue:[^self salir].			^self menuPrincipal.			].		4=accion ifTrue:[^self validarRetiro].		5=accion ifTrue:[^self pedirIngreso].		"mensajes"		10=accion ifTrue:[^self pantallaRetiro].	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 16:31'!pedirIngreso! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 16:31' prior: 34956474!pedirIngresoaceptaingresos:=true.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 16:31' prior: 34956568!pedirIngresoaceptaingresos:=true.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 16:33' prior: 34956684!pedirIngresoself print:'Ingrese Monto de Deposito (o cero para salir): ' position:10@40.aceptaingresos:=true.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 16:34' prior: 34956800!pedirIngresoself print:'Ingrese el dinero en la ranura de deposito.' position:10@40.puedeingresar:=false.aceptaingresos:=true.! !ATM new.!ATM new.!!Billete methodsFor: 'iniciales' stamp: 'agb 3/18/2011 16:38' prior: 34918060!initializesuper initialize.valor:=20.self image: (ImageReadWriter formFromFileNamed: 'atm\20Dollar1.jpg').todo:=false.self openInWorld.! !('20.5')asNumber!('20')asNumber!('20')asNumber!RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter estado pdeposito pretiro puedeingresar temp accion usuario usuarios dinerocajero aceptaingresos valoringresado'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 16:40' prior: 34956994!pedirIngresoself print:'Ingrese el dinero en la ranura de deposito.' position:10@40.valoringresado:=0.puedeingresar:=false.aceptaingresos:=true.! !!ATM methodsFor: 'nil' stamp: 'agb 3/18/2011 16:41'!valorIngresado:aNumbervaloringresado:=aNumber.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 16:42'!valorIngresado^valoringresado! !!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 16:46' prior: 34953090!justDroppedInto: newOwner event: evt|punto posicion ingresado valortotal|atm aceptaIngresos ifFalse:[^nil].ingresado:=atm valorIngresado.posicion:=contenedor position.valortotal:=((atm temp) content)asNumber.punto:=(self position)+((self extent)/2).((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (contenedor width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (contenedor height)))ifTrue:[	(ingresado + valor)<=valortotal	ifTrue:[			atm valorIngresado:valor+ingresado.			self delete.		].	].! !!ATM methodsFor: 'nil' stamp: 'agb 3/18/2011 16:46'!temp^temp! !ATM new.!!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 16:47' prior: 34958214!justDroppedInto: newOwner event: evt|punto posicion ingresado valortotal|atm aceptaIngresos ifFalse:[^nil].ingresado:=atm valorIngresado.posicion:=contenedor position.valortotal:=((atm temp) contents)asNumber.punto:=(self position)+((self extent)/2).((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (contenedor width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (contenedor height)))ifTrue:[	(ingresado + valor)<=valortotal	ifTrue:[			atm valorIngresado:valor+ingresado.			self delete.		].	].! !ATM new.!!Billete methodsFor: 'eventos' stamp: 'agb 3/18/2011 16:51' prior: 34958899!justDroppedInto: newOwner event: evt|punto posicion ingresado valortotal|atm aceptaIngresos ifFalse:[^nil].ingresado:=atm valorIngresado.posicion:=contenedor position.valortotal:=((atm temp) contents)asNumber.punto:=(self position)+((self extent)/2).((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (contenedor width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (contenedor height)))ifTrue:[	(ingresado + valor)<=valortotal	ifTrue:[			atm valorIngresado:valor+ingresado.			self delete.			(atm valorIngresado = valortotal)ifTrue:[atm depositoCompleto.].		].	].! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 16:52'!depositoCompletousuario monto:(usuario monto).! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 16:52' prior: 34960178!depositoCompletousuario monto:(usuario monto) + valoringresado.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 16:53' prior: 34960306!depositoCompletousuario monto:(usuario monto) + valoringresado.self print:'Ingreso exitoso!!' position:120@40.self print:'Presione enter para regresar.' position:120@60.puedeingresar:=true.accion:=10.! !ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/18/2011 16:54' prior: 34960452!depositoCompletousuario monto:(usuario monto) + valoringresado.self print:'Ingreso exitoso!!' position:120@40.self print:'Presione enter para regresar.' position:120@60.puedeingresar:=true.accion:=0.! !ATM new.!ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 16:58' prior: 34953551!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	(i=10)ifTrue:[b text:0.].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 16:58' prior: 34961066!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 17:00' prior: 34962744!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !ATM new.!ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 17:00' prior: 34964406!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 17:01' prior: 34966107!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseUp send: #value to:[		b push.		b pop.	].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 17:01' prior: 34967788!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		b push.		b pop.	].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 17:01' prior: 34969524!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #click send: #value to:[		b push.		b pop.	].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 17:02' prior: 34971273!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #click send: #value to:[			].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 17:02' prior: 34973018!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #click send: #value to:[		puedeingresar ifFalse:[^nil].			].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 17:04' prior: 34974736!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #click send: #value to:[		puedeingresar ifFalse:[^nil].		temp contents:temp contents, i asString.	].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !ATM new.!ATM new.!atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 17:08' prior: 34976486!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #click send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].			].]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 17:10' prior: 34978315!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #click send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].			].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(160@10).controles addMorph:enter."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 17:10' prior: 34980186!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #click send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].			].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(10@160).controles addMorph:enter."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 17:14' prior: 34982150!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #click send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].			].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!----QUIT----{18 March 2011 . 5:15:09 pm} Squeak4.2.image priorSource: 1397754!----STARTUP----{18 March 2011 . 11:04:32 pm} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.2.image!atm _ ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 23:07'!controlarEnter! !!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 23:08' prior: 34955624!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/18/2011 23:08' prior: 34986301!controlarEnterpuedeingresar:=false.		0=accion ifTrue:[^self menuPrincipal].		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=((temp contents) asInteger)ifTrue:[^self mostrarSaldo].			2=((temp contents) asInteger)ifTrue:[^self pantallaRetiro].			3=((temp contents) asInteger)ifTrue:[^self pantallaDeposito].			4=((temp contents) asInteger)ifTrue:[^self salir].			^self menuPrincipal.			].		4=accion ifTrue:[^self validarRetiro].		5=accion ifTrue:[^self pedirIngreso].		"mensajes"		10=accion ifTrue:[^self pantallaRetiro].! !atm _ ATM new.!atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 23:10' prior: 34984131!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #click send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].			].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.b on: #click send: #value to:[			]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 23:11' prior: 34987413!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #click send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].			].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.b on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 23:11' prior: 34989415!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #click send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].			].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/18/2011 23:18' prior: 34991478!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #click send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!KeyButton removeSelector: #handlesKeyboard:!KeyButton removeSelector: #hasFocus!KeyButton removeSelector: #keyStroke:!KeyButton removeSelector: #keyboardFocusChange:!!KeyButton methodsFor: 'nil' stamp: 'agb 3/19/2011 00:12'!stepTime   ^interval ! !!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:13'!interval   ^interval ! !!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:13' prior: 34995858!interval   ^interval ! !!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:13'!interval: aNumber   interval _ aNumber! !!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:14'!step self position:self position + (2@2).! !key:=KeyButton new.!key openInWorld.!!KeyButton methodsFor: 'nil' stamp: 'agb 3/19/2011 00:16'!initializesuper initialize.interval:=1000.! !key:=KeyButton new openInWorld.!key startStepping.!key interval:500.!key interval:100.!!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:21' prior: 34996194!step Transcript show:'una vez!! '.! !key:=KeyButton new openInWorld.!key stopStepping.!key interval:100000.!key startStepping.!key1:=KeyButton new openInWorld.!!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:27' prior: 34996340!initializesuper initialize.self stopStepping.interval:=1000.! !!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:27' prior: 34996837!initializesuper initialize.self stopStepping.interval:=10000.! !key1:=KeyButton new openInWorld.!!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:28' prior: 34996995!initializesuper initialize.self stop.interval:=10000.! !key1:=KeyButton new openInWorld.!!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:28' prior: 34997189!initializesuper initialize.self stop.interval:=1000.! !!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:28' prior: 34997375!initializesuper initialize.self stop.interval:=100.! !key1:=KeyButton new openInWorld.!atm _ ATM new.!!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:31' prior: 34997525!initializesuper initialize.! !key1:=KeyButton new openInWorld.!!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:31' prior: 34997726!initializeself stopStepping.super initialize.! !KeyButton removeSelector: #interval!KeyButton removeSelector: #interval:!!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:32' prior: 34997885!initializeself stopStepping.interval:=1000.super initialize.! !!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:32' prior: 34998105!initializesuper initialize.self stopStepping.interval:=1000.! !key1:=KeyButton new openInWorld.!!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:33' prior: 34998264!initializesuper initialize.interval:=1000.self stopStepping.! !key1:=KeyButton new openInWorld.!!KeyButton methodsFor: 'nil' stamp: 'agb 3/19/2011 00:33'!interval:aNumberinterval:=aNumber! !key1:=KeyButton new openInWorld.!!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:34'!interval^interval! !key1:=KeyButton new openInWorld.!key:=KeyButton new openInWorld.!!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:34' prior: 34998458!initializesuper initialize.interval:=1000.self stop.! !key:=KeyButton new openInWorld.!!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:35' prior: 34998951!initializesuper initialize.interval:=1000.self stopStepping.! !!KeyButton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:36' prior: 34998621!interval: aNumberinterval_ aNumber! !key:=KeyButton new openInWorld.!atm _ ATM new.!RectangleMorph subclass: #PanelRetiro	instanceVariableNames: 'interval'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!PanelRetiro methodsFor: 'nil' stamp: 'agb 3/19/2011 00:41'!initializesuper initialize.interval:=1000.self stopStepping.! !!PanelRetiro methodsFor: 'nil' stamp: 'agb 3/19/2011 00:42'!interval^interval! !!PanelRetiro methodsFor: 'nil' stamp: 'agb 3/19/2011 00:42'!interval: aNumberinterval_ aNumber! !!PanelRetiro methodsFor: 'nil' stamp: 'agb 3/19/2011 00:42'!step Transcript show:'una vez!! '.! !!PanelRetiro methodsFor: 'nil' stamp: 'agb 3/19/2011 00:42'!stepTime   ^interval ! !Smalltalk removeClassNamed: #KeyButton!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:45' prior: 34993545!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #click send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel retiro"pretiro:= PanelRetiro new.pretiro position:180@210.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !!PanelRetiro methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:45' prior: 34999586!initializesuper initialize.self extent:300@100.self borderWidth:0.self color:(Color r: 0.972 g: 0.972 b: 0.944).interval:=1000.self stopStepping.! !key:=PanelRetiro new openInWorld.!RectangleMorph subclass: #PanelRetiro	instanceVariableNames: 'interval atm'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!PanelRetiro methodsFor: 'inicial' stamp: 'agb 3/19/2011 00:47'!atm^atm! !!PanelRetiro methodsFor: 'inicial' stamp: 'agb 3/19/2011 00:47'!atm:aATMatm:=aATM.! !ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 00:51' prior: 35000149!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel retiro"pretiro:= PanelRetiro new.pretiro position:180@210.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 00:52' prior: 34902003!salirusuario:=nil.self pedirNumeroCuenta.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 00:53' prior: 35004658!salirself pedirNumeroCuenta.! !atm _ ATM new.!atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 00:54' prior: 35004799!salirusuario vaciar.self pedirNumeroCuenta.! !!Usuario methodsFor: 'nil' stamp: 'agb 3/19/2011 00:55'!vaciarpin:=0.cuenta:=0.monto:=0.nombre:=''.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 00:59' prior: 34898608!validarUsuario|n user|usuario pin: temp contents.n:=usuarios size.Transcript show:usuario cuenta.1to:n do:[:i|		user:=usuarios at:i.		((user cuenta) = (usuario cuenta))&((user pin) = (usuario pin))		ifTrue:[				usuario:=user.				^self menuPrincipal.			].	].^self pedirNumeroCuenta.! !atm _ ATM new.!atm _ ATM new.!!PanelRetiro methodsFor: 'inicial' stamp: 'agb 3/19/2011 01:02' prior: 35002104!initializesuper initialize.self extent:300@100.self borderWidth:0.self color:(Color r: 0.972 g: 0.972 b: 0.944).self stopStepping.interval:=1000.! !atm _ ATM new.!!PanelRetiro methodsFor: 'inicial' stamp: 'agb 3/19/2011 01:03' prior: 35005607!initializesuper initialize.self extent:300@100.self borderWidth:0.self color:(Color r: 0.972 g: 0.972 b: 0.944).self stopStepping.interval:=1000.! !!PanelRetiro methodsFor: 'inicial' stamp: 'agb 3/19/2011 01:04' prior: 35005861!initializesuper initialize.self extent:300@100.self borderWidth:0.self color:(Color r: 0.972 g: 0.972 b: 0.944).self stop.interval:=1000.! !atm _ ATM new.!----SNAPSHOT----{19 March 2011 . 1:31:55 am} Squeak4.2.image priorSource: 1431594!----QUIT----{19 March 2011 . 1:32:02 am} Squeak4.2.image priorSource: 1451830!----STARTUP----{19 March 2011 . 11:16:04 am} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.2.image!!ATM methodsFor: 'validaciones' stamp: 'agb 3/19/2011 11:20' prior: 35005194!validarUsuario|n user|usuario pin: temp contents.n:=usuarios size.1to:n do:[:i|		user:=usuarios at:i.		((user cuenta) = (usuario cuenta))&((user pin) = (usuario pin))		ifTrue:[				usuario:=user.				^self menuPrincipal.			].	].^self pedirNumeroCuenta.! !!ATM methodsFor: 'validaciones' stamp: 'agb 3/19/2011 11:21' prior: 35006625!validarUsuario|n user|usuario pin: temp contents.n:=usuarios size.1to:n do:[:i|		user:=usuarios at:i.		((user cuenta) = (usuario cuenta))&((user pin) = (usuario pin))		ifTrue:[				usuario:=user.				Transcript show:'entre comparando ',(user cuenta) asString,' con ', (usuario cuenta) asString. 				^self menuPrincipal.			].	].^self pedirNumeroCuenta.! !atm _ ATM new.!!ATM methodsFor: 'validaciones' stamp: 'agb 3/19/2011 11:27' prior: 35006969!validarUsuario|n user|usuario pin: temp contents.n:=usuarios size.1to:n do:[:i|		user:=usuarios at:i.		((user cuenta) = (usuario cuenta))&((user pin) = (usuario pin))		ifTrue:[				usuario nombre:user nombre.				usuario monto:user monto.				^self menuPrincipal.			].	].^self pedirNumeroCuenta.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:29'!print:aString position:aPoint size:aSize|text|text:= StringMorph new.text fontName:'Sans' size:aSize.text contents:aString.text position:(pantalla position) + aPoint.pantalla addMorph:text.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:29' prior: 34896062!menuPrincipalself limpiarPantalla.self print:'Menu Principal' position:10@20size:20.self print:'1 - Ver Saldo' position:50@40.self print:'2 - Retirar dinero' position:50@60.self print:'3 - Depositar dinero' position:50@80.self print:'4 - Salir' position:50@100.self print:'Elija una opcion:' position:10@120.self read:110@120.accion:=3.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:31' prior: 35008093!menuPrincipalself limpiarPantalla.self print:'Menu Principal' position:10@20size:20.self print:'1 - Ver Saldo' position:50@50.self print:'2 - Retirar dinero' position:50@70.self print:'3 - Depositar dinero' position:50@90.self print:'4 - Salir' position:50@110.self print:'Elija una opcion:' position:10@130.self read:110@120.accion:=3.! !atm _ ATM new.!!PanelRetiro methodsFor: 'inicial' stamp: 'agb 3/19/2011 11:32' prior: 35006098!initializesuper initialize.self extent:300@100.self borderWidth:0.self color:(Color r: 0.972 g: 0.972 b: 0.944).self stopStepping.interval:=1000.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:34' prior: 34889093!pedirNumeroCuentaself limpiarPantalla.self print: 'Bienvenidos' position:10@10 size:20.self print: 'Por favor ingrese su numero de cuenta:' position:10@40.self read:10@50.accion:=1.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:35' prior: 35009233!pedirNumeroCuentaself limpiarPantalla.self print: 'Bienvenidos' position:10@10 size:20.self print: 'Por favor ingrese su numero de cuenta:' position:10@40.self read:210@40.accion:=1.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:35' prior: 35009517!pedirNumeroCuentaself limpiarPantalla.self print: 'Bienvenidos' position:10@10 size:20.self print: 'Por favor ingrese su numero de cuenta:' position:10@40.self read:300@40.accion:=1.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:35' prior: 35009802!pedirNumeroCuentaself limpiarPantalla.self print: 'Bienvenidos' position:10@10 size:20.self print: 'Por favor ingrese su numero de cuenta:' position:10@40.self read:250@40.accion:=1.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:35' prior: 35010087!pedirNumeroCuentaself limpiarPantalla.self print: 'Bienvenidos' position:10@10 size:20.self print: 'Por favor ingrese su numero de cuenta:' position:10@40.self read:255@40.accion:=1.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:35' prior: 34874166!pedirPinusuario cuenta: temp contents.self print: 'Ingrese su PIN:' position:10@60.self read:10@80.accion:=2.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:36' prior: 35010657!pedirPinusuario cuenta: temp contents.self print: 'Ingrese su PIN:' position:10@80.self read:180@80.accion:=2.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:36' prior: 35010851!pedirPinusuario cuenta: temp contents.self print: 'Ingrese su PIN:' position:10@60.self read:180@60.accion:=2.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:36' prior: 35011063!pedirPinusuario cuenta: temp contents.self print: 'Ingrese su PIN:' position:10@60.self read:120@60.accion:=2.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:37' prior: 35011275!pedirPinusuario cuenta: temp contents.self print: 'Ingrese su PIN:' position:10@70.self read:100@70.accion:=2.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:37' prior: 35011487!pedirPinusuario cuenta: temp contents.self print: 'Ingrese su PIN:' position:10@65.self read:100@65.accion:=2.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:38' prior: 34900637!mostrarSaldoself limpiarPantalla.self print:'El saldo de su cuenta es: $', ((usuario monto) asString) position:120@40 size:20.self print:'Presione enter para regresar.' position:120@60.puedeingresar:=true.accion:=0.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:39' prior: 35011911!mostrarSaldoself limpiarPantalla."self print:'El saldo de su cuenta es: $', ((usuario monto) asString) position:120@40 size:20."self print:'Presione enter para regresar.' position:120@60.puedeingresar:=true.accion:=0.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:39' prior: 35012229!mostrarSaldoself limpiarPantalla."self print:'El saldo de su cuenta es: $', ((usuario monto) asString) position:120@40 size:20."self print:'Presione enter para regresar.' position:120@60.puedeingresar:=true.accion:=0.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 11:39' prior: 35002698!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel retiro"pretiro:= PanelRetiro new.pretiro position:180@210.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self mostrarSaldo.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:40' prior: 35012533!mostrarSaldoself limpiarPantalla."self print:'El saldo de su cuenta es: $', ((usuario monto) asString) position:120@40 size:20."self print:'El saldo de su cuenta es: $200' position:120@40 size:20.self print:'Presione enter para regresar.' position:120@60.puedeingresar:=true.accion:=0.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:40' prior: 35014799!mostrarSaldoself limpiarPantalla."self print:'El saldo de su cuenta es: $', ((usuario monto) asString) position:120@40 size:20."self print:'El saldo de su cuenta es: $200' position:100@60 size:20.self print:'Presione enter para regresar.' position:120@60.puedeingresar:=true.accion:=0.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:40' prior: 35015188!mostrarSaldoself limpiarPantalla."self print:'El saldo de su cuenta es: $', ((usuario monto) asString) position:120@40 size:20."self print:'El saldo de su cuenta es: $200' position:100@50 size:20.self print:'Presione enter para regresar.' position:120@60.puedeingresar:=true.accion:=0.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:41' prior: 35015577!mostrarSaldoself limpiarPantalla."self print:'El saldo de su cuenta es: $', ((usuario monto) asString) position:120@40 size:20."self print:'El saldo de su cuenta es: $200' position:100@50 size:20.self print:'Presione enter para regresar.' position:120@80.puedeingresar:=true.accion:=0.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:41' prior: 35015966!mostrarSaldoself limpiarPantalla."self print:'El saldo de su cuenta es: $', ((usuario monto) asString) position:120@40 size:20."self print:'El saldo de su cuenta es: $200' position:100@60 size:20.self print:'Presione enter para regresar.' position:120@80.puedeingresar:=true.accion:=0.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:41' prior: 35016355!mostrarSaldoself limpiarPantalla."self print:'El saldo de su cuenta es: $', ((usuario monto) asString) position:120@40 size:20."self print:'El saldo de su cuenta es: $200' position:110@60 size:20.self print:'Presione enter para regresar.' position:130@80.puedeingresar:=true.accion:=0.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:41' prior: 35016744!mostrarSaldoself limpiarPantalla."self print:'El saldo de su cuenta es: $', ((usuario monto) asString) position:120@40 size:20."self print:'El saldo de su cuenta es: $200' position:105@60 size:20.self print:'Presione enter para regresar.' position:125@80.puedeingresar:=true.accion:=0.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:42' prior: 35017133!mostrarSaldoself limpiarPantalla."self print:'El saldo de su cuenta es: $', ((usuario monto) asString) position:120@40 size:20."self print:'El saldo de su cuenta es: $200' position:110@60 size:20.self print:'Presione enter para regresar.' position:130@80.puedeingresar:=true.accion:=0.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:43' prior: 35017522!mostrarSaldoself limpiarPantalla.self print:'El saldo de su cuenta es: $', ((usuario monto) asString) position:110@60 size:20.self print:'Presione enter para regresar.' position:130@80.puedeingresar:=true.accion:=0.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 11:43' prior: 35012844!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel retiro"pretiro:= PanelRetiro new.pretiro position:180@210.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self menuPrincipal.self openInWorld.! !atm _ ATM new.!!PanelRetiro methodsFor: 'inicial' stamp: 'agb 3/19/2011 11:44' prior: 35008983!initializesuper initialize.self extent:300@100.self borderWidth:0.self color:(Color r: 0.972 g: 0.972 b: 0.944).self stopStepping.interval:=1000.self stopStepping.! !atm _ ATM new.!!PanelRetiro methodsFor: 'timer' stamp: 'agb 3/19/2011 11:44' prior: 34999897!step ! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:46' prior: 35008536!menuPrincipalself limpiarPantalla.self print:'Menu Principal' position:10@10size:20.self print:'1 - Ver Saldo' position:50@50.self print:'2 - Retirar dinero' position:50@70.self print:'3 - Depositar dinero' position:50@90.self print:'4 - Salir' position:50@110.self print:'Elija una opcion:' position:10@130.self read:110@120.accion:=3.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:47' prior: 35020536!menuPrincipalself limpiarPantalla.self print:'Menu Principal' position:10@10size:20.self print:'1 - Ver Saldo' position:50@40.self print:'2 - Retirar dinero' position:50@60.self print:'3 - Depositar dinero' position:50@80.self print:'4 - Salir' position:50@100.self print:'Elija una opcion:' position:10@120.self read:110@120.accion:=3.! !atm _ ATM new.!atm _ ATM new.!atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 11:51' prior: 35018203!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.595 g: 0.595 b: 0.599)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.627 g: 0.627 b: 0.63).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.944).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel retiro"pretiro:= PanelRetiro new.pretiro position:180@210.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:51' prior: 35010372!pedirNumeroCuentaself limpiarPantalla.self print: 'Bienvenidos' position:100@10 size:20.self print: 'Por favor ingrese su numero de cuenta:' position:100@40.self read:355@40.accion:=1.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:51' prior: 35023407!pedirNumeroCuentaself limpiarPantalla.self print: 'Bienvenidos' position:500@10 size:20.self print: 'Por favor ingrese su numero de cuenta:' position:50@40.self read:305@40.accion:=1.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 11:52' prior: 35023694!pedirNumeroCuentaself limpiarPantalla.self print: 'Bienvenidos' position:50@10 size:20.self print: 'Por favor ingrese su numero de cuenta:' position:50@40.self read:305@40.accion:=1.! !atm _ ATM new.!atm _ ATM new.!atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 12:03' prior: 35021464!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel retiro"pretiro:= PanelRetiro new.pretiro position:180@210.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.944).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 12:04' prior: 33559059!initializeenabled_ true.super initialize.self color:(Color r: 0.784 g: 0.94 b: 0.976).! !atm _ ATM new.!!PanelRetiro methodsFor: 'inicial' stamp: 'agb 3/19/2011 12:07' prior: 35020163!initializesuper initialize.self extent:300@100.self borderWidth:0.self color:(Color r: 0.972 g: 0.972 b: 0.976).self stopStepping.interval:=1000.self stopStepping.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 12:07' prior: 35024307!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel retiro"pretiro:= PanelRetiro new.pretiro position:180@210.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.976).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:09' prior: 35023980!pedirNumeroCuentaself limpiarPantalla.self print: 'Bienvenidos' position:50@10 size:20.self print: 'Por favor ingrese su numero de cuenta:' position:50@40.self read:285@40.accion:=1.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:09' prior: 35028689!pedirNumeroCuentaself limpiarPantalla.self print: 'Bienvenidos' position:50@10 size:20.self print: 'Por favor ingrese su numero de cuenta:' position:50@40.self read:295@40.accion:=1.! !atm _ ATM new.!atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 12:12' prior: 35026711!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].		b push.	].	b on: #mouseUp send: #value to:[b pop.].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel retiro"pretiro:= PanelRetiro new.pretiro position:180@210.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.976).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 12:12' prior: 35029284!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].		self push.	].	b on: #mouseUp send: #value to:[self pop.].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel retiro"pretiro:= PanelRetiro new.pretiro position:180@210.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.976).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 12:13' prior: 35031305!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].	b on: #mouseUp send: #value to:[b pop.].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel retiro"pretiro:= PanelRetiro new.pretiro position:180@210.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.976).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 12:13' prior: 35033332!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].		b push.	].	b on: #mouseUp send: #value to:[b pop.].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel retiro"pretiro:= PanelRetiro new.pretiro position:180@210.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.976).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 12:14' prior: 35035343!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel retiro"pretiro:= PanelRetiro new.pretiro position:180@210.self addMorph:pretiro."panel deposito"pdeposito:= RectangleMorph new.pdeposito position:180@320.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.976).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:14' prior: 35011699!pedirPinusuario cuenta: temp contents.self print: 'Ingrese su PIN:' position:50@65.self read:140@65.accion:=2.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:37' prior: 35020979!menuPrincipalself limpiarPantalla.self print:'Menu Principal' position:50@10size:20.self print:'1 - Ver Saldo' position:70@40.self print:'2 - Retirar dinero' position:70@60.self print:'3 - Depositar dinero' position:70@80.self print:'4 - Salir' position:70@100.self print:'Elija una opcion:' position:50@120.self read:150@120.accion:=3.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:38' prior: 34906895!pantallaRetiroself limpiarPantalla.self print:'Menu Retiro' position:50@10 size:20.self print:'1 - $20' position:50@50.self print:'2 - $40' position:50@70.self print:'3 - $60' position:50@90.self print:'4 - $100' position:150@50.self print:'5 - $200' position:150@70.self print:'6 - Cancelar Transaccion' position:150@90.self print:'Elija una opcion:' position:10@120.self read:110@120.accion:=4.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:40' prior: 35039963!pantallaRetiroself limpiarPantalla.self print:'Menu Retiro' position:50@10 size:20.self print:'1 - $20' position:50@40.self print:'2 - $40' position:50@60.self print:'3 - $60' position:50@80.self print:'4 - $100' position:150@40.self print:'5 - $200' position:150@60.self print:'6 - Cancelar Transaccion' position:150@80.self print:'Elija una opcion:' position:50@120.self read:150@120.accion:=4.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:40' prior: 35040468!pantallaRetiroself limpiarPantalla.self print:'Menu Retiro' position:50@10 size:20.self print:'1 - $20' position:50@40.self print:'2 - $40' position:50@60.self print:'3 - $60' position:50@80.self print:'4 - $100' position:150@40.self print:'5 - $200' position:150@60.self print:'6 - Cancelar Transaccion' position:150@80.self print:'Elija una opcion:' position:50@100.self read:150@100.accion:=4.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:41' prior: 35040956!pantallaRetiroself limpiarPantalla.self print:'Menu Retiro' position:50@10 size:20.self print:'1 - $20' position:50@40.self print:'2 - $40' position:50@60.self print:'3 - $60' position:50@80.self print:'4 - $100' position:150@40.self print:'5 - $200' position:150@60.self print:'6 - Cancelar Transaccion' position:150@80.self print:'Elija una opcion:' position:50@110.self read:150@110.accion:=4.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:42' prior: 34941549!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'Por favor retire su dinero!!.'position:50@50 size:20.dinero:=Fajo new.dinero atm:self.dinero de:(cantidad) position:pretiro position+(50@50) contenedor:pdeposito.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:43' prior: 35041932!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'Por favor retire su dinero!!.'position:110@60 size:20.dinero:=Fajo new.dinero atm:self.dinero de:(cantidad) position:pretiro position+(50@50) contenedor:pdeposito.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:44' prior: 35042323!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'Por favor retire su dinero!!.'position:110@60 size:20.self print:'Tome su dinero para continuar.' position:130@80.dinero:=Fajo new.dinero atm:self.dinero de:(cantidad) position:pretiro position+(50@50) contenedor:pdeposito.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:46' prior: 35042715!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'Por favor retire su dinero!!.'position:120@60 size:20.self print:'Tome su dinero para continuar.' position:130@80.dinero:=Fajo new.dinero atm:self.dinero de:(cantidad) position:pretiro position+(50@50) contenedor:pdeposito.! !atm _ ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/19/2011 12:48' prior: 34986705!controlarEnterpuedeingresar:=false.		0=accion ifTrue:[^self menuPrincipal].		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=((temp contents) asInteger)ifTrue:[^self mostrarSaldo].			2=((temp contents) asInteger)ifTrue:[^self pantallaRetiro].			3=((temp contents) asInteger)ifTrue:[^self pantallaDeposito].			4=((temp contents) asInteger)ifTrue:[^self salir].			^self menuPrincipal.			].		4=accion ifTrue:[^self validarRetiro].		5=accion ifTrue:[			0=accion ifTrue:[^self menuPrincipal].			^self pedirIngreso			].		"mensajes"		10=accion ifTrue:[^self pantallaRetiro].! !!ATM methodsFor: 'eventos' stamp: 'agb 3/19/2011 12:48' prior: 35043651!controlarEnterpuedeingresar:=false.		0=accion ifTrue:[^self menuPrincipal].		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=((temp contents) asInteger)ifTrue:[^self mostrarSaldo].			2=((temp contents) asInteger)ifTrue:[^self pantallaRetiro].			3=((temp contents) asInteger)ifTrue:[^self pantallaDeposito].			4=((temp contents) asInteger)ifTrue:[^self salir].			^self menuPrincipal.			].		4=accion ifTrue:[^self validarRetiro].		5=accion ifTrue:[			0=((temp contents) asInteger) ifTrue:[^self menuPrincipal].			^self pedirIngreso			].		"mensajes"		10=accion ifTrue:[^self pantallaRetiro].! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:56' prior: 34955402!pantallaDepositoself limpiarPantalla.self print:'Deposito de dinero' position:50@10 size:20.self print:'Ingrese Monto de Deposito (o cero para cancelar): ' position:50@40.self read:150@120.accion:=5.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:56' prior: 35045100!pantallaDepositoself limpiarPantalla.self print:'Deposito de dinero' position:50@10 size:20.self print:'Ingrese Monto de Deposito (o cero para cancelar): ' position:50@40.self read:550@40.accion:=5.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:57' prior: 35045402!pantallaDepositoself limpiarPantalla.self print:'Deposito de dinero' position:50@10 size:20.self print:'Ingrese Monto de Deposito (o cero para cancelar): ' position:50@40.self read:350@40.accion:=5.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:57' prior: 35045686!pantallaDepositoself limpiarPantalla.self print:'Deposito de dinero' position:50@10 size:20.self print:'Ingrese Monto de Deposito (o cero para cancelar): ' position:50@40.self read:360@40.accion:=5.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:58' prior: 34957777!pedirIngresoself print:'Ingrese el dinero en la ranura de deposito.' position:50@60.valoringresado:=0.puedeingresar:=false.aceptaingresos:=true.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:58' prior: 34960750!depositoCompletousuario monto:(usuario monto) + valoringresado.self print:'Ingreso exitoso!!' position:150@80 size:20.self print:'Presione enter para regresar.' position:120@90.puedeingresar:=true.accion:=0.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 12:59' prior: 35046484!depositoCompletousuario monto:(usuario monto) + valoringresado.self print:'Ingreso exitoso!!' position:160@80 size:20.self print:'Presione enter para regresar.' position:125@100.puedeingresar:=true.accion:=0.! !atm _ ATM new.!atm _ ATM new.!atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 13:04' prior: 35046778!depositoCompletousuario monto:(usuario monto) + valoringresado.self print:'Ingreso exitoso!!' position:160@80 size:20.self print:'Presione enter para regresar.' position:125@100.aceptaingresos:=false.puedeingresar:=true.accion:=0.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 13:05' prior: 35047124!depositoCompletousuario monto:(usuario monto) + valoringresado.self print:'Ingreso exitoso!!' position:160@80 size:20.self print:'Presione enter para regresar.' position:130@100.aceptaingresos:=false.puedeingresar:=true.accion:=0.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 13:19' prior: 35037364!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pretiro:= PanelDeposito new.pretiro position:180@320.self addMorph:pretiro."panel retiro"pdeposito:= RectangleMorph new.pdeposito position:180@210.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.976).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 13:19' prior: 35047802!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pretiro:= PanelDeposito new.pretiro position:180@320.self addMorph:pretiro."panel retiro"pdeposito:= RectangleMorph new.pdeposito position:180@210.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.976).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 13:22' prior: 35049756!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pretiro:= PanelDeposito new.pretiro position:180@320.self addMorph:pretiro."panel retiro"pdeposito:= RectangleMorph new.pdeposito position:180@210.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.976).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 13:22' prior: 35051727!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pretiro:= PanelDeposito new.pretiro position:180@320.self addMorph:pretiro."panel retiro"pdeposito:= RectangleMorph new.self print:'Retire su dinero aqui.'position:190@220.pdeposito position:180@210.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.976).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/19/2011 13:24'!print:aString position:aPoint en:aMorph|text|text:= StringMorph new.text fontName:'Sans' size:18.text contents:aString.text position:aPoint.aMorph addMorph:text.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 13:24' prior: 35053682!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pretiro:= PanelDeposito new.pretiro position:180@320.self addMorph:pretiro."panel retiro"pdeposito:= RectangleMorph new.self print:'Retire su dinero aqui.'position:190@220en:pdeposito.pdeposito position:180@210.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.976).self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 13:25' prior: 35055955!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pretiro:= PanelDeposito new.pretiro position:180@320.self addMorph:pretiro."panel retiro"pdeposito:= RectangleMorph new.pdeposito position:180@210.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.976).self print:'Retire su dinero aqui.'position:190@220en:pdeposito.self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 13:25' prior: 35057991!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pretiro:= PanelDeposito new.pretiro position:180@320.self addMorph:pretiro."panel retiro"pdeposito:= RectangleMorph new.pdeposito position:180@210.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.976).self print:'Retire su dinero aqui.'position:0@0en:World.self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 13:26' prior: 35060010!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pretiro:= PanelDeposito new.pretiro position:180@320.self addMorph:pretiro."panel retiro"pdeposito:= RectangleMorph new.pdeposito position:180@210.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.976).self print:'Retire su dinero aqui.'position:0@0en:pdeposito.self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 13:26' prior: 35062038!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pretiro:= PanelDeposito new.pretiro position:180@320.self addMorph:pretiro."panel retiro"pdeposito:= RectangleMorph new.pdeposito position:180@210.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.976).self print:'Retire su dinero aqui.'position:180@210en:pdeposito.self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 13:26' prior: 35064070!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pretiro:= PanelDeposito new.pretiro position:180@320.self addMorph:pretiro."panel retiro"pdeposito:= RectangleMorph new.pdeposito position:180@210.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.976).self print:'Retire su dinero aqui.'position:200@240en:pdeposito.self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 13:27' prior: 35066106!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pretiro:= PanelDeposito new.pretiro position:180@320.self addMorph:pretiro."panel retiro"pdeposito:= RectangleMorph new.pdeposito position:220@210.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.976).self print:'Retire su dinero aqui.'position:200@240en:pdeposito.self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/19/2011 13:27' prior: 35068142!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pretiro:= PanelDeposito new.pretiro position:180@320.self addMorph:pretiro."panel retiro"pdeposito:= RectangleMorph new.pdeposito position:180@210.pdeposito extent:300@100.pdeposito borderWidth:0.pdeposito color:(Color r: 0.972 g: 0.972 b: 0.976).self print:'Retire su dinero aqui.'position:210@240en:pdeposito.self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!----QUIT----{19 March 2011 . 1:28:20 pm} Squeak4.2.image priorSource: 1451914!----STARTUP----{20 March 2011 . 1:48:50 am} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.2.image!atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/20/2011 01:57' prior: 35043185!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'Por favor retire su dinero!!.'position:120@60 size:20.self print:'Tome su dinero para continuar.' position:130@80.dinero:=Fajo new.dinero atm:self.dinero de:(cantidad) position:pretiro position+(50@50) contenedor:pretiro.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:00' prior: 35070178!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pretiro."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).self print:'Retire su dinero aqui.'position:210@240en:pdeposito.self addMorph:pdeposito.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:01' prior: 35072898!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).self print:'Retire su dinero aqui.'position:210@240en:pdeposito.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:07' prior: 35074911!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).self print:'Retire su dinero aqui.'position:210@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:09' prior: 35076941!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).self print:'Retire su dinero aqui.'position:250@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:09' prior: 35078986!initialize|b inicial alto ancho|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!Fajo methodsFor: 'iniciales' stamp: 'agb 3/20/2011 02:11' prior: 34951717!de:aNumber position:aPoint contenedor:aMorph|billete pinicial n|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=aPoint.n:=(aNumber/20).1to:n do:[:i|		billete:=Billete new.		billetes add:billete.		billete position:pinicial.		billete contenedor:aMorph.		billete atm:atm.		self addMorphBack:billete.		pinicial:=pinicial+(0@10).].self extent:0@0.self openInWorld.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/20/2011 02:12' prior: 35072422!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'Por favor retire su dinero!!.'position:120@60 size:20.self print:'Tome su dinero para continuar.' position:130@80.dinero:=Fajo new.dinero atm:self.dinero de:(cantidad) position:pretiro position+(50@50) contenedor:pretiro.self addMorph:dinero.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:13' prior: 35081014!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:14' prior: 35084000!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro:= RectangleMorph new.a:=RectangleMorph new.a position:235@260.a extent:260@20.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:15' prior: 35086013!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro:= RectangleMorph new.a:=RectangleMorph new.a position:235@260.a extent:260@20.self addMorph:a.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:16' prior: 35088103!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).pretiro:= RectangleMorph new.a:=RectangleMorph new.a position:200@260.a extent:260@10.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:16' prior: 35090210!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a position:200@260.a extent:260@10.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:18' prior: 35092303!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:190@210.pretiro extent:280@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a position:200@260.a extent:260@10.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:18' prior: 35094413!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:18@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a position:200@260.a extent:260@10.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:19' prior: 35096506!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:18@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a position:210@260.a extent:240@10.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:19' prior: 35098598!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:18@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a position:210@260.a extent:250@10.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:19' prior: 35100690!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a position:210@260.a extent:250@10.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:20' prior: 35102799!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a position:210@260.a extent:240@10.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:20' prior: 35104909!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a position:210@260.a extent:240@6.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:20' prior: 35107019!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:0.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/20/2011 02:22' prior: 35083502!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'Por favor retire su dinero!!.'position:120@60 size:20.self print:'Tome su dinero para continuar.' position:130@80.dinero:=Fajo new.dinero atm:self.dinero de:(cantidad) position:pretiro position+(50@40) contenedor:pretiro.self addMorph:dinero.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/20/2011 02:22' prior: 35111229!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'Por favor retire su dinero!!.'position:120@60 size:20.self print:'Tome su dinero para continuar.' position:130@80.dinero:=Fajo new.dinero atm:self.dinero de:(cantidad) position:pretiro position+(60@35) contenedor:pretiro.self addMorph:dinero.! !atm _ ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/20/2011 02:23' prior: 35111719!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'Por favor retire su dinero!!.'position:120@60 size:20.self print:'Tome su dinero para continuar.' position:130@80.dinero:=Fajo new.dinero atm:self.dinero de:(cantidad) position:pretiro position+(60@37) contenedor:pretiro.self addMorph:dinero.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/20/2011 02:23' prior: 35112209!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'Por favor retire su dinero!!.'position:120@60 size:20.self print:'Tome su dinero para continuar.' position:130@80.dinero:=Fajo new.dinero atm:self.dinero de:(cantidad) position:pretiro position+(60@38) contenedor:pretiro.self addMorph:dinero.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/20/2011 02:24' prior: 35112682!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self limpiarPantalla.self print:'Por favor retire su dinero!!.'position:120@60 size:20.self print:'Tome su dinero para continuar.' position:130@80.dinero:=Fajo new.dinero atm:self.dinero de:(cantidad) position:pretiro position+(60@36) contenedor:pretiro.self addMorph:dinero.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:34' prior: 35109128!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 02:34' prior: 35113636!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!----QUIT----{20 March 2011 . 3:06:14 am} Squeak4.2.image priorSource: 1517696!----STARTUP----{20 March 2011 . 12:52:24 pm} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.2.image!atm _ ATM new.!!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/20/2011 12:54' prior: 35026452!initialize|a|super initialize.self extent:300@100.self borderWidth:0.self color:(Color r: 0.972 g: 0.972 b: 0.976).self stopStepping.interval:=1000.self stopStepping.! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/20/2011 12:56' prior: 35118096!initialize|a|super initialize.self extent:300@100.self borderWidth:0.self color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.self addMorph:a.self print:'Retire su dinero aqui.'position:255@350en:self.self stopStepping.interval:=1000.self stopStepping.! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/20/2011 12:57' prior: 35118357!initialize|a|super initialize.self extent:300@100.self borderWidth:0.self color:(Color r: 0.972 g: 0.972 b: 0.976).self stopStepping.interval:=1000.self stopStepping.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 12:58' prior: 35115728!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Retire su dinero aqui.'position:255@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:00' prior: 35119061!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:255@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:00' prior: 35121404!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:250@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:00' prior: 35123739!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:240@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:01' prior: 35126091!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #mouseDown send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!----SNAPSHOT----{20 March 2011 . 1:01:48 pm} Squeak4.2.image priorSource: 1563363!atm _ ATM new.!ImageMorph subclass: #SobreATM	instanceVariableNames: 'atm'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!Fajo methodsFor: 'iniciales' stamp: 'agb 3/20/2011 13:15' prior: 35083033!de:aNumber position:aPoint contenedor:aMorph|billete pinicial n|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=aPoint.n:=(aNumber/20).1to:n do:[:i|		billete:=Billete new.		billetes add:billete.		billete position:pinicial.		billete contenedor:aMorph.		billete atm:atm.		self addMorph:billete.		pinicial:=pinicial+(0@10).].self extent:0@0.self openInWorld.! !!Fajo methodsFor: 'iniciales' stamp: 'agb 3/20/2011 13:15' prior: 35131013!de:aNumber position:aPoint contenedor:aMorph|billete pinicial n|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=aPoint.n:=(aNumber/20).n to:1 do:[:i|		billete:=Billete new.		billetes add:billete.		billete position:pinicial.		billete contenedor:aMorph.		billete atm:atm.		self addMorph:billete.		pinicial:=pinicial+(0@10).].self extent:0@0.self openInWorld.! !atm _ ATM new.!!Fajo methodsFor: 'iniciales' stamp: 'agb 3/20/2011 13:16' prior: 35131477!de:aNumber position:aPoint contenedor:aMorph|billete pinicial n|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=aPoint.n:=(aNumber/20).1 to:n do:[:i|		billete:=Billete new.		billetes add:billete.		billete position:pinicial.		billete contenedor:aMorph.		billete atm:atm.		self addMorphBack:billete.		pinicial:=pinicial+(0@10).].self extent:0@0.self openInWorld.! !!Fajo methodsFor: 'eventos' stamp: 'agb 3/20/2011 13:17' prior: 34950798!justDroppedInto: newOwner event: evt|n billete|atm menuPrincipal.n:=billetes size.n to:1 do:[:i|	billete:=billetes removeFirst.	World addMorph:billete.	billete handlesMouseDown:true.	].self delete.! !atm _ ATM new.!!Fajo methodsFor: 'eventos' stamp: 'agb 3/20/2011 13:21' prior: 35132426!justDroppedInto: newOwner event: evt|n billete|atm menuPrincipal.n:=billetes size.1 to:n do:[:i|	billete:=billetes removeFirst.	World addMorph:billete.	billete handlesMouseDown:true.	].self delete.! !atm _ ATM new.!!SobreATM methodsFor: 'nil' stamp: 'agb 3/20/2011 13:24'!click: evt ^nil! !!Billete methodsFor: 'eventos' stamp: 'agb 3/20/2011 13:24' prior: 34918375!click: evt ^nil! !!Billete methodsFor: 'eventos' stamp: 'agb 3/20/2011 13:24' prior: 34939020!doubleClick: evt ^nil! !!SobreATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:24'!doubleClick: evt ^nil! !!SobreATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:24'!firstClickTimedOut: evt evt hand grabMorph: self.! !!Billete methodsFor: 'eventos' stamp: 'agb 3/20/2011 13:25' prior: 34925123!handlesMouseDown: evt^ false! !!SobreATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:25'!handlesMouseDown: evt^ false! !!SobreATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:28'!justDroppedInto: newOwner event: evt|punto posicion ingresado valortotal|atm aceptaIngresos ifFalse:[^nil].ingresado:=atm valorIngresado.posicion:=contenedor position.valortotal:=((atm temp) contents)asNumber.punto:=(self position)+((self extent)/2).((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (contenedor width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (contenedor height)))ifTrue:[		].! !!SobreATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:29' prior: 35133753!justDroppedInto: newOwner event: evt|punto posicion ingresado|atm aceptaIngresos ifFalse:[^nil].ingresado:=atm valorIngresado.posicion:=contenedor position.punto:=(self position)+((self extent)/2).((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (contenedor width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (contenedor height)))ifTrue:[		].! !!SobreATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:29' prior: 35134273!justDroppedInto: newOwner event: evt|punto posicion ingresado|atm aceptaIngresos ifFalse:[^nil].posicion:=contenedor position.punto:=(self position)+((self extent)/2).((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (contenedor width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (contenedor height)))ifTrue:[		].! !!SobreATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:29' prior: 35134739!justDroppedInto: newOwner event: evt|punto posicion|atm aceptaIngresos ifFalse:[^nil].posicion:=contenedor position.punto:=(self position)+((self extent)/2).((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (contenedor width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (contenedor height)))ifTrue:[		].! !!SobreATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:29'!mouseDown: evt	evt hand waitForClicksOrDrag: self event: evt selectors: { #click:. #doubleClick:. #firstClickTimedOut:. nil} threshold: 5! !!Fajo methodsFor: 'eventos' stamp: 'agb 3/20/2011 13:29' prior: 35132727!justDroppedInto: newOwner event: evt|n billete|atm menuPrincipal.n:=billetes size.1 to:n do:[:i|	billete:=billetes removeFirst.	World addMorph:billete.].self delete.! !!Fajo methodsFor: 'eventos' stamp: 'agb 3/20/2011 13:30' prior: 35135799!justDroppedInto: newOwner event: evt|n billete|atm menuPrincipal.n:=billetes size.1 to:n do:[:i|	billete:=billetes removeFirst.	World addMorph:billete.	"billete handlesMouseDown:true."].self delete.! !!Boton methodsFor: 'nil' stamp: 'agb 3/20/2011 13:36'!handlesMouseDown^true! !atm _ ATM new.!!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:36'!mouseDownself push! !!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:36'!mouseUpself pop! !atm _ ATM new.!boton _Boton new.!boton openInWorld.!!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:37'!handlesMouseDown:evt^true! !Boton removeSelector: #handlesMouseDown!!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:38'!mouseDown:evtself push! !Boton removeSelector: #mouseDown!!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:38'!mouseUp:evtself pop! !Boton removeSelector: #mouseUp!boton openInWorld.!atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:39' prior: 35128443!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b on: #click send: #value to:[		puedeingresar ifFalse:[^nil].		(i=10)ifFalse:[temp contents:temp contents, i asString.]		ifTrue:[temp contents:temp contents,'0'.].	].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:40' prior: 35136816!mouseDown:evtTranscript show:evt.self push! !atm _ ATM new.!!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:41' prior: 35139479!mouseDown:evtTranscript show:'asdf'.self push! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:41' prior: 35137129!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:41' prior: 35139784!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:42' prior: 35139631!mouseDown:evtTranscript show:'asdf'.self push! !!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:42' prior: 35144123!mouseDown:evtTranscript show:'asdf'.! !!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:43' prior: 35144261!mouseDown:evtTranscript show:'asdf'.self push.! !!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:43' prior: 35144389!mouseDown:evtTranscript show:evt.self push.! !!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:46' prior: 35144528!mouseDown:evtTranscript show:evt parent.self push.! !atm _ ATM new.!!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:46' prior: 35144664!mouseDown:evtTranscript show:evt owner.self push.! !!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:46' prior: 35144824!mouseDown:evtTranscript show:evt name.self push.! !!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:48' prior: 35144966!mouseDown:evtTranscript show:evt self.self push.! !!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:49' prior: 35145107!mouseDown:evtTranscript show:self.self push.! !!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:49' prior: 35145248!mouseDown:evtTranscript show:self name.self push.! !!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:51' prior: 35145385!mouseDown:evtclaseAccion operacionBotones:self name.self push.! !!Boton methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:51'!claseAccion:aClassclaseAccion:=aClass.! !!Boton methodsFor: 'eventos' stamp: 'agb 3/20/2011 13:53' prior: 35145527!mouseDown:evtclaseAccion operacionBotones:self.self push.! !!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:53' prior: 35141945!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter.enter on: #click send: #value to:[		puedeingresar ifTrue:[self controlarEnter.].	]."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'nil' stamp: 'agb 3/20/2011 13:54'!operacionBotones:aBotonTranscript show:aBoton.! !atm _ ATM new.!!ATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 13:55' prior: 35148080!operacionBotones:aBotonaBoton=(botones at:1)ifTrue:[Transcript show:'uno'.].! !atm _ ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 13:56' prior: 35148233!operacionBotones:aBotonpuedeingresar ifFalse:[^nil].aBoton=(botones at:1)ifTrue:[Transcript show:'uno'.].! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 13:57' prior: 35148404!operacionBotones:aBotonpuedeingresar ifFalse:[^nil].aBoton=(botones at:1)ifTrue:[temp contents:temp contents,'1'.].aBoton=(botones at:2)ifTrue:[temp contents:temp contents,'2'.].aBoton=(botones at:3)ifTrue:[temp contents:temp contents,'3'.].aBoton=(botones at:4)ifTrue:[temp contents:temp contents,'4'.].aBoton=(botones at:5)ifTrue:[temp contents:temp contents,'5'.].aBoton=(botones at:6)ifTrue:[temp contents:temp contents,'6'.].aBoton=(botones at:7)ifTrue:[temp contents:temp contents,'7'.].aBoton=(botones at:8)ifTrue:[temp contents:temp contents,'8'.].aBoton=(botones at:9)ifTrue:[temp contents:temp contents,'9'.].aBoton=(botones at:10)ifTrue:[temp contents:temp contents,'0'.].! !!ATM methodsFor: 'iniciales' stamp: 'agb 3/20/2011 13:59' prior: 35145932!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm _ ATM new.!!ATM methodsFor: 'iniciales' stamp: 'agb 3/20/2011 13:59' prior: 35149361!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 14:00' prior: 35148588!operacionBotones:aBotonpuedeingresar ifFalse:[^nil].aBoton=(botones at:1)ifTrue:[temp contents:temp contents,'1'.].aBoton=(botones at:2)ifTrue:[temp contents:temp contents,'2'.].aBoton=(botones at:3)ifTrue:[temp contents:temp contents,'3'.].aBoton=(botones at:4)ifTrue:[temp contents:temp contents,'4'.].aBoton=(botones at:5)ifTrue:[temp contents:temp contents,'5'.].aBoton=(botones at:6)ifTrue:[temp contents:temp contents,'6'.].aBoton=(botones at:7)ifTrue:[temp contents:temp contents,'7'.].aBoton=(botones at:8)ifTrue:[temp contents:temp contents,'8'.].aBoton=(botones at:9)ifTrue:[temp contents:temp contents,'9'.].aBoton=(botones at:10)ifTrue:[temp contents:temp contents,'0'.].aBoton=(botones at:10)ifTrue:[puedeingresar ifTrue:[self controlarEnter.].].! !atm _ ATM new.!atm _ ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 14:01' prior: 35153568!operacionBotones:aBotonpuedeingresar ifFalse:[^nil].aBoton=(botones at:1)ifTrue:[temp contents:temp contents,'1'.].aBoton=(botones at:2)ifTrue:[temp contents:temp contents,'2'.].aBoton=(botones at:3)ifTrue:[temp contents:temp contents,'3'.].aBoton=(botones at:4)ifTrue:[temp contents:temp contents,'4'.].aBoton=(botones at:5)ifTrue:[temp contents:temp contents,'5'.].aBoton=(botones at:6)ifTrue:[temp contents:temp contents,'6'.].aBoton=(botones at:7)ifTrue:[temp contents:temp contents,'7'.].aBoton=(botones at:8)ifTrue:[temp contents:temp contents,'8'.].aBoton=(botones at:9)ifTrue:[temp contents:temp contents,'9'.].aBoton=(botones at:10)ifTrue:[temp contents:temp contents,'0'.].aBoton=enter ifTrue:[puedeingresar ifTrue:[self controlarEnter.].].! !atm _ ATM new.!atm _ ATM new.!atm _ ATM new.!RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter estado pretiro puedeingresar temp accion usuario usuarios dinerocajero aceptaingresos valoringresado'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter estado pretiro puedeingresar temp accion usuario usuarios dinerocajero aceptaingresos tecla'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 14:32' prior: 34986392!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.botones at:1 push.botones at:1 pop.! !atm _ ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 14:33' prior: 35155859!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.(botones at:1) push.(botones at:1) pop.! !atm _ ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 14:33'!keyDown: anEvent Transcript show:'asdf'.! !atm _ ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 14:34' prior: 35156581!keyDown: anEvent Transcript show:'asdf'.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 14:36' prior: 35156716!keyDown: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor>9) | (valor<0) ifTrue:[^nil].Transcript show:valor.! !atm _ ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 14:37' prior: 35156835!keyDown: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.Transcript show:valor.(valor>9) | (valor<0) ifTrue:[^nil].! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 14:37' prior: 35157074!keyDown: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue).Transcript show:valor.(valor>9) | (valor<0) ifTrue:[^nil].! !atm _ ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 14:39' prior: 35157296!keyDown: anEvent |valor valor1|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.Transcript show:valor as String ,'  ',valor1 as String,' '.(valor>9) | (valor<0) ifTrue:[^nil].! !atm _ ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 14:40' prior: 35157532!keyDown: anEvent |valor valor1|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.Transcript show:valor asString ,'  ',valor1 asString,' '.(valor>9) | (valor<0) ifTrue:[^nil].! !atm _ ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 14:40' prior: 35157846!keyDown: anEvent |valor valor1|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.Transcript show:valor asString ,'  ',valor1 asString,' '.(valor>9) | (valor<0) | (valor1>9) | (valor1<0) ifTrue:[^nil].! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 15:00' prior: 35158158!keyDown: anEvent |valor valor1|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.Transcript show:valor asString ,'  ',valor1 asString,' '.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 15:00' prior: 35158479!keyDown: anEvent |valor valor1|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].Transcript show:valor asString ,'  ',valor1 asString,' '.! !atm _ ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 15:01' prior: 35158804!keyDown: anEvent |valor valor1|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].Transcript show:valor asString ,'  ',valor1 asString,' '.(botones at:valor) push.! !atm _ ATM new.!atm _ ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 15:02' prior: 35156226!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, ((anEvent keyValue)-48) asString.(botones at:1) push.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 15:02' prior: 35159146!keyDown: anEvent ! !atm _ ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 15:03'!keyUp: anEvent |valor valor1|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].Transcript show:valor asString ,'  ',valor1 asString,' '.! !atm _ ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 15:06' prior: 35159960!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].boton:= ((valor>9) | (valor<0))ifTrue:[botones at:valor1] ifFalse:[botones at:valor].boton pop.! !atm _ ATM new.!atm _ ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 15:07' prior: 35159530!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.(botones at:valor) push.! !ATM new.!RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter estado pretiro puedeingresar temp accion usuario usuarios dinerocajero aceptaingresos teclapresionada'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!ATM removeSelector: #valorIngresado!ATM removeSelector: #valorIngresado:!!Billete methodsFor: 'eventos' stamp: 'agb 3/20/2011 15:09' prior: 34959518!justDroppedInto: newOwner event: evt|punto posicion ingresado valortotal|atm aceptaIngresos ifFalse:[^nil].ingresado:=atm valorIngresado.posicion:=contenedor position.valortotal:=((atm temp) contents)asNumber.punto:=(self position)+((self extent)/2).((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (contenedor width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (contenedor height)))ifTrue:[	(ingresado + valor)<=valortotal	ifTrue:[			"atm valorIngresado:valor+ingresado.			self delete.			(atm valorIngresado = valortotal)ifTrue:[atm depositoCompleto.]."		].	].! !RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter estado pretiro puedeingresar temp accion usuario usuarios dinerocajero aceptaingresos pdeposito teclapresionada'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!ATM methodsFor: 'interaccion' stamp: 'agb 3/20/2011 15:10' prior: 35047459!depositoCompletousuario monto:(usuario monto).self print:'Ingreso exitoso!!' position:160@80 size:20.self print:'Presione enter para regresar.' position:130@100.aceptaingresos:=false.puedeingresar:=true.accion:=0.! !RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter estado pretiro puedeingresar temp accion usuario usuarios dinerocajero aceptaingresos pdeposito teclapresionada'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!ATM methodsFor: 'iniciales' stamp: 'agb 3/20/2011 15:11' prior: 35151462!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.teclapresionada:=false.estado := false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/20/2011 15:11' prior: 35046254!pedirIngresoself print:'Ingrese el dinero en la ranura de deposito.' position:50@60.puedeingresar:=false.aceptaingresos:=true.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 15:13' prior: 35160642!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].teclapresionada ifTrue:[^nil].teclapresionada:=true.valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.(botones at:valor) push.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 15:13' prior: 35160270!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].boton:= ((valor>9) | (valor<0))ifTrue:[botones at:valor1] ifFalse:[botones at:valor].boton pop.teclapresionada:=false.! !ATM new.!ATM removeSelector: #keyDown:!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 15:14' prior: 35165561!keyUp: anEvent |valor valor1 boton|teclapresionada ifTrue:[^nil].valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].boton:= ((valor>9) | (valor<0))ifTrue:[botones at:valor1] ifFalse:[botones at:valor].boton pop.teclapresionada:=false.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 15:15' prior: 35165966!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].boton:= ((valor>9) | (valor<0))ifTrue:[botones at:valor1] ifFalse:[botones at:valor].boton pop.teclapresionada:=false.! !ATM new.!ATM new.!RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter pretiro puedeingresar temp accion usuario usuarios dinerocajero aceptaingresos pdeposito teclapresionada'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!ATM methodsFor: 'iniciales' stamp: 'agb 3/20/2011 15:16' prior: 35162846!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.teclapresionada:=false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !!Fajo methodsFor: 'iniciales' stamp: 'agb 3/20/2011 15:18' prior: 35131959!de:aNumber position:aPoint contenedor:aMorph|billete pinicial n|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=aPoint.n:=(aNumber/20).1 to:n do:[:i|		billete:=Billete new.		billetes add:billete.		billete position:pinicial.		self addMorphBack:billete.		pinicial:=pinicial+(0@10).].self extent:0@0.self openInWorld.! !Morph subclass: #Fajo	instanceVariableNames: 'billetes'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!Morph subclass: #Fajo	instanceVariableNames: 'billetes atm'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!Billete removeSelector: #mouseDown:!Billete removeSelector: #justDroppedInto:event:!Billete removeSelector: #handlesMouseDown:!Billete removeSelector: #firstClickTimedOut:!Billete removeSelector: #doubleClick:!Billete removeSelector: #click:!Billete removeSelector: #atm:!Billete removeSelector: #contenedor:!ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 15:22' prior: 35165187!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.(botones at:valor) push.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 15:22' prior: 35166370!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].boton:= ((valor>9) | (valor<0))ifTrue:[botones at:valor1] ifFalse:[botones at:valor].boton pop.! !RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter pretiro puedeingresar temp accion usuario usuarios dinerocajero aceptaingresos pdeposito'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!ATM methodsFor: 'iniciales' stamp: 'agb 3/20/2011 15:23' prior: 35167024!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !ATM new.!ATM new.!ATM new.!ATM new.!!Billete methodsFor: 'iniciales' stamp: 'agb 3/20/2011 15:41' prior: 34957229!initializesuper initialize.valor:=20.self borderWidth:1.self image: (ImageReadWriter formFromFileNamed: 'atm\20Dollar1.jpg').todo:=false.self openInWorld.! !ATM new.!!SobreATM methodsFor: 'nil' stamp: 'agb 3/20/2011 15:44'!initializesuper initialize.self image: (ImageReadWriter formFromFileNamed: 'atm\20Dollar1.jpg').self openInWorld.! !SobreATM new.!!SobreATM methodsFor: 'as yet unclassified' stamp: 'agb 3/20/2011 15:44' prior: 35173426!initializesuper initialize.self image: (ImageReadWriter formFromFileNamed: 'atm\atmenvelope.jpg').self openInWorld.! !SobreATM new.!SobreATM new.!SobreATM new.!SobreATM new.!SobreATM new.!ATM new.!!PanelDeposito methodsFor: 'timer' stamp: 'agb 3/20/2011 15:47' prior: 35020433!step Transcript show:'asdf'.! !ATM new.!!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/20/2011 15:48' prior: 35118798!initialize|a|super initialize.self extent:300@100.self borderWidth:0.self color:(Color r: 0.972 g: 0.972 b: 0.976).interval:=1000.! !!ATM methodsFor: 'iniciales' stamp: 'agb 3/20/2011 15:48' prior: 35171054!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito.pdeposito stopStepping."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'iniciales' stamp: 'agb 3/20/2011 15:48' prior: 35174289!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito stopStepping.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !ATM new.!!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/20/2011 15:53'!wantsSteps^ interval isNil ! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/20/2011 15:54' prior: 35178522!wantsSteps^interval isNil.! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/20/2011 15:54'!stopSteppingsuper stopStepping.! !ATM new.!PanelDeposito new.!PanelDeposito new openInWorld.!a:=PanelDeposito new openInWorld.!a startStepping.!!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/20/2011 15:56' prior: 35178735!stopSteppingsuper stopStepping.interval:=nil.! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/20/2011 15:57'!startSteppingsuper startStepping.interval:=1000.! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/20/2011 15:57' prior: 35174073!initialize|a|super initialize.self extent:300@100.self borderWidth:0.self color:(Color r: 0.972 g: 0.972 b: 0.976).! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/20/2011 15:57' prior: 35179229!initializesuper initialize.self extent:300@100.self borderWidth:0.self color:(Color r: 0.972 g: 0.972 b: 0.976).! !a stopStepping.!a startStepping.!a stopStepping.!ATM new.!a:=PanelDeposito new.!a:=PanelDeposito new openInWorld.!!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/20/2011 15:59' prior: 35179437!initializesuper initialize.interval:=1000.self extent:300@100.self borderWidth:0.self color:(Color r: 0.972 g: 0.972 b: 0.976).! !a:=PanelDeposito new openInWorld.!ATM new.!a:=PanelDeposito new openInWorld.!ATM new.!!ATM methodsFor: 'iniciales' stamp: 'agb 3/20/2011 16:00' prior: 35176404!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !ATM new.!ATM removeSelector: #keyboardFocusChange:!ATM new.!ATM new.!RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter pretiro puedeingresar temp accion usuario usuarios dinerocajero aceptaingresos pdeposito teclapresionada'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:04' prior: 35170142!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.teclapresionada:=valor.(botones at:valor) push.! !!ATM methodsFor: 'iniciales' stamp: 'agb 3/20/2011 16:04' prior: 35180073!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.teclapresionada:=nil.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:05' prior: 35182507!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].teclapresionada=nil ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.teclapresionada:=valor.(botones at:valor) push.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:08' prior: 35170462!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].(valor=teclapresionada | valor1=teclapresionada) ifFalse:[^nil].boton:= ((valor>9) | (valor<0))ifTrue:[botones at:valor1] ifFalse:[botones at:valor].boton pop.teclapresionada:=nil.! !ATM new.!ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:11' prior: 35184964!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].teclapresionada=nil ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.teclapresionada:=valor.(valor=0)ifTrue:[valor=10].(botones at:valor) push.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:13' prior: 35185344!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].(valor=teclapresionada | valor1=teclapresionada) ifFalse:[^nil].boton:= ((valor>9) | (valor<0))ifTrue:[(valor1=0)ifTrue:[valor1=10]. botones at:valor1] ifFalse:[(valor=0)ifTrue:[valor=10]. botones at:valor].boton pop.teclapresionada:=nil.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:13' prior: 35186199!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].(valor=teclapresionada | valor1=teclapresionada) ifFalse:[^nil].boton:= ((valor>9) | (valor<0))	ifTrue:[(valor1=0) ifTrue:[valor1=10]. botones at:valor1] 	ifFalse:[(valor=0) ifTrue:[valor=10]. botones at:valor].boton pop.teclapresionada:=nil.! !ATM new.!ATM new.!ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:15' prior: 35185791!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].teclapresionada=nil ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.teclapresionada:=valor.(valor=0)ifTrue:[valor:=10].(botones at:valor) push.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:15' prior: 35186682!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].(valor=teclapresionada | valor1=teclapresionada) ifFalse:[^nil].boton:= ((valor>9) | (valor<0))	ifTrue:[(valor1=0) ifTrue:[valor1:=10]. botones at:valor1] 	ifFalse:[(valor=0) ifTrue:[valor:=10]. botones at:valor].boton pop.teclapresionada:=nil.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:16' prior: 35187204!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].teclapresionada=nil ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		enter push.		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.teclapresionada:=valor.(valor=0)ifTrue:[valor:=10].(botones at:valor) push.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:16' prior: 35187613!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.(valor= -35)ifTrue:[^enter push.	].((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].(valor=teclapresionada | valor1=teclapresionada) ifFalse:[^nil].boton:= ((valor>9) | (valor<0))	ifTrue:[(valor1=0) ifTrue:[valor1:=10]. botones at:valor1] 	ifFalse:[(valor=0) ifTrue:[valor:=10]. botones at:valor].boton pop.teclapresionada:=nil.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:17' prior: 35188538!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.(valor= -35)ifTrue:[^enter pop.	].((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].(valor=teclapresionada | valor1=teclapresionada) ifFalse:[^nil].boton:= ((valor>9) | (valor<0))	ifTrue:[(valor1=0) ifTrue:[valor1:=10]. botones at:valor1] 	ifFalse:[(valor=0) ifTrue:[valor:=10]. botones at:valor].boton pop.teclapresionada:=nil.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:18' prior: 35188115!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].teclapresionada=nil ifFalse:[^nil].valor:=(anEvent keyValue)-48.teclapresionada:=valor.(valor= -35)ifTrue:[		enter push.		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.(valor=0)ifTrue:[valor:=10].(botones at:valor) push.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:18' prior: 35189613!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].teclapresionada=nil ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		enter push.		teclapresionada:=-35.		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.(valor=0)ifTrue:[valor:=10].(botones at:valor) push.teclapresionada:=valor.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:19' prior: 35190036!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].teclapresionada=nil ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		enter push.		teclapresionada:=-35.		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.(valor=0)ifTrue:[valor:=10].(botones at:valor) push.teclapresionada:=valor.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:19' prior: 35189076!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.(valor= -35 =teclapresionada)ifTrue:[^enter pop.	].((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].(valor=teclapresionada | valor1=teclapresionada) ifFalse:[^nil].boton:= ((valor>9) | (valor<0))	ifTrue:[(valor1=0) ifTrue:[valor1:=10]. botones at:valor1] 	ifFalse:[(valor=0) ifTrue:[valor:=10]. botones at:valor].boton pop.teclapresionada:=nil.! !1=1=2!ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:19' prior: 35190931!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.(valor= -35 =teclapresionada)ifTrue:[^enter pop.].((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].(valor=teclapresionada | valor1=teclapresionada) ifFalse:[^nil].boton:= ((valor>9) | (valor<0))	ifTrue:[(valor1=0) ifTrue:[valor1:=10]. botones at:valor1] 	ifFalse:[(valor=0) ifTrue:[valor:=10]. botones at:valor].boton pop.teclapresionada:=nil.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:21' prior: 35191493!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.(valor= -35 =teclapresionada)ifTrue:[	teclapresionada:=nil.	^enter pop.].((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].(valor=teclapresionada | valor1=teclapresionada) ifFalse:[^nil].boton:= ((valor>9) | (valor<0))	ifTrue:[(valor1=0) ifTrue:[valor1:=10]. botones at:valor1] 	ifFalse:[(valor=0) ifTrue:[valor:=10]. botones at:valor].boton pop.teclapresionada:=nil.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:29' prior: 35192046!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].(valor=teclapresionada | valor1=teclapresionada) ifFalse:[^nil].boton:= ((valor>9) | (valor<0))	ifTrue:[(valor1=0) ifTrue:[valor1:=10]. botones at:valor1] 	ifFalse:[(valor=0) ifTrue:[valor:=10]. botones at:valor].boton pop.teclapresionada:=nil.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/20/2011 16:29' prior: 35190484!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].teclapresionada=nil ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.(valor=0)ifTrue:[valor:=10].(botones at:valor) push.teclapresionada:=valor.! !ATM new.!----QUIT----{20 March 2011 . 4:54:15 pm} Squeak4.2.image priorSource: 1576277!----STARTUP----{21 March 2011 . 2:45:54 am} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.2.image!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 02:51' prior: 35192625!keyUp: anEvent ! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 02:51' prior: 35193735!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].(valor=teclapresionada | valor1=teclapresionada) ifFalse:[^nil].boton:= ((valor>9) | (valor<0))	ifTrue:[(valor1=0) ifTrue:[valor1:=10]. botones at:valor1] 	ifFalse:[(valor=0) ifTrue:[valor:=10]. botones at:valor].boton pop.teclapresionada:=nil.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 02:52' prior: 35193116!keyStroke: anEvent |valor|Transcript show:'hola'.puedeingresar ifFalse:[^nil].teclapresionada=nil ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.(valor=0)ifTrue:[valor:=10].(botones at:valor) push.teclapresionada:=valor.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 02:52' prior: 35194330!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].teclapresionada=nil ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].Transcript show:'hola'.(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.(valor=0)ifTrue:[valor:=10].(botones at:valor) push.teclapresionada:=valor.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 02:53' prior: 35194774!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].teclapresionada=nil ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.(valor=0)ifTrue:[valor:=10].(botones at:valor) push.teclapresionada:=valor.Transcript show:'hola'.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 02:53' prior: 35195218!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].teclapresionada=nil ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].Transcript show:valor.(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.(valor=0)ifTrue:[valor:=10].(botones at:valor) push.teclapresionada:=valor.! !ATM new.!ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 02:55' prior: 35195651!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].teclapresionada=nil ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.(valor=0)ifTrue:[valor:=10].(botones at:valor) push.teclapresionada:=valor.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 02:57' prior: 35196106!keyStroke: anEvent |valor|Transcript show:(anEvent keyValue)-48.puedeingresar ifFalse:[^nil].teclapresionada=nil ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.(valor=0)ifTrue:[valor:=10].(botones at:valor) push.teclapresionada:=valor.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 02:58' prior: 35193839!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].(valor=teclapresionada | valor1=teclapresionada) ifFalse:[^nil].boton:= ((valor>9) | (valor<0))	ifTrue:[(valor=0) ifTrue:[valor:=10]. botones at:valor] 	ifFalse:[(valor1=0) ifTrue:[valor1:=10]. botones at:valor1].boton pop.teclapresionada:=nil.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 02:59' prior: 35196987!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].(valor=teclapresionada | valor1=teclapresionada) ifFalse:[^nil].boton:= ((valor>9) | (valor<0))	ifTrue:[(valor1=0) ifTrue:[valor1:=10]. botones at:valor1] 	ifFalse:[(valor=0) ifTrue:[valor:=10]. botones at:valor].boton pop.teclapresionada:=nil.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 02:59' prior: 35197489!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].Transcript show:'aqui estoy'.(valor=teclapresionada | valor1=teclapresionada) ifFalse:[^nil].boton:= ((valor>9) | (valor<0))	ifTrue:[(valor1=0) ifTrue:[valor1:=10]. botones at:valor1] 	ifFalse:[(valor=0) ifTrue:[valor:=10]. botones at:valor].boton pop.teclapresionada:=nil.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 03:00' prior: 35197991!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].Transcript show:valor asString,' ', valor1 as String.(valor=teclapresionada | valor1=teclapresionada) ifFalse:[^nil].boton:= ((valor>9) | (valor<0))	ifTrue:[(valor1=0) ifTrue:[valor1:=10]. botones at:valor1] 	ifFalse:[(valor=0) ifTrue:[valor:=10]. botones at:valor].boton pop.teclapresionada:=nil.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 03:00' prior: 35198523!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].Transcript show:valor asString,' ', valor1 asString.(valor=teclapresionada | valor1=teclapresionada) ifFalse:[^nil].boton:= ((valor>9) | (valor<0))	ifTrue:[(valor1=0) ifTrue:[valor1:=10]. botones at:valor1] 	ifFalse:[(valor=0) ifTrue:[valor:=10]. botones at:valor].boton pop.teclapresionada:=nil.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 03:02' prior: 35199079!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].(valor=teclapresionada | valor1=teclapresionada) ifFalse:[^nil].boton:= ((valor>9) | (valor<0))	ifTrue:[(valor1=0) ifTrue:[valor1:=10]. botones at:valor1] 	ifFalse:[(valor=0) ifTrue:[valor:=10]. botones at:valor].boton pop.teclapresionada:=nil.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 03:02' prior: 35199634!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].(valor=teclapresionada | valor1=teclapresionada) ifFalse:[^nil].Transcript show:valor asString,' ', valor1 asString.boton:= ((valor>9) | (valor<0))	ifTrue:[(valor1=0) ifTrue:[valor1:=10]. botones at:valor1] 	ifFalse:[(valor=0) ifTrue:[valor:=10]. botones at:valor].boton pop.teclapresionada:=nil.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 03:03' prior: 35200125!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].(valor=teclapresionada) | (valor1=teclapresionada) ifFalse:[^nil].Transcript show:valor asString,' ', valor1 asString.boton:= ((valor>9) | (valor<0))	ifTrue:[(valor1=0) ifTrue:[valor1:=10]. botones at:valor1] 	ifFalse:[(valor=0) ifTrue:[valor:=10]. botones at:valor].boton pop.teclapresionada:=nil.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 03:03' prior: 35200680!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].Transcript show:valor asString,' ', valor1 asString.(valor=teclapresionada) | (valor1=teclapresionada) ifFalse:[^nil].Transcript show:valor asString,' ', valor1 asString.boton:= ((valor>9) | (valor<0))	ifTrue:[(valor1=0) ifTrue:[valor1:=10]. botones at:valor1] 	ifFalse:[(valor=0) ifTrue:[valor:=10]. botones at:valor].boton pop.teclapresionada:=nil.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 03:04' prior: 35201226!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.((valor>9) | (valor<0)) & ((valor1>9) | (valor1<0)) ifTrue:[^nil].Transcript show:valor asString,' : ', valor1 asString,' -- '.(valor=teclapresionada) | (valor1=teclapresionada) ifFalse:[^nil].Transcript show:valor asString,' ', valor1 asString.boton:= ((valor>9) | (valor<0))	ifTrue:[(valor1=0) ifTrue:[valor1:=10]. botones at:valor1] 	ifFalse:[(valor=0) ifTrue:[valor:=10]. botones at:valor].boton pop.teclapresionada:=nil.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 03:05' prior: 35196527!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].teclapresionada=nil ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.(valor=0)ifTrue:[valor:=10].(botones at:valor) push.teclapresionada:=valor.! !teclaPresionada:=0.!teclaPresioanda isNil!teclaPresioanda=nil.!teclaPresionada:=0.0.!teclaPresionada!teclaPresionada isNil.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 03:13' prior: 35201825!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.valor:=(valor<=9) & (valor>=0) ifTrue:[valor] ifFalse:[valor1].(valor>9) | (valor<0) ifTrue:[^nil].(valor=0) ifTrue:[valor:=10].(valor=teclapresionada) ifFalse:[^nil].boton:= botones at:valor.boton pop.teclapresionada:=nil.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 03:14' prior: 35202444!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].teclapresionada=nil ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		teclapresionada= -35.		enter push.		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.(valor=0)ifTrue:[valor:=10].(botones at:valor) push.teclapresionada:=valor.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 03:15' prior: 35202990!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.valor:=(valor<=9) & (valor>=0) ifTrue:[valor] ifFalse:[valor1].(valor>9) | (valor<0) ifTrue:[^nil].(valor=0) ifTrue:[valor:=10].(valor=teclapresionada) ifFalse:[^nil].(valor= -35)ifTrue:[		teclapresionada:=nil.		enter push.		^self controlarEnter.	].boton:= botones at:valor.boton pop.teclapresionada:=nil.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 03:15' prior: 35203405!keyStroke: anEvent |valor|puedeingresar ifFalse:[^nil].teclapresionada=nil ifFalse:[^nil].valor:=(anEvent keyValue)-48.(valor= -35)ifTrue:[		teclapresionada:= -35.		enter push.		^self controlarEnter.	].(valor>9) | (valor<0) ifTrue:[^nil].temp contents:temp contents, valor asString.(valor=0)ifTrue:[valor:=10].(botones at:valor) push.teclapresionada:=valor.! !!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 03:15' prior: 35203853!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.valor:=(valor<=9) & (valor>=0) ifTrue:[valor] ifFalse:[valor1].(valor>9) | (valor<0) ifTrue:[^nil].(valor=0) ifTrue:[valor:=10].(valor=teclapresionada) ifFalse:[^nil].(valor= -35)ifTrue:[		teclapresionada:=nil.		^enter pop.	].boton:= botones at:valor.boton pop.teclapresionada:=nil.! !ATM new.!ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 03:17' prior: 35204793!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.(valor= -35 | valor1= -35)ifTrue:[		teclapresionada:=nil.		^enter pop.	].valor:=(valor<=9) & (valor>=0) ifTrue:[valor] ifFalse:[valor1].(valor>9) | (valor<0) ifTrue:[^nil].(valor=0) ifTrue:[valor:=10].(valor=teclapresionada) ifFalse:[^nil].boton:= botones at:valor.boton pop.teclapresionada:=nil.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 03:18' prior: 35205282!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.(valor= -35) | (valor1= -35)ifTrue:[		teclapresionada:=nil.		^enter pop.	].Transcript show:valor asString,' ',valor1 asString.valor:=(valor<=9) & (valor>=0) ifTrue:[valor] ifFalse:[valor1].(valor>9) | (valor<0) ifTrue:[^nil].(valor=0) ifTrue:[valor:=10].(valor=teclapresionada) ifFalse:[^nil].boton:= botones at:valor.boton pop.teclapresionada:=nil.! !ATM new.!!ATM methodsFor: 'iniciales' stamp: 'agb 3/21/2011 03:19' prior: 35182853!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.teclapresionada:=nil.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter text:'Enter'.enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !ATM new.!ATM new.!!ATM methodsFor: 'validaciones' stamp: 'agb 3/21/2011 03:22' prior: 34913290!validarRetiro|opcion cantidad|opcion:=(temp contents)asInteger.(opcion=6)ifTrue:[^self menuPrincipal].(opcion<4)ifTrue:[cantidad:=opcion*20].(opcion=4)ifTrue:[cantidad:=100].(opcion=5)ifTrue:[cantidad:=200].(cantidad<=usuario monto)ifFalse:[^self notieneDinero].(cantidad<=dinerocajero)ifFalse:[^self notieneDineroCajero].self retirarDinero:cantidad.! !!ATM methodsFor: 'validaciones' stamp: 'agb 3/21/2011 03:25' prior: 35208480!validarRetiro|opcion cantidad|opcion:=(temp contents)asInteger.(opcion<1 | opcion>6)ifTrue:[^self pantallaRetiro].(opcion=6)ifTrue:[^self menuPrincipal].(opcion<4)ifTrue:[cantidad:=opcion*20].(opcion=4)ifTrue:[cantidad:=100].(opcion=5)ifTrue:[cantidad:=200].(cantidad<=usuario monto)ifFalse:[^self notieneDinero].(cantidad<=dinerocajero)ifFalse:[^self notieneDineroCajero].self retirarDinero:cantidad.! !ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 03:25' prior: 35205774!keyUp: anEvent |valor valor1 boton|valor:=(anEvent keyValue)-48.valor1:=(anEvent keyValue)-96.(valor= -35) | (valor1= -35)ifTrue:[		teclapresionada:=nil.		^enter pop.	].valor:=(valor<=9) & (valor>=0) ifTrue:[valor] ifFalse:[valor1].(valor>9) | (valor<0) ifTrue:[^nil].(valor=0) ifTrue:[valor:=10].(valor=teclapresionada) ifFalse:[^nil].boton:= botones at:valor.boton pop.teclapresionada:=nil.! !ATM new.!RectangleMorph subclass: #PanelDeposito	instanceVariableNames: 'interval atm reloj'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!ImageMorph subclass: #Billete	instanceVariableNames: 'valor contenedor'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!ImageMorph subclass: #Billete	instanceVariableNames: 'valor contenedor todo'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!ImageMorph subclass: #Billete	instanceVariableNames: 'valor todo'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!ATM new.!RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter pretiro puedeingresar temp accion usuario usuarios dinerocajero aceptaingresos pdeposito teclapresionada reloj'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!ATM new.!RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter pretiro puedeingresar temp accion usuario usuarios dinerocajero aceptaingresos pdeposito teclapresionada'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 03:33' prior: 35179767!initializesuper initialize.interval:=1000.reloj:=StringMorph new.self extent:300@100.self borderWidth:0.self color:(Color r: 0.972 g: 0.972 b: 0.976).! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 03:34' prior: 34841898!print:aString position:aPoint|text|text:= StringMorph new.text fontName:'Sans' size:18.text contents:aString.text position:(pantalla position) + aPoint.pantalla addMorph:text.! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 03:35' prior: 35211053!initializesuper initialize.interval:=1000.reloj:=StringMorph new.reloj fontName:'Sans' size:18.reloj contents:'60'.reloj position:(10@10).self addMorph:reloj.self extent:300@100.self borderWidth:0.self color:(Color r: 0.972 g: 0.972 b: 0.976).! !ATM new.!RectangleMorph subclass: #PanelDeposito	instanceVariableNames: 'interval atm reloj valor'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 03:37' prior: 35179092!startSteppingsuper startStepping.valor:=60.interval:=1000.! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 03:37' prior: 35173946!step! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 03:38' prior: 35212215!stepvalor:=valor-1.self valorReloj:valor.! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 03:38'!valorReloj:aNumber! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 03:38' prior: 35212420!valorReloj:aNumberreloj contents:aNumber.! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 03:39' prior: 35212526!valorReloj:aNumberreloj contents:aNumber.! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 03:39' prior: 35212655!valorReloj:aNumberreloj contents:aNumber.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 03:39' prior: 35164980!pedirIngresoself print:'Ingrese el dinero en la ranura de deposito.' position:50@60.pdeposito startStepping.puedeingresar:=false.aceptaingresos:=true.! !ATM new.!!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 03:40' prior: 35212306!stepvalor:=valor-1.self valorReloj:valor asString.! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 03:40' prior: 35213160!stepvalor:=valor-1.self valorReloj:valor.! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 03:41' prior: 35212784!valorReloj:aNumberreloj contents:aNumber asString.! !ATM new.!!ATM methodsFor: 'iniciales' stamp: 'agb 3/21/2011 03:42' prior: 35206322!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.teclapresionada:=nil.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter text:'Enter'.enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.pdeposito atm:self.self addMorph:pdeposito.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !ATM new.!!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 03:46'!tiempoAgotadoself limpiarPantalla.self print:'Su transcaccion ha sido cancelada por inactividad!!' position:100@40.self print:'Presione enter para regresar.' position:120@60.puedeingresar:=true.accion:=10.! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 03:48' prior: 35213299!stepvalor:=valor-1.self valorReloj:valor.valor=0 ifTrue:[	atm tiempoAgotado.	self stopStepping.]! !ATM new.!!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 03:48' prior: 35212067!startSteppingsuper startStepping.valor:=10.interval:=1000.! !ATM new.!!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 03:49' prior: 35215717!tiempoAgotadoself limpiarPantalla.self print:'Su transcaccion ha sido cancelada por inactividad!!' position:100@40.self print:'Presione enter para regresar.' position:120@60.puedeingresar:=true.accion:=0.! !ATM new.!ATM new.!!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 03:51' prior: 34934706!notieneDineroself limpiarPantalla.self print:'No posee fondos suficientes!!' position:120@40 size:20.self print:'Presione enter para regresar.' position:120@60.puedeingresar:=true.accion:=10.! !!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 03:52' prior: 34934972!notieneDineroCajeroself limpiarPantalla.self print:'Este equipo no posee fondos suficientes!!' position:120@40 size:20.self print:'Presione enter para regresar.' position:120@60.puedeingresar:=true.accion:=10.! !!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 03:52' prior: 35216364!tiempoAgotadoself limpiarPantalla.self print:'Su transcaccion ha sido cancelada por inactividad!!' position:90@40 size:20.self print:'Presione enter para regresar.' position:120@60.puedeingresar:=true.accion:=0.! !ATM new.!!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 03:53' prior: 35216673!notieneDineroself limpiarPantalla.self print:'No posee fondos suficientes!!' position:110@60 size:20.self print:'Presione enter para regresar.' position:130@80.puedeingresar:=true.accion:=10.! !!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 03:53' prior: 35216947!notieneDineroCajeroself limpiarPantalla.self print:'Este equipo no posee fondos suficientes!!' position:110@60 size:20.self print:'Presione enter para regresar.' position:130@80.puedeingresar:=true.accion:=10.! !!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 03:53' prior: 35217239!tiempoAgotadoself limpiarPantalla.self print:'Su transcaccion ha sido cancelada por inactividad!!' position:110@60 size:20.self print:'Presione enter para regresar.' position:130@80.puedeingresar:=true.accion:=0.! !ATM new.!!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 03:54' prior: 35218110!tiempoAgotadoself limpiarPantalla.self print:'Su transcaccion ha sido cancelada por inactividad!!' position:80@60 size:20.self print:'Presione enter para regresar.' position:130@80.puedeingresar:=true.accion:=0.! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 03:55' prior: 35216014!stepvalor:=valor-1.self valorReloj:valor.valor=0 ifTrue:[	self stopStepping.	atm tiempoAgotado.]! !ATM new.!!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 03:56' prior: 35218416!tiempoAgotadoself limpiarPantalla.self print:'Su transcaccion ha sido cancelada por inactividad!!' position:40@60 size:20.self print:'Presione enter para regresar.' position:130@80.puedeingresar:=true.accion:=0.! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 03:56' prior: 35216214!startSteppingsuper startStepping.valor:=3.interval:=1000.! !ATM new.!!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 03:57' prior: 35218910!tiempoAgotadoself limpiarPantalla.self print:'Su transcaccion ha sido cancelada por inactividad!!' position:30@60 size:20.self print:'Presione enter para regresar.' position:130@80.puedeingresar:=true.accion:=0.! !ATM new.!ATM new.!!SobreATM methodsFor: 'nil' stamp: 'agb 3/21/2011 03:58'!atm:aATMatm:=aATM.! !!SobreATM methodsFor: 'as yet unclassified' stamp: 'agb 3/21/2011 03:59'!atm^atm.! !!ATM methodsFor: 'iniciales' stamp: 'agb 3/21/2011 04:02' prior: 35213570!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.teclapresionada:=nil.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter text:'Enter'.enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.pdeposito atm:self.self addMorph:pdeposito.a:=SobreATM new.a position:(self position)+((self width)+20)@10.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'iniciales' stamp: 'agb 3/21/2011 04:02' prior: 35219847!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.teclapresionada:=nil.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter text:'Enter'.enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.pdeposito atm:self.self addMorph:pdeposito.a:=SobreATM new.a position:(self position)+((self width)+20@10).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !ATM new.!!ATM methodsFor: 'iniciales' stamp: 'agb 3/21/2011 04:03' prior: 35222066!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.teclapresionada:=nil.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter text:'Enter'.enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.pdeposito atm:self.self addMorph:pdeposito.a:=SobreATM new.a position:(self position)+((self width)+20@50).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !ATM new.!!ATM methodsFor: 'iniciales' stamp: 'agb 3/21/2011 04:03' prior: 35224296!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.teclapresionada:=nil.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self borderWidth:1.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter text:'Enter'.enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.pdeposito atm:self.self addMorph:pdeposito.a:=SobreATM new.a position:(self position)+((self width)+20@50).a atm:self.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 04:05' prior: 35162272!depositoCompletousuario monto:(usuario monto)+(((temp contents) asNumber)/100).self print:'Ingreso exitoso!!' position:160@80 size:20.self print:'Presione enter para regresar.' position:130@100.aceptaingresos:=false.puedeingresar:=true.accion:=0.! !!SobreATM methodsFor: 'iniciales' stamp: 'agb 3/21/2011 04:06' prior: 35219662!atm:aATMatm:=aATM.contenedor:=atm pdeposito.! !!SobreATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 04:06' prior: 35135174!justDroppedInto: newOwner event: evt|punto posicion|atm aceptaIngresos ifFalse:[^nil].posicion:=contenedor position.punto:=(self position)+((self extent)/2).((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (contenedor width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (contenedor height)))ifTrue:[		atm ingres.	].! !!SobreATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 04:08' prior: 35229235!justDroppedInto: newOwner event: evt|punto posicion|atm aceptaIngresos ifFalse:[^nil].posicion:=contenedor position.punto:=(self position)+((self extent)/2).((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (contenedor width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (contenedor height)))ifTrue:[		atm depositoCompleto.	].! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 04:09' prior: 35219213!startSteppingsuper startStepping.valor:=10.interval:=1000.! !ATM new.!!SobreATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 04:09' prior: 35229660!justDroppedInto: newOwner event: evt|punto posicion|atm aceptaIngresos ifFalse:[^nil].posicion:=contenedor position.punto:=(self position)+((self extent)/2).((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (contenedor width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (contenedor height)))ifTrue:[		atm depositoCompleto.		self delete.	].! !!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 04:10' prior: 35228770!depositoCompletousuario monto:(usuario monto)+(((temp contents) asNumber)/100).self print:'Ingreso exitoso!!' position:160@80 size:20.self print:'Presione enter para regresar.' position:130@100.pdeposito stopStepping.aceptaingresos:=false.puedeingresar:=true.accion:=0.! !ATM new.!ATM new.!!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 04:12' prior: 35178974!stopSteppingsuper stopStepping.interval:=0.! !ATM new.!4.0 /  2.0!4 /  2!4 /  2!!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 04:16' prior: 35230700!depositoCompletousuario monto:(usuario monto)+(((temp contents) asFloat)/100).self print:'Ingreso exitoso!!' position:160@80 size:20.self print:'Presione enter para regresar.' position:130@100.pdeposito stopStepping.aceptaingresos:=false.puedeingresar:=true.accion:=0.! !ATM new.!(('20') asNumber)/100.!(('200') asNumber)/100.!(('200') asNumber) / 100.!(('20') asNumber) / 100.!((('20') asNumber) / 100) asNumber.!((('20') asNumber) / 100) asFloat.!!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 04:18' prior: 35231251!depositoCompletousuario monto:(usuario monto)+(((temp contents) asNumber)/100) asFloat.self print:'Ingreso exitoso!!' position:160@80 size:20.self print:'Presione enter para regresar.' position:130@100.pdeposito stopStepping.aceptaingresos:=false.puedeingresar:=true.accion:=0.! !ATM new.!ATM new.!atm:=ATM new.!sobre:=SobreATM new.sobre atm:atm.!sobre:=SobreATM new.sobre atm:atm.!!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 04:22' prior: 35217818!notieneDineroCajeroself limpiarPantalla.self print:'Este equipo no posee fondos suficientes!!' position:60@60 size:20.self print:'Presione enter para regresar.' position:130@80.puedeingresar:=true.accion:=10.! !!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 04:22' prior: 35232274!notieneDineroCajeroself limpiarPantalla.self print:'Este equipo no posee fondos suficientes!!' position:70@60 size:20.self print:'Presione enter para regresar.' position:130@80.puedeingresar:=true.accion:=10.! !sobre:=SobreATM new.sobre atm:atm.!sobre:=SobreATM new.sobre atm:atm.!RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter pretiro puedeingresar temp accion usuario usuarios dinerocajero aceptaingresos pdeposito teclapresionada reloj'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 04:25'!reloj:aMorphreloj:=aMorph.! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 04:26' prior: 35211559!initializesuper initialize.interval:=1000.self addMorph:reloj.self extent:300@100.self borderWidth:0.self color:(Color r: 0.972 g: 0.972 b: 0.976).! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 04:27' prior: 35212907!pedirIngresoreloj:=StringMorph new.reloj fontName:'Sans' size:18.reloj contents:'60'.reloj position:(10@10).pantalla addMorph:reloj.self print:'Ingrese el dinero en la ranura de deposito.' position:50@60.pdeposito startStepping.puedeingresar:=false.aceptaingresos:=true.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 04:27' prior: 35233548!pedirIngresoreloj:=StringMorph new.reloj fontName:'Sans' size:18.reloj contents:'60'.reloj position:(10@10).pantalla addMorph:reloj.self print:'Ingrese el dinero en la ranura de deposito.' position:50@60.pdeposito startStepping.puedeingresar:=false.aceptaingresos:=true.! !!ATM methodsFor: 'iniciales' stamp: 'agb 3/21/2011 04:28'!reloj^reloj! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 04:28' prior: 35213429!valorReloj:aNumber(atm reloj) contents:aNumber asString.! !PanelDeposito removeSelector: #reloj:!!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 04:29' prior: 35231086!stopSteppingsuper stopStepping.(atm reloj) delete.interval:=0.! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 04:30' prior: 35233313!initializesuper initialize.interval:=1000.self extent:300@100.self borderWidth:0.self color:(Color r: 0.972 g: 0.972 b: 0.976).! !atm:=ATM new.!atm:=ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 04:33' prior: 35233909!pedirIngresoreloj:=StringMorph new.reloj fontName:'Sans' size:18.reloj contents:'60'.reloj position:(pantalla position)+(50@200).pantalla addMorph:reloj.self print:'Ingrese el dinero en la ranura de deposito. Restante:' position:50@60.pdeposito startStepping.puedeingresar:=false.aceptaingresos:=true.! !atm:=ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 04:34' prior: 35234933!pedirIngresoreloj:=StringMorph new.reloj fontName:'Sans' size:18.reloj contents:'60'.reloj position:(pantalla position)+(200@50).pantalla addMorph:reloj.self print:'Ingrese el dinero en la ranura de deposito. Restante:' position:50@60.pdeposito startStepping.puedeingresar:=false.aceptaingresos:=true.! !atm:=ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 04:35' prior: 35235341!pedirIngresoreloj:=StringMorph new.reloj fontName:'Sans' size:18.reloj contents:'60'.reloj position:(pantalla position)+(350@60).pantalla addMorph:reloj.self print:'Ingrese el dinero en la ranura de deposito. Restante:' position:50@60.pdeposito startStepping.puedeingresar:=false.aceptaingresos:=true.! !atm:=ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 04:35' prior: 35235749!pedirIngresoreloj:=StringMorph new.reloj fontName:'Sans' size:18.reloj contents:'60s'.reloj position:(pantalla position)+(360@60).pantalla addMorph:reloj.self print:'Ingrese el dinero en la ranura de deposito. Restante:' position:50@60.pdeposito startStepping.puedeingresar:=false.aceptaingresos:=true.! !atm:=ATM new.!atm:=ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 04:36' prior: 35236157!pedirIngresoreloj:=StringMorph new.reloj fontName:'Sans' size:18.reloj contents:'60s'.reloj position:(pantalla position)+(380@60).pantalla addMorph:reloj.self print:'Ingrese el dinero en la ranura de deposito. Restante:' position:50@60.pdeposito startStepping.puedeingresar:=false.aceptaingresos:=true.! !atm:=ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 04:36' prior: 35236582!pedirIngresoreloj:=StringMorph new.reloj fontName:'Sans' size:18.reloj contents:'60s'.reloj position:(pantalla position)+(370@60).pantalla addMorph:reloj.self print:'Ingrese el dinero en la ranura de deposito. Restante:' position:50@60.pdeposito startStepping.puedeingresar:=false.aceptaingresos:=true.! !!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 04:36' prior: 35234351!valorReloj:aNumber(atm reloj) contents:aNumber asString,'s'.! !atm:=ATM new.!!ATM methodsFor: 'iniciales' stamp: 'agb 3/21/2011 04:37' prior: 35226526!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.teclapresionada:=nil.ancho:=500.alto:=430.super initialize.self extent:ancho@alto.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter text:'Enter'.enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.pdeposito atm:self.self addMorph:pdeposito.a:=SobreATM new.a position:(self position)+((self width)+20@50).a atm:self.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 04:38' prior: 35236991!pedirIngresoreloj:=StringMorph new.reloj fontName:'Sans' size:18.reloj contents:'60s'.reloj position:(pantalla position)+(375@60).pantalla addMorph:reloj.self print:'Ingrese el dinero en la ranura de deposito. Restante:' position:50@60.pdeposito startStepping.puedeingresar:=false.aceptaingresos:=true.! !atm:=ATM new.!!ATM methodsFor: 'iniciales' stamp: 'agb 3/21/2011 04:38' prior: 35237546!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.teclapresionada:=nil.ancho:=500.alto:=430.super initialize.superior borderWidth:0.self extent:ancho@alto.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter text:'Enter'.enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.pdeposito atm:self.self addMorph:pdeposito.a:=SobreATM new.a position:(self position)+((self width)+20@50).a atm:self.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !!ATM methodsFor: 'iniciales' stamp: 'agb 3/21/2011 04:38' prior: 35240166!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.teclapresionada:=nil.ancho:=500.alto:=430.super initialize.self borderWidth:0.self extent:ancho@alto.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter text:'Enter'.enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.pdeposito atm:self.self addMorph:pdeposito.a:=SobreATM new.a position:(self position)+((self width)+20@50).a atm:self.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm:=ATM new.!!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 04:39' prior: 35039537!menuPrincipalself limpiarPantalla.self print:'Menu Principal - ',usuario nombre position:50@10size:20.self print:'1 - Ver Saldo' position:70@40.self print:'2 - Retirar dinero' position:70@60.self print:'3 - Depositar dinero' position:70@80.self print:'4 - Salir' position:70@100.self print:'Elija una opcion:' position:50@120.self read:150@120.accion:=3.! !atm:=ATM new.!atm:=ATM new.!!PanelDeposito methodsFor: 'inicial' stamp: 'agb 3/21/2011 04:42' prior: 35230100!startSteppingsuper startStepping.valor:=120.interval:=1000.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 04:42' prior: 35239759!pedirIngresoreloj:=StringMorph new.reloj fontName:'Sans' size:18.reloj contents:'120s'.reloj position:(pantalla position)+(375@60).pantalla addMorph:reloj.self print:'Ingrese el dinero en la ranura de deposito. Restante:' position:50@60.pdeposito startStepping.puedeingresar:=false.aceptaingresos:=true.! !atm:=ATM new.!atm:=ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 04:44' prior: 35044363!controlarEnterpuedeingresar:=false.		0=accion ifTrue:[^self menuPrincipal].		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=((temp contents) asInteger)ifTrue:[^self mostrarSaldo].			2=((temp contents) asInteger)ifTrue:[^self pantallaRetiro].			3=((temp contents) asInteger)ifTrue:[^self pantallaDeposito].			4=((temp contents) asInteger)ifTrue:[^self salir].			^self menuPrincipal.			].		4=accion ifTrue:[^self validarRetiro].		5=accion ifTrue:[			0=((temp contents) asInteger) ifTrue:[^self menuPrincipal].			Transcript show:(temp contents).			^self pedirIngreso			].		"mensajes"		10=accion ifTrue:[^self pantallaRetiro].! !atm:=ATM new.!0=nil!atm:=ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 04:47' prior: 35245697!controlarEnterpuedeingresar:=false.		0=accion ifTrue:[^self menuPrincipal].		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=((temp contents) asInteger)ifTrue:[^self mostrarSaldo].			2=((temp contents) asInteger)ifTrue:[^self pantallaRetiro].			3=((temp contents) asInteger)ifTrue:[^self pantallaDeposito].			4=((temp contents) asInteger)ifTrue:[^self salir].			^self menuPrincipal.			].		4=accion ifTrue:[^self validarRetiro].		5=accion ifTrue:[			0=((temp contents) asInteger) ifTrue:[^self menuPrincipal].			Transcript show:(temp contents).			^self pedirIngreso			].		"mensajes"		10=accion ifTrue:[^self pantallaRetiro].! !!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 04:47' prior: 35246506!controlarEnterpuedeingresar:=false.		0=accion ifTrue:[^self menuPrincipal].		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=((temp contents) asInteger)ifTrue:[^self mostrarSaldo].			2=((temp contents) asInteger)ifTrue:[^self pantallaRetiro].			3=((temp contents) asInteger)ifTrue:[^self pantallaDeposito].			4=((temp contents) asInteger)ifTrue:[^self salir].			^self menuPrincipal.			].		4=accion ifTrue:[^self validarRetiro].		5=accion ifTrue:[			0=((temp contents) asInteger) ifTrue:[^self menuPrincipal].			Transcript show:(temp contents).			^self pedirIngreso			].		"mensajes"		10=accion ifTrue:[^self pantallaRetiro].! !atm:=ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 04:49' prior: 35247275!controlarEnterpuedeingresar:=false.		0=accion ifTrue:[^self menuPrincipal].		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=((temp contents) asInteger)ifTrue:[^self mostrarSaldo].			2=((temp contents) asInteger)ifTrue:[^self pantallaRetiro].			3=((temp contents) asInteger)ifTrue:[^self pantallaDeposito].			4=((temp contents) asInteger)ifTrue:[^self salir].			^self menuPrincipal.			].		4=accion ifTrue:[^self validarRetiro].		5=accion ifTrue:[			0=((temp contents) asInteger) ifTrue:[^self menuPrincipal].			nil=(temp contents) ifTrue:[^nil].			^self pedirIngreso			].		"mensajes"		10=accion ifTrue:[^self pantallaRetiro].! !atm:=ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 04:49' prior: 35248060!controlarEnterpuedeingresar:=false.		''=(temp contents) ifTrue:[^nil].		0=accion ifTrue:[^self menuPrincipal].		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=((temp contents) asInteger)ifTrue:[^self mostrarSaldo].			2=((temp contents) asInteger)ifTrue:[^self pantallaRetiro].			3=((temp contents) asInteger)ifTrue:[^self pantallaDeposito].			4=((temp contents) asInteger)ifTrue:[^self salir].			^self menuPrincipal.			].		4=accion ifTrue:[^self validarRetiro].		5=accion ifTrue:[			0=((temp contents) asInteger) ifTrue:[^self menuPrincipal].			^self pedirIngreso			].		"mensajes"		10=accion ifTrue:[^self pantallaRetiro].! !!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 04:50' prior: 35248847!controlarEnter		''=(temp contents) ifTrue:[^nil].puedeingresar:=false.		0=accion ifTrue:[^self menuPrincipal].		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=((temp contents) asInteger)ifTrue:[^self mostrarSaldo].			2=((temp contents) asInteger)ifTrue:[^self pantallaRetiro].			3=((temp contents) asInteger)ifTrue:[^self pantallaDeposito].			4=((temp contents) asInteger)ifTrue:[^self salir].			^self menuPrincipal.			].		4=accion ifTrue:[^self validarRetiro].		5=accion ifTrue:[			0=((temp contents) asInteger) ifTrue:[^self menuPrincipal].			^self pedirIngreso			].		"mensajes"		10=accion ifTrue:[^self pantallaRetiro].! !atm:=ATM new.!atm:=ATM new.!!ATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 04:51' prior: 35249616!controlarEnter		''=(temp contents) ifTrue:[^nil].		puedeingresar:=false.		0=accion ifTrue:[^self menuPrincipal].		1=accion ifTrue:[^self pedirPin].		2=accion ifTrue:[^self validarUsuario].		3=accion ifTrue:[			1=((temp contents) asInteger)ifTrue:[^self mostrarSaldo].			2=((temp contents) asInteger)ifTrue:[^self pantallaRetiro].			3=((temp contents) asInteger)ifTrue:[^self pantallaDeposito].			4=((temp contents) asInteger)ifTrue:[^self salir].			^self menuPrincipal.			].		4=accion ifTrue:[^self validarRetiro].		5=accion ifTrue:[			0=((temp contents) asInteger) ifTrue:[^self menuPrincipal].			^self pedirIngreso			].		"mensajes"		10=accion ifTrue:[^self pantallaRetiro].! !atm:=ATM new.!atm:=ATM new.!atm:=ATM new.!sobre:=SobreATM new.sobre atm:atm.!----QUIT----{21 March 2011 . 4:55:39 am} Squeak4.2.image priorSource: 1639030!----STARTUP----{21 March 2011 . 4:56:22 am} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!----QUIT----{21 March 2011 . 4:57:24 am} Squeak4.1.image priorSource: 1696768!----STARTUP----{21 March 2011 . 1:07:04 pm} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!!Fajo methodsFor: 'iniciales' stamp: 'agb 3/21/2011 13:32' prior: 35169140!de:aNumber position:aPoint contenedor:aMorph|billete pinicial n|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=aPoint.n:=(aNumber/20).1 to:n do:[:i|		billete:=Billete new.		billetes add:billete.		billete position:pinicial.		self addMorphBack:billete.		pinicial:=pinicial+(0@5).].self extent:0@0.self openInWorld.! !atm:=ATM new.!atm:=ATM new.!!Fajo methodsFor: 'iniciales' stamp: 'agb 3/21/2011 13:34' prior: 35251675!de:aNumber position:aPoint contenedor:aMorph|billete pinicial n|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=aPoint.n:=(aNumber/20).1 to:n do:[:i|		billete:=Billete new.		billetes add:billete.		billete position:pinicial.		self addMorphBack:billete.		pinicial:=pinicial+(0@2).].self extent:0@0.self openInWorld.! !atm:=ATM new.!!Fajo methodsFor: 'iniciales' stamp: 'agb 3/21/2011 13:36' prior: 35252127!de:aNumber position:aPoint contenedor:aMorph|billete pinicial n|[billetes size >0] whileTrue:[billetes removeFirst].pinicial:=aPoint.n:=(aNumber/20).1 to:n do:[:i|		billete:=Billete new.		billetes add:billete.		billete position:pinicial.		self addMorphBack:billete.		pinicial:=pinicial+(0@5).].self extent:0@0.self openInWorld.! !!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 13:40'!despedidaself limpiarPantalla.self print:'Gracias por utilizar nuestros servicios!!' position:70@60 size:20.self print:'Equipo de ATM.' position:150@80.! !ATM removeSelector: #despedida!!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 13:42' prior: 35004943!salirself limpiarPantalla.self print:'Gracias por utilizar nuestros servicios!!' position:70@60 size:20.self print:'Equipo de ATM.' position:150@80.usuario vaciar.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 13:42' prior: 35253235!salirself limpiarPantalla.self print:'Gracias por utilizar nuestros servicios!!' position:70@60 size:20.self print:'Equipo de ATM.' position:160@80.usuario vaciar.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 13:42' prior: 35253484!salirself limpiarPantalla.self print:'Gracias por utilizar nuestros servicios!!' position:70@60 size:20.self print:'Equipo de ATM.' position:165@80.usuario vaciar.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 13:43' prior: 35253733!salirself limpiarPantalla.self print:'Gracias por utilizar nuestros servicios!!' position:70@60 size:20.self print:'Equipo de ATM.' position:165@80.self startStepping.usuario vaciar.! !!ATM methodsFor: 'timer' stamp: 'agb 3/21/2011 13:44'!startSteppingsuper startStepping.interval:=1000.! !!ATM methodsFor: 'timer' stamp: 'agb 3/21/2011 13:44'!stepTime   ^interval ! !!ATM methodsFor: 'timer' stamp: 'agb 3/21/2011 13:44'!stopSteppingsuper stopStepping.interval:=0.! !!ATM methodsFor: 'timer' stamp: 'agb 3/21/2011 13:45'!wantsSteps^interval isNil.! !!ATM methodsFor: 'timer' stamp: 'agb 3/21/2011 13:46'!stepaccion=0 ifTrue:[	self stopStepping.]! !RectangleMorph subclass: #ATM	instanceVariableNames: 'superior pantalla controles botones enter pretiro puedeingresar temp accion usuario usuarios dinerocajero aceptaingresos pdeposito teclapresionada reloj interval tiempo'	classVariableNames: ''	poolDictionaries: ''	category: 'ATM'!!ATM methodsFor: 'timer' stamp: 'agb 3/21/2011 13:47' prior: 35254229!startSteppingsuper startStepping.tiempo:=5.interval:=1000.! !!ATM methodsFor: 'timer' stamp: 'agb 3/21/2011 13:48' prior: 35254609!steptiempo:=tiempo-1.tiempo=0 ifTrue:[	self stopStepping.	self pedirNumeroCuenta.]! !atm:=ATM new. !!ATM methodsFor: 'iniciales' stamp: 'agb 3/21/2011 13:49' prior: 35242401!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.interval:=1000.teclapresionada:=nil.ancho:=500.alto:=430.super initialize.self borderWidth:0.self extent:ancho@alto.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter text:'Enter'.enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.pdeposito atm:self.self addMorph:pdeposito.a:=SobreATM new.a position:(self position)+((self width)+20@50).a atm:self.a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@370.a extent:240@8.pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm:=ATM new. !!ATM methodsFor: 'timer' stamp: 'agb 3/21/2011 13:50' prior: 35255155!stepTranscript show:'hola'.tiempo:=tiempo-1.tiempo=0 ifTrue:[	self stopStepping.	self pedirNumeroCuenta.]! !atm:=ATM new. !!ATM methodsFor: 'timer' stamp: 'agb 3/21/2011 13:51' prior: 35255019!startSteppingsuper startStepping.tiempo:=3.interval:=1000.! !atm:=ATM new. !!ATM methodsFor: 'timer' stamp: 'agb 3/21/2011 13:52' prior: 35257801!startSteppingsuper startStepping.tiempo:=4.interval:=1000.! !!ATM methodsFor: 'timer' stamp: 'agb 3/21/2011 13:52' prior: 35257598!steptiempo:=tiempo-1.tiempo=0 ifTrue:[	self stopStepping.	self pedirNumeroCuenta.]! !atm:=ATM new. !atm:=ATM new. !!SobreATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 13:56'!wantsToBeDroppedInto:aMorphTranscript show:aMorph.! !!SobreATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 13:57' prior: 35258277!wantsToBeDroppedInto:aMorphTranscript show:aMorph.^false.! !!SobreATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 13:58' prior: 35258410!wantsToBeDroppedInto:aMorphTranscript show:(aMorph isKindOf: PanelDeposito).^false.! !!SobreATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 13:58' prior: 35258551!wantsToBeDroppedInto:aMorphTranscript show:(aMorph isKindOf: ATM).^false.! !!SobreATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 13:58' prior: 35258718!wantsToBeDroppedInto:aMorphTranscript show:(aMorph isKindOf: World).^false.! !!SobreATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 14:00' prior: 35230254!justDroppedInto: newOwner event: evt"|punto posicion|atm aceptaIngresos ifFalse:[^nil].posicion:=contenedor position.punto:=(self position)+((self extent)/2).((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (contenedor width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (contenedor height)))ifTrue:[		atm depositoCompleto.		self delete.	]."! !atm borderWidth:2.!SobreATM removeSelector: #wantsToBeDroppedInto:!!SobreATM methodsFor: 'eventos' stamp: 'agb 3/21/2011 14:03' prior: 35259034!justDroppedInto: newOwner event: evt|punto posicion|atm aceptaIngresos ifFalse:[^nil].posicion:=contenedor position.punto:=(self position)+((self extent)/2).((posicion x)<=(punto x)) & ((punto x)<=((posicion x)+ (contenedor width))) & ((posicion y)<=(punto y)) & ((punto y)<=((posicion y)+ (contenedor height)))ifTrue:[		atm depositoCompleto.		self delete.	].! !!ATM methodsFor: 'iniciales' stamp: 'agb 3/21/2011 14:06' prior: 35255338!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.interval:=1000.teclapresionada:=nil.ancho:=500.alto:=430.super initialize.self borderWidth:0.self extent:ancho@alto.self color:(Color r: 0.439 g: 0.439 b: 0.443)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.439 g: 0.439 b: 0.443).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter text:'Enter'.enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.pdeposito atm:self.self addMorph:pdeposito.a:=SobreATM new.a position:(self position)+((self width)+20@50).a atm:self.a:=RectangleMorph new.a color:(Color r: 0.972 g: 0.972 b: 0.976).a position:210@370.a extent:240@8.a borderColor:(Color r: 0.439 g: 0.439 b: 0.443).pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.a borderColor:(Color r: 0.439 g: 0.439 b: 0.443).a color:(Color r: 0.972 g: 0.972 b: 0.976).pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !atm:=ATM new. !!ATM methodsFor: 'timer' stamp: 'agb 3/21/2011 14:07' prior: 35257954!startSteppingsuper startStepping.tiempo:=3.interval:=1000.! !atm:=ATM new. !!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 14:08' prior: 35245275!pedirIngresoreloj:=StringMorph new.reloj fontName:'Sans' size:18.reloj contents:'120s'.reloj position:(pantalla position)+(375@60).pantalla addMorph:reloj.self print:'Ingrese el sobre en la ranura de deposito. Restante:' position:50@60.pdeposito startStepping.puedeingresar:=false.aceptaingresos:=true.! !atm:=ATM new. !sobre:=SobreATM new.sobre atm:atm.!atm:=ATM new. !sobre:=SobreATM new.sobre atm:atm.!----SNAPSHOT----{21 March 2011 . 2:09:46 pm} Squeak4.1.image priorSource: 1696967!!ATM methodsFor: 'iniciales' stamp: 'agb 3/21/2011 14:45' prior: 35260005!initialize|b inicial alto ancho a|usuarios:=self cargarDatos.usuario:=Usuario new.dinerocajero:=500.aceptaingresos:=false.interval:=1000.teclapresionada:=nil.ancho:=500.alto:=430.super initialize.self borderWidth:0.self extent:ancho@alto.self color:(Color r: 0.219 g: 0.219 b: 0.223)."superior"superior:= RectangleMorph new.superior extent:ancho@200.superior borderWidth:0.superior color:(Color r: 0.219 g: 0.219 b: 0.223).self addMorph:superior."pantalla"pantalla:= RectangleMorph new.pantalla position:20@20.pantalla extent:460@160.pantalla color:(Color r: 0.972 g: 0.972 b: 0.976).pantalla borderWidth:0.superior addMorph:pantalla."botones numeros"controles:= RectangleMorph new.controles borderWidth:0.controles position:10@210.self addMorph:controles.controles color:(Color r: 0.878 g: 0.878 b: 0.882).controles extent:160@210.inicial:=(controles position)+(10@10).botones :=OrderedCollection new.1to:10do:[:i|	b:= Boton new. 					botones add:b.	b extent:40@40.	b text: i asString.	(i=10)ifTrue:[b text:'0'].	b position:inicial.	controles addMorph:b.	inicial:=inicial+(50@0).	(i\\3=0)ifTrue:[inicial:=20@(inicial y + 50).].	b claseAccion:self.].enter:=Boton new.enter extent:90@40.enter position:(controles position)+(60@160).enter text:'Enter'.enter claseAccion:self.controles addMorph:enter."panel deposito"pdeposito:= PanelDeposito new.pdeposito position:180@320.pdeposito atm:self.self addMorph:pdeposito.a:=SobreATM new.a position:(self position)+((self width)+20@50).a atm:self.a:=RectangleMorph new.a color:(Color r: 0.972 g: 0.972 b: 0.976).a position:210@370.a extent:240@8.a borderColor:(Color r: 0.219 g: 0.219 b: 0.223).pdeposito addMorph:a.self print:'Inserte sobre de deposito aqui.'position:235@350en:pdeposito."panel retiro"pretiro:= RectangleMorph new.pretiro position:180@210.pretiro extent:300@100.pretiro borderWidth:0.pretiro color:(Color r: 0.972 g: 0.972 b: 0.976).a:=RectangleMorph new.a color:(Color r: 0.815 g: 0.815 b: 0.819).a position:210@260.a extent:240@8.a borderColor:(Color r: 0.219 g: 0.219 b: 0.223).a color:(Color r: 0.972 g: 0.972 b: 0.976).pretiro addMorph:a.self print:'Retire su dinero aqui.'position:255@240en:pretiro.self addMorph:pretiro.self pedirNumeroCuenta.self openInWorld.! !sobre:=SobreATM new.sobre atm:atm.!atm:=ATM new. !sobre:=SobreATM new.sobre atm:atm.!----QUIT----{21 March 2011 . 2:45:40 pm} Squeak4.1.image priorSource: 1708561!----STARTUP----{21 March 2011 . 2:45:51 pm} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!----QUIT/NOSAVE----{21 March 2011 . 2:46:23 pm} Squeak4.1.image priorSource: 1711129!----STARTUP----{21 March 2011 . 10:41:54 pm} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!!ATM methodsFor: 'datos' stamp: 'agb 3/21/2011 22:44' prior: 34883468!guardarDatos| dir filename text file n usuario|n := usuarios size.text := ''.1to: n do:[:i|		usuario:= usuarios at:i.		text:= text, usuario cuenta,';',usuario pin,';',usuario nombre,';',usuario monto,(Character cr) asString.	].filename := 'sample.txt'.dir := FileDirectory default.(dir fileExists: filename) ifTrue:[ dir deleteFileNamed: filename ].filename isEmpty ifTrue:[^self].file := dir newFileNamed: filename.file nextPutAll: text.file close.! !!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 22:44' prior: 35231797!depositoCompletousuario monto:(usuario monto)+(((temp contents) asNumber)/100) asFloat.self print:'Ingreso exitoso!!' position:160@80 size:20.self print:'Presione enter para regresar.' position:130@100.self guardarDatos.pdeposito stopStepping.aceptaingresos:=false.puedeingresar:=true.accion:=0.! !!ATM methodsFor: 'mensajes' stamp: 'agb 3/21/2011 22:45' prior: 35113155!retirarDinero:cantidad|dinero|usuario monto:(usuario monto)-cantidad.dinerocajero:=dinerocajero-cantidad.self guardarDatos.self limpiarPantalla.self print:'Por favor retire su dinero!!.'position:120@60 size:20.self print:'Tome su dinero para continuar.' position:130@80.dinero:=Fajo new.dinero atm:self.dinero de:(cantidad) position:pretiro position+(60@36) contenedor:pretiro.self addMorph:dinero.! !atm:=ATM new. !atm:=ATM new. !atm usuarios.!atm usuarios.!atm:=ATM new. !a:= Usuario new.!a!!ATM methodsFor: 'validaciones' stamp: 'agb 3/21/2011 22:53' prior: 35007430!validarUsuario|n user|usuario pin: temp contents.n:=usuarios size.1to:n do:[:i|		user:=usuarios at:i.		((user cuenta) = (usuario cuenta))&((user pin) = (usuario pin))		ifTrue:[				usuario:=user.				^self menuPrincipal.			].	].^self pedirNumeroCuenta.! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 22:54' prior: 35253982!salirself limpiarPantalla.self print:'Gracias por utilizar nuestros servicios!!' position:70@60 size:20.self print:'Equipo de ATM.' position:165@80.self startStepping.usuario:=Usuario new..! !!ATM methodsFor: 'interaccion' stamp: 'agb 3/21/2011 22:54' prior: 35267904!salirself limpiarPantalla.self print:'Gracias por utilizar nuestros servicios!!' position:70@60 size:20.self print:'Equipo de ATM.' position:165@80.self startStepping.usuario:=Usuario new.! !atm:=ATM new. !atm:=ATM new. !!ATM methodsFor: 'datos' stamp: 'agb 3/21/2011 22:59' prior: 35266039!guardarDatos| dir filename text file n usuario|n := usuarios size.text := ''.1to: n do:[:i|		usuario:= usuarios at:i.		text:= text, usuario cuenta,';',usuario pin,';',usuario nombre,';',usuario monto,(Character cr) asString.	].filename := 'atm\usuarios.txt'.dir := FileDirectory default.(dir fileExists: filename) ifTrue:[ dir deleteFileNamed: filename ].filename isEmpty ifTrue:[^self].file := dir newFileNamed: filename.file nextPutAll: text.file close.! !atm:=ATM new. !!ATM methodsFor: 'datos' stamp: 'agb 3/21/2011 23:05' prior: 35268483!guardarDatos| dir filename text file n usuario|n := usuarios size.text := ''.1to: n do:[:i|		usuario:= usuarios at:i.		text:= text, usuario cuenta,';',usuario pin,';',usuario nombre,';',usuario monto,(Character cr) asString.	].filename := 'usuarios.txt'.dir := FileDirectory default.(dir fileExists: filename) ifTrue:[ dir deleteFileNamed: filename ].filename isEmpty ifTrue:[^self].file := dir newFileNamed: filename.file nextPutAll: text.file close.! !atm:=ATM new. !!ATM methodsFor: 'datos' stamp: 'agb 3/21/2011 23:06' prior: 34878395!cargarDatos|file line datos usuarios usuario|file := FileStream fileNamed: 'usuarios.txt'.usuarios:= OrderedCollection new.[file atEnd] whileFalse:	[		line := file nextLine.		datos:=line findBetweenSubStrs:';'.		usuario:= Usuario new.		usuario cuenta:(datos at:1).		usuario pin:(datos at:2).		usuario nombre:(datos at:3).		usuario monto:(datos at:4).		usuarios add:usuario.	].file close. ^usuarios.! !atm:=ATM new. !atm:=ATM new. !!ATM methodsFor: 'datos' stamp: 'agb 3/21/2011 23:08' prior: 35269044!guardarDatos| dir filename text file n usuario|n := usuarios size.text := ''.1to: n do:[:i|		usuario:= usuarios at:i.		text:= text, usuario cuenta,';',usuario pin,';',usuario nombre,';',usuario monto,(Character cr) asString.	].filename := 'usuarios.txt'.dir := FileDirectory default.Transcript show:dir.(dir fileExists: filename) ifTrue:[ dir deleteFileNamed: filename ].filename isEmpty ifTrue:[^self].file := dir newFileNamed: filename.file nextPutAll: text.file close.! !!ATM methodsFor: 'datos' stamp: 'agb 3/21/2011 23:09' prior: 35270124!guardarDatos| dir filename text file n usuario|n := usuarios size.text := ''.1to: n do:[:i|		usuario:= usuarios at:i.		text:= text, usuario cuenta,';',usuario pin,';',usuario nombre,';',usuario monto,(Character cr) asString.	].filename := 'usuarios.txt'.dir := FileDirectory default,'\atm'.Transcript show:dir.(dir fileExists: filename) ifTrue:[ dir deleteFileNamed: filename ].filename isEmpty ifTrue:[^self].file := dir newFileNamed: filename.file nextPutAll: text.file close.! !atm:=ATM new. !!ATM methodsFor: 'datos' stamp: 'agb 3/21/2011 23:10' prior: 35270685!guardarDatos| dir filename text file n usuario|n := usuarios size.text := ''.1to: n do:[:i|		usuario:= usuarios at:i.		text:= text, usuario cuenta,';',usuario pin,';',usuario nombre,';',usuario monto,(Character cr) asString.	].filename := 'usuarios.txt'.dir := (FileDirectory default),'\atm'.Transcript show:dir.(dir fileExists: filename) ifTrue:[ dir deleteFileNamed: filename ].filename isEmpty ifTrue:[^self].file := dir newFileNamed: filename.file nextPutAll: text.file close.! !atm:=ATM new. !!ATM methodsFor: 'datos' stamp: 'agb 3/21/2011 23:12' prior: 35271270!guardarDatos| dir filename text file n usuario|n := usuarios size.text := ''.1to: n do:[:i|		usuario:= usuarios at:i.		text:= text, usuario cuenta,';',usuario pin,';',usuario nombre,';',usuario monto,(Character cr) asString.	].filename := 'usuarios.txt'.dir := FileDirectory default.Transcript show:dir.(dir fileExists: filename) ifTrue:[ dir deleteFileNamed: filename ].filename isEmpty ifTrue:[^self].file := dir newFileNamed: filename.file nextPutAll: text.file close.! !atm:=ATM new. !atm:=ATM new. !!ATM methodsFor: 'datos' stamp: 'agb 3/21/2011 23:13' prior: 35271857!guardarDatos| dir filename text file n usuario|n := usuarios size.text := ''.1to: n do:[:i|		usuario:= usuarios at:i.		text:= text, usuario cuenta,';',usuario pin,';',usuario nombre,';',usuario monto,(Character cr) asString.	].filename := 'usuarios.txt'.dir := FileDirectory default.(dir fileExists: filename) ifTrue:[ dir deleteFileNamed: filename ].filename isEmpty ifTrue:[^self].file := dir newFileNamed: filename.file nextPutAll: text.file close.! !atm:=ATM new. !sobre:=SobreATM new.sobre atm:atm.!----SNAPSHOT----{21 March 2011 . 11:13:52 pm} Squeak4.1.image priorSource: 1711129!----QUIT----{21 March 2011 . 11:13:55 pm} Squeak4.1.image priorSource: 1718543!----STARTUP----{21 March 2011 . 11:14:07 pm} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!----QUIT/NOSAVE----{21 March 2011 . 11:14:52 pm} Squeak4.1.image priorSource: 1718628!----STARTUP----{10 April 2011 . 6:40:16 pm} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!----QUIT/NOSAVE----{10 April 2011 . 6:40:35 pm} Squeak4.1.image priorSource: 1718628!----STARTUP----{28 July 2011 . 11:40:33 am} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!----QUIT/NOSAVE----{28 July 2011 . 11:41:40 am} Squeak4.1.image priorSource: 1718628!----STARTUP----{7 October 2011 . 5:57:25 pm} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!----QUIT/NOSAVE----{7 October 2011 . 5:57:48 pm} Squeak4.1.image priorSource: 1718628!----STARTUP----{17 October 2011 . 11:02:23 am} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!----SNAPSHOT----{17 October 2011 . 11:02:32 am} Squeak4.1.image priorSource: 1718628!----QUIT----{17 October 2011 . 11:03:43 am} Squeak4.1.image priorSource: 1719659!----STARTUP----{17 October 2011 . 4:06:35 pm} as E:\Documents and Settings\user\Escritorio\Squeak 4.1\Squeak4.1.image!----QUIT----{17 October 2011 . 4:06:55 pm} Squeak4.1.image priorSource: 1719746!----STARTUP----{5 October 2015 . 1:31:54 pm} as E:\doculitmo\escritorio\Squeak 4.1\Squeak4.1.image!----QUIT/NOSAVE----{5 October 2015 . 1:31:56 pm} Squeak4.1.image priorSource: 1719950!----STARTUP----{5 October 2015 . 1:31:59 pm} as E:\doculitmo\escritorio\Squeak 4.1\Squeak4.1.image!----QUIT----{5 October 2015 . 1:32:14 pm} Squeak4.1.image priorSource: 1719950!----STARTUP----{5 October 2015 . 1:32:18 pm} as E:\doculitmo\escritorio\Squeak 4.1\Squeak4.1.image!----QUIT----{5 October 2015 . 1:32:40 pm} Squeak4.1.image priorSource: 1720324!----STARTUP----{5 October 2015 . 1:46:03 pm} as E:\doculitmo\escritorio\Squeak 4.1\Squeak4.1.image!----QUIT/NOSAVE----{5 October 2015 . 1:46:07 pm} Squeak4.1.image priorSource: 1720507!----STARTUP----{5 October 2015 . 1:46:10 pm} as E:\doculitmo\escritorio\Squeak 4.1\Squeak4.1.image!----QUIT/NOSAVE----{5 October 2015 . 1:48:24 pm} Squeak4.1.image priorSource: 1720507!----STARTUP----{5 October 2015 . 2:45:52 pm} as E:\doculitmo\escritorio\Squeak 4.1\Squeak4.1.image!----QUIT/NOSAVE----{5 October 2015 . 2:46:02 pm} Squeak4.1.image priorSource: 1720507!----STARTUP----{5 October 2015 . 2:46:04 pm} as E:\doculitmo\escritorio\Squeak 4.1\Squeak4.1.image!----QUIT/NOSAVE----{5 October 2015 . 2:46:07 pm} Squeak4.1.image priorSource: 1720507!----STARTUP----{5 October 2015 . 2:46:16 pm} as E:\doculitmo\escritorio\Squeak 4.1\Squeak4.1.image!----QUIT/NOSAVE----{5 October 2015 . 2:46:55 pm} Squeak4.1.image priorSource: 1720507!----STARTUP----{5 October 2015 . 2:46:58 pm} as E:\doculitmo\escritorio\Squeak 4.1\Squeak4.1.image!----QUIT/NOSAVE----{5 October 2015 . 2:47 pm} Squeak4.1.image priorSource: 1720507!